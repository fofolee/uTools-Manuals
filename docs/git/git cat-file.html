<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>命名</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-cat-file  - 提供资源库对象的内容或类型和大小信息</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">git cat-file (-t [--allow-unknown-type]| -s [--allow-unknown-type]| -e | -p | &lt;type&gt; | --textconv | --filters ) [--path=&lt;path&gt;] &lt;object&gt;git cat-file (--batch | --batch-check) [ --textconv | --filters ] [--follow-symlinks]</pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>在第一种形式中，该命令提供存储库中对象的内容或类型。类型是必需的，除非<code>-t</code>或<code>-p</code>用于查找的对象类型，或<code>-s</code>用于查找对象的大小，或<code>--textconv</code>或<code>--filters</code>使用（其暗示型“斑点”）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在第二种形式中，在 stdin 上提供了一个对象列表（由换行符分隔），每个对象的 SHA-1，类型和大小都打印在 stdout 上。使用可选<code>&lt;format&gt;</code>参数可以覆盖输出格式。如果指定了其中之一<code>--textconv</code>或者<code>--filters</code>被指定，则输入需要列出对象名称，后跟路径名称，并用一个空格分隔，以便可以确定适当的驱动程序。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;object&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要显示的对象的名称。有关拼写对象名称的更完整列表，请参阅 gitrevisions [7] 中的“指定修订”部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-t</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示由&lt;object&gt;标识的对象类型而不是内容。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-s</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示由&lt;object&gt;标识的对象大小，而不是内容。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-e</p></div></div><div class="doc-postil"><div class="c-markdown"><p>控制所有输出； 如果&lt;object&gt;存在并且是有效的对象，则返回零状态。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-p</p></div></div><div class="doc-postil"><div class="c-markdown"><p>基于其类型 Pretty-print（漂亮地打印）&lt;object&gt;的内容。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;type&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通常情况下，它匹配&lt;object&gt;的实际类型，但是要求可以轻松地从给定&lt;object&gt;取消引用的类型也是允许的。一个例子是要求一个“树”，其中&lt;object&gt;是一个包含它的提交对象，或者要求一个&lt;blob&gt;作为指向它的标记对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--textconv</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示由 textconv过滤器转换的内容。在这种情况下，为了将过滤器应用于记录在&lt;path&gt;索引处的内容，&lt;object&gt; 必须采用 &lt;tree-ish&gt;：&lt;path&gt;或&lt;path&gt;的形式。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--filters</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示由当前工作树中为给定&lt;路径&gt;配置的过滤器转换的内容（即涂抹过滤器，行尾转换等）。在这种情况下，&lt;object&gt; 的格式必须是 &lt;tree-ish&gt;：&lt;path&gt;或&lt;path&gt;。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--path=&lt;path&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>与--textconv或--filters一起使用时，允许单独指定对象名称和路径，例如，当难以找出 blob 来自哪个版本时。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--batch   --batch=&lt;format&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>打印 stdin 上提供的每个对象的对象信息和内容。不能与其他选项或参数结合使用，除非<code>--textconv</code>或者<code>--filters</code>，在这种情况下，输入行还需要指定由空白分隔的路径。有关<code>BATCH OUTPUT</code>详情，请参阅下面的部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--batch-check   --batch-check=&lt;format&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>打印 stdin 上提供的每个对象的对象信息。不能与其他选项或参数结合使用，除非<code>--textconv</code>或者<code>--filters</code>，在这种情况下，输入行还需要指定由空白分隔的路径。有关<code>BATCH OUTPUT</code>详情，请参阅下面的部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--batch-all-objects</p></div></div><div class="doc-postil"><div class="c-markdown"><p>除了读取 stdin 上的对象列表，还可以对存储库中的所有对象以及任何其他对象存储（不仅仅是可到达的对象）执行请求的批处理操作。需要<code>--batch</code>或被<code>--batch-check</code>指定。请注意，这些对象是按照它们的散列顺序进行访问的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--buffer</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在每个对象输出后，通常会批处理输出刷新，以便进程可以交互式读取和写入<code>cat-file</code>。使用此选项，输出使用正常的stdio缓冲; 这在调用<code>--batch-check</code>大量对象时效率更高。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--allow-unknown-type</p></div></div><div class="doc-postil"><div class="c-markdown"><p>允许 -s 或 -t 查询未知类型的破坏/损坏（ broken/corrupt）的对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--follow-symlinks</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用 --batch或--batch-check，当请求具有表单 tree-ish：path-in-tree 的扩展 SHA-1 表达式的对象时，请遵循存储库内的符号链接。提供关于链接本身的输出，而不是提供有关链接到对象的输出。如果符号链接指向 tree-ish 之外（例如指向/ foo的链接或指向 ../foo 的根级别链接），则会打印树外部分的链接部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当索引中的对象被指定（例如，<code>:link</code>而不是<code>HEAD:link</code>）而不是树中的一个时，此选项不能正常工作。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>除非<code>--batch</code>或<code>--batch-check</code>正在使用此选项不能（当前）使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>例如，考虑一个包含以下内容的 git 存储库：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">f: a file containing "hello\n"link: a symlink to f
dir/link: a symlink to ../f
plink: a symlink to ../f
alink: a symlink to /etc/passwd</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>对于常规文件<code>f</code>，<code>echo HEAD:f | git cat-file --batch</code>将打印</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">ce013625030ba8dba906f756967f9e9ca394464a blob 6</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>并且<code>echo HEAD:link | git cat-file --batch --follow-symlinks</code>会打印同样的东西<code>HEAD:dir/link</code>，就像他们都指出<code>HEAD:f</code>的那样。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>没有<code>--follow-symlinks</code>，这些将打印有关符号链接本身的数据。在这种情况下<code>HEAD:link</code>，你会看到</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">4d1ae35ba2c8ec712fa2a379db44ad639ca277bd blob 1</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>无论<code>plink</code>和<code>alink</code>点外树，因此他们将分别打印：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">symlink 4../f</pre></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">symlink 11/etc/passwd</pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>输出</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>-t</code>指定了其中一个&lt;type&gt;。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>-s</code>指定，则以字节为单位的&lt;object&gt;的大小。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>-e</code>指定，则不输出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>-p</code>指定，则&lt;object&gt;的内容将被打印出来。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果指定&lt;type&gt;，则会返回&lt;object&gt;的原始（但未压缩的）内容。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>批量输出</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>--batch</code>或者<code>--batch-check</code>给出，<code>cat-file</code>将从标准输入读取对象，每行一个，并打印关于它们的信息。默认情况下，整行被认为是一个对象，就像它被馈送到 git-rev-parse [1] 一样。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以使用自定义指定每个对象显示的信息<code>&lt;format&gt;</code>。它<code>&lt;format&gt;</code>被逐字复制到每个对象的标准输出中，<code>%(atom)</code>扩展形式的占位符后跟一个换行符。可用的原子是：</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>objectname</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>对象的40-十六进制对象名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>objecttype</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>对象的类型（与<code>cat-file -t</code>报告相同）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>objectsize</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>对象的大小（以字节为单位<code>cat-file -s</code>）（与报告相同）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>objectsize:disk</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>对象在磁盘上占用的大小（以字节为单位）。请参阅<code>CAVEATS</code>以下部分有关磁盘大小的说明。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>deltabase</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果对象存储为磁盘上的增量，则此扩展为delta基本对象的40-hex sha1。否则，展开为 null sha1（40个零）。见<code>CAVEATS</code>下文。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>rest</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果在输出字符串中使用此原子，则会在第一个空白边界处分割输入行。该空白之前的所有字符都被认为是对象名称；在第一次运行空白（即，线的“休息”）之后的字符被输出以代替<code>%(rest)</code>原子。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果未指定格式，则默认格式为<code>%(objectname) %(objecttype) %(objectsize)</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>--batch</code>指定，则对象信息后面是对象内容（由<code>%(objectsize)</code>字节组成），后面跟着换行符。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>例如，<code>--batch</code>没有自定义格式会产生：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">&lt;sha1&gt; SP &lt;type&gt; SP &lt;size&gt; LF&lt;contents&gt; LF</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>而<code>--batch-check='%(objectname) %(objecttype)'</code>会产生：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">&lt;sha1&gt; SP &lt;type&gt; LF</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>如果在标准输入中指定了一个名称，该名称无法解析为存储库中的对象，<code>cat-file</code>则将忽略任何自定义格式并进行打印：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">&lt;object&gt; SP missing LF</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>如果使用--follow-symlinks，并且存储库中的符号链接指向存储库外部，<code>cat-file</code>则将忽略任何自定义格式并打印：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">symlink SP &lt;size&gt; LF&lt;symlink&gt; LF</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>符号链接将是绝对的（以/开头），或者相对于树根。例如，如果 dir / link 指向 ../../foo，那么&lt;symlink&gt;将是 ../foo。&lt;size&gt;是符号链接的大小（以字节为单位）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果使用--follow-symlinks，则会显示以下错误消息：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">&lt;object&gt; SP missing LF</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>在请求的初始符号链接不存在时打印。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">dangling SP &lt;size&gt; LF&lt;object&gt; LF</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>是在初始符号链接存在时打印的，但它（传递）指向的东西没有。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">loop SP &lt;size&gt; LF&lt;object&gt; LF</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>是为符号链接循环（或任何需要超过40个链接分辨率才能解析的符号链接）打印的。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">notdir SP &lt;size&gt; LF&lt;object&gt; LF</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>在符号链接解析期间，当文件被用作目录名称时，会打印该文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>注意事项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，磁盘上的对象大小是准确报告的，但应该小心确定哪些引用或对象负责磁盘使用。压缩的非 delta 对象的大小可能远远大于反对它的 delta 对象的大小，但是选择哪个对象是基础，哪个是 delta 是任意的，并且在重新包装期间可能会发生变化。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>还要注意对象数据库中可能存在多个对象副本；在这种情况下，未定义将报告哪个副本的大小或增量基数。</p></div></div></div>