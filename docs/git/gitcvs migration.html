<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>命名</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>gitcvs-migration - Git for CVS users</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">git cvsimport *</pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>Git 与 CVS 的不同之处在于，每个工作树都包含一个具有项目历史记录完整副本的存储库，并且任何存储库本身都比其他任何存储库都重要。但是，您可以通过指定人员可以同步的单个共享存储库来模拟 CVS 模型; 本文档解释了如何做到这一点。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对 Git 有一些基本的了解是必需的。通过 gittutorial [7] 和 gitglossary [7] 就足够了。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>针对共享存储库进行开发</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>假设在主机 foo.com 上的 /pub/repo.git 中设置了共享存储库。然后作为一个单独的提交者，你可以通过 ssh 克隆共享库：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ git clone foo.com:/pub/repo.git/ my-project
$ cd my-project</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>并删去。相当于<code>cvs update</code>是</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ git pull origin</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>它合并在副本操作后其他人可能完成的任何工作中。如果工作树中有未提交的更改，请在运行 git pull 之前先提交它们。</p></div></div><div class="doc-postil"><div class="c-markdown"><div class="table-wrapper"><table><thead><tr class="firstRow"><th style="text-align: left;"><div class="table-header"><p>Note</p></div></th><th style="text-align: left;"><div class="table-header"><p>The pull command knows where to get updates from because of certain configuration variables that were set by the first git clone command; see git config -l and the git-config1 man page for details.</p></div></th></tr></thead><tbody></tbody></table></div></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以通过首先提交更改并使用以下<code>git push</code>命令来更新共享存储库：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ git push origin master</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>将这些提交 “push” 到共享存储库。如果其他人最近更新了存储库<code>git push</code>，就像<code>cvs commit</code>会抱怨的那样，在这种情况下，您必须在尝试再次推送前进行任何更改。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在<code>git push</code>上面的命令中，我们指定了要更新（<code>master</code>）的远程分支的名称。如果我们不这样做，则<code>git push</code>尝试更新远程存储库中与本地存储库中的分支具有相同名称的任何分支。所以最后<code>push</code>可以通过以下任一方式完成：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ git push origin
$ git push foo.com:/pub/project.git/</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>只要共享存储库没有任何其他分支<code>master</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>设置共享存储库</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>我们假设您已经为您的项目创建了一个 Git 存储库，可能是从头开始或从 tarball 创建的（请参阅 gittutorial [7]），或者从现有的 CVS 存储库导入（请参阅下一节）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>假设您的现有回购在 / home / alice / myproject 。创建一个新的 “bare” 存储库（一个没有工作树的存储库）并将你的项目存入它：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ mkdir /pub/my-repo.git
$ cd /pub/my-repo.git
$ git --bare init --shared
$ git --bare fetch /home/alice/myproject master:master</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>接下来，让每个团队成员都可以读取/写入这个存储库。一个简单的方法是让所有团队成员 ssh 访问存储库所在的机器。如果你不想在机器上给它们一个完整的外壳，那么就有一个限制外壳，它只允许用户做 Git 推动和拉动; 请参阅 git-shell [1] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将所有提交者放在同一组中，并使该存储库可由该组写入：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ chgrp -R $group /pub/my-repo.git</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>确保提交者拥有最多027的 umask ，以便他们创建的目录可由其他组成员写入和搜索。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>导入一个 cvs 档案</h2></div></div><div class="doc-postil"><div class="c-markdown"><div class="table-wrapper"><table><thead><tr class="firstRow"><th style="text-align: left;"><div class="table-header"><p>Note</p></div></th><th style="text-align: left;"><div class="table-header"><p>These instructions use the git-cvsimport script which ships with git, but other importers may provide better results. See the note in git-cvsimport1 for other options.</p></div></th></tr></thead><tbody></tbody></table></div></div></div><div class="doc-postil"><div class="c-markdown"><p>首先，从<a href="https://github.com/andreyvit/cvsps" target="_blank">https://github.com/andreyvit/cvsps</a>安装 cvsps2.1 或更高版本，并确保它在你的路径中。然后 cd 到您感兴趣的项目的签出 CVS 工作目录并运行 git-cvsimport [1] ：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ git cvsimport -C &lt;destination&gt; &lt;module&gt;</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>这会将名为 CVS 模块的 Git 存档放在目录 &lt;destination&gt; 中，如果需要将会创建它。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>导入从 CVS 检出每个文件的每个修订版本。据报道，cvsimport 平均每秒可以修改大约20个版本，所以对于一个中等规模的项目来说，这应该不会超过几分钟。较大的项目或远程存储库可能需要更长的时间。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>主干存储在命名为<code>origin</code>的 Git 分支中，其他 CVS 分支存储在具有相同名称的 Git 分支中。主干线的最新版本也会在<code>master</code>分支上检出，因此您可以立即开始添加自己的更改。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>导入是增量式的，所以如果你在下个月再次调用它，它将获取在此期间所做的任何 CVS 更新。为此，您不得修改导入的分支; 相反，请为自己的更改创建新分支，并根据需要合并输入分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您需要共享存储库，则需要对导入的目录进行裸机复制，如上所述。然后将导入的目录作为另一个开发副本用于合并增量导入。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>高级共享存储库管理</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>Git 允许你指定在某些点运行的叫做 “hooks” 的脚本。例如，您可以使用它们将所有提交到共享存储库的邮件发送到邮件列表。见 githooks [5] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以使用更新挂钩来实施更细粒度的权限。请参阅使用更新挂钩控制对分支机构的访问。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>提供对 git 存储库的 cvs 访问</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>还可以提供对 Git 存储库的真正 CVS 访问，以便开发人员仍然可以使用 CVS ; 有关详细信息，请参阅 git-cvsserver [1] 。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>替代发展模式</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>CVS 用户习惯于让一组开发人员访问公共存储库。正如我们所看到的，Git 也可以这样做。但是，Git 的分布式特性允许其他开发模型，您可能需要首先考虑其中一个模型是否适合您的项目。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>例如，您可以选择一个人来维护项目的主要公共存储库。其他开发人员然后复制这个存储库，并在他们自己的副本中工作 当他们有一系列他们感到满意的变化时，他们会要求维护人员从包含变更的分支中撤出。维护人员检查他们的变化并将他们拖入主存储库中，其他开发人员根据需要从中取得协调。Linux 内核和其他项目使用此模型的变体。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通过一个小团队，开发人员可以在不需要集中维护人员的情况下从对方的存储库中获取更改。</p></div></div></div>