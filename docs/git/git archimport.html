<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>名称</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-archimport  - 将 Arch 资料库导入 Git</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">git archimport [-h] [-v] [-o] [-a] [-f] [-T] [-D depth] [-t tempdir]               &lt;archive/branch&gt;[:&lt;git-branch&gt;] …</pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>从一个或多个 Arch 存储库导入项目。它将跟随由所提供的&lt;archive / branch&gt;参数定义的名称空间内的分支和存储库。如果找不到合并来自的远程分支，它只会将其作为常规提交导入。如果它能找到它，它会尽可能将它标记为合并（参见下面的讨论）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>脚本希望您提供可以从 Arch 提交<code>initial import</code>或<code>tag</code>类型的提交开始导入的关键根。它将跟随并导入新的分支机构。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>它期望只处理一个项目。如果它看到具有不同根的分支，它将拒绝运行。在这种情况下，编辑您的&lt;archive / branch&gt;参数以明确定义导入的范围。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git archimporttla</code>在后台广泛使用以访问Arch存储库。确保<code>tla</code>在路径中有可用的最新版本。<code>tla</code>必须知情您传递给<code>git archimport</code>的存储库。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对于初次导入，<code>git archimport</code>希望找到一个空目录。要遵循使用 Arch 的项目的开发，请使用<code>git archimport</code>与初始导入相同的参数重新运行以执行增量导入。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>虽然<code>git archimport</code>会尝试为其导入的存档创建合理的分支名称，但也可以手动指定 Git 分支名称。为此，请在每个&lt;archive / branch&gt;参数后面写一个 Git 分支名称，用冒号分隔。这样，您可以缩短 Arch 分支名称并将 Arch 术语转换为 Git 术语，例如，将“PROJECT{litdd}devo{litdd}VERSION”分支映射到“master”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将多个 Arch 分支关联到一个 Git 分支是可能的；只有在创建第二个分支之后没有对第一个分支进行提交时，结果才会最有意义。不过，这对转换定期旋转的 Arch 存储库非常有用。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>合并</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>补丁合并来自 Arch 的数据也用于在 Git 中标记合并。Git 并不关心追踪补丁，只考虑分支自从分叉点起合并所有提交时的合并。最终的结果是，Git 可以很好地了解分支有多远。所以导入过程确实会丢失一些补丁交易元数据。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>幸运的是，当您尝试合并从 Arch 导入的分支时，Git 将找到一个很好的合并基础，并且它有很好的机会识别在分支之间失序交易的补丁。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>-h</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示用法。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-v</p></div></div><div class="doc-postil"><div class="c-markdown"><p>详细输出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-T</p></div></div><div class="doc-postil"><div class="c-markdown"><p>很多标签。将为每次提交创建一个标签，反映 Arch 存储库中的提交名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-f</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用快速补丁集导入策略。对于大型树，这可能会明显更快，但无法处理目录重命名或权限更改。默认策略是缓慢且安全的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-o</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用它来与早期版本的旧式分支名称兼容<code>git archimport</code>。旧式分支名称为{litdd}分支，而新式分支名称为归档，分类为{litdd}分支{litdd}版本。在这两种情况下，命令行中给出的名称都会覆盖自动生成的名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-D &lt;depth&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>遵循合并祖先并尝试导入已合并的树。如果修补程序日志已被修剪，则指定大于1的深度。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-a</p></div></div><div class="doc-postil"><div class="c-markdown"><p>尝试自动在<code>http://mirrors.sourcecontrol.net</code>注册归档文件，这对于-D选项特别有用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-t &lt;tmpdir&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>覆盖默认的 tempdir。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;archive/branch&gt;  （&lt;存档/分支&gt;）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以<code>tla log</code>可理解的格式存档/分支标识符。</p></div></div></div>