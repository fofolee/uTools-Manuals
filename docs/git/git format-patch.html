<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>名称（Name）</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-format-patch  - 为电子邮件提交准备补丁</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">git format-patch [-k] [(-o|--output-directory) &lt;dir&gt; | --stdout]                   [--no-thread | --thread[=&lt;style&gt;]]                   [(--attach|--inline)[=&lt;boundary&gt;] | --no-attach]                   [-s | --signoff]                   [--signature=&lt;signature&gt; | --no-signature]                   [--signature-file=&lt;file&gt;]                   [-n | --numbered | -N | --no-numbered]                   [--start-number &lt;n&gt;] [--numbered-files]                   [--in-reply-to=Message-Id] [--suffix=.&lt;sfx&gt;]                   [--ignore-if-in-upstream]                   [--rfc] [--subject-prefix=Subject-Prefix]                   [(--reroll-count|-v) &lt;n&gt;]                   [--to=&lt;email&gt;] [--cc=&lt;email&gt;]                   [--[no-]cover-letter] [--quiet] [--notes[=&lt;ref&gt;]]                   [&lt;common diff options&gt;]                   [ &lt;since&gt; | &lt;revision range&gt; ]</pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>每个提交准备每个提交的补丁文件，格式化为类似于 UNIX 邮箱格式。这个命令的输出很方便用于电子邮件提交或用于<code>git am</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有两种方式可以指定对哪些提交进行操作。</p></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>一次提交（&lt;since&gt;）指定通向当前分支尖端的不在历史中导致&lt;since&gt;输出的提交。</p></li><li><p>通用&lt;修订范围&gt;表达式（参见 gitrevisions [7]中的“指定修订”一节）意味着指定范围内的提交。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>第一条规则优先于单个&lt;commit&gt;的情况。要应用第二条规则，即格式化从历史开始直到&lt;commit&gt;的所有内容，请使用<code>\--root</code>选项：<code>git format-patch --root &lt;commit&gt;</code>。如果你只想格式化&lt;commit&gt;本身，你可以这样做<code>git format-patch -1 &lt;commit&gt;</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，每个输出文件都从1开始依次编号，并使用提交消息的第一行（按路径名安全性）作为文件名。使用该<code>--numbered-files</code>选项，输出文件名称将仅为数字，而不会附加提交的第一行。除非<code>--stdout</code>指定了选项，否则输出文件的名称将打印到标准输出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>-o</code>指定，则输出文件将在&lt;dir&gt;中创建。否则，它们将在当前工作目录中创建。默认路径可以使用<code>format.outputDirectory</code>配置选项进行设置。该<code>-o</code>选项优先<code>format.outputDirectory</code>。要将补丁存储在当前工作目录中，即使在<code>format.outputDirectory</code>其他位置使用也是如此<code>-o .</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，单个补丁的主题是“PATCH”，接下来是从提交消息到第一个空行的连接（请参阅 git-commit [1]的讨论部分））。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当输出多个音色时，主题前缀将改为“PATCH n / m”。要强制为单个补丁添加1/1，请使用<code>-n</code>。要从主题中省略修补程序编号，请使用<code>-N</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果给定<code>--thread</code>，<code>git-format-patch</code>将生成<code>In-Reply-To</code>并<code>References</code>标题使第二个和后续的补丁邮件显示为对第一个邮件的答复; 这也会生成一个<code>Message-Id</code>头引用。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>-p   --no-stat</p></div></div><div class="doc-postil"><div class="c-markdown"><p>无需任何 diffstats 即可生成简单的修补程序。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-U&lt;n&gt;   --unified=&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用&lt;n&gt;行上下文生成差异，而不是通常的三行。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--indent-heuristic   --no-indent-heuristic</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这些是为了帮助调试和调整实验启发式（默认情况下是关闭的），这些启发式技术改变了差异边界以使修补程序更易于阅读。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--minimal</p></div></div><div class="doc-postil"><div class="c-markdown"><p>花费额外的时间来确保生成最小可能的差异。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--patience</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用“耐心差异”算法生成差异。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--histogram</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用“直方图差异”算法生成差异。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--diff-algorithm={patience|minimal|histogram|myers}</p></div></div><div class="doc-postil"><div class="c-markdown"><p>选择一种差异算法。变体如下：</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>default</code>, <code>myers</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>基本的贪婪 diff 算法。目前，这是默认设置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>minimal</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>花费额外的时间来确保生成最小可能的差异。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>patience</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>生成补丁时使用“耐心差异”算法。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>histogram</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>该算法将耐心算法扩展为“支持低出现率的通用元素”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>例如，如果您将 diff.algorithm 变量配置为非默认值并且想要使用默认值，那么您必须使用<code>--diff-algorithm=default</code>选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--stat[=&lt;width&gt;[,&lt;name-width&gt;,&lt;count&gt;]]</p></div></div><div class="doc-postil"><div class="c-markdown"><p>生成一个 diffstat。默认情况下，文件名部分使用尽可能多的空间，其余部分使用图形部分。最大宽度默认为终端宽度，如果未连接到终端，则最大宽度为80列，并且可以被覆盖<code>&lt;width&gt;</code>。文件名部分的宽度可以通过<code>&lt;name-width&gt;</code>逗号后面的另一个宽度来限制。图形部分的宽度可以通过使用<code>--stat-graph-width=&lt;width&gt;</code>（影响所有生成统计图的命令）或通过设置<code>diff.statGraphWidth=&lt;width&gt;</code>（不影响<code>git format-patch</code>）来限制。通过给出第三个参数<code>&lt;count&gt;</code>，可以将输出限制在第一<code>&lt;count&gt;</code>行，<code>...</code>如果还有更多的话。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这些参数也可以单独设置<code>--stat-width=&lt;width&gt;</code>，<code>--stat-name-width=&lt;name-width&gt;</code>和<code>--stat-count=&lt;count&gt;</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--numstat</p></div></div><div class="doc-postil"><div class="c-markdown"><p>类似于<code>--stat</code>，但显示十进制表示法中添加和删除的行数以及不带缩写的路径名，以使其更加机器友好。对于二进制文件，输出两个<code>-</code>而不是说<code>0 0</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--shortstat</p></div></div><div class="doc-postil"><div class="c-markdown"><p>只输出<code>--stat</code>包含修改文件总数的格式的最后一行，以及添加和删除行的数量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--dirstat=&lt;param1,param2,…&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>输出每个子目录的相对变化量分布。<code>--dirstat</code>可以通过传递逗号分隔的参数列表来定制行为。默认值由<code>diff.dirstat</code>配置变量控制（请参阅 git-config [1]）。以下参数可用：</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>changes</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>通过计算已从源中删除或添加到目标的行来计算 dirstat 数字。这会忽略文件中纯代码移动的数量。换句话说，重新排列文件中的行数不会与其他更改一样多。这是没有给出参数时的默认行为。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>lines</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>通过执行常规基于行的差异分析来计算dirstat数字，并将删除/添加的行数相加。（对于二进制文件，取而代之的是计算64字节的块，因为二进制文件没有自然的行概念）。这是一种<code>--dirstat</code>比<code>changes</code>行为更为昂贵的行为，但它可以像其他更改一样计算文件中重新排列的行数。结果输出与您从其他<code>--*stat</code>选项中获得的结果一致。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>files</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>通过计算更改的文件数量来计算 dirstat 数字。 dirstat 分析中每个更改的文件都相同。这是计算上最便宜的<code>--dirstat</code>行为，因为它不必查看文件内容。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>cumulative</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>计数父目录的子目录中的更改。请注意，使用时<code>cumulative</code>，报告的百分比总和可能超过100％。默认（非累积）行为可以用<code>noncumulative</code>参数指定。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;limit&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>整数参数指定截断百分比（默认为3％）。输出中不显示贡献小于此百分比的目录。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>示例：以下内容将计数已更改的文件，同时忽略占已更改文件总数少于10％的目录，并累积父目录中的子目录计数：<code>--dirstat=files,10,cumulative</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--summary</p></div></div><div class="doc-postil"><div class="c-markdown"><p>输出扩展头信息的精简摘要，如创建，重命名和模式更改。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-renames</p></div></div><div class="doc-postil"><div class="c-markdown"><p>关闭重命名检测，即使配置文件提供了默认设置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--full-index</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在生成补丁格式输出时，在“索引”行上显示完整的映像前和映像后 blob 对象名称，而不是第一批字符。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--binary</p></div></div><div class="doc-postil"><div class="c-markdown"><p>除了<code>--full-index</code>输出可以应用的二进制差异<code>git-apply</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--abbrev=&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不是在 diff-raw 格式输出和 diff-tree 标题行中显示完整的40字节十六进制对象名称，只显示部分前缀。这与<code>--full-index</code>上面的选项无关，后者控制 diff-patch 输出格式。非默认的位数可以用指定<code>--abbrev=&lt;n&gt;</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-B&lt;n&gt;   --break-rewrites[=&lt;n&gt;]</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将完全重写更改分解为删除和创建对。这有两个目的：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>它影响到一种改变的方式，这种改变相当于整个文件的重写，而不是像一系列删除和插入混合在一起，只有几行文本与上下文相匹配，但是作为一个单一的删除旧的一切，随后是一个单次插入所有新事物，并且数字<code>m</code>控制-B选项的这个方面（默认为60％）。<code>-B/70%</code>指定只有少于30％的原始数据应保留在Git的结果中，以便将其视为全部重写（否则结果补丁将是一系列与上下文行混合的删除和插入）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>与-M 一起使用时，完全重写的文件也被认为是重命名的来源（通常-M 仅考虑作为重命名源消失的文件），并且该数字<code>n</code>控制着-B选项的这个方面（默认为50％）。<code>-B20%</code>指定添加和删除相对于文件大小的20％或更多的更改有资格作为重命名为其他文件的可能来源。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-M&lt;n&gt;   --find-renames=&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>检测重命名。如果<code>n</code>被指定，则它是相似度指数的阈值（即与文件大小相比的添加/删除量）。例如，<code>-M90%</code>如果超过90％的文件没有改变，Git 应该考虑删除/添加对是一个重命名。如果没有<code>%</code>符号，该数字应作为分数读取，并在其前面加小数点。即，<code>-M5</code>变成0.5，并且因此是相同的<code>-M50%</code>。同样的，<code>-M05</code>也是一样的<code>-M5%</code>。要将检测限制为精确重命名，请使用<code>-M100%</code>。默认相似度指数为50％。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-C&lt;n&gt;   --find-copies=&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>检测副本以及重命名。另见<code>--find-copies-harder</code>。如果<code>n</code>被指定，它的含义与<code>-M&lt;n&gt;</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--find-copies-harder</p></div></div><div class="doc-postil"><div class="c-markdown"><p>出于性能原因，默认情况下，<code>-C</code>只有当副本的原始文件在相同的变更集中被修改时，选项才会查找副本。该标志使命令检查未修改的文件作为复制源的候选项。对于大型项目来说这是一项非常昂贵的操作，因此请谨慎使用。给予多个<code>-C</code>选项具有相同的效果。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-D  - 不可逆 - 删除 （--irreversible-delete ）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>省略原图像进行删除，即仅打印标题，但不打印原像和之间的差异<code>/dev/null</code>。由此产生的补丁不适用于<code>patch</code>或<code>git apply</code>; 这仅适用于那些想专注于更改后查看文本的人。另外，输出显然缺乏足够的信息来反向应用这样的补丁，甚至是手动的，因此也就是选项的名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在与<code>-B</code>删除/创建对的删除部分一起使用时，还要省略原像。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-l&lt;num&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在<code>-M</code>和<code>-C</code>选项需要为O（n ^ 2）的处理时间，其中n是/复制目标潜在的重命名的数目。如果重命名/复制目标的数量超过指定的数量，则此选项可防止重命名/复制检测运行。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-O&lt;orderfile&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>控制文件在输出中出现的顺序。这覆盖了<code>diff.orderFile</code>配置变量（请参阅git-config [1]）。取消<code>diff.orderFile</code>，使用<code>-O/dev/null</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>输出顺序由&lt;orderfile&gt;中的全局模式顺序决定。所有具有与第一个模式相匹配的路径名的文件将首先输出，接下来将输出所有具有匹配第二个模式（但不是第一个）的路径名的文件，依此类推。最后输出所有不匹配任何模式的路径名的文件，就好像文件末尾有一个隐含的匹配模式一样。如果多个路径名具有相同的排名（它们匹配相同的模式但没有更早的模式），则它们的输出顺序相对于彼此是正常顺序。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>按以下方式解析&lt;orderfile&gt;：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>空白行被忽略，所以它们可以用作分隔符以提高可读性。</p></li><li><p>以散列（“ <code>#</code>”）开头的行会被忽略，因此它们可以用于注释。<code>\</code>如果以散列开头，则在模式的开头添加反斜杠（“ ”）。</p></li><li><p>每隔一行包含一个模式。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>模式与没有 FNM_PATHNAME 标志的 fnmantch（3）使用的模式具有相同的语法和语义，但如果删除任何数量的最终路径名组件都与模式匹配，则路径名也与模式匹配。例如，模式“ <code>foo*bar</code>”匹配“ <code>fooasdfbar</code>”和“ <code>foo/bar/baz/asdf</code>”但不是“ <code>foobarx</code>”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-a   --text</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将所有文件视为文本。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--ignore-space-at-eol</p></div></div><div class="doc-postil"><div class="c-markdown"><p>忽略 EOL 中的空白变化。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-b   --ignore-space-change</p></div></div><div class="doc-postil"><div class="c-markdown"><p>忽略空白量的变化。这会忽略行结束处的空白，并认为一个或多个空白字符的所有其他序列是等价的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-w --ignore-all-space</p></div></div><div class="doc-postil"><div class="c-markdown"><p>比较行时忽略空格。即使一行有空白，而另一行没有空白，这也会忽略差异。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--ignore-blank-lines</p></div></div><div class="doc-postil"><div class="c-markdown"><p>忽略其行全部空白的更改。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--inter-hunk-context=&lt;lines&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示差异 hunk 之间的上下文，直到指定的行数，从而融合彼此接近的 hunk。<code>diff.interHunkContext</code>如果配置选项未设置，则默认为0或0。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-W  - 功能上下文 （--function-context ）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示整个周围的变化功能。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--ext-diff</p></div></div><div class="doc-postil"><div class="c-markdown"><p>允许执行一个外部比较助手。如果你用 gitattributes [5]设置外部差异驱动程序，你需要在 git-log [1]和朋友中使用这个选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-ext-diff</p></div></div><div class="doc-postil"><div class="c-markdown"><p>禁止外部差异驱动程序。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--textconv   --no-textconv</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在比较二进制文件时，允许（或不允许）运行外部文本转换过滤器。有关详细信息，请参阅 gitattributes [5]。由于 textconv 过滤器通常是单向转换，因此生成的差异适合人类消费，但无法应用。出于这个原因，默认情况下，textconv 过滤器仅针对 git-diff [1]和 git-log [1]启用，但不适用于 git-format-patch [1]或 diff plumbing命令。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--ignore-submodules=&lt;when&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>忽略差异代中子模块的更改。&lt;when&gt;可以是“none”，“untracked”，“dirty”或“all”，这是默认设置。如果子模块包含未跟踪或已修改的文件，或者 HEAD 与超级项目中记录的提交不同，并且可用于覆盖<code>ignore</code>git-config [1]或 gitmodules [5]中的任何选项设置，则使用“none” ]。当使用“未跟踪”时，如果子模块仅包含未跟踪内容（但仍然针对修改内容进行扫描），则子模块不会被视为脏。使用“dirty”会忽略对子模块工作树的所有更改，只会显示超级项目中存储的提交更改（这是1.7.0之前的行为）。使用“全部”</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--src-prefix=&lt;prefix&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示给定的源前缀而不是“a /”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--dst-prefix=&lt;prefix&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示给定的目的地前缀而不是“b /”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-prefix</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要显示任何来源或目的地前缀。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--line-prefix=&lt;prefix&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>为每行输出预留一个额外的前缀。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--ita-invisible-in-index</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，由“git add -N”添加的条目显示为“git diff”中的现有空文件和“git diff --cached”中的新文件。该选项使得该条目在“git diff”中显示为新文件，而在“git diff --cached”中不存在。这个选项可以恢复<code>--ita-visible-in-index</code>。这两个选项都是实验性的，可以在将来删除。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有关这些常用选项的更详细的解释，请参阅 gitdiffcore [7]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>从最顶端的&lt;n&gt;提交中准备补丁。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-o &lt;dir&gt; --output-directory &lt;dir&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用&lt;dir&gt;来存储结果文件，而不是当前的工作目录。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-n   --numbered</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以<code>[PATCH n/m]</code>格式输出名称，即使只有一个补丁。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-N   --no-numbered</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以<code>[PATCH]</code>格式输出名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--start-number &lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>从&lt;n&gt;开始编号，而不是1。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--numbered-files</p></div></div><div class="doc-postil"><div class="c-markdown"><p>输出文件名将是一个简单的数字序列，不需要追加提交的默认第一行。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-k   --keep-subject</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要<code>[PATCH]</code>从提交日志消息的第一行剥离/添加。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-s   --signoff</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用自己的提交者身份将<code>Signed-off-by:</code>行添加到提交消息中。有关更多信息，请参阅git-commit [1]中的signoff选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--stdout</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以 mbox 格式打印所有提交到标准输出，而不是为每个文件创建一个文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--attach=&lt;boundary&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>创建多部分/混合附件，第一部分是第二部分中的提交消息和补丁本身<code>Content-Disposition: attachment</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-attach</p></div></div><div class="doc-postil"><div class="c-markdown"><p>禁用创建附件，覆盖配置设置。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--inline=&lt;boundary&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>创建多部分/混合附件，第一部分是第二部分中的提交消息和补丁本身<code>Content-Disposition: inline</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--thread=&lt;style&gt;   --no-thread</p></div></div><div class="doc-postil"><div class="c-markdown"><p>控制添加<code>In-Reply-To</code>和<code>References</code>标题以使第二个和后续邮件显示为对第一个的回复。还控制生成<code>Message-Id</code>头引用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>可选的&lt;style&gt;参数可以是<code>shallow</code>或<code>deep</code>。<code>shallow</code>线程使得每一封邮件都可以回复该系列的头部，头部从封面信件，<code>--in-reply-to</code>第一个补丁邮件中按顺序选择。<code>deep</code>线程使每个邮件回复到前一个邮件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认值是<code>--no-thread</code>，除非<code>format.thread</code>配置已设置。如果<code>--thread</code>未指定样式，则默认为由<code>format.thread</code>if 指定的样式，否则<code>shallow</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，默认设置<code>git send-email</code>是线程邮件本身。如果你想<code>git format-patch</code>照顾线程，你需要确保禁用线程<code>git send-email</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--in-reply-to=Message-Id</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使第一封邮件（或所有邮件<code>--no-thread</code>）显示为对给定 Message-Id的回复，从而避免中断线程以提供新的补丁系列。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--ignore-if-in-upstream</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请勿在&lt;until&gt; .. &lt;since&gt;中包含与提交相匹配的修补程序。这将检查从&lt;since&gt;但不是从&lt;until&gt;到达的所有修补程序，并将它们与正在生成的修补程序进行比较，并且忽略匹配的任何修补程序。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--subject-prefix=&lt;Subject-Prefix&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>而不是<code>[PATCH]</code>主题行中的标准前缀，而是使用<code>[&lt;Subject-Prefix&gt;]</code>。这允许对补丁序列进行有用的命名，并且可以与<code>--numbered</code>选项结合使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--rfc</p></div></div><div class="doc-postil"><div class="c-markdown"><p>别名<code>--subject-prefix="RFC PATCH"</code>。RFC 意思是“征求意见”; 在发送实验性补丁以供讨论而不是应用时使用它。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-v &lt;n&gt;   --reroll-count=&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将该系列标记为该主题的第n次迭代。输出文件名已<code>v&lt;n&gt;</code>添加到它们，并且主题前缀（缺省情况下为“PATCH”，但可通过<code>--subject-prefix</code>选项配置）已<code>v&lt;n&gt;</code>附加到它。例如<code>--reroll-count=4</code>可能会产生<code>v4-0001-add-makefile.patch</code>具有“主题：PATCH v4 1/20添加makefile”的文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--to=&lt;email&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将<code>To:</code>标题添加到电子邮件标题。这是除了任何配置的标题之外，可能会多次使用。否定形式<code>--no-to</code>丢弃<code>To:</code>迄今为止添加的所有头文件（来自配置或命令行）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--cc=&lt;email&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将<code>Cc:</code>标题添加到电子邮件标题。这是除了任何配置的标题之外，可能会多次使用。否定形式<code>--no-cc</code>丢弃<code>Cc:</code>迄今为止添加的所有头文件（来自配置或命令行）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--from   --from=&lt;ident&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>ident</code>在<code>From:</code>每个提交电子邮件的标题中使用。如果提交的作者标识与提供的文本不相同，则在原始作者的邮件正文中<code>ident</code>放置一个<code>From:</code>标题。如果没有<code>ident</code>给出，请使用提交者标识。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，此选项仅在您实际发送电子邮件并希望将自己标识为发件人时有用，但保留原作者（并且<code>git am</code>将正确拾取主体内标头）。还请注意，<code>git send-email</code>已经为您处理这种转换，并且如果您要将结果提供给该选项，则不应使用此选项<code>git send-email</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--add-header=&lt;header&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将任意标题添加到电子邮件标题。这是除了任何配置的标题之外，可能会多次使用。例如，<code>--add-header="Organization: git-foo"</code>。否定形式<code>--no-add-header</code>丢弃<strong>所有</strong>（<code>To:</code>，<code>Cc:</code>和自定义）标题添加到配置或命令行。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-cover-letter</p></div></div><div class="doc-postil"><div class="c-markdown"><p>除了这些补丁之外，还要生成一个包含分支描述，shortlog 和总体diffstat的封面文件。您可以在发送之前在文件中填写说明。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--notes=&lt;ref&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在三条虚线后添加注释（请参阅 git-notes [1]）以进行提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>预期的用例是编写不属于提交日志消息的提交的支持解释，并将其包含在补丁提交中。尽管可以在<code>format-patch</code>运行之后但在发送之前简单地编写这些解释，但将它们保留为Git便笺可让它们在补丁系列的各个版本之间维护它们（但请参阅<code>notes.rewrite</code>git-notes [1]中有关使用此工作流的配置选项的讨论）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-signature=&lt;signature&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>为每条生成的消息添加一个签名。根据 RFC 3676，签名与身体之间由一条带“ - ”的线隔开。如果省略签名选项，则签名默认为 Git 版本号。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--signature-file=&lt;file&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>就像 - 签名（--signature）一样工作，除了从文件读取签名。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--suffix=.&lt;sfx&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要<code>.patch</code>使用指定的后缀作为生成的文件名的后缀。一个常见的选择是<code>--suffix=.txt</code>。将其留空将删除<code>.patch</code>后缀。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>请注意，主角不一定是点; 例如，你可以<code>--suffix=-patch</code>用来获取<code>0001-description-of-my-change-patch</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-q   --quiet</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要将生成的文件的名称打印到标准输出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-binary</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要在二进制文件中输出更改的内容，而是显示这些文件已更改的通知。使用此选项生成的修补程序无法正确应用，但它们对代码审阅仍然有用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--zero-commit</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在每个修补程序的 From 头中输出全零散列，而不是提交的散列。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--base=&lt;commit&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>记录基本树信息以标识补丁系列适用的状态。有关详细信息，请参阅下面的基础树信息部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--root</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将修订参数视为&lt;修订范围&gt;，即使它只是单个提交（通常会被视为&lt;since&gt;）。请注意，包含在指定范围内的根提交始终格式化为创建补丁，与此标志无关。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>组态</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以指定要添加到每封邮件的额外邮件标题行，主题前缀和文件后缀的默认值，输出多个修补程序时的数字修补程序，添加“To”或“Cc：”标题，配置附件以及注销修补程序带有配置变量。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">[format]
        headers = "Organization: git-foo\n"
        subjectPrefix = CHANGE
        suffix = .txt
        numbered = auto
        to = &lt;email&gt;
        cc = &lt;email&gt;
        attach [ = mime-boundary-string ]
        signOff = true
        coverletter = auto</pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>讨论</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>生成的补丁<code>git format-patch</code>是 UNIX 邮箱格式的，带有一个固定的“魔术”时间戳，表示该文件是从 format-patch 而不是真实邮箱输出的，如下所示：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">From 8f72bad1baf19a53459661343e21d6491c3908d3 Mon Sep 17 00:00:00 2001From: Tony Luck &lt;tony.luck@intel.com&gt;Date: Tue, 13 Jul 2010 11:42:54 -0700Subject: [PATCH] =?UTF-8?q?[IA64]=20Put=20ia64=20config=20files=20on=20the=20?= =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig=20diet?=MIME-Version: 1.0Content-Type: text/plain; charset=UTF-8Content-Transfer-Encoding: 8bit

arch/arm config files were slimmed down using a python script(See commit c2330e286f68f1c408b4aa6515ba49d57f05beae comment)Do the same for ia64 so we can have sleek &amp; trim looking...</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>通常，它将被放置在 MUA 的草稿文件夹中，进行编辑以便及时添加评论，这些评论不应在三条破折号后进入更改日志中，然后作为消息发送，在我们的示例中，其主体以“arch / arm配置文件开头...”。在接收端，读者可以在 UNIX 邮箱中保存有趣的补丁，并将其应用于git-am [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当补丁是正在进行的讨论的一部分时，<code>git format-patch</code>可以调整补丁生成的补丁以利用该<code>git am --scissors</code>特性。在对讨论作出回应后，会出现一行仅包含“ <code>-- &gt;8 --</code>”（剪刀和穿孔）的行，然后是带有不必要的标题字段的修补程序：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">...&gt; So we should do such-and-such.Makes sense to me.  How about this patch?-- &gt;8 --Subject: [IA64] Put ia64 config files on the Uwe Kleine-K��nig diet

arch/arm config files were slimmed down using a python script...</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>以这种方式发送补丁程序时，通常您会发送自己的补丁程序，因此除了“ <code>From $SHA1 $magic_timestamp</code>”标记之外，您应该省略<code>From:</code>并<code>Date:</code>从补丁程序文件中直接输入。补丁标题可能与补丁所回应的讨论主题不同，因此您可能希望保留Subject：行，如上例所示。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>检查修补程序损坏</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>许多邮件程序如果设置不当会破坏空白。这里有两种常见的腐败类型：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>没有<code>any</code>空格的空上下文行。</p></li><li><p>非空的上下文行在开始处有一个额外的空白字符。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>测试 MUA 是否正确设置的一种方法是：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>将修补程序发送给您自己，完全按照您的方式发送，除了To：和Cc：行不包含列表和维护者地址。</p></li><li><p>以 UNIX 邮箱格式将该修补程序保存到文件中。说它称为a.patch。</p></li><li><p>应用它：$ git fetch &lt;project&gt; master：test-apply $ git checkout test-apply $ git reset --hard $ git am a.patch</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>如果不正确应用，可能有各种原因。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>补丁本身并不适用。这<code>bad</code>与你的 MUA 没有多大关系。在这种情况下重新生成之前，您可能需要使用 git-rebase [1]重新绑定修补程序。</p></li><li><p>MUA 破坏了你的补丁; “我”会抱怨补丁不适用。查看 .git / rebase-apply /子目录，查看<code>patch</code>包含的文件，并检查上面提到的常见损坏模式。</p></li><li><p>在它的同时，检查<code>info</code>和<code>final-commit</code>文件。如果<code>final-commit</code>进入的内容与提交日志消息中不完全相同，接收者很可能在应用您的补丁时最终手动编辑日志消息。诸如“你好，这是我的第一个补丁。”补丁电子邮件中的\ n应该出现在表示提交消息结束的三点划线之后。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><h2>Mua 特有的提示</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>以下是有关如何使用各种邮件程序成功提交内联补丁的一些提示。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>GMail</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>GMail 没有任何方法可以关闭网络界面中的换行功能，因此它会破坏您发送的任何电子邮件。然而，您可以使用“git send-email”并通过 GMail SMTP 服务器发送补丁，或者使用任何 IMAP 电子邮件客户端连接到谷歌 IMAP 服务器并通过它转发电子邮件。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有关使用<code>git send-email</code>通过 GMail SMTP 服务器发送补丁的提示，请参阅 git-send-email [1]的示例部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有关使用 IMAP 界面提交的提示，请参阅 git-imap-send [1]的示例部分。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>雷鸟（Thunderbird）</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，Thunderbird 既会封装电子邮件，也会将它们标记为存在<code>format=flowed</code>，这两者都会使得由 Git 导致的电子邮件无法使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>有三种不同的方法：使用附件关闭换行，将 Thunderbird 配置为不破坏修补程序，或使用外部编辑器阻止 Thunderbird 修补修补程序。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4>方法＃1（附加）</h4></div></div><div class="doc-postil"><div class="c-markdown"><p>安装可从 <strong>https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/</strong><a href="https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/" target="_blank"> </a>获得的切换单词封套加载项。它在作曲家的“选项”菜单中添加菜单项“启用 Word 封套”你可以打勾。现在，您可以按照其他方式撰写邮件（剪切+粘贴，<code>git format-patch</code>| <code>git imap-send</code>等），但必须在键入的任何文本中手动插入换行符。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4>方法＃2（配置）</h4></div></div><div class="doc-postil"><div class="c-markdown"><p>三个步骤：</p></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>将您的邮件服务器组合配置为纯文本：编辑...帐户设置...组合和地址，取消选中“用 HTML 编写邮件”。</p></li><li><p>配置你的一般合成窗口不要换行。在 Thunderbird 2：Edit..Preferences..Composition中，在Thunderbird 3：Edit..Preferences..Advanced..Config Editor 中将纯文本消息包装为0。搜索“mail.wrap_long_lines”。切换它以确保它已设置为<code>false</code>。此外，搜索“mailnews.wraplength”并将值设置为0。</p></li><li><p>禁用使用 format = flowed：Edit..Preferences..Advanced..Config Editor。搜索“mailnews.send_plaintext_flowed”。切换它以确保它已设置为<code>false</code>。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>完成之后，您应该能够编写电子邮件，否则会（剪切+粘贴，<code>git format-patch</code>| <code>git imap-send</code>等），并且修补程序不会被损坏。</p></div></div><div class="doc-postil"><div class="c-markdown"><h4>方法＃3（外部编辑器）</h4></div></div><div class="doc-postil"><div class="c-markdown"><p>需要以下Thunderbird扩展：<strong>http ://aboutconfig.mozdev.org/的AboutConfig</strong> 和<strong>http://globs.org/articles.php?lng=en&amp;pg=8的</strong>外部编辑器</p></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>使用您选择的方法将补丁作为文本文件准备。</p></li><li><p>在打开撰写窗口之前，使用编辑→帐户设置取消选中用于发送补丁的帐户的“撰写和寻址”面板中的“以 HTML 格式撰写邮件”设置。</p></li><li><p>在主 Thunderbird 窗口中，<code>before</code>打开修补程序的撰写窗口，使用工具→about：config 将以下内容设置为指示值：mailnews.send_plaintext_flowed =&gt; false mailnews.wraplength =&gt; 0</p></li><li><p>打开撰写窗口并单击外部编辑器图标。</p></li><li><p>在外部编辑器窗口中，读入补丁文件并正常退出编辑器。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>注意：可以使用 about：config 和以下设置执行第2步，但尚未尝试过。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">        mail.html_compose                       =&gt; false
        mail.identity.default.compose_html      =&gt; false
        mail.identity.id?.compose_html          =&gt; false</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>在 contrib / thunderbird-patch-inline中有一个脚本，它可以帮助您以简单的方式在 Thunderbird 中包含修补程序。要使用它，请执行上述步骤，然后使用脚本作为外部编辑器。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>KMail</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>这应该可以帮助您使用 KMail 内联提交补丁。</p></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>准备修补程序作为文本文件。</p></li><li><p>点击新邮件。</p></li><li><p>在 Composer 窗口中的“选项”下面，确保没有设置“自动换行”。</p></li><li><p>使用消息→插入文件...并插入修补程序。</p></li><li><p>返回撰写窗口：在邮件中添加您希望的任何其他文本，填写地址和主题字段，然后按发送。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><h2>基础树信息</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>基本树信息块用于维护人员或第三方测试人员了解修补程序系列适用的确切状态。它包括的<code>base commit</code>，这是一个众所周知的承诺即是该项目历史上其他人的稳定部分的一部分工作过的，零个或多个<code>prerequisite patches</code>，这是众所周知的补丁在飞行中是没有的又一部分<code>base commit</code>是需要<code>base commit</code>在补丁应用之前以拓扑顺序应用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在<code>base commit</code>被示为“基提交：”，后跟提交对象名称的40进制。<code>prerequisite patch</code>显示为“prerequisite-patch-id：”，后跟40-hex <code>patch id</code>，可通过将<code>git patch-id --stable</code>命令传递给补丁来获得。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>想象一下，在公共提交 P 的基础上，你从其他人那里应用了众所周知的补丁 X，Y 和 Z，然后构建了你的三个补丁系列 A，B，C，历史将会是这样的：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">---P---X---Y---Z---A---B---C</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>git format-patch --base=P -3 C</code>（或其变体，例如使用<code>--cover-letter</code>或使用<code>Z..C</code>而不是<code>-3 C</code>指定范围），基本树信息块显示在命令输出的第一条消息（第一个补丁或封面信函）的末尾，如下所示：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">base-commit: P
prerequisite-patch-id: X
prerequisite-patch-id: Y
prerequisite-patch-id: Z</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>对于非线性拓扑，如</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">---P---X---A---M---C
    \         /
     Y---Z---B</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>您也可以使用<code>git format-patch --base=P -3 C</code>为 A，B 和 C 生成补丁，P，X，Y，Z的标识符将附加在第一条消息的末尾。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>--base=auto</code>在 cmdline 中设置，它将自动跟踪基本提交，基本提交将成为远程跟踪分支的提交提交和 cmdline 中指定的修订范围的合并基础。对于本地分支，您需要<code>git branch --set-upstream-to</code>在使用此选项之前跟踪远程分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>示例</h2></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>提取修订 R1 和 R2 之间的提交，然后将它们应用到当前分支的顶部，并用<code>git am</code>樱桃选择它们：$ git format-patch -k --stdout R1..R2 | git am -3 -k</p></li><li><p>提取当前分支中但不在原始分支中的所有提交：$ git format-patch origin</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>对于每个提交，在当前目录中创建一个单独的文件。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>提取<code>origin</code>自项目开始以来的所有提交：$ git format-patch --root origin</p></li><li><p>与前一个相同：$ git format-patch -M -b origin</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>此外，它还可以检测并处理重命名并完全重写以生成重命名补丁。重命名补丁减少了文本输出量，并且通常更容易查看。请注意，非 Git“修补程序”程序不会理解重命名修补程序，所以只有当您知道收件人使用 Git 来应用修补程序时才使用它。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>从当前分支中提取三个最高提交并将它们格式化为电子邮件补丁：$ git format-patch -3</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><h2>也可以看看</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-am[1], git-send-email[1]</p></div></div></div>