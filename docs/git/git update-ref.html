<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>命名</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-update-ref  - 安全地更新存储在ref中的对象名称</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">git update-ref [-m &lt;reason&gt;] (-d &lt;ref&gt; [&lt;oldvalue&gt;] | [--no-deref] [--create-reflog] &lt;ref&gt; &lt;newvalue&gt; [&lt;oldvalue&gt;] | --stdin [-z])</pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>给定两个参数，将&lt;newvalue&gt;存储在&lt;ref&gt;中，可能会取消引用符号引用。例如，<code>git update-ref HEAD &lt;newvalue&gt;</code>将当前分支头更新为新对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>给定三个参数，在验证&lt;ref&gt;的当前值匹配&lt;oldvalue&gt;之后，将&lt;newvalue&gt;存储在&lt;ref&gt;中，可能会解引用符号引用。例如<code>git update-ref refs/heads/master &lt;newvalue&gt; &lt;oldvalue&gt;</code>，只有当它的当前值是&lt;oldvalue&gt;时，才将主分支头更新为&lt;newvalue&gt;。您可以指定40“0”或空字符串作为&lt;oldvalue&gt;以确保您创建的引用不存在。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>它还允许“ref”文件通过从“ref：”的四字节标题序列开始，成为另一个ref文件的符号指针。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>更重要的是，它允许ref文件的更新遵循这些符号指针，无论它们是符号链接还是这些“常规文件符号引用”。它仅在以“refs /”开头时遵循<strong>真正的</strong>符号链接：否则它只会尝试读取它们并将它们更新为常规文件（即，它将允许文件系统跟随它们，但会覆盖此类符号链接到其他位置一个普通的文件名）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果给出--no-deref，则&lt;ref&gt;本身被覆盖，而不是遵循符号指针的结果。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一般来说，使用</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">git update-ref HEAD "$head"</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>应该<code>lot</code>比做更安全</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">echo "$head" &gt; "$GIT_DIR/HEAD"</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>从符号链接<strong>和</strong>错误检查的角度来看都是如此。符号链接的“refs /”规则意味着指向树“外部”的符号链接是安全的：它们将被读取而不是写入（因此，我们将永远不会通过ref符号链接写入其他树，如果您通过创建符号链接树来复制整个存档）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>-d</code>标志，它会在验证它仍包含&lt;oldvalue&gt;后删除指定的&lt;ref&gt;。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>With <code>--stdin</code>，update-ref从标准输入读取指令并一起执行所有修改。指定表单的命令：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">update SP &lt;ref&gt; SP &lt;newvalue&gt; [SP &lt;oldvalue&gt;] LF
create SP &lt;ref&gt; SP &lt;newvalue&gt; LFdelete SP &lt;ref&gt; [SP &lt;oldvalue&gt;] LF
verify SP &lt;ref&gt; [SP &lt;oldvalue&gt;] LF
option SP &lt;opt&gt; LF</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>与此同时<code>--create-reflog</code>，即使通常不会创建一个ref，update-ref也会为每个ref创建一个reflog。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>引用包含空白的字段，就好像它们是C源代码中的字符串一样; 即由双引号和反斜杠转义字符包围。使用40个“0”字符或空字符串指定一个零值。要指定缺失值，请完全省略该值及其前面的SP。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>或者，使用<code>-z</code>以NUL终止的格式指定，不用引用：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">update SP &lt;ref&gt; NUL &lt;newvalue&gt; NUL [&lt;oldvalue&gt;] NUL
create SP &lt;ref&gt; NUL &lt;newvalue&gt; NULdelete SP &lt;ref&gt; NUL [&lt;oldvalue&gt;] NUL
verify SP &lt;ref&gt; NUL [&lt;oldvalue&gt;] NUL
option SP &lt;opt&gt; NUL</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>在这种格式中，使用40“0”来指定零值，并使用空字符串指定缺失值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>无论哪种格式，值都可以以Git认为是对象名称的任何形式指定。任何其他格式的命令或重复的&lt;ref&gt;都会产生错误。命令的含义是：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>更新</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果给定，在验证&lt;oldvalue&gt;之后将&lt;ref&gt;设置为&lt;newvalue&gt;。指定一个零&lt;newvalue&gt;以确保ref在更新后不存在和/或一个零&lt;oldvalue&gt;以确保ref在更新之前不存在。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>create</p></div></div><div class="doc-postil"><div class="c-markdown"><p>验证它不存在后，用&lt;newvalue&gt;创建&lt;ref&gt;。给定的&lt;newvalue&gt;可能不是零。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>delete</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果给定，在验证它存在&lt;oldvalue&gt;之后删除&lt;ref&gt;。如果给出，&lt;oldvalue&gt;可能不是零。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>verify</p></div></div><div class="doc-postil"><div class="c-markdown"><p>验证&lt;ref&gt;与&lt;oldvalue&gt;，但不要更改它。如果&lt;oldvalue&gt;零或丢失，则ref不能存在。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>option</p></div></div><div class="doc-postil"><div class="c-markdown"><p>修改命名&lt;ref&gt;的下一个命令的行为。唯一有效的选择是<code>no-deref</code>避免取消引用符号引用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果所有&lt;ref&gt; s可以同时与匹配的&lt;oldvalue&gt;锁定，则会执行所有修改。否则，不会执行修改。请注意，虽然每个单独的&lt;ref&gt;以原子方式更新或删除，但并发读者仍可能看到修改的子集。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>记录更新</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>如果配置参数“core.logAllRefUpdates”为true并且ref为“refs / heads /”，“refs / remotes /”，“refs / notes /”下的符号，或者符号ref HEAD; 或者存在“$ GIT_DIR / logs / &lt;ref&gt;”文件，则会在日志文件“$ GIT_DIR / logs / &lt;ref&gt;”后<code>git update-ref</code>添加一行（在创建日志名称前解除所有符号引用），描述ref值的变化。日志行格式为：</p></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>oldsha1 SP newsha1 SP提交者LF其中“oldsha1”是先前存储在&lt;ref&gt;中的40个字符的十六进制值，“newsha1”是&lt;newvalue&gt;的40个字符的十六进制值，“committer”是提交者的姓名，电子邮件地址和日期标准的Git提交者ident格式。可选用-m：</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>oldsha1 SP newsha1 SP 提交者 TAB 消息 LF</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>其中所有字段均如上所述，“消息”是提供给 -m 选项的值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果当前用户无法创建新的日志文件，追加到现有的日志文件或没有可用的提交者信息，则更新将失败（不会更改&lt;ref&gt;）。</p></div></div></div>