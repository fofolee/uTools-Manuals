<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>名称</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-cvsimport  - 将您的数据从另一个人们喜欢讨厌的 SCM 中拯救出来</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">git cvsimport [-o &lt;branch-for-HEAD&gt;] [-h] [-v] [-d &lt;CVSROOT&gt;]              [-A &lt;author-conv-file&gt;] [-p &lt;options-for-cvsps&gt;] [-P &lt;file&gt;]              [-C &lt;git_repository&gt;] [-z &lt;fuzz&gt;] [-i] [-k] [-u] [-s &lt;subst&gt;]              [-a] [-m] [-M &lt;regex&gt;] [-S &lt;regex&gt;] [-L &lt;commitlimit&gt;]              [-r &lt;remote&gt;] [-R] [&lt;CVS_module&gt;]</pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p><strong>警告：</strong> <code>git cvsimport</code>使用 cvsps 版本2，这被视为弃用; 它不适用于 cvsps 版本3和更高版本。如果您正在执行 CVS 存储库的一次性导入，请考虑使用cvs2git或cvs-fast-export。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将 CVS 存储库导入 Git。它将创建一个新的存储库，或者增量导入到现有的存储库中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将 CVS 日志分割成补丁集是由<code>cvsps</code>。至少需要2.1版本。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><strong>警告：</strong>对于某些情况下导入导致不正确的结果。请参阅“问题”一节以作进一步参考。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>你应该<strong>永远不会</strong>做由创建的分支自己的任何工作<code>git cvsimport</code>。默认情况下，初始导入将创建并填充
 CVS 存储库的主分支的“主”分支，您可以自由使用该分支; 之后，您需要<code>git merge</code>自行增量导入或任何 CVS 分支。建议通过-r指定一个命名的远程来分隔和保护传入的分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您打算建立一个所有开发人员都可以读/写的共享公共存储库，或者如果您想使用 git-cvsserver [1]，那么您可能想要对导入的存储库进行裸克隆，并将克隆用作共享存储库。请参阅 gitcvs-migration [7]。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>-v</p></div></div><div class="doc-postil"><div class="c-markdown"><p>详细程度：让我们<code>cvsimport</code>报告它在做什么。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-d &lt;CVSROOT&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>CVS 存档的根。可能是本地（简单路径）或远程; 目前，仅支持：local :，：ext：和：pserver：访问方法。如果没有给出，<code>git cvsimport</code>将尝试读取它<code>CVS/Root</code>。如果不存在这样的文件，它检查<code>CVSROOT</code>环境变量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;CVS_module&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您要导入的 CVS 模块。相对于&lt;CVSROOT&gt;。如果没有给出，<code>git cvsimport</code>尝试从<code>CVS/Repository</code>读取它。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-C &lt;target-dir&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>要导入到的 Git 存储库。如果该目录不存在，它将被创建。默认是当前目录。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-r &lt;remote&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将此 CVS 存储库导入到远程的 Git。类似于默认使用<code>origin</code>的<code>git clone</code>方式，将所有 CVS 分支移动到远程/ &lt;远程&gt; / &lt;分支&gt;中。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-o &lt;branch-for-HEAD&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果没有指定 remote（通过-r），则 CVS 的<code>HEAD</code>分支将被导入到 Git 存储库中的<code>origin</code>分支中，因为<code>HEAD</code>已经对 Git 有特殊意义。当指定远程时，<code>HEAD</code>分支命名为远程/远程/主镜像<code>git clone</code>行为。如果要导入到其他分支，请使用此选项。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>使用<code>-o master</code>继续，最初由旧的 cvs2git 工具进行导入。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-i</p></div></div><div class="doc-postil"><div class="c-markdown"><p>仅导入：导入后不要执行检出切换。这个选项确保工作目录和索引保持不变，如果它们不存在，将不会创建它们。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-k</p></div></div><div class="doc-postil"><div class="c-markdown"><p>杀死关键字：将<code>-kk</code>文件从 CVS 存档中提取，以避免噪音变化集。强烈建议，但默认关闭以保持与早期导入树的兼容性。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-u</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将标记和分支名称中的下划线转换为点。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-s &lt;subst&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>用&lt;subst&gt;替换分支名称中的字符“/”</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-p &lt;options-for-cvsps&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>cvsps 的其他选项。选项<code>-u</code>和<code>-A</code>是隐式的，不应该用在这里。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您需要传递多个选项，请用逗号分隔它们。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-z &lt;fuzz&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以秒为单位将时间戳模糊因子传递给 cvsps。如果未设置，则 cvsps 默认为300秒。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-P &lt;cvsps-output-file&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>不要调用 cvsps，请阅读提供的 cvsps 输出文件。用于调试或在 cvsimport 之外处理cvsps时使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-m</p></div></div><div class="doc-postil"><div class="c-markdown"><p>尝试根据提交消息检测合并。此选项将启用试图从提交消息中捕获源分支名称的默认正则表达式。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-M &lt;regex&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>尝试使用自定义正则表达式检测基于提交消息的合并。它也可以用来<code>-m</code>启用默认的正则表达式。你必须逃避正斜杠。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>正则表达式必须在$ 1中捕获源分支名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>该选项可以多次使用以提供多个检测正则表达式。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-S &lt;regex&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>跳过与正则表达式匹配的路径。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-a</p></div></div><div class="doc-postil"><div class="c-markdown"><p>导入所有提交，包括最近的提交。默认情况下，cvsimport会跳过时间小于10分钟前的提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-L &lt;limit&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>限制导入的提交数量。解决 cvsimport 泄漏内存的问题。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-A &lt;author-conv-file&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，CVS 在编写提交日志时使用 Unix 用户名。使用此选项和 author-conv-file 将在 CVS 中记录的名称映射到作者姓名，电子邮件和可选时区：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">        exon=Andreas Ericsson &lt;ae@op5.se&gt;
        spawn=Simon Pawn &lt;spawn@frog-pond.org&gt; America/Chicago</pre></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git cvsimport</code>将使其显示为这些作者始终正确设置了其 GIT_AUTHOR_NAME和GIT_AUTHOR_EMAIL。如果指定了时区，则
 GIT_AUTHOR_DATE 将应用相应的偏移量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>为方便起见，每次<code>-A</code>提供选项时都会保存此数据到<code>$GIT_DIR/cvs-authors</code>，并且每次<code>git cvsimport</code>运行时都会从同一文件中读取。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您打算稍后使用<code>git cvsexportcommit</code>再将更改导出回 CVS，则不推荐使用此功能。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-R</p></div></div><div class="doc-postil"><div class="c-markdown"><p>生成<code>$GIT_DIR/cvs-revisions</code>包含从 CVS 修订号到新创建的 Git 提交 ID 的映射的文件。生成的文件将为导入的每个（文件名，修订版）对包含一行; 每一行看起来像</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">src/widget.c 1.1 1d862f173cdc7325b6fa6d2ae1cfd61fd1b512b7</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>如果修订数据已经存在，则修改数据会附加到该文件，以便在执行增量导入时使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您将 CVS 修订号存储在提交消息，错误跟踪系统，电子邮件存档等中，则此选项可能很有用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-h</p></div></div><div class="doc-postil"><div class="c-markdown"><p>打印一条简短的使用信息并退出。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>输出</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>如果<code>-v</code>指定，脚本报告它正在做什么。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>否则，成功表示为 Unix 方式，即通过简单地以零退出状态退出。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>问题</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>与时间戳有关的问题：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>如果 CVS 存储库中的提交时间戳不够稳定，无法用于排序提交，则更改可能以错误的顺序显示。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>如果有任何文件曾多次“cvs import”编辑过（例如，导入多个供应商版本），则 HEAD 包含错误的内容。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>如果不同文件的时间戳顺序在提交匹配时间窗口内与修订订单相交，提交顺序可能是错误的。与分支有关的问题：</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>未提交任何提交的分支未导入。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>即使从未添加到CVS中，分支点中的所有文件也会添加到分支中。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>这适用于创建子分支<strong>后</strong>添加到源分支的文件：如果先前没有对子分支进行提交，它们将错误地添加到 git 中的子分支中。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>与标签相关的问题：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>不会导入同一修订版中的多个标记。如果您怀疑这些问题中的任何一个可能适用于要导入的存储库，请考虑使用 cvs2git：</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>cvs2git (part of cvs2svn), <code>http://subversion.apache.org/</code></p></li></ul></div></div></div>