<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>命名</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>giteveryday  -  Everyday Git 的一组有用的最小命令</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>每天 Git 有20个命令或者如此</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>Git 用户可以大致分为四类，用于描述日常 Git 的一小部分有用命令。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>个人开发者（独立）命令对于任何进行提交的人都是必不可少的，即使对于单独工作的人也是如此。</p></li><li><p>如果您与其他人一起工作，您还需要个人开发者（参与者）部分中列出的命令。</p></li><li><p>扮演集成角色的人除了需要上面的内容外，还需要学习更多的命令。</p></li><li><p>存储库管理命令用于负责照顾和提供 Git 存储库的系统管理员。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><h2>个人开发者（独立）</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>独立的个人开发人员不会与其他人交换补丁，并使用以下命令单独在单个资源库中工作。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>git-init [1]创建一个新的存储库。</p></li><li><p>git-log [1]看看发生了什么。</p></li><li><p>git-checkout [1]和git-branch [1]来切换分支。</p></li><li><p>git-add [1]来管理索引文件。</p></li><li><p>git-diff [1]和git-status [1]来查看你在做什么。</p></li><li><p>git-commit [1]推进当前分支。</p></li><li><p>git-reset [1]和git-checkout [1]（带路径名参数）撤销更改。</p></li><li><p>git-merge [1]在本地分支之间合并。</p></li><li><p>git-rebase [1]维护主题分支。</p></li><li><p>git-tag [1]标记已知点。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><h3>例子</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>使用 tarball 作为新存储库的起点。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ tar zxf frotz.tar.gz
$ cd frotz
$ git init
$ git add . (1)$ git commit -m "import of frotz source tree."$ git tag v2.43 (2)</pre></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>在当前目录下添加所有内容。</p></li><li><p>制作一个轻量级，不带标签的标签。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>创建主题分支并进行开发。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ git checkout -b alsa-audio (1)$ edit/compile/test
$ git checkout -- curses/ux_audio_oss.c (2)$ git add curses/ux_audio_alsa.c (3)$ edit/compile/test
$ git diff HEAD (4)$ git commit -a -s (5)$ edit/compile/test
$ git diff HEAD^ (6)$ git commit -a --amend (7)$ git checkout master (8)$ git merge alsa-audio (9)$ git log --since='3 days ago' (10)$ git log v2.43.. curses/ (11)</pre></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>创建一个新的主题分支。</p></li><li><p>恢复你的拙劣的变化<code>curses/ux_audio_oss.c</code>。</p></li><li><p>如果你添加了一个新文件，你需要告诉Git; 如果您<code>git commit -a</code>稍后再做，删除和修改将会被捕获。</p></li><li><p>查看您正在提交的更改。</p></li><li><p>按照您的测试，承诺您的签名。</p></li><li><p>查看所有更改，包括以前的提交。</p></li><li><p>修改以前的提交，使用原始消息添加所有新的更改。</p></li><li><p>切换到主分支。</p></li><li><p>将主题分支合并到您的主分支中。</p></li><li><p>审查提交日志; 限制输出的其他形式可以组合并包括<code>-10</code>（最多显示10次提交）<code>--until=2005-12-10</code>等。</p></li><li><p><code>curses/</code>由于<code>v2.43</code>标记，只查看触及目录内容的更改。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><h2>个人开发者（参与者）</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>作为团队项目参与者的开发人员需要学习如何与他人沟通，并使用这些命令以及独立开发人员所需的命令。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>git-clone [1] 从上游迁移到本地存储库。</p></li><li><p>git-pull [1] 和 git-fetch [1]从 “origin” 与上游保持同步。</p></li><li><p>如果您采用 CVS 风格的共享存储库工作流，请将 git-push [1] 共享存储库。</p></li><li><p>git-format-patch [1] 准备电子邮件提交，如果你采用 Linux 内核式的公共论坛工作流程。</p></li><li><p>git-send-email [1] 发送您的电子邮件提交没有由您的 MUA 腐败。</p></li><li><p>git-request-pull [1] 为你的上游创建一个变更摘要。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><h3>例子</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>克隆上游并开始工作。Feed 更改为上游。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ git clone git://git.kernel.org/pub/scm/.../torvalds/linux-2.6 my2.6$ cd my2.6$ git checkout -b mine master (1)$ edit/compile/test; git commit -a -s (2)$ git format-patch master (3)$ git send-email --to="person &lt;email@example.com&gt;" 00*.patch (4)$ git checkout master (5)$ git pull (6)$ git log -p ORIG_HEAD.. arch/i386 include/asm-i386 (7)$ git ls-remote --heads http://git.kernel.org/.../jgarzik/libata-dev.git (8)$ git pull git://git.kernel.org/pub/.../jgarzik/libata-dev.git ALL (9)$ git reset --hard ORIG_HEAD (10)$ git gc (11)</pre></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p><code>mine</code>从主人结帐一个新的分支。</p></li><li><p>根据需要重复。</p></li><li><p>从你的分支中提取补丁，相对于主，</p></li><li><p>并给他们发邮件。</p></li><li><p>返回<code>master</code>，准备好看看有什么新鲜事</p></li><li><p><code>git pull</code>从<code>origin</code>默认提取并合并到当前分支。</p></li><li><p>在拉动后立即查看自上次检查以来上游所做的更改，仅限于我们感兴趣的区域。</p></li><li><p>检查外部存储库中的分支名称（如果未知）。</p></li><li><p>从<code>ALL</code>特定存储库的特定分支中获取并合并它。</p></li><li><p>恢复拉力。</p></li><li><p>垃圾收集回复拉的剩余物品。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>推入另一个存储库。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">satellite$ git clone mothership:frotz frotz (1)satellite$ cd frotz
satellite$ git config --get-regexp '^(remote|branch)\.' (2)remote.origin.url mothership:frotz
remote.origin.fetch refs/heads/*:refs/remotes/origin/*
branch.master.remote origin
branch.master.merge refs/heads/master
satellite$ git config remote.origin.push \
           +refs/heads/*:refs/remotes/satellite/* (3)
satellite$ edit/compile/test/commit
satellite$ git push origin (4)

mothership$ cd frotz
mothership$ git checkout master
mothership$ git merge satellite/master (5)</pre></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>母机在您的主目录下有一个 frotz 存储库; 从它克隆到在卫星机器上启动存储库。</p></li><li><p>克隆默认设置这些配置变量。它安排<code>git pull</code>将母机分支机构存放到当地的<code>remotes/origin/*</code>远程追踪分支机构。</p></li><li><p>安排<code>git push</code>将所有当地分支机构推到母机的相应分支。</p></li><li><p>推动将把我们所有的工作都<code>remotes/satellite/*</code>放在母机上的远程跟踪分支上。你可以用它作为备份方法。同样，你可以假装母亲从你身上“获取”（当访问是单方面时很有用）。</p></li><li><p>在母机上，将在卫星机器上完成的工作合并到主分支中。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>分支出一个特定的标签。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ git checkout -b private2.6.14 v2.6.14 (1)$ edit/compile/test; git commit -a
$ git checkout master
$ git cherry-pick v2.6.14..private2.6.14 (2)</pre></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>创建一个基于众所周知的（但有点落后的）标签的私人分支。</p></li><li><p>将<code>private2.6.14</code>分支中的所有更改转发到<code>master</code>分支，而无需正式的“合并”。或者是徒手画 <code>git format-patch -k -m --stdout v2.6.14..private2.6.14 |   git am -3 -k</code></p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>另一个参与者提交机制正在使用<code>git request-pull</code>或拉请求机制（例如 GitHub（www.github.com）上使用的机制来通知您上游的贡献。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>集成</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>作为集体项目集成者的一个相当中心的人接收其他人所做的更改，审核并整合他们，并将结果发布给其他人使用，除了参与者需要的命令之外，还使用这些命令。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这部分内容也可供那些<code>git request-pull</code>对 GitHub（www.github.com）作出响应或请求将其他人的工作整合到其历史中的人使用。储存库的一个子区域中尉将扮演参与者和集成者的角色。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>git-am [1] 应用从您的贡献者电子邮件发送的补丁。</p></li><li><p>git-pull [1] 从你信任的副手中合并。</p></li><li><p>git-format-patch [1] 准备并向贡献者发送推荐替代方案。</p></li><li><p>git-revert [1] 撤消拙劣的提交。</p></li><li><p>git-push [1] 发布出血的边缘。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><h3>例子</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>典型并集成的 Git day。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ git status (1)$ git branch --no-merged master (2)$ mailx (3)&amp; s 2 3 4 5 ./+to-apply&amp; s 7 8 ./+hold-linus&amp; q
$ git checkout -b topic/one master
$ git am -3 -i -s ./+to-apply (4)$ compile/test
$ git checkout -b hold/linus &amp;&amp; git am -3 -i -s ./+hold-linus (5)$ git checkout topic/one &amp;&amp; git rebase master (6)$ git checkout pu &amp;&amp; git reset --hard next (7)$ git merge topic/one topic/two &amp;&amp; git merge hold/linus (8)$ git checkout maint
$ git cherry-pick master~4 (9)$ compile/test
$ git tag -s -m "GIT 0.99.9x" v0.99.9x (10)$ git fetch ko &amp;&amp; for branch in master maint next pu (11)    do
        git show-branch ko/$branch $branch (12)
    done
$ git push --follow-tags ko (13)</pre></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>看看你中间部分做了些什么，如果有的话。</p></li><li><p>看哪些分支还没有合并到<code>master</code>。同样，对于任何其他集成分支如<code>maint</code>，<code>next</code>和<code>pu</code>（潜在的更新）。</p></li><li><p>阅读邮件，保存适用的邮件，并保存其他未准备好的邮件（其他邮件阅读器可用）。</p></li><li><p>以交互方式将它们应用于您的签名。</p></li><li><p>根据需要创建主题分支并再次应用签名。</p></li><li><p>rebase 内部主题分支尚未合并到主或作为稳定分支的一部分公开。</p></li><li><p><code>pu</code>每次从下一次重新启动。</p></li><li><p>并捆绑主题分支仍在烹饪。</p></li><li><p>支持重要的修复。</p></li><li><p>创建一个签名标签。</p></li><li><p>确保主人不会意外地重新超出已经推出的水平。</p></li><li><p>在输出中<code>git show-branch</code>，<code>master</code>应该拥有一切<code>ko/master</code>，并且<code>next</code>应该拥有一切<code>ko/next</code>，等等。</p></li><li><p>推出流血的边缘，以及指向推送历史的新标签。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>在这个例子中，<code>ko</code>简写指向 Git 维护者在 kernel.org 的仓库，看起来像这样：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">(in .git/config)[remote "ko"]
        url = kernel.org:/pub/scm/git/git.git
        fetch = refs/heads/*:refs/remotes/ko/*
        push = refs/heads/master
        push = refs/heads/next
        push = +refs/heads/pu
        push = refs/heads/maint</pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>存储库管理</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>存储库管理员使用以下工具来设置和维护开发人员对存储库的访问。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>git-daemon [1] 允许匿名从版本库下载。</p></li><li><p>git-shell [1] 可以用作<code>restricted login shell</code>共享中央资源库用户。</p></li><li><p>git-http-backend [1] 提供了允许提取和推送服务的 Git-over-HTTP（“Smart http”）的服务器端实现。</p></li><li><p>gitweb [1] 为 Git 存储库提供了 Web 前端，可以使用 git-instaweb [1] 脚本进行设置。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>更新 hook howto 有一个管理共享中央存储库的好例子。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>此外，还有其他一些广泛部署的托管，浏览和审查解决方案，例如：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>gitolite，gerrit 代码审查，cgit 和其他。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><h3>例子</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>我们在 / etc / services 的假设如下</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ grep 9418 /etc/services
git                9418/tcp                # Git Version Control System</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>运行 git-daemon 来从 inetd 提供 / pub / scm 。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ grep git /etc/inetd.conf
git        stream        tcp        nowait        nobody \  /usr/bin/git-daemon git-daemon --inetd --export-all /pub/scm</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>实际的配置线应该在一条线上。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>运行 git-daemon 以从 xinetd 提供 / pub / scm 。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ cat /etc/xinetd.d/git-daemon
# default: off
# description: The Git server offers access to Git repositories
service git{
        disable = no
        type            = UNLISTED
        port            = 9418
        socket_type     = stream
        wait            = no
        user            = nobody
        server          = /usr/bin/git-daemon
        server_args     = --inetd --export-all --base-path=/pub/scm
        log_on_failure  += USERID}</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>检查你的 xinetd（8）文档和设置，这是来自 Fedora 系统。其他可能不同。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>给使用 git-over-ssh 的开发人员提供 push/pull 的访问权限。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>例如那些使用： <code>$ git push/pull ssh://host.xz/pub/scm/project</code></p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ grep git /etc/passwd (1)alice:x:1000:1000::/home/alice:/usr/bin/git-shell
bob:x:1001:1001::/home/bob:/usr/bin/git-shell
cindy:x:1002:1002::/home/cindy:/usr/bin/git-shell
david:x:1003:1003::/home/david:/usr/bin/git-shell
$ grep git /etc/shells (2)/usr/bin/git-shell</pre></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>登录 shell 设置为 / usr / bin / git-shell ，它不允许任何内容<code>git push</code>和<code>git pull</code>。用户需要 ssh 访问机器。</p></li><li><p>在许多发行版中，/ etc / shells 需要列出用作登录 shell 的内容。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><p>CVS 风格的共享库。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ grep git /etc/group (1)git:x:9418:alice,bob,cindy,david
$ cd /home/devo.git
$ ls -l (2)
  lrwxrwxrwx   1 david git    17 Dec  4 22:40 HEAD -&gt; refs/heads/master
  drwxrwsr-x   2 david git  4096 Dec  4 22:40 branches  -rw-rw-r--   1 david git    84 Dec  4 22:40 config  -rw-rw-r--   1 david git    58 Dec  4 22:40 description
  drwxrwsr-x   2 david git  4096 Dec  4 22:40 hooks  -rw-rw-r--   1 david git 37504 Dec  4 22:40 index
  drwxrwsr-x   2 david git  4096 Dec  4 22:40 info
  drwxrwsr-x   4 david git  4096 Dec  4 22:40 objects
  drwxrwsr-x   4 david git  4096 Nov  7 14:58 refs
  drwxrwsr-x   2 david git  4096 Dec  4 22:40 remotes
$ ls -l hooks/update (3)  -r-xr-xr-x   1 david git  3536 Dec  4 22:40 update
$ cat info/allowed-users (4)refs/heads/master        alice\|cindy
refs/heads/doc-update        bob
refs/tags/v[0-9]*        david</pre></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>将开发人员放入同一个 git 组中。</p></li><li><p>并使共享存储库可由组写入。</p></li><li><p>使用来自 Documentation / howto / for 分支策略控制的 Carl 的更新钩子示例。</p></li><li><p>爱丽丝和辛迪可以推进主人，只有鲍勃可以推入文档更新。david 是发布经理，是唯一可以创建和推送版本标签的人。</p></li></ol></div></div></div>