<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>Name</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-fetch  - 从另一个存储库下载对象和引用</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">git fetch [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;…]]git fetch [&lt;options&gt;] &lt;group&gt;git fetch --multiple [&lt;options&gt;] [(&lt;repository&gt; | &lt;group&gt;)…]git fetch --all [&lt;options&gt;]</pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>从一个或多个其他存储库获取分支和/或标签（统称为“参考”），以及完成其历史记录所需的对象。远程跟踪分支已更新（请参阅下面的 &lt;refspec&gt; 描述以了解如何控制此行为）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，还会提取指向正在提取的历史记录的任何标记; 其效果是获取指向您感兴趣的分支的标记。可以使用 --tags 或 --no-tags 选项或通过配置远程。&lt;name&gt; .tagOpt 来更改此默认行为。通过使用显式提取标签的 refspec，您可以获取不指向您感兴趣的分支的标签。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git fetch</code>可以从单个指定的存储库或 URL 中获取数据，也可以在给定 &lt;group&gt; 的情况下同时从多个存储库中获取，并且配置文件中存在远程。&lt;group&gt; 条目。（请参阅 git-config [1]）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果未指定远程，默认情况下<code>origin</code>将使用远程，除非为当前分支配置了上游分支。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>被读取的引用的名称以及它们指向的对象名称将被写入<code>.git/FETCH_HEAD</code>。这些信息可以被脚本或其他 git 命令使用，例如 git-pull [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>--all</p></div></div><div class="doc-postil"><div class="c-markdown"><p>获取所有远端。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-a   --append</p></div></div><div class="doc-postil"><div class="c-markdown"><p>追加 refs 的 ref 名称和对象名称到现有的内容<code>.git/FETCH_HEAD</code>。如果没有这个选项，旧的数据<code>.git/FETCH_HEAD</code>将被覆盖。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--depth=&lt;depth&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>将提取限制为从每个远程分支历史记录的提示中指定的提交数量。如果获取到使用<code>git clone</code>和<code>--depth=&lt;depth&gt;</code>选项 创建的<code>shallow</code>存储库（请参阅 git-clone [1]），请将历史记录加深或缩短为指定的提交数。深化提交的标签不会被提取。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--deepen=&lt;depth&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>与 --depth 相似，只是它指定了来自当前浅层边界而不是每个远程分支历史记录的提示的提交数。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--shallow-since=&lt;date&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>加深或缩短浅储存库的历史记录以在 &lt;date&gt; 之后包含所有可访问的提交。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--shallow-exclude=&lt;revision&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>加深或缩短浅储存库的历史记录以排除可从指定远程分支或标记访问的提交。该选项可以多次指定。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--unshallow</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果源存储库已完成，请将浅层存储库转换为完整存储库，以消除浅存储库施加的所有限制。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>如果源存储库较浅，则尽可能多地获取，以便当前存储库具有与源存储库相同的历史记录。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--update-shallow</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，从浅仓库中获取时，<code>git fetch</code>拒绝需要更新 .git / shallow 的引用。该选项更新 .git / shallow 并接受此类参考。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--dry-run</p></div></div><div class="doc-postil"><div class="c-markdown"><p>显示将做什么，不做任何改变。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-f   --force</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当<code>git fetch</code>与<code>&lt;rbranch&gt;:&lt;lbranch&gt;</code> refspec 一起使用时，它拒绝更新本地分支，<code>&lt;lbranch&gt;</code>除非<code>&lt;rbranch&gt;</code>它获取的远程分支是后代<code>&lt;lbranch&gt;</code>。该选项将覆盖该检查。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-k   --keep</p></div></div><div class="doc-postil"><div class="c-markdown"><p>保持下载的包。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--multiple</p></div></div><div class="doc-postil"><div class="c-markdown"><p>允许指定几个 &lt;repository&gt; 和 &lt;group&gt; 参数。没有 &lt;refspec&gt;s 可能被指定。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-p   --prune</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在提取之前，请删除远程不再存在的所有远程跟踪参考。如果标签仅由于默认标签自动跟随或由于 --tags 选项而被提取，则标签不会被修剪。但是，如果由于明确的 refspec（在命令行或远程配置中，例如，如果远程使用 --mirror 选项克隆）而获取标记，则它们也将受到修改。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-n   --no-tags</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下，指向从远程存储库下载的对象的标签将在本地获取并存储。该选项将禁用此自动标记。远程的默认行为可以通过远程。&lt;name&gt; .tagOpt 设置指定。请参阅 git-config [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--refmap=&lt;refspec&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在获取命令行中列出的 ref 时，使用指定的 refspec（可以多次提供）将 ref 映射到远程跟踪分支，而不是<code>remote.*.fetch</code>远程存储库的配置变量的值。有关详细信息，请参阅“配置远程跟踪分支”一节。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-t   --tags</p></div></div><div class="doc-postil"><div class="c-markdown"><p>从远程获取所有标签（即，将远程标签获取<code>refs/tags/*</code>到具有相同名称的本地标签中），除此之外的任何其他内容都将被提取。即使 --prune 被使用（尽管如果标签也是明确的 refspec 的目的地，可能会被修剪，请参阅<code>--prune</code>），但单独使用此选项不会使标签遭到修剪。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--recurse-submodules=yes|on-demand|no</p></div></div><div class="doc-postil"><div class="c-markdown"><p>此选项控制是否以及在什么条件下也应提取填充的子模块的新提交。它可以用作布尔选项来完全禁用设置为<code>no</code>或设置为无条件递归到所有已填充的子模块时的递归<code>yes</code>，这是使用此选项时没有任何值的默认设置。使用<code>on-demand</code>仅递归到填充的子模块，当上层项目检索提交，更新子模块的参考一犯，是不是已经在本地子模块克隆。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-j   --jobs=&lt;n&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>用于提取子模块的并行子项的数量。每个子模块都将从不同的子模块中获取，从而获取多个子模块的速度会更快。默认情况下，子模块将一次取一个。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--no-recurse-submodules</p></div></div><div class="doc-postil"><div class="c-markdown"><p>禁用递归获取子模块（这与使用该<code>--recurse-submodules=no</code>选项具有相同的效果）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--submodule-prefix=&lt;path&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在信息消息（例如“获取子模块foo”）中打印路径前加上 &lt;path&gt; 。此选项在子模块上递归时用于内部。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--recurse-submodules-default=yes|on-demand</p></div></div><div class="doc-postil"><div class="c-markdown"><p>此选项在内部用于为 --recurse-submodules 选项临时提供非负的默认值。所有其他配置获取子模块递归的方法（例如 gitmodules [5]和 git-config [1]中的设置）将覆盖此选项，就像直接指定 --no-recurse 子模块一样。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-u   --update-head-ok</p></div></div><div class="doc-postil"><div class="c-markdown"><p>默认情况下<code>git fetch</code>拒绝更新对应于当前分支的头部。此标志禁用检查。这纯粹是供内部使用<code>git pull</code>来沟通<code>git fetch</code>，除非你正在实施自己的瓷器，否则你不应该使用它。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--upload-pack &lt;upload-pack&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当给出并且从中获取的存储库被处理时<code>git fetch-pack</code>，<code>--exec=&lt;upload-pack&gt;</code>被传递给该命令以指定在另一端运行的命令的非默认路径。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-q   --quiet</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通过 - 安静的 git-fetch-pack 和沉默任何其他内部使用的 git 命令。进度未报告给标准错误流。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-v   --verbose</p></div></div><div class="doc-postil"><div class="c-markdown"><p>详细。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>--progress</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当连接到终端时，默认情况下，标准错误流中会报告进度状态，除非指定了 -q 。即使标准错误流未定向到终端，此标志也会强制进度状态。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-4   --ipv4</p></div></div><div class="doc-postil"><div class="c-markdown"><p>仅使用 IPv4 地址，忽略 IPv6 地址。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>-6   --ipv6</p></div></div><div class="doc-postil"><div class="c-markdown"><p>仅使用 IPv6 地址，忽略 IPv4 地址。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;repository&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>作为提取或拉取操作源的“远程”存储库。此参数可以是 URL（请参阅下面的 GIT URLS 部分）或远程名称（请参阅下面的 REMOTES 部分）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;group&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>名称指的是存储库列表，作为配置文件中的远程数据 &lt;group&gt; 的值。（请参阅 git-config [1]）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;refspec&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>指定要获取哪些引用以及哪些本地引用要更新。当命令行中没有 &lt;refspec&gt; 时，<code>remote.&lt;repository&gt;.fetch</code>取而代之的是从变量中读取（参见下面的 CONFIGURED REMOTE-TRACKING BRANCHES）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个 &lt;refspec&gt; 参数的格式是一个可选的 plus <code>+</code>，后跟 source &lt;src&gt;，后跟一个冒号<code>:</code>，后跟目标 ref &lt;dst&gt; 。当 &lt;dst&gt;为空时，可以省略冒号。&lt;src&gt; 通常是 ref，但它也可以是拼写完整的十六进制对象名称。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>tag &lt;tag&gt;</code>意味着相同<code>refs/tags/&lt;tag&gt;:refs/tags/&lt;tag&gt;</code>; 它请求将所有内容都提取到给定的标签。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>匹配 &lt;src&gt;的远程 ref 被取出，如果 &lt;dst&gt;不是空字符串，匹配它的本地引用使用 &lt;src&gt; 进行快速转发。如果使用可选的 plus <code>+</code>，即使不引起快速更新，本地 ref 也会被更新。</p></div></div><div class="doc-postil"><div class="c-markdown"><div class="table-wrapper"><table><thead><tr class="firstRow"><th style="text-align: left;"><div class="table-header"><p>Note</p></div></th><th style="text-align: left;"><div class="table-header"><p>When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched). You would want to use the + sign to indicate non-fast-forward updates will be needed for such branches. There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch.</p></div></th></tr></thead><tbody></tbody></table></div></div></div><div class="doc-postil"><div class="c-markdown"><h2>Git 网址</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>通常，URL 包含有关传输协议，远程服务器地址和存储库路径的信息。根据传输协议，这些信息可能不存在。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>Git 支持 ssh，git，http 和 https 协议（另外，ftp 和 ftps 可用于提取，但效率低下，不推荐使用;不要使用它）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>本地传输（即 git：// URL）不进行身份验证，因此在不安全的网络上应谨慎使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>以下语法可以与它们一起使用：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>ssh://user@host.xz:port/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>git://host.xz:port/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>https://host.xz:port/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>ftps://host.xz:port/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>ssh 协议也可以使用另一种类似 scp 的语法：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>user@host.xz：path / to / repo.git / 只有在第一个冒号前没有斜线时才能识别此语法。这有助于区分包含冒号的本地路径。例如，本地路径<code>foo:bar</code>可以被指定为绝对路径或<code>./foo:bar</code>避免被误解为 ssh url 。ssh 和 git 协议还支持〜用户名扩展：</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>ssh://user@host.xz:port/~user/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>git://host.xz:port/~user/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>user@host.xz:/~user/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>对于本地支持的本地存储库，可以使用以下语法：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>/path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>file:///path/to/repo.git/</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>这两种语法大多是相同的，除了克隆时，前者意味着 --local 选项。有关详细信息，请参阅 git-clone [1]。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>当 Git 不知道如何处理某个传输协议时，它会尝试使用<code>remote-&lt;transport&gt;</code>远程助手（如果存在）。要显式请求远程助手，可以使用以下语法：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>&lt;transport&gt; :: &lt;address&gt;其中&lt;address&gt;可能是一个路径，一个服务器和路径，或者是由被调用的特定远程助手识别的任意类似URL的字符串。有关详细信息，请参阅gitremote-helpers [1]。如果存在大量名称相似的远程存储库，并且您希望为它们使用不同的格式（例如，您使用的URL将被重写为可工作的URL），则可以创建一个形式的配置部分：[url] &lt;actual url base&gt;“] insteadOf = &lt;other url base&gt;例如，使用：[url：git：//git.host.xz/]] insteadOf = host。 xz：/ path / to / insteadOf = work：像“work：repo.git”或类似“host.xz：/path/to/repo.git”的URL将在任何需要URL为“混帐：//git.host。<code>&lt;repository&gt;</code> 论据：</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>Git 配置文件中的远程：<code>$GIT_DIR/config</code>，</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>目录中的<code>$GIT_DIR/remotes</code>文件，或</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>目录中的<code>$GIT_DIR/branches</code>文件。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>所有这些也允许你从命令行中省略 refspec，因为它们都包含 git 将默认使用的 refspec 。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3>在配置文件中命名远程</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以选择提供您之前使用 git-remote [1]，git-config [1] 或者通过手动编辑<code>$GIT_DIR/config</code>文件来配置的远程名称。此远程的 URL 将用于访问存储库。当您不在命令行中提供 refspec 时，将默认使用此远程程序的 refspec 。配置文件中的条目将如下所示：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">        [remote "&lt;name&gt;"]
                url = &lt;url&gt;
                pushurl = &lt;pushurl&gt;
                push = &lt;refspec&gt;
                fetch = &lt;refspec&gt;</pre></div></div><div class="doc-postil"><div class="c-markdown"><p><code>&lt;pushurl&gt;</code>仅用于推动。它是可选的，默认为<code>&lt;url&gt;</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3><code>$GIT_DIR/remotes</code>中的命名文件</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以选择提供文件的名称<code>$GIT_DIR/remotes</code>。该文件中的 URL 将用于访问存储库。当你不在命令行上提供
 refspec 时，这个文件中的 refspec 将被用作默认值。该文件应该具有以下格式：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">        URL: one of the above URL format
        Push: &lt;refspec&gt;
        Pull: &lt;refspec&gt;</pre></div></div><div class="doc-postil"><div class="c-markdown"><p><code>Push:</code>行被使用<code>git push</code>，<code>Pull:</code>行被<code>git pull</code>和使用<code>git fetch</code>。可以为多个分支映射指定多个<code>Push:</code>和<code>Pull:</code>行。</p></div></div><div class="doc-postil"><div class="c-markdown"><h3><code>$GIT_DIR/branches</code>中的命名文件</h3></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以选择提供<code>$GIT_DIR/branches</code>文件的名称。该文件中的 URL 将用于访问存储库。该文件应该具有以下格式：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">        &lt;url&gt;#&lt;head&gt;</pre></div></div><div class="doc-postil"><div class="c-markdown"><p><code>&lt;url&gt;</code>是必须的; <code>#&lt;head&gt;</code>是可选的。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>根据操作，如果你没有在命令行中提供一个参数，那么 git 将使用下列其中一个参考规范。<code>&lt;branch&gt;</code>这个文件中的名称<code>$GIT_DIR/branches</code>和<code>&lt;head&gt;</code>默认<code>master</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>git fetch 使用：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">        refs/heads/&lt;head&gt;:refs/heads/&lt;branch&gt;</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>git push 使用：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">        HEAD:refs/heads/&lt;head&gt;</pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>配置的远程跟踪分支</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>您经常通过定期和反复地从相同的远程存储库进行交互来进行交互。为了跟踪这种远程存储库的进度，<code>git fetch</code>可以配置<code>remote.&lt;repository&gt;.fetch</code>配置变量。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>通常这样的变量可能看起来像这样：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">[remote "origin"]
        fetch = +refs/heads/*:refs/remotes/origin/*</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>这种配置有两种使用方式：</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>在<code>git fetch</code>没有指定要在命令行上获取哪些分支和/或标签的情况下运行时（例如，<code>git fetch origin</code>或者<code>git fetch</code>，<code>remote.&lt;repository&gt;.fetch</code>值被用作refspecs），它们指定要获取哪些引用以及哪些本地引用要更新。上面的例子将获取存在于<code>origin</code>（即与值的左侧相匹配的任何 ref）中的所有分支，<code>refs/heads/*</code>并更新<code>refs/remotes/origin/*</code>层次结构中相应的远程跟踪分支。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>当<code>git fetch</code>与明确的分支和/或标签运行在命令行，例如上取<code>git fetch origin master</code>中，&lt;Refspec&gt; s 上的命令行给出确定什么是要被取出（例如<code>master</code>在该示例中，这是一种短手<code>master:</code>，其反过来的意思是“取<code>master</code>分支，但我并没有明确说什么远程跟踪分支的命令行用它来更新”），示例命令将获取<code>only</code>的<code>master</code>分支。这些<code>remote.&lt;repository&gt;.fetch</code>值确定哪个远程跟踪分支（如果有的话）被更新。以这种方式使用时，这些<code>remote.&lt;repository&gt;.fetch</code>值在决定<code>what</code>获取时没有任何影响（即，在命令行列表 refspecs 时，这些值不会用作 refspecs）; 他们只是用来决定<code>where</code> 通过充当映射来存储被提取的 ref 。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p><code>remote.&lt;repository&gt;.fetch</code>通过<code>--refmap=&lt;refspec&gt;</code>在命令行中提供参数，可以覆盖后面这些值的使用。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>输出</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>“git fetch”的输出取决于所使用的传输方法; 本节描述通过 Git 协议（本地或通过 ssh）和 Smart HTTP 协议获取时的输出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>提取状态以表格形式输出，每行代表单个参考的状态。每一行的格式如下：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript"> &lt;flag&gt; &lt;summary&gt; &lt;from&gt; -&gt; &lt;to&gt; [&lt;reason&gt;]</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>只有在使用 --verbose 选项时才会显示最新参考资料的状态。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在紧凑输出模式下，使用配置变量 fetch.output 指定，如果全部<code>&lt;from&gt;</code>或<code>&lt;to&gt;</code>在另一个字符串中找到，它将用<code>*</code>另一个字符串替换。例如，<code>master -&gt; origin/master</code>变成<code>master -&gt; origin/*</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>标志</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个字符表示 ref 的状态：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>（空格）</p></div></div><div class="doc-postil"><div class="c-markdown"><p>成功取得快进;</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>+</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>成功强制更新;</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>-</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>为成功删除 ref；</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>t</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>为成功更新标签;</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>*</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>为成功获取新的 ref ;</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>!</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>对于被拒绝或未能更新的裁判; 和</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>=</code></p></div></div><div class="doc-postil"><div class="c-markdown"><p>对于那些最新的并且不需要抓取的 ref 来说。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>总结</p></div></div><div class="doc-postil"><div class="c-markdown"><p>对于成功获取的 ref，摘要以适合用作参数的形式<code>git log</code>（<code>&lt;old&gt;..&lt;new&gt;</code>在大多数情况下以及<code>&lt;old&gt;...&lt;new&gt;</code>强制非快进更新）显示 ref 的旧值和新值。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>从</p></div></div><div class="doc-postil"><div class="c-markdown"><p>正在从中获取远程引用的名称，减去其<code>refs/&lt;type&gt;/</code>前缀。在删除的情况下，远程参考的名称是“（无）”。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>至</p></div></div><div class="doc-postil"><div class="c-markdown"><p>正在更新的本地引用的名称，减去它的<code>refs/&lt;type&gt;/</code>前缀。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>原因</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一个可读的解释。在成功获取 ref 的情况下，不需要解释。对于失败的 ref，描述失败的原因。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>例子</h2></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>更新远程跟踪分支：$ git fetch origin 以上命令从远程 refs / heads / namespace 复制所有分支，并将它们存储到本地 refs / remotes / origin / 命名空间，除非使用分支。&lt;name&gt; .fetch 选项指定一个非默认的 refspec 。</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>明确使用 refspecs：</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><p>$ git fetch origin + pu：pu maint：tmp</p></div></div><div class="doc-postil"><div class="c-markdown"><p>这将更新（或根据需要创建）分支，<code>pu</code>和<code>tmp</code>通过从分支（分别）<code>pu</code>和<code>maint</code>远程存储库中获取来更新本地存储库。</p></div></div><div class="doc-postil"><div class="c-markdown"><p><code>pu</code>是没有快进的，因为它是一个加号前缀，分支将被更新; <code>tmp</code>不会是。</p></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>查看远程分支，而不在本地存储库中配置远程程序：$ git fetch git：//git.kernel.org/pub/scm/git/git.git maint $ git log FETCH_HEAD 第一个命令<code>maint</code>从存储库中获取分支在<code>git://git.kernel.org/pub/scm/git/git.git</code>和第二个命令使用<code>FETCH_HEAD</code>用 git-log [1] 检查分支。抓取的对象最终会被 git 的内置管家删除（参见 git-gc [1]）。安全性抓取和推送协议并不旨在防止一方从另一个存储库窃取数据，而这些数据并不是要共享的。如果您需要保护私密数据免受恶意对等攻击，则最佳选择是将其存储在另一个存储库中。这适用于客户端和服务器。特别是，服务器上的名称空间对读取访问控制无效; 您应该只允许对读取访问整个存储库的用户可以信任的名称空间的读取权限。已知的攻击媒介如下：</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ul class="ul-level-0 list-paddingleft-2" style="margin: 10px 0px 10px 20px;"><li><p>victim 发送“有”线广告其具有的对象的 ID，这些对象的 ID 没有明确地意图共享，但是如果对等方也拥有它们，则可用于优化传送。攻击者选择一个对象 ID X 来窃取并向 X 发送一个 ref，但不需要发送 X 的内容，因为受害者已经拥有了它。现在受害者认为攻击者拥有 X，并且稍后将X的内容发送回攻击者。（这种攻击对于客户端来说在服务器上执行起来是最直接的，通过在客户端有权访问的命名空间中创建对 X 的引用，然后获取它，服务器在客户端上执行它的最可能方式是“合并“X 到一个公共分支，并希望用户在这个分支上做额外的工作，并将其推回服务器而不会注意到合并。）</p></li></ul></div></div><div class="doc-postil"><div class="c-markdown"><ol class="ol-level-0 list-paddingleft-2"><li><p>和＃1一样，攻击者选择一个对象 ID X 来窃取。受害者发送攻击者已经拥有的对象 Y，并且攻击者错误地声称具有 X 而不是 Y，所以受害者发送 Y 作为与 X 相对的三角点。该三角点揭示 X 与攻击者类似的 X 的区域。</p></li></ol></div></div><div class="doc-postil"><div class="c-markdown"><h2>Bugs</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>使用 --recurse 子模块只能在已签出的子模块中立即获取新的提交。例如，如果上游在超级项目的刚提取的提交中添加了新的子模块，则无法提取子模块本身，从而无法在稍后检查该子模块而无需再次执行提取。预计这将在未来的 Git 版本中得到修复。</p></div></div></div>