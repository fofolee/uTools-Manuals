<div class="c-markdown doc-markdown"><div class="doc-postil"><div class="c-markdown"><h2>命名</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>git-bundle  - 通过归档移动对象和引用</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>概要</h2></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">git bundle create &lt;file&gt; &lt;git-rev-list-args&gt;git bundle verify &lt;file&gt;git bundle list-heads &lt;file&gt; [&lt;refname&gt;…]git bundle unbundle &lt;file&gt; [&lt;refname&gt;…]</pre></div></div><div class="doc-postil"><div class="c-markdown"><h2>描述</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>有些工作流要求一台机器上的一个或多个开发分支在另一台机器上复制，但这两台机器不能直接连接，因此不能使用交互式Git协议（git，ssh，http）。该命令提供了一种用于支撑<code>git fetch</code>和<code>git pull</code>通过在始发机器包装在归档对象和引用，然后导入到那些使用另一存储库来操作<code>git fetch</code>并<code>git pull</code>通过某种手段移动存档（例如，通过sneakernet）之后。由于存储库之间不存在直接连接，因此用户必须为目标存储库持有的数据包指定基础：数据包假定基础中的所有对象都已存在于目标存储库中。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>选项</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>create &lt;file&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>用于创建名为<code>file</code>的包。这需要<code>git-rev-list-args</code>参数来定义包内容。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>verify &lt;file&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>用于检查捆绑文件是否有效，并将干净地应用于当前存储库。这包括对捆绑格式本身的检查以及检查先决条件提交是否存在并且在当前存储库中完全链接。<code>git bundle</code>打印缺少提交列表（如果有），并以非零状态退出。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>list-heads &lt;file&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>列出软件包中定义的引用。如果后面跟随一个引用列表，则只会打印出与给定值相匹配的引用。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>unbundle &lt;file&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>传递包中的对象以<code>git index-pack</code>存储在存储库中，然后打印所有定义的引用的名称。如果给出了参考文献列表，则只列出与列表中相匹配的参考文献。这个命令真的很管用，打算只能被调用<code>git fetch</code>。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;git-rev-list-args&gt;</p></div></div><div class="doc-postil"><div class="c-markdown"><p>一列的参数，接受列表<code>git rev-parse</code>和<code>git rev-list</code>（和包含命名ref时，请参阅指定下面的参考文献），它指定的特定对象和引用运输。例如，<code>master~10..master</code>导致当前主引用与自第10个祖先提交后添加的所有对象一起打包。对可能打包的引用和对象的数量没有明确的限制。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>&lt;refname&gt;…</p></div></div><div class="doc-postil"><div class="c-markdown"><p>用于限制报告的参考文献的列表。这主要是为了使用<code>git fetch</code>，它只希望接收那些被请求的引用，而不一定是包中的所有内容（在这种情况下，<code>git bundle</code>就像<code>git fetch-pack</code>）。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>指定参考</h2></div></div><div class="doc-postil"><div class="c-markdown"><p><code>git bundle</code>将只打包显示的引用<code>git show-ref</code>：这包括头部，标签和远程头部。诸如<code>master~1</code>不能打包的参考文献，但完全适合于定义基础。可以打包多个参考，并且可以指定多个参考。包装的物品是那些没有包含在给定基地联盟中的物品。每个基可以明确指定（例如<code>^master~10</code>），或隐式地（例如<code>master~10..master</code>，<code>--since=10.days.ago master</code>）。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>目的地所使用的基础是非常重要的。在谨慎的方面犯错是可以的，导致包文件包含已经在目标中的对象，因为在目的地解包时忽略这些对象。</p></div></div><div class="doc-postil"><div class="c-markdown"><h2>例子</h2></div></div><div class="doc-postil"><div class="c-markdown"><p>假设您希望将历史记录从计算机A上的存储库R1传输到计算机B上的另一个存储库R2中。出于任何原因，A和B之间的直接连接不被允许，但我们可以通过某种机制将数据从A移动到B（CD ，电子邮件等）。我们想要在R1的分支主机上进行开发时更新R2。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>为了引导流程，您可以先创建一个没有任何基础的软件包。您可以使用标签来记住您上次处理的内容，以便稍后使用增量包更新其他存储库：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">machineA$ cd R1
machineA$ git bundle create file.bundle master
machineA$ git tag -f lastR2bundle master</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>然后将file.bundle传输到目标计算机B.由于此捆绑包不需要提取任何现有对象，因此可以通过从计算机克隆来在计算机B上创建新的存储库：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">machineB$ git clone -b master /home/me/tmp/file.bundle R2</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>这将在生成的存储库中定义一个名为“origin”的远程服务器，该服务器允许您从包中获取和拉取数据。R2中的$ GIT_DIR / config文件将包含如下所示的条目：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">[remote "origin"]
    url = /home/me/tmp/file.bundle
    fetch = refs/heads/*:refs/remotes/origin/*</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>要更新生成的mine.git存储库，可以使用增量更新替换存储在/home/me/tmp/file.bundle中的包后进行读取或拉取。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>在原始存储库中完成更多工作后，可以创建增量包来更新其他存储库：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">machineA$ cd R1
machineA$ git bundle create file.bundle lastR2bundle..master
machineA$ git tag -f lastR2bundle master</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>然后您将该软件包转移到另一台机器以替换/home/me/tmp/file.bundle，并从中取出。</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">machineB$ cd R2
machineB$ git pull</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>如果您知道预期的收件人存储库应提供哪些必要的对象，则可以使用该知识来指定基准，并提供一个截止点来限制生成的捆绑包中的修订和对象。前面的例子为此使用了lastR2bundle标签，但您可以使用任何其他选项，您可以将它们提供给git-log [1]命令。这里有更多的例子：</p></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以使用以下两种标签：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ git bundle create mybundle v1.0.0..master</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>你可以使用基于时间的基础：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ git bundle create mybundle --since=10.days master</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以使用提交的数量：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ git bundle create mybundle -10 master</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>您可以运行<code>git-bundle verify</code>以查看是否可以从以基础创建的包中提取：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ git bundle verify mybundle</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>这将列出你必须提交什么提交，如果你没有提交，就会出错。</p></div></div><div class="doc-postil"><div class="c-markdown"><p>从收件人存储库的角度来看，捆绑包就像它从中提取或从中取出的常规存储库。例如，您可以在提取时映射引用：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ git fetch mybundle master:localRef</pre></div></div><div class="doc-postil"><div class="c-markdown"><p>你也可以看到它提供的参考资料：</p></div></div><div class="doc-postil"><div class="c-markdown"><pre class="prism-token token language-javascript">$ git ls-remote mybundle</pre></div></div></div>