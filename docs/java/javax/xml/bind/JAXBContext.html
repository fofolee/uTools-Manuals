<div class="header">
<div class="subTitle">
     javax.xml.bind 
   </div>
<h2 class="title" title="Class JAXBContext">Class JAXBContext</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>javax.xml.bind.JAXBContext</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre>public abstract class <span class="typeNameLabel">JAXBContext</span>
extends <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></pre>
<div class="block">
<p> <span><tt>JAXBContext</tt>类提供客户端的JAXB API入口点。</span> <span>它为管理实现JAXB绑定框架操作所必需的XML / Java绑定信息提供了一个抽象：unmarshal，marshal和validate。</span> </p>
<p> <span>客户端应用程序通常使用newInstance方法的这两种样式之一获取此类的新实例，尽管还有其他专门的方法可用：</span> </p>
<ul>
<li> <span><a href="../../../javax/xml/bind/JAXBContext.html#newInstance-java.lang.String-java.lang.ClassLoader-"><code>JAXBContext.newInstance( "com.acme.foo:com.acme.bar" )</code></a></span> <br/> <span>JAXBContext实例是从冒号分隔的Java包名称列表中初始化的。</span> <span>每个java包都包含JAXB映射类，模式派生类和/或用户注释类。</span> <span>此外，java包可能包含必须处理的JAXB包注释。</span> <span>（参见JLS，第7.4.1节“命名包”）。</span> </li>
<li> <span><a href="../../../javax/xml/bind/JAXBContext.html#newInstance-java.lang.Class...-"><code>JAXBContext.newInstance( com.acme.foo.Foo.class )</code></a></span> <br/> <span>JAXBContext实例使用作为参数传递的类和从这些类静态访问的类来初始化。</span> <span>详见<a href="../../../javax/xml/bind/JAXBContext.html#newInstance-java.lang.Class...-"><code>newInstance(Class...)</code></a> 。</span> </li>
</ul>
<p> <span><i><b>规范要求：</b>提供者必须提供一个包含以下方法签名的实现类：</i></span> </p>
<pre>  <span>public static JAXBContext createContext( String contextPath, ClassLoader classLoader, Map&lt;String,Object&gt; properties ) throws JAXBException
 public static JAXBContext createContext( Class[] classes, Map&lt;String,Object&gt; properties ) throws JAXBException</span> </pre>
<p> <span><i>以下JAXB 1.0要求仅适用于模式到java接口/实现绑定。</i></span> <span><i>它不适用于JAXB注释类。</i></span> <span><i>JAXB提供商必须在每个包含模式派生类的包中生成一个<tt>jaxb.properties</tt>文件。</i></span> <span><i>属性文件必须包含一个名为<tt>javax.xml.bind.context.factory</tt>的属性，其值是实现<tt>createContext</tt> API的类的名称。</i></span> </p>
<p> <span><i>提供者提供的类不需要分配给<tt>javax.xml.bind.JAXBContext</tt> ，它只需要提供一个实现<tt>createContext</tt> API的类。</i></span> </p>
<p> <span><i>此外，提供者必须在任何客户端调用元组和解组件方法之前调用<a href="../../../javax/xml/bind/DatatypeConverter.html#setDatatypeConverter-javax.xml.bind.DatatypeConverterInterface-"><code>DatatypeConverter.setDatatypeConverter</code></a> api。</i></span> <span><i>这是配置在这些操作期间将使用的数据类型转换器所必需的。</i></span> <span><a name="Unmarshalling"></a></span> </p>
<h3> <span>解组</span> </h3>
<p> <span><a href="../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind中的接口"><code>Unmarshaller</code></a>类为客户端应用程序提供将XML数据转换为Java内容对象树的能力。</span> <span>unmarshal方法允许在模式中声明的任何全局XML元素作为实例文档的根解组。</span> <span>此外，unmarshal方法允许一个无法识别的根元素，该元素的xsi：type属性的值引用在模式中声明的类型定义作为实例文档的根而被解组。</span> <span><tt>JAXBContext</tt>对象允许在一组模式（ <tt>contextPath</tt>中列出）中合并全局元素和类型定义。</span> <span>由于模式集中的每个模式都可以属于不同的命名空间，所以将模式统一到解组上下文应该与命名空间无关。</span> <span>这意味着客户端应用程序能够解组是任何在<tt>contextPath</tt>列出的模式实例的XML文档。</span> <span>例如：</span> </p>
<pre>  <span>JAXBContext jc = JAXBContext.newInstance( "com.acme.foo:com.acme.bar" );
        Unmarshaller u = jc.createUnmarshaller();
        FooObject fooObj = (FooObject)u.unmarshal( new File( "foo.xml" ) ); // ok
        BarObject barObj = (BarObject)u.unmarshal( new File( "bar.xml" ) ); // ok
        BazObject bazObj = (BazObject)u.unmarshal( new File( "baz.xml" ) ); // error, "com.acme.baz" not in contextPath</span> </pre>
<p> <span>客户端应用程序也可以显式生成Java内容树，而不是解组现有的XML数据。</span> <span>对于所有JAXB注释的值类，应用程序可以使用构造函数创建内容。</span> <span>对于模式导出的接口/实现类以及创建未绑定到JAXB注释类的元素，应用程序需要具有对每个包含的java包中存在的每个模式派生的<tt>ObjectFactory</tt>类的访问和知识<tt>contextPath</tt> 。</span> <span>对于每个模式派生的java类，都有一个静态工厂方法来生成该类型的对象。</span> <span>例如，假设在编译模式之后，您有一个包含<tt>PurchaseOrder</tt>的模式导出接口的包<tt>com.acme.foo</tt> 。</span> <span>为了创建该类型的对象，客户端应用程序将使用如下所示的工厂方法：</span> </p>
<pre>  <span>com.acme.foo.PurchaseOrder po =
           com.acme.foo.ObjectFactory.createPurchaseOrder();</span> </pre>
<p> <span>一旦客户端应用程序具有模式派生对象的实例，它可以使用mutator方法来设置内容。</span> </p>
<p> <span>有关生成的<tt>ObjectFactory</tt>类的更多信息，请参见<tt>规范的</tt>第4.2节<i>Java包</i> 。</span> </p>
<p> <span><i><b>规范要求：</b>提供程序必须在每个包中生成一个类，其中包含名为ObjectFactory的包的所有必需对象工厂方法以及静态<tt>newInstance( javaContentInterface )</tt>方法</i></span> </p>
<h3> <span>编组</span> </h3>
<p> <span><a href="../../../javax/xml/bind/Marshaller.html" title="javax.xml.bind中的接口"><code>Marshaller</code></a>类为客户端应用程序提供将Java内容树转换回XML数据的能力。</span> <span>编组使用工厂方法手动创建的内容树和编组作为<tt>unmarshal</tt>操作的结果的内容树之间没有区别。</span> <span>客户端可以将Java内容树编组回到XML数据到<tt>java.io.OutputStream</tt>或<tt>java.io.Writer</tt> 。</span> <span>编组过程可以替代地将SAX2事件流生成到注册的<tt>ContentHandler</tt>或生成DOM节点对象。</span> <span>客户端应用程序可以控制输出编码以及是否将XML数据编组为完整的文档或片段。</span> </p>
<p> <span>这是一个简单的示例，它解组XML文档，然后将其重新编排出来：</span> </p>
<pre>  <span>JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" );

        // unmarshal from foo.xml
        Unmarshaller u = jc.createUnmarshaller();
        FooObject fooObj = (FooObject)u.unmarshal( new File( "foo.xml" ) );

        // marshal to System.out
        Marshaller m = jc.createMarshaller();
        m.marshal( fooObj, System.out );</span> </pre>
<h3> <span>验证</span> </h3>
<p> <span>自JAXB 1.0以来，验证已经发生了重大变化。</span> <span><a href="../../../javax/xml/bind/Validator.html" title="javax.xml.bind中的接口"><code>Validator</code></a>类已被弃用，可选。</span> <span>这意味着建议您不要使用此类，实际上，根据您的JAXB提供程序，它可能甚至不可用。</span> <span>使用JAXB 1.0运行时系统部署时，依赖于<tt>Validator的</tt> JAXB 1.0客户端应用程序仍将正常工作。</span> <span>在JAXB 2.0中， <a href="../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind中的接口"><code>Unmarshaller</code></a>包含了方便的方法来暴露JAXP 1.3 <a href="../../../javax/xml/validation/package-summary.html"><code>javax.xml.validation</code></a>框架。</span> <span>有关详细信息，请参阅<a href="../../../javax/xml/bind/Unmarshaller.html#setSchema-javax.xml.validation.Schema-"><code>Unmarshaller.setSchema(javax.xml.validation.Schema)</code></a> API。</span> </p>
<h3> <span>JAXB运行时绑定框架兼容性</span> </h3>
<p> <span>以下JAXB 1.0限制仅适用于绑定到接口/实现类的模式。</span> <span>由于此绑定不需要常见的运行时系统，JAXB客户端应用程序不得尝试从不同的提供程序混合运行时对象（ <tt>JAXBContext, Marshaller</tt>等）。</span> <span>这并不意味着客户端应用程序不可移植，它只是意味着客户端必须使用由用于编译模式的同一提供程序提供的运行时系统。</span> </p>
<h3> <span>发现JAXB实现</span> </h3>
<p> <span>当调用其中一个<tt>newInstance</tt>方法时，将通过以下步骤发现JAXB实现。</span> </p>
<ol>
<li> <span>对于明确传递给<a href="../../../javax/xml/bind/JAXBContext.html#newInstance-java.lang.String-"><code>newInstance(java.lang.String)</code></a>方法的每个包/类，按照指定的顺序， <tt>jaxb.properties</tt>文件在其包中查找，通过使用关联的类加载器 - 这是<a href="../../../java/lang/Class.html#getClassLoader--"><code>the owner class loader</code></a>用于<a href="../../../java/lang/Class.html" title="java.lang中的类"><code>类</code></a>参数，对于一个包指定为<a href="../../../java/lang/ClassLoader.html" title="java.lang中的类"><code>ClassLoader</code></a> 。</span> <p> <span>如果发现这样一个文件，它是<a href="../../../java/util/Properties.html#load-java.io.InputStream-"><code>loaded</code></a>作为属性文件，并且<a href="../../../javax/xml/bind/JAXBContext.html#JAXB_CONTEXT_FACTORY"><code>JAXB_CONTEXT_FACTORY</code></a>键的值将被假设为提供者工厂类。</span> <span>然后，上面讨论的关联类加载器加载该类。</span> </p><p> <span>这个阶段的查找允许一些软件包强制使用某个JAXB实现。</span> <span>（例如，可能模式编译器已经在代码中生成了一些供应商扩展。）</span> </p></li>
<li> <span>如果系统属性<a href="../../../javax/xml/bind/JAXBContext.html#JAXB_CONTEXT_FACTORY"><code>JAXB_CONTEXT_FACTORY</code></a>存在，则其值被假定为提供者工厂类。</span> <span>这个查询阶段使得每个JVM覆盖JAXB实现。</span> </li>
<li> <span>在相关的类加载器中查找<tt>/META-INF/services/javax.xml.bind.JAXBContext</tt>文件。</span> <span>该文件遵循标准服务描述符约定，并且如果存在这样的文件，则其内容被假定为提供者工厂类。</span> <span>查找的这个阶段是自动发现。</span> <span>它允许用户将JAXB实现放在类路径中，并使用它，而不需要任何更改。</span> </li>
<li> <span>最后，如果上述所有步骤失败，那么其余的查找是未指定的。</span> <span>也就是说，推荐的行为是简单地寻找一些硬编码的平台默认JAXB实现。</span> <span>这个查询阶段是为了使JavaSE可以有自己的JAXB实现作为最后的手段。</span> </li>
</ol>
<p> <span>一旦发现提供者工厂类，将调用其<tt>public static JAXBContext createContext(String,ClassLoader,Map)</tt>方法（参见<a href="../../../javax/xml/bind/JAXBContext.html#newInstance-java.lang.String-java.lang.ClassLoader-java.util.Map-">参数语义</a>参见<a href="../../../javax/xml/bind/JAXBContext.html#newInstance-java.lang.String-java.lang.ClassLoader-java.util.Map-"><code>newInstance(String, ClassLoader, Map)</code></a> ）或<tt>public static JAXBContext createContet(Class[],Map)</tt>方法（参见<a href="../../../javax/xml/bind/JAXBContext.html#newInstance-java.lang.Class:A-java.util.Map-"><code>newInstance(Class[], Map)</code></a>参见参数语义），以创建<a href="../../../javax/xml/bind/JAXBContext.html" title="javax.xml.bind中的类"><code>JAXBContext</code></a> 。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         JAXB1.0 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../../javax/xml/bind/Marshaller.html" title="javax.xml.bind中的接口"><code>Marshaller</code></a> ， <a href="../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind中的接口"><code>Unmarshaller</code></a> ， <code>7.4.1 "Named Packages" in Java Language Specification</code></span>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!-- --> </a> <h3>Field Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Field Summary table, listing fields, and an explanation">
<caption>
<span>Fields</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/JAXBContext.html#JAXB_CONTEXT_FACTORY">JAXB_CONTEXT_FACTORY</a></span></code>
<div class="block">
              包含能够创建新的 
             <tt>JAXBContext</tt>对象的类的名称的属性的名称。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!-- --> </a> <h3>构造方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Constructor Summary table, listing constructors, and an explanation">
<caption>
<span>构造方法</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier</th>
<th class="colLast" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/JAXBContext.html#JAXBContext--">JAXBContext</a></span>()</code> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t1"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t3"><span><a href="javascript:show(4);">抽象方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t6"><span><a href="javascript:show(32);">弃用的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code><a href="../../../javax/xml/bind/Binder.html" title="class in javax.xml.bind">Binder</a>&lt;<a href="../../../org/w3c/dom/Node.html" title="interface in org.w3c.dom">Node</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/JAXBContext.html#createBinder--">createBinder</a></span>()</code>
<div class="block">
              为W3C DOM创建一个 
             <tt>Binder</tt> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>&lt;T&gt; <a href="../../../javax/xml/bind/Binder.html" title="class in javax.xml.bind">Binder</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/JAXBContext.html#createBinder-java.lang.Class-">createBinder</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;T&gt; domType)</code>
<div class="block">
              创建可用于关联/原地解组/编组一个 
             <tt>Binder</tt>对象。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code><a href="../../../javax/xml/bind/JAXBIntrospector.html" title="class in javax.xml.bind">JAXBIntrospector</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/JAXBContext.html#createJAXBIntrospector--">createJAXBIntrospector</a></span>()</code>
<div class="block">
              创建可用于内省JAXB对象 
             <tt>JAXBIntrospector</tt>对象。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>abstract <a href="../../../javax/xml/bind/Marshaller.html" title="interface in javax.xml.bind">Marshaller</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/JAXBContext.html#createMarshaller--">createMarshaller</a></span>()</code>
<div class="block">
              创建一个可用于将java内容树转换为XML数据的 
             <tt>Marshaller</tt>对象。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>abstract <a href="../../../javax/xml/bind/Unmarshaller.html" title="interface in javax.xml.bind">Unmarshaller</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/JAXBContext.html#createUnmarshaller--">createUnmarshaller</a></span>()</code>
<div class="block">
              创建一个可以将XML数据转换为java内容树的 
             <tt>Unmarshaller</tt>对象。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>abstract <a href="../../../javax/xml/bind/Validator.html" title="interface in javax.xml.bind">Validator</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/JAXBContext.html#createValidator--">createValidator</a></span>()</code>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<div class="block">
<span><span class="deprecationComment">自JAXB2.0起</span></span>
</div>
</div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/JAXBContext.html#generateSchema-javax.xml.bind.SchemaOutputResolver-">generateSchema</a></span>(<a href="../../../javax/xml/bind/SchemaOutputResolver.html" title="class in javax.xml.bind">SchemaOutputResolver</a> outputResolver)</code>
<div class="block">
              生成此上下文的模式文档。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>static <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind">JAXBContext</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/JAXBContext.html#newInstance-java.lang.Class...-">newInstance</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>... classesToBeBound)</code>
<div class="block">
              获得一个新的 
             <tt>JAXBContext</tt>类的实例。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>static <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind">JAXBContext</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/JAXBContext.html#newInstance-java.lang.Class:A-java.util.Map-">newInstance</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>[] classesToBeBound, <a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>,?&gt; properties)</code>
<div class="block">
              获得一个新的 
             <tt>JAXBContext</tt>类的实例。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>static <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind">JAXBContext</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/JAXBContext.html#newInstance-java.lang.String-">newInstance</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> contextPath)</code>
<div class="block">
              获得一个新的 
             <tt>JAXBContext</tt>类的实例。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>static <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind">JAXBContext</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/JAXBContext.html#newInstance-java.lang.String-java.lang.ClassLoader-">newInstance</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> contextPath, <a href="../../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> classLoader)</code>
<div class="block">
              获得一个新的 
             <tt>JAXBContext</tt>类的实例。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>static <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind">JAXBContext</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/JAXBContext.html#newInstance-java.lang.String-java.lang.ClassLoader-java.util.Map-">newInstance</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> contextPath, <a href="../../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> classLoader, <a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>,?&gt; properties)</code>
<div class="block">
              获得一个新的 
             <tt>JAXBContext</tt>类的实例。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#toString--">toString</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!-- --> </a> <h3>字段详细信息</h3> <a name="JAXB_CONTEXT_FACTORY">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>JAXB_CONTEXT_FACTORY</h4> <pre>public static final <a href="../../../java/lang/String.html" title="class in java.lang">String</a> JAXB_CONTEXT_FACTORY</pre>
<div class="block">
            包含能够创建新的 
           <tt>JAXBContext</tt>对象的类的名称的属性的名称。 
          </div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../constant-values.html#javax.xml.bind.JAXBContext.JAXB_CONTEXT_FACTORY">Constant Field Values</a>
</dd>
</dl> </li>
</ul> </li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!-- --> </a> <h3>构造方法详细信息</h3> <a name="JAXBContext--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>JAXBContext</h4> <pre>protected JAXBContext()</pre> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="newInstance-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newInstance</h4> <pre>public static <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind">JAXBContext</a> newInstance(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> contextPath)
                               throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<p> <span>获得一个新的<tt>JAXBContext</tt>类的实例。</span> </p>
<p> <span>这是使用当前线程的上下文类加载器调用<a href="../../../javax/xml/bind/JAXBContext.html#newInstance-java.lang.String-java.lang.ClassLoader-"><code>newInstance(String,ClassLoader)</code></a>方法的<a href="../../../javax/xml/bind/JAXBContext.html#newInstance-java.lang.String-java.lang.ClassLoader-">方便</a>方法。</span> </p>
</div>
<dl>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> -如果创建<tt>JAXBContext</tt>如遇到错误</span>
<ol>
<li> <span>无法在包中找到ObjectFactory.class或jaxb.index</span> </li>
<li> <span>contextPath中包含的全局元素之间存在模糊</span> </li>
<li> <span>无法找到上下文工厂提供程序属性的值</span> </li>
<li> <span>在相同的contextPath上混合来自不同提供者的模式派生包</span> </li>
</ol>
</dd>
</dl> </li>
</ul> <a name="newInstance-java.lang.String-java.lang.ClassLoader-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newInstance</h4> <pre>public static <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind">JAXBContext</a> newInstance(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> contextPath,
                                      <a href="../../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> classLoader)
                               throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<p> <span>获得一个新的<tt>JAXBContext</tt>类的实例。</span> </p>
<p> <span>客户端应用程序必须提供一个上下文路径，该路径是包含模式派生类和/或完全限定JAXB注释类的分隔的java包名称的冒号（'：'，\ u003A）列表。</span> <span>通过每个包生成的ObjectFactory.class，向JAXBContext注册模式派生代码。</span> <span>除了在上下文路径中列出，程序员注释的JAXB映射类可以列在<tt>jaxb.index</tt>资源文件中，格式如下所述。</span> <span>请注意，java包可以包含模式派生类和用户注释的JAXB类。</span> <span>此外，java包可能包含必须处理的JAXB包注释。</span> <span>（参见JLS，第7.4.1节“命名包”）。</span> </p>
<p> <span>contextPath中列出的每个包都必须符合<b>以下一个或两个</b>条件， <tt>否则</tt>将抛出<tt>JAXBException</tt> ：</span> </p>
<ol>
<li> <span>它必须包含ObjectFactory.class</span> </li>
<li> <span>它必须包含jaxb.index</span> </li>
</ol>
<p> <span><b>jaxb.index的格式</b></span> </p>
<p> <span>该文件包含一个换行的类名列表。</span> <span>空格和制表符字符以及空白行将被忽略。</span> <span>注释字符为'＃'（0x23）;</span> <span>在每行上，忽略第一个注释字符之后的所有字符。</span> <span>文件必须以UTF-8编码。</span> <span>类，可达，如在定义<a href="../../../javax/xml/bind/JAXBContext.html#newInstance-java.lang.Class...-"><code>newInstance(Class...)</code></a> ，从列出的类也与JAXBContext中注册。</span> </p>
<p> <span>在<tt>jaxb.index</tt>文件中出现的类名的<tt>限制</tt>是：</span> </p>
<ul>
<li> <span>不得以“.class”结尾。</span> </li>
<li> <span>类名相对于包含<tt>jaxb.index</tt>文件的包解析。</span> <span>只允许在包含<tt>jaxb.index</tt>文件的包中直接发行。</span> </li>
<li> <span>不允许使用完全限定的类名。</span> <span>相对于当前包的限定类名仅允许指定嵌套或内部类。</span> </li>
</ul>
<p> <span>为了保持与JAXB 1.0模式到Java接口/实现绑定的兼容性，通过模式定制<tt>&lt;jaxb:globalBindings valueClass="false"&gt;</tt>启用，JAXB提供程序将确保上下文路径上的每个包都有一个<tt>jaxb.properties</tt>文件，其中包含<tt>javax.xml.bind.context.factory</tt>属性的值，并且所有值都解析为同一供应商。</span> <span>此要求不适用于JAXB注释类。</span> </p>
<p> <span>如果在contextPath上列出的各种软件包之间存在任何全局XML元素名称<tt>冲突</tt> ， <tt>那么</tt>将抛出一个<tt>JAXBException</tt> 。</span> </p>
<p> <span>在同一上下文路径中混合来自多个JAXB提供程序的生成的接口/ impl绑定可能会导致抛出<tt>JAXBException</tt> 。</span> </p>
<p> <span>发现JAXB实现涉及的步骤在类javadoc中讨论。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>contextPath</code> - 包含模式派生类和/或Java到模式（JAXB注释）映射类的java包名称列表 
           </dd>
<dd>
<code>classLoader</code> - 此类加载器将用于定位实现类。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个新的一个 
            <tt>JAXBContext的</tt>实例 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> -如果创建<tt>JAXBContext</tt>如遇到错误</span>
<ol>
<li> <span>无法在包中找到ObjectFactory.class或jaxb.index</span> </li>
<li> <span>contextPath中包含的全局元素之间存在模糊</span> </li>
<li> <span>无法找到上下文工厂提供程序属性的值</span> </li>
<li> <span>在相同的contextPath上混合来自不同提供者的模式派生包</span> </li>
</ol>
</dd>
</dl> </li>
</ul> <a name="newInstance-java.lang.String-java.lang.ClassLoader-java.util.Map-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newInstance</h4> <pre>public static <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind">JAXBContext</a> newInstance(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> contextPath,
                                      <a href="../../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> classLoader,
                                      <a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>,?&gt; properties)
                               throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<p> <span>获得一个新的<tt>JAXBContext</tt>类的实例。</span> </p>
<p> <span>这大部分与<a href="../../../javax/xml/bind/JAXBContext.html#newInstance-java.lang.String-java.lang.ClassLoader-"><code>newInstance(String, ClassLoader)</code></a>相同，但此版本允许您传递提供者特定的属性来配置<code>JAXBContext</code>的<a href="../../../javax/xml/bind/JAXBContext.html" title="javax.xml.bind中的类">实例化</a> 。</span> </p>
<p> <span>属性的解释取决于实现。</span> <span>实现应该抛出<tt>JAXBException</tt>如果发现它无法理解的属性。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>contextPath</code> - 包含模式派生类的java包名称列表 
           </dd>
<dd>
<code>classLoader</code> - 此类加载器将用于查找实现类。 
           </dd>
<dd>
<span><code>properties</code> - 提供者特定的属性。</span>
<span>可以是null，这意味着与传递一个空的地图相同的东西。</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个新的一个 
            <tt>JAXBContext的</tt>实例 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> -如果创建<tt>JAXBContext</tt>如遇到错误</span>
<ol>
<li> <span>无法在包中找到ObjectFactory.class或jaxb.index</span> </li>
<li> <span>contextPath中包含的全局元素之间存在模糊</span> </li>
<li> <span>无法找到上下文工厂提供程序属性的值</span> </li>
<li> <span>在相同的contextPath上混合来自不同提供者的模式派生包</span> </li>
</ol>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
</dl> </li>
</ul> <a name="newInstance-java.lang.Class...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newInstance</h4> <pre>public static <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind">JAXBContext</a> newInstance(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>... classesToBeBound)
                               throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<p> <span>获得一个新的<tt>JAXBContext</tt>类的实例。</span> </p>
<p> <span>客户端应用程序必须提供新的上下文对象需要识别的类的列表。</span> <span>不仅新的上下文将识别所有指定的类，而且还将识别从指定的类静态地直接/间接引用的任何类。</span> <span>引用类的子类和<tt>引用的</tt>类都没有注册到JAXBContext。</span> <span>例如，在以下Java代码中，如果您做了<tt>newInstance(Foo.class)</tt> ，新创建的<a href="../../../javax/xml/bind/JAXBContext.html" title="javax.xml.bind中的类"><code>JAXBContext</code></a>将会识别<tt>Foo</tt>和<tt>Bar</tt> ，但不会<tt>识别Zot</tt>或<tt>FooBar</tt> ：</span> </p>
<pre>  <span>class Foo {
      @XmlTransient FooBar c;
      Bar b;
 }
 class Bar { int x; }
 class Zot extends Bar { int y; }
 class FooBar { }</span> </pre>
<span>因此，典型的客户端应用程序只需要指定顶级类，但需要注意。</span>
<p> <span>请注意，对于JAXBContext注册的每个java包，当可选包注释存在时，都必须处理它们。</span> <span>（参见JLS，第7.4.1节“命名包”）。</span> </p>
<p> <span>发现JAXB实现涉及的步骤在类javadoc中讨论。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>classesToBeBound</code> - 要由新的<a href="../../../javax/xml/bind/JAXBContext.html" title="javax.xml.bind中的类"><code>JAXBContext</code>识别</a>的java类的列表。</span>
<span>可以是空的，在这种情况下，只能知道定义类的<a href="../../../javax/xml/bind/JAXBContext.html" title="javax.xml.bind中的类"><code>JAXBContext</code></a>将被返回。</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>一个新的一个<tt>JAXBContext的</tt>实例。</span>
<span>始终为非空的有效对象。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> -如果创建<tt>JAXBContext，</tt>例如（但不限于）时遇到错误：</span>
<ol>
<li> <span>没有发现JAXB实现</span> </li>
<li> <span>类使用JAXB注释不正确</span> </li>
<li> <span>类具有冲突注释（即，具有相同类型名称的两个类）</span> </li>
<li> <span>JAXB实现无法找到提供程序特定的带外信息（例如在开发时生成的附加文件）。</span> </li>
</ol>
</dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果参数包含 
            <code>null</code> （即 
            <code>newInstance(null);</code> ） 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
</dl> </li>
</ul> <a name="newInstance-java.lang.Class:A-java.util.Map-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newInstance</h4> <pre>public static <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind">JAXBContext</a> newInstance(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>[] classesToBeBound,
                                      <a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>,?&gt; properties)
                               throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<p> <span>获得一个新的<tt>JAXBContext</tt>类的实例。</span> </p>
<p> <span>的超载<a href="../../../javax/xml/bind/JAXBContext.html#newInstance-java.lang.Class...-"><code>newInstance(Class...)</code></a>配置“属性”这一实例化<a href="../../../javax/xml/bind/JAXBContext.html" title="javax.xml.bind中的类"><code>JAXBContext</code></a> 。</span> </p>
<p> <span>属性的解释取决于实现。</span> <span>实现应该抛出<tt>JAXBException</tt>如果发现它无法理解的属性。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>classesToBeBound</code> - 要由新的<a href="../../../javax/xml/bind/JAXBContext.html" title="javax.xml.bind中的类"><code>JAXBContext</code>识别</a>的java类的列表。</span>
<span>可以是空的，在这种情况下，只能知道定义类的<a href="../../../javax/xml/bind/JAXBContext.html" title="javax.xml.bind中的类"><code>JAXBContext</code></a>将被返回。</span>
</dd>
<dd>
<span><code>properties</code> - 提供者特定的属性。</span>
<span>可以是null，这意味着与传递一个空的地图相同的东西。</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>一个新的一个<tt>JAXBContext的</tt>实例。</span>
<span>始终为非空的有效对象。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> -如果创建<tt>JAXBContext，</tt>例如（但不限于）时遇到错误：</span>
<ol>
<li> <span>没有发现JAXB实现</span> </li>
<li> <span>类使用JAXB注释不正确</span> </li>
<li> <span>类具有冲突注释（即，具有相同类型名称的两个类）</span> </li>
<li> <span>JAXB实现无法找到提供程序特定的带外信息（例如在开发时生成的附加文件）。</span> </li>
</ol>
</dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果参数包含 
            <code>null</code> （即 
            <code>newInstance(null,someMap);</code> ） 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
</dl> </li>
</ul> <a name="createUnmarshaller--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>createUnmarshaller</h4> <pre>public abstract <a href="../../../javax/xml/bind/Unmarshaller.html" title="interface in javax.xml.bind">Unmarshaller</a> createUnmarshaller()
                                         throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
            创建一个可用于将XML数据转换为java内容树的 
           <tt>Unmarshaller</tt>对象。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <tt>Unmarshaller</tt>对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 如果在创建 
            <tt>Unmarshaller</tt>对象时遇到错误 
           </dd>
</dl> </li>
</ul> <a name="createMarshaller--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>createMarshaller</h4> <pre>public abstract <a href="../../../javax/xml/bind/Marshaller.html" title="interface in javax.xml.bind">Marshaller</a> createMarshaller()
                                     throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
            创建一个可用于将java内容树转换为XML数据的 
           <tt>Marshaller</tt>对象。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <tt>Marshaller</tt>对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 如果在创建 
            <tt>Marshaller</tt>对象时遇到错误 
           </dd>
</dl> </li>
</ul> <a name="createValidator--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>createValidator</h4> <pre>public abstract <a href="../../../javax/xml/bind/Validator.html" title="interface in javax.xml.bind">Validator</a> createValidator()
                                   throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<span><span class="deprecationComment">自JAXB2.0起</span></span>
</div>
<div class="block">
<span><a href="../../../javax/xml/bind/Validator.html" title="javax.xml.bind中的接口"><code>Validator</code></a>已经在JAXB 2.0中被选为和不推荐使用。</span>
<span>有关更多详细信息，请参阅javadoc for <a href="../../../javax/xml/bind/Validator.html" title="javax.xml.bind中的接口"><code>Validator</code></a> 。</span>
<p> <span>创建一个可用于根据其源模式验证java内容树的<tt>Validator</tt>对象。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <tt>Validator</tt>对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 如果在创建 
            <tt>Validator</tt>对象时遇到错误 
           </dd>
</dl> </li>
</ul> <a name="createBinder-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>createBinder</h4> <pre>public &lt;T&gt; <a href="../../../javax/xml/bind/Binder.html" title="class in javax.xml.bind">Binder</a>&lt;T&gt; createBinder(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;T&gt; domType)</pre>
<div class="block">
            创建可用于关联/原地解组/编组一个 
           <tt>Binder</tt>对象。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>domType</code> - 通过传入其DOM Node类来选择要使用的DOM API。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             总是一个新的有效的 
            <tt>Binder</tt>对象。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果实现不支持对应于 
            <tt>domType的</tt> DOM API。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
</dl> </li>
</ul> <a name="createBinder--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>createBinder</h4> <pre>public <a href="../../../javax/xml/bind/Binder.html" title="class in javax.xml.bind">Binder</a>&lt;<a href="../../../org/w3c/dom/Node.html" title="interface in org.w3c.dom">Node</a>&gt; createBinder()</pre>
<div class="block">
            为W3C DOM创建一个 
           <tt>Binder</tt> 。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             总是一个新的有效的 
            <tt>Binder</tt>对象。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
</dl> </li>
</ul> <a name="createJAXBIntrospector--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>createJAXBIntrospector</h4> <pre>public <a href="../../../javax/xml/bind/JAXBIntrospector.html" title="class in javax.xml.bind">JAXBIntrospector</a> createJAXBIntrospector()</pre>
<div class="block">
            创建可用于内省JAXB对象 
           <tt>JAXBIntrospector</tt>对象。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             总是返回一个非空的有效 
            <tt>JAXBIntrospector</tt>对象。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 在JAXB 1.0实现中调用此方法将抛出UnsupportedOperationException异常。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
</dl> </li>
</ul> <a name="generateSchema-javax.xml.bind.SchemaOutputResolver-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>generateSchema</h4> <pre>public void generateSchema(<a href="../../../javax/xml/bind/SchemaOutputResolver.html" title="class in javax.xml.bind">SchemaOutputResolver</a> outputResolver)
                    throws <a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></pre>
<div class="block">
            生成此上下文的模式文档。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>outputResolver</code> - 此对象控制将发送模式的输出。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></code> - 如果<a href="../../../javax/xml/bind/SchemaOutputResolver.html" title="javax.xml.bind中的类"><code>SchemaOutputResolver</code></a>抛出一个<a href="../../../java/io/IOException.html" title="java.io中的类"><code>IOException</code></a> 。</span>
</dd>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 在JAXB 1.0实现上调用此方法将抛出UnsupportedOperationException异常。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB 2.0 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>