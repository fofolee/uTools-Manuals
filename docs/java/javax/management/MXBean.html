<div class="header">
<div class="subTitle">
     javax.management 
   </div>
<h2 class="title" title="Annotation Type MXBean">Annotation Type MXBean</h2>
</div><div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre><a href="../../java/lang/annotation/Documented.html" title="annotation in java.lang.annotation">@Documented</a>
 <a href="../../java/lang/annotation/Retention.html" title="annotation in java.lang.annotation">@Retention</a>(<a href="../../java/lang/annotation/Retention.html#value--">value</a>=<a href="../../java/lang/annotation/RetentionPolicy.html#RUNTIME">RUNTIME</a>)
 <a href="../../java/lang/annotation/Target.html" title="annotation in java.lang.annotation">@Target</a>(<a href="../../java/lang/annotation/Target.html#value--">value</a>=<a href="../../java/lang/annotation/ElementType.html#TYPE">TYPE</a>)
public @interface <span class="memberNameLabel">MXBean</span></pre>
<div class="block">
<p> <span>用于将界面明确标记为MXBean接口或不作为MXBean接口的注释。</span> <span>默认情况下，界面是MXBean接口，如果它是公共的，其名称以<code>MXBean</code> ，如<code>SomethingMXBean</code> 。</span> <span>以下接口是MXBean接口：</span> </p>
<pre>  <span>public interface WhatsitMXBean {}

    @MXBean
    public interface Whatsit1Interface {}

    @MXBean(true)
    public interface Whatsit2Interface {}</span> </pre>
<p> <span>以下接口不是MXBean接口：</span> </p>
<pre>  <span>interface NonPublicInterfaceNotMXBean{}

    public interface Whatsit3Interface{}

    @MXBean(false)
    public interface MisleadingMXBean {}</span> </pre>
<h3 id="MXBean-spec"> <span>MXBean规范</span> </h3>
<p> <span>MXBean概念提供了一种简单的方法来编写一个仅引用预定义类型的MBean，由<a href="../../javax/management/openmbean/package-summary.html"><code>javax.management.openmbean</code></a>定义。</span> <span>这样，您可以确保您的MBean可以由任何客户端（包括远程客户端）使用，无需客户端访问代表您的MBean类型的<em>模型特定类</em> 。</span> </p>
<p> <span>与标准MBean概念相比，这些概念更容易理解。</span> <span>以下是管理对象如何表示为标准MBean以及MXBean：</span> </p>
<span>  Standard MBean MXBean   <pre>
public interface MemoryPool<b>MBean</b> {
    String getName();
    MemoryUsage getUsage();
    // ...
}
          </pre> <pre>
public interface MemoryPool<b>MXBean</b> {
    String getName();
    MemoryUsage getUsage();
    // ...
}
          </pre> </span>
<table border="1" cellpadding="5" summary="Standard Bean vs. MXBean">
</table>
<p> <span>你可以看到，这些定义非常相似。</span> <span>唯一的区别是，命名接口的惯例是使用<code><em>Something</em>MXBean</code>作为MXBeans，而不是<code><em>Something</em>MBean</code>用于标准MBean。</span> </p>
<p> <span>在此管理对象中，有一个名为<code>Usage</code>的属性类型为<a href="../../java/lang/management/MemoryUsage.html" title="java.lang.management中的类"><code>MemoryUsage</code></a> 。</span> <span>像这样的属性的点是它给出了一组数据项的一致的快照。</span> <span>例如，它可能包括内存池中当前使用的内存量以及内存池的当前最大值。</span> <span>如果这些是单独的项目，通过单独的<a href="../../javax/management/MBeanServer.html#getAttribute-javax.management.ObjectName-java.lang.String-"><code>getAttribute</code></a>调用获得，那么我们可以得到在不同时间看不一致的值。</span> <span>我们可能会得到一个<code>used</code>值比更大<code>max</code>值。</span> </p>
<p> <span>所以我们可以这样定义<code>MemoryUsage</code> ：</span> </p>
<span>  Standard MBean MXBean   <pre>
public class MemoryUsage <b>implements Serializable</b> {
    // standard JavaBean conventions with getters

    public MemoryUsage(long init, long used,
                       long committed, long max) {...}
    long getInit() {...}
    long getUsed() {...}
    long getCommitted() {...}
    long getMax() {...}
}
          </pre> <pre>
public class MemoryUsage {
    // standard JavaBean conventions with getters
    <b>@ConstructorProperties({"init", "used", "committed", "max"})</b>
    public MemoryUsage(long init, long used,
                       long committed, long max) {...}
    long getInit() {...}
    long getUsed() {...}
    long getCommitted() {...}
    long getMax() {...}
}
          </pre> </span>
<table border="1" cellpadding="5" summary="Standard Bean vs. MXBean">
</table>
<p> <span>在两种情况下，定义是相同的，除了使用MXBean， <code>MemoryUsage</code>不再需要标记<code>Serializable</code> （尽管可以）。</span> <span>另一方面，我们添加了一个<code>@ConstructorProperties</code>注释来将构造函数参数链接到相应的getter。</span> <span>我们将在下面看到更多。</span> </p>
<p> <span><code>MemoryUsage</code>是一个<em>模特儿类</em> 。</span> <span>使用标准MBean，如果MBean服务器的客户端不知道<code>Usage</code>类，则无法访问<code>Usage</code> <code>MemoryUsage</code> 。</span> <span>假设客户端是基于JMX技术的通用控制台。</span> <span>那么控制台必须配置它可能连接到的每个应用程序的特定于模型的类。</span> <span>对于不是以Java语言编写的客户端，问题更加严重。</span> <span>那么可能没有办法告诉客户<code>MemoryUsage</code>是什么样的。</span> </p>
<p> <span>这是MXBeans与标准MBeans不同的地方。</span> <span>虽然我们以几乎完全相同的方式定义了管理界面，但MXBean框架<em>将</em>特定于类的类转换为Java平台中的标准类。</span> <span>使用数组和标准<a href="../../javax/management/openmbean/package-summary.html"><code>javax.management.openmbean</code></a>包中的<a href="../../javax/management/openmbean/CompositeData.html" title="javax.management.openmbean中的接口"><code>CompositeData</code></a>和<a href="../../javax/management/openmbean/TabularData.html" title="javax.management.openmbean中的接口"><code>TabularData</code></a>类，可以使用标准类构建任意复杂的数据结构。</span> </p>
<p> <span>如果我们比较两个模型的客户端可能是什么样子，这将变得更加清晰</span> </p>
<span>  Standard MBean MXBean   <pre>
String name = (String)
    mbeanServer.<a href="../../javax/management/MBeanServer.html#getAttribute-javax.management.ObjectName-java.lang.String-"><code>getAttribute</code></a>(objectName, "Name");
<b>MemoryUsage</b> usage = (<b>MemoryUsage</b>)
    mbeanServer.getAttribute(objectName, "Usage");
<b>long used = usage.getUsed();</b>
          </pre> <pre>
String name = (String)
    mbeanServer.<a href="../../javax/management/MBeanServer.html#getAttribute-javax.management.ObjectName-java.lang.String-"><code>getAttribute</code></a>(objectName, "Name");
<b><a href="../../javax/management/openmbean/CompositeData.html" title="interface in javax.management.openmbean"><code>CompositeData</code></a></b> usage = (<b>CompositeData</b>)
    mbeanServer.getAttribute(objectName, "Usage");
<b>long used = (Long) usage.<a href="../../javax/management/openmbean/CompositeData.html#get-java.lang.String-"><code>get</code></a>("used");</b>
          </pre> </span>
<table border="1" cellpadding="5" summary="Standard Bean vs. MXBean">
</table>
<p> <span>对于类似于String的简单类型的<code>String</code> ，代码是一样的。</span> <span>但是对于具有复杂类型的属性，标准MBean代码要求客户端了解特定于型号的类别<code>MemoryUsage</code> ，而MXBean代码不需要非标准类。</span> </p>
<p> <span>这里显示的客户端代码对于MXBean客户端来说稍微复杂一些。</span> <span>但是，如果客户端实际上知道该模型，这里的接口是<code>MemoryPoolMXBean</code>和<code>MemoryUsage</code>类，那么它可以构造一个<em>代理</em> 。</span> <span>当您事先知道模型时，无论您使用的是标准MBean还是MXBean，这是建议与受管对象进行交互的方式：</span> </p>
<span>  Standard MBean MXBean   <pre>
MemoryPool<b>MBean</b> proxy =
    JMX.<b><a href="../../javax/management/JMX.html#newMBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-"><code>newMBeanProxy</code></a></b>(
        mbeanServer,
        objectName,
        MemoryPool<b>MBean</b>.class);
String name = proxy.getName();
MemoryUsage usage = proxy.getUsage();
long used = usage.getUsed();
          </pre> <pre>
MemoryPool<b>MXBean</b> proxy =
    JMX.<b><a href="../../javax/management/JMX.html#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-"><code>newMXBeanProxy</code></a></b>(
        mbeanServer,
        objectName,
        MemoryPool<b>MXBean</b>.class);
String name = proxy.getName();
MemoryUsage usage = proxy.getUsage();
long used = usage.getUsed();
          </pre> </span>
<table border="1" cellpadding="5" summary="Standard Bean vs. MXBean">
</table>
<p> <span>实现MemoryPool对象与标准MBean和MXBean类似。</span> </p>
<span>  Standard MBean MXBean   <pre>
public class MemoryPool
        implements MemoryPool<b>MBean</b> {
    public String getName() {...}
    public MemoryUsage getUsage() {...}
    // ...
}
          </pre> <pre>
public class MemoryPool
        implements MemoryPool<b>MXBean</b> {
    public String getName() {...}
    public MemoryUsage getUsage() {...}
    // ...
}
          </pre> </span>
<table border="1" cellpadding="5" summary="Standard Bean vs. MXBean">
</table>
<p> <span>在这两种情况下，在MBean服务器中注册MBean的工作原理都是相同的：</span> </p>
<span>  Standard MBean MXBean   <pre>
{
    MemoryPool<b>MBean</b> pool = new MemoryPool();
    mbeanServer.<a href="../../javax/management/MBeanServer.html#registerMBean-java.lang.Object-javax.management.ObjectName-"><code>registerMBean</code></a>(pool, objectName);
}
          </pre> <pre>
{
    MemoryPool<b>MXBean</b> pool = new MemoryPool();
    mbeanServer.<a href="../../javax/management/MBeanServer.html#registerMBean-java.lang.Object-javax.management.ObjectName-"><code>registerMBean</code></a>(pool, objectName);
}
          </pre> </span>
<table border="1" cellpadding="5" summary="Standard Bean vs. MXBean">
</table>
<h2 id="mxbean-def"> <span>MXBean的定义</span> </h2>
<p> <span>MXBean是一种MBean。</span> <span>MXBean对象可以直接注册到MBean服务器中，也可以用作<a href="../../javax/management/StandardMBean.html" title="javax.management中的类"><code>StandardMBean</code></a>的参数，MBean服务器中注册的MBean。</span> </p>
<p> <span>当一个对象在MBean服务器使用注册<code>registerMBean</code>或<code>createMBean</code>的方法<a href="../../javax/management/MBeanServer.html" title="javax.management中的接口"><code>MBeanServer</code></a>接口，该对象的类的检查，以确定是什么类型的MBean：</span> </p>
<ul>
<li> <span>如果类实现接口<a href="../../javax/management/DynamicMBean.html" title="javax.management中的接口"><code>DynamicMBean</code>，</a>则MBean是动态MBean。</span> <span>请注意， <code>StandardMBean</code>类<code>StandardMBean</code>了此接口，因此本例适用于使用<code>StandardMBean</code>类创建的标准MBean或MXBean。</span> </li>
<li> <span>否则，如果类与标准MBean命名约定匹配，则MBean是标准MBean。</span> </li>
<li> <span>否则，它可能是一个MXBean。</span> <span>检查由对象实现的一组接口，用于以下接口：</span>
<ul>
<li> <span>有一个类名<code><em>S</em>MXBean</code>其中<code><em>S</em></code>是任何非空字符串，并没有注释<code>@MXBean(false)</code> ;</span> <span>和/或</span> </li>
<li> <span>有一个注释<code>@MXBean(true)</code>或只是<code>@MXBean</code> 。</span> </li>
</ul> <span>如果只有一个这样的接口，或者如果有一个这样的接口是所有其他接口的子接口，则对象是MXBean。</span> <span>该界面是<em>MXBean界面</em> 。</span> <span>在上面的示例中，MXBean接口为<code>MemoryPoolMXBean</code> 。</span> </li>
<li> <span>如果这些条件都不满足，则MBean无效，并且尝试注册它将生成<a href="../../javax/management/NotCompliantMBeanException.html" title="javax.management中的类"><code>NotCompliantMBeanException</code></a> 。</span> </li>
</ul>
<p> <span>显示为在MXBean接口的参数或返回类型的方法的每一个Java类型必须使用下面的规则是<em>可兑换</em> 。</span> <span>另外，参数必须如下<em>所述重构</em> 。</span> </p>
<p> <span>尝试构造不符合上述规则的MXBean将产生异常。</span> </p>
<h2 id="naming-conv"> <span>命名约定</span> </h2>
<p> <span>相同的命名约定应用于MXBean中的方法，如标准MBean中所示：</span> </p>
<ol>
<li> <span>方法<code><em>T</em> get<em>N</em>()</code> ，其中<code><em>T</em></code>是Java类型（不是<code>void</code> ），而<code><em>N</em></code>是非空字符串，指定有一个可读属性叫做<code><em>N</em></code> 。</span> <span>属性的Java类型和Open类型由下面的映射规则确定。</span> <span>从<code>Object</code>的方法<code>final Class getClass()</code>在查找getter时被忽略。</span> </li>
<li> <span>方法<code>boolean is<em>N</em>()</code>指定有一个名为<code><em>N</em></code>的可读<code><em>N</em></code> ，Java类型为<code>boolean</code> ，打开类型为<code>SimpleType.Boolean</code> 。</span> </li>
<li> <span>方法<code>void set<em>N</em>(<em>T</em> x)</code>指定有一个可写属性叫做<code><em>N</em></code> 。</span> <span>属性的Java类型和Open类型由下面的映射规则确定。</span> <span>（当然，名称<code>x</code>参数是无关的。）</span> </li>
<li> <span>每个其他方法都指定有一个与该方法名称相同的操作。</span> <span>返回值和每个参数的Java类型和Open类型由以下映射规则确定。</span> </li>
</ol>
<p> <span><code>get<em>N</em></code>和<code>is<em>N</em></code>的规则共同定义了<em>吸气剂</em>的概念。</span> <span><code>set<em>N</em></code>的规则定义了<em>设置者</em>的概念。</span> </p>
<p> <span>这是一个错误，有两个同名的getter，或两个同名的setter。</span> <span>如果有同一个名字的getter和setter，那么两者中的类型<code><em>T</em></code>必须相同。</span> <span>在这种情况下，属性是读/写。</span> <span>如果只有一个getter或只有一个setter，那么该属性是分别只读或只写的。</span> </p>
<h2 id="mapping-rules"> <span>键入映射规则</span> </h2>
<p> <span>MXBean是一种开放MBean，由<a href="../../javax/management/openmbean/package-summary.html"><code>javax.management.openmbean</code></a>包定义。</span> <span>这意味着属性，操作参数和操作返回值的类型必须全部使用<em>Open Types进行描述</em> ，即<code>OpenType</code>的四个标准子<a href="../../javax/management/openmbean/OpenType.html" title="javax.management.openmbean中的类">类</a> 。</span> <span>MXBeans通过将Java类型映射到“打开类型”来实现此目的。</span> </p>
<p> <span>对于每个Java类型<em>J</em> ，MXBean映射由以下信息描述：</span> </p>
<ul>
<li> <span>相应的Open Type， <em>opentype（J）</em> 。</span> <span>这是<a href="../../javax/management/openmbean/OpenType.html" title="javax.management.openmbean中的类"><code>OpenType</code></a>的子类的一个实例。</span> </li>
<li> <span><em>映射的</em> Java类型， <em>opendata（J）</em> ，对于任何给定的<em>opentype（J）</em>来说都是相同的。</span> <span>这是一个Java类。</span> </li>
<li> <span>如何将值从类型<em>J</em>转换为类型<em>opendata（J）</em> 。</span> </li>
<li> <span>如何将值从类型<em>opendata（J）</em>转换为类型<em>J</em> （如果可以）。</span> </li>
</ul>
<p> <span>例如，对于Java类型<code>List&lt;String&gt;</code> ：</span> </p>
<ul>
<li> <span>开放型<em>，OpenType字体（</em> <code>List&lt;String&gt;</code> <em>），</em>是<a href="../../javax/management/openmbean/ArrayType.html" title="javax.management.openmbean中的类"><code>ArrayType</code></a> <code>(1,</code> <a href="../../javax/management/openmbean/SimpleType.html#STRING"><code>SimpleType.STRING</code></a> <code>)</code>表示的1维阵列<code>String</code>秒。</span> </li>
<li> <span>映射的Java类型， <em>opendata（</em> <code>List&lt;String&gt;</code> <em>）</em>是<code>String[]</code> 。</span> </li>
<li> <span>A <code>List&lt;String&gt;</code>可以转换为<code>String[]</code>使用<a href="../../java/util/List.html#toArray-T:A-"><code>List.toArray(new String[0])</code></a> 。</span> </li>
<li> <span>甲<code>String[]</code>可以被转换为一个<code>List&lt;String&gt;</code>使用<a href="../../java/util/Arrays.html#asList-T...-"><code>Arrays.asList</code></a> 。</span> </li>
</ul>
<p> <span>如果没有映射规则从<em>J</em>导出<em>opentype（J）</em> ，则<em>J</em>不能是MXBean接口中的方法参数或返回值的类型。</span> </p>
<p id="reconstructible-def"> <span>如果有一种方法将<em>opendata（J）</em>转换回<em>J，</em>那么我们说<em>J</em>是可<em>重构的</em> 。</span> <span>MXBean接口中的所有方法参数必须可重构，因为当MXBean框架正在调用方法时，将需要将这些参数从<em>opendata（J）</em>转换为<em>J。</em></span> <span>在由<a href="../../javax/management/JMX.html#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-"><code>JMX.newMXBeanProxy</code>生成</a>的代理中，MXBean接口中方法的返回值必须可重构。</span> </p>
<p> <span>所有Java类型和开放类型都允许空值，除了不可能的原始Java类型。</span> <span>当从类型<em>J</em>转换为类型<em>opendata（J）</em>或从类型<em>opendata（J）</em>转换为类型<em>J</em>时，空值映射到空值。</span> </p>
<p> <span>下表总结了类型映射规则。</span> </p>
<span>  Java type <em>J</em> <em>opentype(J)</em> <em>opendata(J)</em> <code>int</code>, <code>boolean</code>, etc<br/> (the 8 primitive Java types) <code>SimpleType.INTEGER</code>,<br/> <code>SimpleType.BOOLEAN</code>, etc <code>Integer</code>, <code>Boolean</code>, etc<br/> (the corresponding boxed types)   <code>Integer</code>, <code>ObjectName</code>, etc<br/> (the types covered by <a href="../../javax/management/openmbean/SimpleType.html" title="class in javax.management.openmbean"><code>SimpleType</code></a>) the corresponding <code>SimpleType</code> <em>J</em>, the same type   <code>int[]</code> etc<br/> (a one-dimensional array with<br/> primitive element type) <code>ArrayType.getPrimitiveArrayType(int[].class)</code> etc <em>J</em>, the same type   <em>E</em><code>[]</code><br/> (an array with non-primitive element type <em>E</em>; this includes <code>int[][]</code>, where <em>E</em> is <code>int[]</code>) <code>ArrayType.getArrayType(</code><em>opentype(E)</em><code>)</code> <em>opendata(E)</em><code>[]</code> <code>List&lt;</code><em>E</em><code>&gt;</code><br/> <code>Set&lt;</code><em>E</em><code>&gt;</code><br/> <code>SortedSet&lt;</code><em>E</em><code>&gt;</code> (see below) same as for <em>E</em><code>[]</code> same as for <em>E</em><code>[]</code>   An enumeration <em>E</em><br/> (declared in Java as <code>枚举</code><em>E</em> <code>{...}</code>) <code>SimpleType.STRING</code> <code>String</code> <code>Map&lt;</code><em>K</em>,<em>V</em><code>&gt;</code><br/> <code>SortedMap&lt;</code><em>K</em>,<em>V</em><code>&gt;</code> <a href="../../javax/management/openmbean/TabularType.html" title="class in javax.management.openmbean"><code>TabularType</code></a><br/> (see below) <a href="../../javax/management/openmbean/TabularData.html" title="interface in javax.management.openmbean"><code>TabularData</code></a><br/> (see below)   An MXBean interface <code>SimpleType.OBJECTNAME</code><br/> (see below) <a href="../../javax/management/ObjectName.html" title="class in javax.management"><code>ObjectName</code></a><br/> (see below)   Any other type <a href="../../javax/management/openmbean/CompositeType.html" title="class in javax.management.openmbean"><code>CompositeType</code></a>, if possible<br/> (see below) <a href="../../javax/management/openmbean/CompositeData.html" title="interface in javax.management.openmbean"><code>CompositeData</code></a> </span>
<table border="1" cellpadding="5" summary="Type Mapping Rules">
</table>
<p> <span>以下部分将详细介绍这些规则。</span> </p>
<h3> <span>原始类型的映射</span> </h3>
<p> <span>8种基本Java类型（ <code>boolean</code> ， <code>byte</code> ， <code>short</code> ， <code>int</code> ， <code>long</code> ， <code>float</code> ， <code>double</code> ， <code>char</code> ）被映射到相应的盒装类型从<code>java.lang</code> ，即<code>Boolean</code> ， <code>Byte</code>等开放式是相应的<code>SimpleType</code> 。</span> <span>因此， <em>opentype（</em> <code>long</code> <em>）</em>是<code>SimpleType.LONG</code> ，而<em>opendata（</em> <code>long</code> <em>）</em>是<code>java.lang.Long</code> 。</span> </p>
<p> <span>原始类型的数组，如<code>long[]</code>可以直接表示为打开类型。</span> <span>因此， <em>openType（</em> <code>long[]</code> <em>）</em>是<code>ArrayType.getPrimitiveArrayType(long[].class)</code> ，而<em>opendata（</em> <code>long[]</code> <em>）</em>是<code>long[]</code> 。</span> </p>
<p> <span>实际上，平原<code>int</code>和<code>Integer</code>等之间的<code>int</code>并不显示，因为JMX API中的操作始终在Java对象而不是基元上。</span> <span>然而，差异<em>确实</em>出现在数组中。</span> </p>
<h3> <span>收藏图（ <code>List&lt;</code> <em>E</em> <code>&gt;</code>等）</span> </h3>
<p> <span>甲<code>List&lt;</code> <em>ë</em> <code>&gt;</code>或<code>Set&lt;</code> <em>Ë</em> <code>&gt;</code> ，如<code>List&lt;String&gt;</code>或<code>Set&lt;ObjectName&gt;</code> ，被映射在相同的方式，相同的元素类型的阵列，如<code>String[]</code>或<code>ObjectName[]</code> 。</span> </p>
<p> <span>A <code>SortedSet&lt;</code> <em>E</em> <code>&gt;</code>也以与<em>E</em> <code>[]</code>相同的方式进行映射，但如果<em>E</em>是实现<code>Comparable</code>的类或接口，则只能<a href="../../java/lang/Comparable.html" title="java.lang中的接口">转换</a> 。</span> <span>因此， <code>SortedSet&lt;String&gt;</code>或<code>SortedSet&lt;Integer&gt;</code>是可转换的，但<code>SortedSet&lt;int[]&gt;</code>或<code>SortedSet&lt;List&lt;String&gt;&gt;</code>不是。</span> <span><code>SortedSet</code>实例的转换将失败， <code>IllegalArgumentException</code>如果它具有非空值<a href="../../java/util/SortedSet.html#comparator--"><code>comparator()</code></a> 。</span> </p>
<p> <span>A <code>List&lt;</code> <em>E</em> <code>&gt;</code>被重建为<code>java.util.ArrayList&lt;</code> <em>E</em> <code>&gt;</code> ;</span> <span>a <code>Set&lt;</code> <em>E</em> <code>&gt;</code> as a <code>java.util.HashSet&lt;</code> <em>E</em> <code>&gt;</code> ;</span> <span>a <code>SortedSet&lt;</code> <em>E</em> <code>&gt;</code> as a <code>java.util.TreeSet&lt;</code> <em>E</em> <code>&gt;</code> 。</span> </p>
<h3> <span>地图绘图（ <code>Map&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code>等）</span> </h3>
<p> <span>A <code>Map&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code>或<code>SortedMap&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code> ，例如<code>Map&lt;String,ObjectName&gt;</code> ，具有开放类型<a href="../../javax/management/openmbean/TabularType.html" title="javax.management.openmbean中的类"><code>TabularType</code></a>并被映射到<a href="../../javax/management/openmbean/TabularData.html" title="javax.management.openmbean中的接口"><code>TabularData</code></a> 。</span> <span><code>TabularType</code>有两个项目叫做<code>key</code>和<code>value</code> 。</span> <span><code>key</code>的开放类型为<em>opentype（K）</em> ， <code>value</code>的开放类型为<em>opentype（V）</em> 。</span> <span><code>TabularType</code>的索引是单项<code>key</code> 。</span> </p>
<p> <span>例如， <code>TabularType</code>为<code>Map&lt;String,ObjectName&gt;</code>可能与这样的代码来构建：</span> </p>
<pre>  <span>String typeName =
    "java.util.Map&lt;java.lang.String, javax.management.ObjectName&gt;";
String[] keyValue =
    new String[] {"key", "value"};
OpenType[] openTypes =
    new OpenType[] {SimpleType.STRING, SimpleType.OBJECTNAME};
CompositeType rowType =
    new CompositeType(typeName, typeName, keyValue, keyValue, openTypes);
TabularType tabularType =
    new TabularType(typeName, typeName, rowType, new String[] {"key"});</span> </pre>
<p> <span><code>typeName</code>这里是由下面详细描述的<a href="#type-names">type name rules决定</a>的。</span> </p>
<p> <span>A <code>SortedMap&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code>以相同的方式映射，但如果<em>K</em>是实现<code>Comparable</code>的类或接口，则只能<a href="../../java/lang/Comparable.html" title="java.lang中的接口">转换</a> 。</span> <span>因此， <code>SortedMap&lt;String,int[]&gt;</code>是可转换的，但<code>SortedMap&lt;int[],String&gt;</code>不是。</span> <span><code>SortedMap</code>实例的转换将失败，如果<code>IllegalArgumentException</code>具有非空值<a href="../../java/util/SortedMap.html#comparator--"><code>comparator()</code>，则失败</a> 。</span> </p>
<p> <span>A <code>Map&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code>被重建为<code>java.util.HashMap&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code> ;</span> <span>a <code>SortedMap&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code> as a <code>java.util.TreeMap&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code> 。</span> </p>
<p> <span><code>TabularData</code>是一个接口。</span> <span>用于表示<code>Map&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code>作为开放数据的具体类是<a href="../../javax/management/openmbean/TabularDataSupport.html" title="javax.management.openmbean中的类"><code>TabularDataSupport</code></a> ，或另一个实现TabularData的<code>TabularData</code> ，序列化为<code>TabularDataSupport</code> 。</span> </p>
<h3 id="mxbean-map"> <span>用于MXBean接口的映射</span> </h3>
<p> <span>MXBean接口或MXBean接口中引用的类型可以引用另一个MXBean接口<em>J。</em></span> <span>那么<em>opentype（J）</em>是<code>SimpleType.OBJECTNAME</code> ，而<em>opendata（J）</em>是<code>ObjectName</code> 。</span> </p>
<p> <span>例如，假设您有两个MXBean接口，如下所示：</span> </p>
<pre>  <span>public interface ProductMXBean {
    public ModuleMXBean[] getModules();
}

public interface ModuleMXBean {
    public ProductMXBean getProduct();
}</span> </pre>
<p> <span>实现该目的<code>ModuleMXBean</code>从其界面返回<code>getProduct</code>方法实现该目的<code>ProductMXBean</code>接口。</span> <span><code>ModuleMXBean</code>对象和返回的<code>ProductMXBean</code>对象都必须在同一MBean服务器中注册为MXBean。</span> </p>
<p> <span>方法<code>ModuleMXBean.getProduct()</code>定义了一个名为<code>Product</code> 。</span> <span>此属性的“打开类型”为<code>SimpleType.OBJECTNAME</code> ，相应的<code>ObjectName</code>值将是MBean Server中引用的ProductMXBean <code>ProductMXBean</code>的名称。</span> </p>
<p> <span>如果您为<code>ModuleMXBean</code>创建MXBean代理并调用其<code>getProduct()</code>方法，则代理将通过创建另一个MXBean代理将<code>ObjectName</code>回<code>ProductMXBean</code> 。</span> <span>更正式地，当代理人用<a href="../../javax/management/JMX.html#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-"><code>JMX.newMXBeanProxy(mbeanServerConnection, objectNameX, interfaceX)</code></a>进行映射时，需要将<code>objectNameY</code>映射到<code>interfaceY</code> ，另一个MXBean接口，它与<code>JMX.newMXBeanProxy(mbeanServerConnection, objectNameY, interfaceY)</code> 。</span> <span>实现可以返回一个以前通过调用创建一个代理<code>JMX.newMXBeanProxy</code>具有相同的参数，也可以创建一个新的代理。</span> </p>
<p> <span>反向映射是由下列变化于图示<code>ModuleMXBean</code>接口：</span> </p>
<pre>  <span>public interface ModuleMXBean {
    public ProductMXBean getProduct();
    public void setProduct(ProductMXBean c);
}</span> </pre>
<p> <span><code>setProduct</code>方法的存在现在意味着<code>Product</code>属性是读/写。</span> <span>如前所述，此属性的值为<code>ObjectName</code> 。</span> <span>当属性设置时， <code>ObjectName</code>必须转换为<code>setProduct</code>方法期望的<code>ProductMXBean</code>对象。</span> <span>该对象将是同一MBean服务器中给定的<code>ObjectName</code>的MXBean代理。</span> </p>
<p> <span>如果您为<code>ModuleMXBean</code>创建MXBean代理，并调用其<code>setProduct</code>方法，则代理将将其<code>ProductMXBean</code>参数映射回<code>ObjectName</code> 。</span> <span>这只有在参数实际上是另一个代理<code>ProductMXBean</code> ，对于同一个<code>ProductMXBean</code>中的<code>MBeanServerConnection</code> 。</span> <span>代理可以被从另一个代理返回（如<code>ModuleMXBean.getProduct()</code> ，它返回一个代理用于<code>ProductMXBean</code> ）;</span> <span>或者它可以由<a href="../../javax/management/JMX.html#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-"><code>JMX.newMXBeanProxy</code></a>创建;</span> <span>或者它可以使用已经创建<a href="../../java/lang/reflect/Proxy.html" title="class java.lang.reflect"><code>Proxy</code></a>与调用处理程序是<a href="../../javax/management/MBeanServerInvocationHandler.html" title="javax.management中的类"><code>MBeanServerInvocationHandler</code></a>或子类。</span> </p>
<p> <span>如果相同的MXBean在两个不同的注册<code>ObjectName</code> S，从另一个那么对哪个MXBean进行引用将是不明确的。</span> <span>因此，如果MXBean对象已在MBean服务器中注册，并尝试以另一个名称将其注册到同一个MBean服务器中，则结果为<a href="../../javax/management/InstanceAlreadyExistsException.html" title="javax.management中的类"><code>InstanceAlreadyExistsException</code></a> 。</span> <span>不鼓励在多个名称下注册相同的MBean对象，特别是因为它对于<a href="../../javax/management/NotificationBroadcaster.html" title="javax.management中的接口"><code>NotificationBroadcaster</code></a>的MBean不能正常工作。</span> </p>
<h3 id="composite-map"> <span>其他类型的映射</span> </h3>
<p> <span>给定一个与上表中其他规则不匹配的Java类或接口<em>J</em> ，MXBean框架将尝试将其映射到<a href="../../javax/management/openmbean/CompositeType.html" title="javax.management.openmbean中的类"><code>CompositeType</code></a> ，如下所示。</span> <span>此<code>CompositeType</code>的类型名称由下面的<a href="#type-names">type name rules决定</a> 。</span> </p>
<p> <span>使用约定<a href="#naming-conv">above</a>检查吸烟者的<a href="#naming-conv">课程</a> 。</span> <span>（Getters必须是公共实例方法。）如果没有getter，或者如果任何getter的类型不可转换，则<em>J</em>不可转换。</span> </p>
<p> <span>如果至少有一个吸气剂和每个吸气剂都有可转换型，那么<em>opentype（J）</em>是一个<code>CompositeType</code> ，每个吸气剂都有一个项目。</span> <span>如果吸气剂是</span> </p>
<blockquote>
<span><code><em>T</em> get<em>Name</em>()</code></span>
</blockquote>
<span>那么<code>CompositeType</code>中的项目被称为<code>name</code> ，并且具有类型<em>opentype（T）</em> 。</span>
<span>例如，如果项目是</span>
<blockquote>
<span><code>String getOwner()</code></span>
</blockquote>
<span>那么该项目被称为<code>owner</code> ，并且具有打开类型<code>SimpleType.STRING</code> 。</span>
<span>如果吸气剂是</span>
<blockquote>
<span><code>boolean is<em>Name</em>()</code></span>
</blockquote>
<span>那么<code>CompositeType</code>中的项目被称为<code>name</code> ，并且具有类型<code>SimpleType.BOOLEAN</code> 。</span>
<p> <span>请注意，第一个字符（或代码点）转换为小写。</span> <span>这遵循Java Beans约定，由于历史原因与标准MBean约定不同。</span> <span>在标准MBean或MXBean接口中，方法<code>getOwner</code>定义了一个称为<code>Owner</code> ，而在Java Bean或映射的<code>CompositeType</code> ，方法<code>getOwner</code>定义了一个名为<code>owner</code>的属性或项。</span> </p>
<p> <span>如果两种方法产生相同的项目名称（例如， <code>getOwner</code>和<code>isOwner</code>或<code>getOwner</code>和<code>getowner</code> ），则该类型不可转换。</span> </p>
<p> <span>当Open Type为<code>CompositeType</code>时，对应的映射Java类型（ <em>opendata（J）</em> ）为<a href="../../javax/management/openmbean/CompositeData.html" title="javax.management.openmbean中的接口"><code>CompositeData</code></a> 。</span> <span>从<em>J</em>的实例所涉及的映射<code>CompositeData</code>对应于<code>CompositeType</code>刚刚描述的如下完成。</span> <span>首先，如果<em>J</em>实现接口<a href="../../javax/management/openmbean/CompositeDataView.html" title="javax.management.openmbean中的接口"><code>CompositeDataView</code></a> ，那么该接口的<a href="../../javax/management/openmbean/CompositeDataView.html#toCompositeData-javax.management.openmbean.CompositeType-"><code>toCompositeData</code></a>方法被调用来进行转换。</span> <span>否则， <code>CompositeData</code>是通过调用每个项目的getter并将其转换为相应的Open Data类型来构造的。</span> <span>因此，吸气剂如</span> </p>
<blockquote>
<span><code>List&lt;String&gt; getNames()</code></span>
</blockquote>
<p> <span>将被映射到名称为“ <code>names</code> ”的项目，并打开类型<code>ArrayType(1, SimpleType.STRING)</code> 。</span> <span>转换为<code>CompositeData</code>将致电<code>getNames()</code> ，并将结果<code>List&lt;String&gt;</code>转换为<code>String[]</code>的项目“ <code>names</code> ”。</span> </p>
<p> <span><code>CompositeData</code>是一个接口。</span> <span>用于表示打开数据类型的具体类别为<a href="../../javax/management/openmbean/CompositeDataSupport.html" title="javax.management.openmbean中的类"><code>CompositeDataSupport</code></a> ，或另一个实现CompositeData的<code>CompositeData</code> ，序列化为<code>CompositeDataSupport</code> 。</span> </p>
<h4> <span>从<code>CompositeData</code> Java类型<em>J</em>的<code>CompositeData</code></span> </h4>
<p> <span>如果对于Java类型<em>J</em> ， <em>opendata（J）</em>为<code>CompositeData</code> ，则可以从<code>CompositeData</code> <em>J的</em>一个实例，或者<em>J</em>不可重构。</span> <span>如果<code>CompositeData</code>中的任何项目不可重构，则<em>J</em>也不可重构。</span> </p>
<p> <span>对于任何给定的<em>J</em> ，参考以下规则来确定如何从CompositeData重建<em>J</em>的<code>CompositeData</code> 。</span> <span>列表中的第一个适用规则是将被使用的规则。</span> </p>
<ol>
<li><p> <span>如果<em>J</em>有一个方法</span> <br/> <span><code>public static</code> <em>J</em> <code>from(CompositeData cd)</code></span> <br/> <span>那么该方法被调用来重建<em>J的</em>一个实例。</span> </p></li>
<li><p> <span>否则，如果<em>J</em>具有至少一个具有<a href="../../java/beans/ConstructorProperties.html" title="java.beans中的注释"><code>ConstructorProperties</code></a>注释的公共构造函数，则将调用其中一个<a href="../../java/beans/ConstructorProperties.html" title="java.beans中的注释">构造</a>函数（不一定总是相同的）来重构<em>J</em>的实例。</span> <span>每个这样的注释必须列出与构造函数具有参数一样多的字符串;</span> <span>每个字符串必须命名一个对应于<em>J</em>的getter的属性;</span> <span>并且该getter的类型必须与相应的构造函数参数相同。</span> <span>在<code>ConstructorProperties</code>注释中没有提到的getter不是错误（这些可能对应于不需要重建对象的信息）。</span> </p><p> <span>通过从CompositeData调用具有适当重建项目的<code>CompositeData</code>函数来重建<em>J的</em>一个实例。</span> <span>被调用的构造函数将根据CompositeData中实际存在的项目在运行时<code>CompositeData</code> ，因为<code>CompositeData</code>可能来自较早版本的<em>J</em> ，其中并不是所有的项目都存在。</span> <span>如果所有在其指定的属性的构造方法是<em>适用</em> <code>ConstructorProperties</code>注释是存在于该项目<code>CompositeData</code> 。</span> <span>如果不适用构造函数，则重建<em>J</em>的尝试失败。</span> </p><p> <span>对于任何可能的属性组合，必须是（a）没有适用的构造函数，或（b）只有一个适用的构造函数，或（c）其中一个适用的构造函数命名属性的正确超集由其他适用的构造函数命名。</span> <span>（换句话说，对于哪个构造函数来说绝对不应该有歧义）。如果这个条件不是真的，那么<em>J</em>不可重构。</span> </p></li>
<li><p> <span>否则，如果<em>J</em>有一个public no-arg构造函数，并且对于类型为<em>T</em>和<em>N的</em> <em>J</em>中的每个getter，都有一个具有相同名称和类型的相应setter，那么<em>J的</em>一个实例使用no-arg构造函数构造，从<code>CompositeData</code>调用重建的项目来恢复值。</span> <span>例如，如果有一个方法</span> <br/> <code>public List&lt;String&gt; getNames()</code> <br/> <span>那么还必须有一种方法</span> <br/> <code>public void setNames(List&lt;String&gt; names)</code> <br/> <span>这个规则适用。</span> </p><p> <span>如果<code>CompositeData</code>来自较早版本的<em>J</em> ，某些项目可能不存在。</span> <span>在这种情况下，不会调用相应的设置器。</span> </p></li>
<li><p> <span>否则，如果<em>J</em>是具有不大于吸气剂的其它方法的接口<em>，J</em>的一个实例是使用构造<a href="../../java/lang/reflect/Proxy.html" title="class java.lang.reflect"><code>Proxy</code></a>与<a href="../../javax/management/openmbean/CompositeDataInvocationHandler.html" title="javax.management.openmbean中的类"><code>CompositeDataInvocationHandler</code></a>由备份<code>CompositeData</code>被转换。</span> </p></li>
<li><p> <span>否则， <em>J</em>不可重构。</span> </p></li>
</ol>
<p> <span>规则2不适用于Java SE的不包括<code>java.beans</code>包的<code>java.beans</code>文件。</span> <span>当定位不包括<code>java.beans</code>包的运行时，并且编译时和运行时间环境之间存在不匹配，其中<em>J</em>使用公共构造函数和<code>ConstructorProperties</code>批注编译时，除非另有规则适用，否则<em>J</em>不可重构。</span> </p>
<p> <span>以下是一些示例，显示了由<code>int</code>和<code>String</code>组成的类型<code>NamedNumber</code>的<code>String</code> 。</span> <span>在每种情况下， <code>CompositeType</code>如下所示：</span> </p>
<blockquote>
<span><pre>
<a href="../../javax/management/openmbean/CompositeType.html" title="class in javax.management.openmbean"><code>CompositeType</code></a>(
    "NamedNumber",                      // typeName
    "NamedNumber",                      // description
    new String[] {"number", "name"},    // itemNames
    new String[] {"number", "name"},    // itemDescriptions
    new OpenType[] {SimpleType.INTEGER,
                    SimpleType.STRING}  // itemTypes
);
      </pre></span>
</blockquote>
<ol>
<li> <span>静态<code>from</code>方法：</span>
<blockquote>
<span><pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public String getName() {return name;}
    private NamedNumber(int number, String name) {
        this.number = number;
        this.name = name;
    }
    <b>public static NamedNumber from(CompositeData cd)</b> {
        return new NamedNumber((Integer) cd.get("number"),
                               (String) cd.get("name"));
    }
    private final int number;
    private final String name;
}
          </pre></span>
</blockquote></li>
<li> <span>具有<code>@ConstructorProperties</code>注释的公共<code>@ConstructorProperties</code>函数：</span>
<blockquote>
<span><pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public String getName() {return name;}
    <b>@ConstructorProperties({"number", "name"})
    public NamedNumber(int number, String name)</b> {
        this.number = number;
        this.name = name;
    }
    private final int number;
    private final String name;
}
          </pre></span>
</blockquote></li>
<li> <span>每个吸气剂的设定者：</span>
<blockquote>
<span><pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public void <b>setNumber</b>(int number) {this.number = number;}
    public String getName() {return name;}
    public void <b>setName</b>(String name) {this.name = name;}
    <b>public NamedNumber()</b> {}
    private int number;
    private String name;
}
          </pre></span>
</blockquote></li>
<li> <span>仅与吸气口接口：</span>
<blockquote>
<span><pre>
public interface NamedNumber {
    public int getNumber();
    public String getName();
}
          </pre></span>
</blockquote></li>
</ol>
<p> <span>它通常是用于简单地表示数据的集合是<em>不可变</em>的类。</span> <span>一个不可变类的实例在构造完成后不能被改变。</span> <span>请注意， <code>CompositeData</code>本身是不可变的。</span> <span>不可变性有很多优点，特别是在线程安全和安全方面。</span> <span>因此，如果可能，通常应避免使用设置器的方法。</span> </p>
<h3> <span>递归类型</span> </h3>
<p> <span>递归（自引用）类型不能在MXBean接口中使用。</span> <span>这是<code>CompositeType</code>的不变性的<a href="../../javax/management/openmbean/CompositeType.html" title="javax.management.openmbean中的类">结果</a> 。</span> <span>例如，以下类型不能是属性的类型，因为它引用自身：</span> </p>
<pre>  <span>public interface <b>Node</b> {
    public String getName();
    public int getPriority();
    public <b>Node</b> getNext();
}</span> </pre>
<p> <span>总是可以重写这样的递归类型，所以它们不再是递归的。</span> <span>这样做可能需要引入新的类型。</span> <span>例如：</span> </p>
<pre>  <span>public interface <b>NodeList</b> {
    public List&lt;Node&gt; getNodes();
}

public interface Node {
    public String getName();
    public int getPriority();
}</span> </pre>
<h3> <span>MXBean的MBeanInfo内容</span> </h3>
<p> <span>MXBean是一种Open MBean。</span> <span>但是，出于兼容性原因，它的<a href="../../javax/management/MBeanInfo.html" title="javax.management中的类"><code>MBeanInfo</code></a>不是<a href="../../javax/management/openmbean/OpenMBeanInfo.html" title="javax.management.openmbean中的接口"><code>OpenMBeanInfo</code></a> 。</span> <span>特别地，当属性，参数或操作返回值的类型是诸如<code>int</code>或<code>void</code> （对于返回类型）的基本类型时，属性，参数或操作将分别由<a href="../../javax/management/MBeanAttributeInfo.html" title="javax.management中的类"><code>MBeanAttributeInfo</code>表示</a> ， <a href="../../javax/management/MBeanParameterInfo.html" title="javax.management中的类"><code>MBeanParameterInfo</code></a>或<a href="../../javax/management/MBeanOperationInfo.html" title="javax.management中的类"><code>MBeanOperationInfo</code></a> ，其<code>getType()</code>或<code>getReturnType()</code>返回原始名称（“ <code>int</code> ”等）。</span> <span>即使上面的映射规则指定<em>opendata</em>映射是包装类型（ <code>Integer</code>等） <code>Integer</code> 。</span> </p>
<p> <span>由MBean Server直接注册的MXBean返回的<a href="../../javax/management/MBeanInfo.html#getConstructors--"><code>MBeanInfo.getConstructors()</code></a>的公共构造函数数组将包含该MXBean的所有公共构造函数。</span> <span>如果MXBean的类不是公开的，那么它的构造函数也不被认为是公开的。</span> <span>为使用<a href="../../javax/management/StandardMBean.html" title="javax.management中的类"><code>StandardMBean</code></a>类构造的MXBean返回的列表的派生方式与标准MBeans相同。</span> <span>不管MXBean如何构造，其构造函数参数不受MXBean映射规则的约束，并且没有相应的<code>OpenType</code> 。</span> </p>
<p> <span>通过返回的通知类型的数组<a href="../../javax/management/MBeanInfo.html#getNotifications--"><code>MBeanInfo.getNotifications()</code></a>于MXBean是在MBean服务器中注册，直接会是空的，如果的MXBean没有实现<a href="../../javax/management/NotificationBroadcaster.html" title="javax.management中的接口"><code>NotificationBroadcaster</code></a>接口。</span> <span>否则，将在MXBean <a href="../../javax/management/NotificationBroadcaster.html#getNotificationInfo--">注册</a>时调用<a href="../../javax/management/NotificationBroadcaster.html#getNotificationInfo--"><code>NotificationBroadcaster.getNotificationInfo()</code></a>的结果。</span> <span>即使这种方法的结果<code>MBeanInfo.getNotifications()</code>改变，MBeanInfo.getNotifications()的结果也不会。</span> <span>使用<a href="../../javax/management/StandardMBean.html" title="javax.management中的类"><code>StandardMBean</code></a>或<a href="../../javax/management/StandardEmitterMBean.html" title="javax.management中的类"><code>StandardEmitterMBean</code></a>类构造的MXBean返回的列表与标准MBean的方法相同。</span> </p>
<p> <span>该<a href="../../javax/management/Descriptor.html" title="javax.management中的接口"><code>Descriptor</code></a>对于所有的<code>MBeanAttributeInfo</code> ， <code>MBeanParameterInfo</code>和<code>MBeanOperationInfo</code>中包含的对象<code>MBeanInfo</code>将有一个字段<code>openType</code> ，其值是<a href="../../javax/management/openmbean/OpenType.html" title="javax.management.openmbean中的类"><code>OpenType</code></a>由上述映射规则指定。</span> <span>所以即使<code>getType()</code>是“ <code>int</code> ”， <code>getDescriptor().getField("openType")</code>将是<a href="../../javax/management/openmbean/SimpleType.html#INTEGER"><code>SimpleType.INTEGER</code></a> 。</span> </p>
<p> <span>每个这些对象的<code>Descriptor</code>也将有一个字段<code>originalType</code> ，它是一个字符串，表示MXBean界面中出现的Java类型。</span> <span>此字符串的格式，以便在部分中描述<a href="#type-names">Type Names</a>下方。</span> </p>
<p> <span><code>Descriptor</code>的<code>MBeanInfo</code>将有一个字段<code>mxbean</code> ，其值是字符串“ <code>true</code> ”。</span> </p>
<h3 id="type-names"> <span>键入名称</span> </h3>
<p> <span>有时，MXBean中的方法参数或返回值的未映射类型<em>T</em>必须用字符串表示。</span> <span>如果<em>T</em>是非泛型类型，则此字符串是由<a href="../../java/lang/Class.html#getName--"><code>Class.getName()</code></a>返回的值。</span> <span>否则它是<em>通用字符串（T）</em>的值，定义如下：</span> </p>
<ul>
<li> <span>如果<em>T</em>是非泛型非数组类型， <em>则</em>通用<em>字符串（T）</em>是由<a href="../../java/lang/Class.html#getName--"><code>Class.getName()</code></a>返回的值，例如<code>"int"</code>或<code>"java.lang.String"</code> 。</span> </li>
<li> <span>如果<em>T</em>是数组<em>E []</em> ， <em>通用字符串（T）</em>是<em>通用字符串（E），</em>后跟<code>"[]"</code> 。</span> <span>例如， <em>通用字符串（ <code>int[]</code> ）</em>是<code>"int[]"</code> ， <em>通用字符串（ <code>List&lt;String&gt;[][]</code> ）</em>是<code>"java.util.List&lt;java.lang.String&gt;[][]"</code> 。</span> </li>
<li> <span>否则， <em>T</em>是一个参数化类型，如<code>List&lt;String&gt;</code> ， <em>genericstring（T）</em>由以下组成：Class.getName()返回的<code>Class.getName()</code>化类型的全限定名;</span> <span>左角括号（ <code>"&lt;"</code> ）;</span> <span><em>通用字符串（A）</em>其中<em>A</em>是第一个类型的参数;</span> <span>如果有第二个类型参数<em>B，</em>那么<code>", "</code> （逗号和一个空格），后跟<em>通用字符串（B）</em> ;</span> <span>一个直角括号（ <code>"&gt;"</code> ）。</span> </li>
</ul>
<p> <span>请注意，如果方法返回<code>int[]</code> ， <code>"[I"</code>返回的字符串<code>"[I"</code> <code>Class.getName()</code> ，但如果方法返回<code>List&lt;int[]&gt;</code> ，则将以字符串<code>"java.util.List&lt;int[]&gt;"</code> 。</span> </p>
<h3> <span>例外</span> </h3>
<p> <span>使用<a href="../../javax/management/openmbean/OpenDataException.html" title="javax.management.openmbean中的类"><code>OpenDataException</code></a>发送<em>从</em> Java类型映射<em>到</em> Open类型的<a href="../../javax/management/openmbean/OpenDataException.html" title="javax.management.openmbean中的类">问题</a> 。</span> <span>当分析MXBean接口时，可能会发生这种情况，例如，如果它引用了一个没有getter的类型，就像<a href="../../java/util/Random.html" title="java.util中的类"><code>java.util.Random</code></a> 。</span> <span>或者当实例被转换时（MXBean代理中的MXBean方法中的返回值或参数转换为MXBean代理中的方法），例如从<code>SortedSet&lt;String&gt;</code>为<code>String[]</code>如果<code>SortedSet</code>具有非空值<code>Comparator</code> ），则<code>SortedSet</code>会<code>Comparator</code> 。</span> </p>
<p> <span>使用<a href="../../java/io/InvalidObjectException.html" title="java.io中的类"><code>InvalidObjectException</code></a>发送<em>从</em>打开类型映射<em>到</em> Java类型的<a href="../../java/io/InvalidObjectException.html" title="java.io中的类">问题</a> 。</span> <span>当分析MXBean接口时，例如，如果在需要可重构类型的上下文中引用了根据上述规则不可<em>重构</em>的类型，则可能会发生这种情况。</span> <span>或者当实例被转换时（MXBean中的方法的参数或MXBean代理中的方法的返回值），例如，如果不存在具有该名称的枚举常量，则可以从字符串到枚举。</span> </p>
<p> <span>根据上下文， <code>OpenDataException</code>或<code>InvalidObjectException</code>可能会被包装在另一个例外中，如<a href="../../javax/management/RuntimeMBeanException.html" title="javax.management中的类"><code>RuntimeMBeanException</code></a>或<a href="../../java/lang/reflect/UndeclaredThrowableException.html" title="class java.lang.reflect"><code>UndeclaredThrowableException</code></a> 。</span> <span>对于每一个被抛出的异常，条件<em>C</em>将为真<em>：“e</em>是<code>OpenDataException</code>或<code>InvalidObjectException</code> （根据需要），或<em>C</em>是<em>E</em>的真。 <a href="../../java/lang/Throwable.html#getCause--"><code>getCause()</code></a> ”。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.6 
       </dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== ANNOTATION TYPE OPTIONAL MEMBER SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="annotation.type.optional.element.summary">
<!-- --> </a> <h3>Optional Element Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Optional Element Summary table, listing optional elements, and an explanation">
<caption>
<span>Optional Elements</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Optional Element and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/management/MXBean.html#value--">value</a></span></code>
<div class="block">
              如果注释的界面是MXBean接口，则为true。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ ANNOTATION TYPE MEMBER DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="annotation.type.element.detail">
<!-- --> </a> <h3>Element Detail</h3> <a name="value--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>value</h4> <pre>public abstract boolean value</pre>
<div class="block">
            如果注释的界面是MXBean接口，则为true。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             如果注释的界面是MXBean接口，则为true。 
           </dd>
</dl>
<dl>
<dt>
             Default: 
           </dt>
<dd>
             真正 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>