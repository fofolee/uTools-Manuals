<div class="header">
<h1 class="title" title="Package">Package javax.sql</h1>
<div class="docSummary">
<div class="block">
      为Java 
     <sup><font size="-2">TM</font></sup>编程语言提供服务器端数据源访问和处理API。 
    </div>
</div>
<p>See: <a href="#package.description">描述</a></p>
</div><div class="contentContainer">
<ul class="blockList">
<li class="blockList">
<table border="0" cellpadding="3" cellspacing="0" class="typeSummary" summary="Interface Summary table, listing interfaces, and an explanation">
<caption>
<span>接口摘要</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">接口</th>
<th class="colLast" scope="col">描述</th>
</tr>
</tbody>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../javax/sql/CommonDataSource.html" title="interface in javax.sql">CommonDataSource</a></td>
<td class="colLast">
<div class="block">
           接口，定义它们之间的共同的方法 
          <code>DataSource</code> ， 
          <code>XADataSource</code>和 
          <code>ConnectionPoolDataSource</code> 。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../javax/sql/ConnectionEventListener.html" title="interface in javax.sql">ConnectionEventListener</a></td>
<td class="colLast">
<div class="block">
           注册通知一个 
          <code>PooledConnection</code>对象生成的事件的对象。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../javax/sql/ConnectionPoolDataSource.html" title="interface in javax.sql">ConnectionPoolDataSource</a></td>
<td class="colLast">
<div class="block">
           一个工厂为 
          <code>PooledConnection</code>对象。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../javax/sql/DataSource.html" title="interface in javax.sql">DataSource</a></td>
<td class="colLast">
<div class="block">
           一个连接到这个 
          <code>DataSource</code>对象所代表的物理数据源的工厂。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../javax/sql/PooledConnection.html" title="interface in javax.sql">PooledConnection</a></td>
<td class="colLast">
<div class="block">
           提供连接池管理钩子的对象。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../javax/sql/RowSet.html" title="interface in javax.sql">RowSet</a></td>
<td class="colLast">
<div class="block">
           该接口为JavaBeans组件模型的JDBC API添加了支持。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../javax/sql/RowSetInternal.html" title="interface in javax.sql">RowSetInternal</a></td>
<td class="colLast">
<div class="block">
           一个 
          <code>RowSet</code>对象实现的接口，以便向 
          <code>RowSetReader</code>或 
          <code>RowSetWriter</code>对象呈现自身。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../javax/sql/RowSetListener.html" title="interface in javax.sql">RowSetListener</a></td>
<td class="colLast">
<div class="block">
           一个接口，必须由一个组件实现，当一个重大事件发生在 
          <code>RowSet</code>对象的生命中时，该组件希望被通知。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../javax/sql/RowSetMetaData.html" title="interface in javax.sql">RowSetMetaData</a></td>
<td class="colLast">
<div class="block">
           包含有关 
          <code>RowSet</code>对象中的列的 
          <code>RowSet</code>对象。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../javax/sql/RowSetReader.html" title="interface in javax.sql">RowSetReader</a></td>
<td class="colLast">
<div class="block">
           断开连接的 
          <code>RowSet</code>对象调用的工具将自己填充数据行。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../javax/sql/RowSetWriter.html" title="interface in javax.sql">RowSetWriter</a></td>
<td class="colLast">
<div class="block">
           一个实现 
          <code>RowSetWriter</code>接口的对象，称为 
          <i>写入器</i> 。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../javax/sql/StatementEventListener.html" title="interface in javax.sql">StatementEventListener</a></td>
<td class="colLast">
<div class="block">
           注册在“声明”池中的PreparedStatements上发生的事件的通知对象。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../javax/sql/XAConnection.html" title="interface in javax.sql">XAConnection</a></td>
<td class="colLast">
<div class="block">
           为分布式事务提供支持的对象。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../javax/sql/XADataSource.html" title="interface in javax.sql">XADataSource</a></td>
<td class="colLast">
<div class="block">
           一个用于 
          <code>XAConnection</code>对象的工厂。 
         </div> </td>
</tr>
</tbody>
</table> </li>
<li class="blockList">
<table border="0" cellpadding="3" cellspacing="0" class="typeSummary" summary="Class Summary table, listing classes, and an explanation">
<caption>
<span>类摘要</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">类</th>
<th class="colLast" scope="col">描述</th>
</tr>
</tbody>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../javax/sql/ConnectionEvent.html" title="class in javax.sql">ConnectionEvent</a></td>
<td class="colLast">
<div class="block">
           一个 
          <code>Event</code>对象，提供有关连接相关事件源的信息。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../javax/sql/RowSetEvent.html" title="class in javax.sql">RowSetEvent</a></td>
<td class="colLast">
<div class="block">
<code>Event</code>对象在 
          <code>Event</code>对象发生事件时 
          <code>RowSet</code>对象。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../javax/sql/StatementEvent.html" title="class in javax.sql">StatementEvent</a></td>
<td class="colLast">
<div class="block">
           A 
          <code>StatementEvent</code>被发送到所有 
          <code>StatementEventListener</code> ，其中注册了 
          <code>PooledConnection</code> 。 
         </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<a name="package.description">
<!-- --> </a>
<h2 title="Package javax.sql Description">Package javax.sql Description</h2>
<div class="block">
     Provides the API for server side data source access and processing from the Java 
    <sup><font size="-2">TM</font></sup> programming language. This package supplements the 
    <code>java.sql</code> package and, as of the version 1.4 release, is included in the Java Platform, Standard Edition (Java SE 
    <sup><font size="-2">TM</font></sup>). It remains an essential part of the Java Platform, Enterprise Edition (Java EE 
    <sup><font size="-2">TM</font></sup>). 
    <p> The <code>javax.sql</code> package provides for the following: </p>
<ol>
<li>The <code>DataSource</code> interface as an alternative to the <code>DriverManager</code> for establishing a connection with a data source </li>
<li>Connection pooling and Statement pooling </li>
<li>Distributed transactions </li>
<li>Rowsets </li>
</ol>
<p> Applications use the <code>DataSource</code> and <code>RowSet</code> APIs directly, but the connection pooling and distributed transaction APIs are used internally by the middle-tier infrastructure. </p>
<h2>Using a <code>DataSource</code> Object to Make a Connection</h2> The 
    <code>javax.sql</code> package provides the preferred way to make a connection with a data source. The 
    <code>DriverManager</code> class, the original mechanism, is still valid, and code using it will continue to run. However, the newer 
    <code>DataSource</code> mechanism is preferred because it offers many advantages over the 
    <code>DriverManager</code> mechanism. 
    <p> These are the main advantages of using a <code>DataSource</code> object to make a connection: </p>
<ul>
<li>Changes can be made to a data source's properties, which means that it is not necessary to make changes in application code when something about the data source or driver changes. </li>
<li>Connection and Statement pooling and distributed transactions are available through a <code>DataSource</code> object that is implemented to work with the middle-tier infrastructure. Connections made through the <code>DriverManager</code> do not have connection and statement pooling or distributed transaction capabilities. </li>
</ul>
<p> Driver vendors provide <code>DataSource</code> implementations. A particular <code>DataSource</code> object represents a particular physical data source, and each connection the <code>DataSource</code> object creates is a connection to that physical data source. </p>
<p> A logical name for the data source is registered with a naming service that uses the Java Naming and Directory Interface<sup><font size="-2">TM</font></sup> (JNDI) API, usually by a system administrator or someone performing the duties of a system administrator. An application can retrieve the <code>DataSource</code> object it wants by doing a lookup on the logical name that has been registered for it. The application can then use the <code>DataSource</code> object to create a connection to the physical data source it represents. </p>
<p> A <code>DataSource</code> object can be implemented to work with the middle tier infrastructure so that the connections it produces will be pooled for reuse. An application that uses such a <code>DataSource</code> implementation will automatically get a connection that participates in connection pooling. A <code>DataSource</code> object can also be implemented to work with the middle tier infrastructure so that the connections it produces can be used for distributed transactions without any special coding. </p>
<h2>Connection Pooling and Statement Pooling</h2> Connections made via a 
    <code>DataSource</code> object that is implemented to work with a middle tier connection pool manager will participate in connection pooling. This can improve performance dramatically because creating new connections is very expensive. Connection pooling allows a connection to be used and reused, thus cutting down substantially on the number of new connections that need to be created. 
    <p> Connection pooling is totally transparent. It is done automatically in the middle tier of a Java EE configuration, so from an application's viewpoint, no change in code is required. An application simply uses the <code>DataSource.getConnection</code> method to get the pooled connection and uses it the same way it uses any <code>Connection</code> object. </p>
<p> The classes and interfaces used for connection pooling are: </p>
<ul>
<li><code>ConnectionPoolDataSource</code> </li>
<li><code>PooledConnection</code> </li>
<li><code>ConnectionEvent</code> </li>
<li><code>ConnectionEventListener</code> </li>
<li><code>StatementEvent</code> </li>
<li><code>StatementEventListener</code> </li>
</ul> The connection pool manager, a facility in the middle tier of a three-tier architecture, uses these classes and interfaces behind the scenes. When a 
    <code>ConnectionPoolDataSource</code> object is called on to create a 
    <code>PooledConnection</code> object, the connection pool manager will register as a 
    <code>ConnectionEventListener</code> object with the new 
    <code>PooledConnection</code> object. When the connection is closed or there is an error, the connection pool manager (being a listener) gets a notification that includes a 
    <code>ConnectionEvent</code> object. 
    <p> If the connection pool manager supports <code>Statement</code> pooling, for <code>PreparedStatements</code>, which can be determined by invoking the method <code>DatabaseMetaData.supportsStatementPooling</code>, the connection pool manager will register as a <code>StatementEventListener</code> object with the new <code>PooledConnection</code> object. When the <code>PreparedStatement</code> is closed or there is an error, the connection pool manager (being a listener) gets a notification that includes a <code>StatementEvent</code> object. </p>
<p> </p>
<h2>Distributed Transactions</h2> As with pooled connections, connections made via a 
    <code>DataSource</code> object that is implemented to work with the middle tier infrastructure may participate in distributed transactions. This gives an application the ability to involve data sources on multiple servers in a single transaction. 
    <p> The classes and interfaces used for distributed transactions are: </p>
<ul>
<li><code>XADataSource</code> </li>
<li><code>XAConnection</code> </li>
</ul> These interfaces are used by the transaction manager; an application does not use them directly. 
    <p> The <code>XAConnection</code> interface is derived from the <code>PooledConnection</code> interface, so what applies to a pooled connection also applies to a connection that is part of a distributed transaction. A transaction manager in the middle tier handles everything transparently. The only change in application code is that an application cannot do anything that would interfere with the transaction manager's handling of the transaction. Specifically, an application cannot call the methods <code>Connection.commit</code> or <code>Connection.rollback</code>, and it cannot set the connection to be in auto-commit mode (that is, it cannot call <code>Connection.setAutoCommit(true)</code>). </p>
<p> An application does not need to do anything special to participate in a distributed transaction. It simply creates connections to the data sources it wants to use via the <code>DataSource.getConnection</code> method, just as it normally does. The transaction manager manages the transaction behind the scenes. The <code>XADataSource</code> interface creates <code>XAConnection</code> objects, and each <code>XAConnection</code> object creates an <code>XAResource</code> object that the transaction manager uses to manage the connection. </p>
<h2>Rowsets</h2> The 
    <code>RowSet</code> interface works with various other classes and interfaces behind the scenes. These can be grouped into three categories. 
    <ol>
<li>Event Notification 
      <ul>
<li><code>RowSetListener</code><br/> A <code>RowSet</code> object is a JavaBeans<sup><font size="-2">TM</font></sup> component because it has properties and participates in the JavaBeans event notification mechanism. The <code>RowSetListener</code> interface is implemented by a component that wants to be notified about events that occur to a particular <code>RowSet</code> object. Such a component registers itself as a listener with a rowset via the <code>RowSet.addRowSetListener</code> method. <p> When the <code>RowSet</code> object changes one of its rows, changes all of it rows, or moves its cursor, it also notifies each listener that is registered with it. The listener reacts by carrying out its implementation of the notification method called on it. </p><p> </p></li>
<li><code>RowSetEvent</code><br/> As part of its internal notification process, a <code>RowSet</code> object creates an instance of <code>RowSetEvent</code> and passes it to the listener. The listener can use this <code>RowSetEvent</code> object to find out which rowset had the event. </li>
</ul> <p> </p></li>
<li>Metadata 
      <ul>
<li><code>RowSetMetaData</code><br/> This interface, derived from the <code>ResultSetMetaData</code> interface, provides information about the columns in a <code>RowSet</code> object. An application can use <code>RowSetMetaData</code> methods to find out how many columns the rowset contains and what kind of data each column can contain. <p> The <code>RowSetMetaData</code> interface provides methods for setting the information about columns, but an application would not normally use these methods. When an application calls the <code>RowSet</code> method <code>execute</code>, the <code>RowSet</code> object will contain a new set of rows, and its <code>RowSetMetaData</code> object will have been internally updated to contain information about the new columns. </p><p> </p></li>
</ul> </li>
<li>The Reader/Writer Facility<br/> A <code>RowSet</code> object that implements the <code>RowSetInternal</code> interface can call on the <code>RowSetReader</code> object associated with it to populate itself with data. It can also call on the <code>RowSetWriter</code> object associated with it to write any changes to its rows back to the data source from which it originally got the rows. A rowset that remains connected to its data source does not need to use a reader and writer because it can simply operate on the data source directly. 
      <ul>
<li><code>RowSetInternal</code><br/> By implementing the <code>RowSetInternal</code> interface, a <code>RowSet</code> object gets access to its internal state and is able to call on its reader and writer. A rowset keeps track of the values in its current rows and of the values that immediately preceded the current ones, referred to as the <i>original</i> values. A rowset also keeps track of (1) the parameters that have been set for its command and (2) the connection that was passed to it, if any. A rowset uses the <code>RowSetInternal</code> methods behind the scenes to get access to this information. An application does not normally invoke these methods directly. <p> </p></li>
<li><code>RowSetReader</code><br/> A disconnected <code>RowSet</code> object that has implemented the <code>RowSetInternal</code> interface can call on its reader (the <code>RowSetReader</code> object associated with it) to populate it with data. When an application calls the <code>RowSet.execute</code> method, that method calls on the rowset's reader to do much of the work. Implementations can vary widely, but generally a reader makes a connection to the data source, reads data from the data source and populates the rowset with it, and closes the connection. A reader may also update the <code>RowSetMetaData</code> object for its rowset. The rowset's internal state is also updated, either by the reader or directly by the method <code>RowSet.execute</code>. </li>
<li><code>RowSetWriter</code><br/> A disconnected <code>RowSet</code> object that has implemented the <code>RowSetInternal</code> interface can call on its writer (the <code>RowSetWriter</code> object associated with it) to write changes back to the underlying data source. Implementations may vary widely, but generally, a writer will do the following: <p> </p>
<ul>
<li>Make a connection to the data source </li>
<li>Check to see whether there is a conflict, that is, whether a value that has been changed in the rowset has also been changed in the data source </li>
<li>Write the new values to the data source if there is no conflict </li>
<li>Close the connection </li>
</ul> </li>
</ul> </li>
</ol>
<p> The <code>RowSet</code> interface may be implemented in any number of ways, and anyone may write an implementation. Developers are encouraged to use their imaginations in coming up with new ways to use rowsets. </p>
<p> <b>IMPORTANT NOTE:</b> Code that uses API marked "Since 1.6" must be run using a JDBC technology driver that implements the JDBC 4.0 API. You must check your driver documentation to be sure that it implements the particular features you want to use. </p>
<p> </p>
<h2>Package Specification</h2>
<ul>
<li><a href="http://java.sun.com/products/jdbc/download.html">Specification of the JDBC 4.0 API</a> </li>
</ul>
<h2>Related Documentation</h2> The Java Series book published by Addison-Wesley Longman provides detailed information about the classes and interfaces in the 
    <code>javax.sql</code> package: 
    <ul>
<li><a href="http://java.sun.com/docs/books/jdbc"><i>JDBC<sup><font size="-2">TM</font></sup> API Tutorial and Reference, Third Edition:</i></a> </li>
</ul>
<p></p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
      1.4 
    </dd>
</dl>
</div>