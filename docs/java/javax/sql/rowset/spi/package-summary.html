<div class="header">
<h1 class="title" title="Package">Package javax.sql.rowset.spi</h1>
<div class="docSummary">
<div class="block">
      第三方供应商在实施同步提供程序时必须使用的标准类和接口。 
    </div>
</div>
<p>See: <a href="#package.description">描述</a></p>
</div><div class="contentContainer">
<ul class="blockList">
<li class="blockList">
<table border="0" cellpadding="3" cellspacing="0" class="typeSummary" summary="Interface Summary table, listing interfaces, and an explanation">
<caption>
<span>接口摘要</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">接口</th>
<th class="colLast" scope="col">描述</th>
</tr>
</tbody>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../javax/sql/rowset/spi/SyncResolver.html" title="interface in javax.sql.rowset.spi">SyncResolver</a></td>
<td class="colLast">
<div class="block">
           定义一个框架，允许应用程序使用手动决策树来决定在发生同步冲突时应该做什么。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../javax/sql/rowset/spi/TransactionalWriter.html" title="interface in javax.sql.rowset.spi">TransactionalWriter</a></td>
<td class="colLast">
<div class="block">
           一个专门的界面，便于扩展标准的 
          <code>SyncProvider</code>抽象类，使其具有更细粒度的事务控制。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../javax/sql/rowset/spi/XmlReader.html" title="interface in javax.sql.rowset.spi">XmlReader</a></td>
<td class="colLast">
<div class="block">
           一个专门的界面，有助于扩展SyncProvider XML定向同步提供 
          <code>SyncProvider</code>抽象类。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../javax/sql/rowset/spi/XmlWriter.html" title="interface in javax.sql.rowset.spi">XmlWriter</a></td>
<td class="colLast">
<div class="block">
           一种专门的界面，有助于扩展面向XML的同步提供程序的 
          <code>SyncProvider</code>抽象类。 
         </div> </td>
</tr>
</tbody>
</table> </li>
<li class="blockList">
<table border="0" cellpadding="3" cellspacing="0" class="typeSummary" summary="Class Summary table, listing classes, and an explanation">
<caption>
<span>类摘要</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">类</th>
<th class="colLast" scope="col">描述</th>
</tr>
</tbody>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../javax/sql/rowset/spi/SyncFactory.html" title="class in javax.sql.rowset.spi">SyncFactory</a></td>
<td class="colLast">
<div class="block">
           服务提供者接口（SPI）机制，生成 
          <code>SyncProvider</code>实例，由断开的 
          <code>RowSet</code>对象使用。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../javax/sql/rowset/spi/SyncProvider.html" title="class in javax.sql.rowset.spi">SyncProvider</a></td>
<td class="colLast">
<div class="block">
           同步机制为断开 
          <code>RowSet</code>对象提供读写器功能。 
         </div> </td>
</tr>
</tbody>
</table> </li>
<li class="blockList">
<table border="0" cellpadding="3" cellspacing="0" class="typeSummary" summary="Exception Summary table, listing exceptions, and an explanation">
<caption>
<span>异常摘要</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">异常</th>
<th class="colLast" scope="col">描述</th>
</tr>
</tbody>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../javax/sql/rowset/spi/SyncFactoryException.html" title="class in javax.sql.rowset.spi">SyncFactoryException</a></td>
<td class="colLast">
<div class="block">
           表示有错误 
          <code>SyncFactory</code>机制。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../javax/sql/rowset/spi/SyncProviderException.html" title="class in javax.sql.rowset.spi">SyncProviderException</a></td>
<td class="colLast">
<div class="block">
           表示与错误 
          <code>SyncProvider</code>机制。 
         </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<a name="package.description">
<!-- --> </a>
<h2 title="Package javax.sql.rowset.spi Description">Package javax.sql.rowset.spi Description</h2>
<div class="block">
<span>第三方供应商在实施同步提供程序时必须使用的标准类和接口。</span>
<span>这些类和接口被称为服务提供者接口（SPI）。</span>
<span>供应商可能会通过发送电子邮件到<code>jdbc@sun.com</code>将其实现包含在JDBC网页上，列出可用的<code>SyncProvider</code> <code>jdbc@sun.com</code> 。</span>
<span>这样做有助于使开发人员了解实施。</span>
<span>为了能够为<code>RowSet</code>的对象使用一个实现，供应商必须与注册它<code>SyncFactory</code>单。</span>
<span>（有关注册过程的完整说明和要使用的命名约定，请参阅<code>SyncProvider</code>的类注释。）</span>
<p></p>
<h2> <span>目录</span> </h2>
<ul>
<li> <span><a href="#pkgspec">1.0 Package Specification</a></span> </li>
<li> <span><a href="#arch">2.0 Service Provider Architecture</a></span> </li>
<li> <span><a href="#impl">3.0 Implementer's Guide</a></span> </li>
<li> <span><a href="#resolving">4.0 Resolving Synchronization Conflicts</a></span> </li>
<li> <span><a href="#relspec">5.0 Related Specifications</a></span> </li>
<li> <span><a href="#reldocs">6.0 Related Documentation</a></span> </li>
</ul>
<h3> <span><a name="pkgspec">1.0 Package Specification</a></span> </h3>
<span><a name="pkgspec"><p> The following classes and interfaces make up the <code>javax.sql.rowset.spi</code> package: </p>
<ul>
<li><code>SyncFactory</code> </li>
<li><code>SyncProvider</code> </li>
<li><code>SyncFactoryException</code> </li>
<li><code>SyncProviderException</code> </li>
<li><code>SyncResolver</code> </li>
<li><code>XmlReader</code> </li>
<li><code>XmlWriter</code> </li>
<li><code>TransactionalWriter</code> </li>
</ul> The following interfaces, in the <code>javax.sql</code> package, are also part of the SPI: 
      <ul>
<li><code>RowSetReader</code> </li>
<li><code>RowSetWriter</code> </li>
</ul> <p> A <code>SyncProvider</code> implementation provides a disconnected <code>RowSet</code> object with the mechanisms for reading data into it and for writing data that has been modified in it back to the underlying data source. A <i>reader</i>, a <code>RowSetReader</code> or <code>XMLReader</code> object, reads data into a <code>RowSet</code> object when the <code>CachedRowSet</code> methods <code>execute</code> or <code>populate</code> are called. A <i>writer</i>, a <code>RowSetWriter</code> or <code>XMLWriter</code> object, writes changes back to the underlying data source when the <code>CachedRowSet</code> method <code>acceptChanges</code> is called. </p><p> The process of writing changes in a <code>RowSet</code> object to its data source is known as <i>synchronization</i>. The <code>SyncProvider</code> implementation that a <code>RowSet</code> object is using determines the level of synchronization that the <code>RowSet</code> object's writer uses. The various levels of synchronization are referred to as <i>grades</i>. </p><p> The lower grades of synchronization are known as <i>optimistic</i> concurrency levels because they optimistically assume that there will be no conflicts or very few conflicts. A conflict exists when the same data modified in the <code>RowSet</code> object has also been modified in the data source. Using the optimistic concurrency model means that if there is a conflict, modifications to either the data source or the <code>RowSet</code> object will be lost. </p><p> Higher grades of synchronization are called <i>pessimistic</i> because they assume that others will be accessing the data source and making modifications. These grades set varying levels of locks to increase the chances that no conflicts occur. </p><p> The lowest level of synchronization is simply writing any changes made to the <code>RowSet</code> object to its underlying data source. The writer does nothing to check for conflicts. If there is a conflict and the data source values are overwritten, the changes other parties have made by to the data source are lost. </p><p> The <code>RIXMLProvider</code> implementation uses the lowest level of synchronization and just writes <code>RowSet</code> changes to the data source. This is true because typically XML data sources do not enable transaction techniques for maintaining the integrity of data. However, specific standards groups have considered offering XML-based synchronization. For details, see </p></a></span>
<pre>  <span><a name="pkgspec"> </a><a href="http://www.syncml.org">http://www.syncml.org</a></span> </pre>
<p> <span>对于下一个级别，作者检查是否有任何冲突，如果有的话，它不会对数据源写任何东西。</span> <span>这种并发级别的问题是，如果另一方已经修改了数据源中的对应数据，因为<code>RowSet</code>对象获得了其数据，则对<code>RowSet</code>对象所做的更改将丢失。</span> <span><code>RIOptimisticProvider</code>实现使用这种级别的同步。</span> </p>
<p> <span>在较高级别的同步，称为悲观并发，作者采取措施通过设置锁来避免冲突。</span> <span>设置锁可以从设置单个行的锁定到在表或整个数据源上设置锁定而有所不同。</span> <span>因此，同步级别是用户同时访问数据源的能力与作者将数据保持在<code>RowSet</code>对象及其数据源同步的能力之间的折衷。</span> </p>
<p> <span>这是所有断开的要求<code>RowSet</code>对象（ <code>CachedRowSet</code> ， <code>FilteredRowSet</code> ， <code>JoinRowSet</code>和<code>WebRowSet</code>对象）获得其<code>SyncProvider</code>从对象<code>SyncFactory</code>机制。</span> </p>
<p> <span>参考实现（RI）提供了两个同步提供程序。</span> </p>
<ul>
<li> <span><b><tt>RIOptimisticProvider</tt></b></span> <br/> <span><code>SyncFactory</code>实例在未指定提供程序实现时将提供给断开<code>RowSet</code>对象的默认提供程序。</span> <br/> <span>该同步提供程序使用乐观并发模型，假设在数据库中访问相同数据的用户之间将存在很少的冲突。</span> <span>它避免使用锁;</span> <span>而是在尝试同步<code>RowSet</code>对象和数据源之前检查是否存在冲突。</span> <span>如果存在冲突，则不执行任何操作，这意味着<code>RowSet</code>对象的更改不会持久保留到数据源。</span> </li>
<li> <span><b><tt>RIXMLProvider</tt></b></span> <br/> <span>可与<code>WebRowSet</code>对象一起使用的同步提供程序，该对象是可以用XML格式编写或从XML格式读取的行集。</span> <span><code>RIXMLProvider</code>实现不会检查冲突，只需将<code>WebRowSet</code>对象中的任何更新的数据写入底层数据源。</span> <span><code>WebRowSet</code>对象在处理XML数据时使用此提供程序。</span> </li>
</ul>
<span>这些<code>SyncProvider</code>实现与<code>SyncProvider</code>实现捆绑在一起，这使得它们始终可用于<code>RowSet</code>实现。</span>
<span><code>SyncProvider</code>实现使自己可以通过注册<code>SyncFactory</code>单身。</span>
<span>当一个<code>RowSet</code>对象请求一个提供者时，通过在构造函数中指定它或<code>CachedRowSet</code>方法<code>setSyncProvider</code>的参数， <code>SyncFactory</code>单例检查以查看请求的提供者是否已经注册。</span>
<span>如果它有， <code>SyncFactory</code>创建一个实例，并将其传递给请求的<code>RowSet</code>对象。</span>
<span>如果指定的<code>SyncProvider</code>实现尚未注册，则<code>SyncFactory</code>单例会导致抛出<code>SyncFactoryException</code>对象。</span>
<span>如果没有指定提供者，SyncFactory <code>SyncFactory</code>例将创建默认提供程序实现的实例<code>RIOptimisticProvider</code> ，并将其传递给请求的<code>RowSet</code>对象。</span>
<p> <span>如果一个<code>WebRowSet</code>对象在其<code>WebRowSet</code>函数中没有指定提供者，则<code>SyncFactory</code>将给它一个<code>RIOptimisticProvider</code>的实例。</span> <span>然而，WebRowSet的<code>WebRowSet</code>被实现以将提供者设置为<code>RIXMLProvider</code> ，其以XML格式读取和写入<code>RowSet</code>对象。</span> </p>
<p> <span>有关详细信息，请参阅<a href="SyncProvider.html">SyncProvider</a>类规范。</span> </p>
<p> <span>供应商可以开发一个<tt>SyncProvider</tt>实现与同步的可能级别中的任何一个，从而使<code>RowSet</code>对象的同步机制的选择。</span> <span>供应商可以通过向甲骨文公司注册完全合格的类名，从而实现其可用性，方法是： <code>jdbc@sun.com</code> 。</span> <span>以下进一步详细讨论该过程。</span> </p>
<p> <span><a name="arch"></a></span> </p>
<h3> <span><a name="arch">2.0 Service Provider Interface Architecture</a></span> </h3>
<span><a name="arch"></a></span>
<ul>
<span><a name="arch"><b>2.1 Overview</b> <p> The Service Provider Interface provides a pluggable mechanism by which <code>SyncProvider</code> implementations can be registered and then generated when required. The lazy reference mechanism employed by the <code>SyncFactory</code> limits unnecessary resource consumption by not creating an instance until it is required by a disconnected <code>RowSet</code> object. The <code>SyncFactory</code> class also provides a standard API to configure logging options and streams that <b>may</b> be provided by a particular <code>SyncProvider</code> implementation. </p><p> <b>2.2 Registering with the <code>SyncFactory</code></b> </p><p> A third party <code>SyncProvider</code> implementation must be registered with the <code>SyncFactory</code> in order for a disconnected <code>RowSet</code> object to obtain it and thereby use its <code>javax.sql.RowSetReader</code> and <code>javax.sql.RowSetWriter</code> implementations. The following registration mechanisms are available to all <code>SyncProvider</code> implementations: </p> </a>
<ul>
<a name="arch"> <li><b>System properties</b> - Properties set at the command line. These properties are set at run time and apply system-wide per invocation of the Java application. See the section <a href="#reldocs">"Related Documentation"</a> further related information. <p> </p></li></a>
<li><b>Property Files</b> - Properties specified in a standard property file. This can be specified using a System Property or by modifying a standard property file located in the platform run-time. The reference implementation of this technology includes a standard property file than can be edited to add additional <code>SyncProvider</code> objects. <p> </p></li>
<li><b>JNDI Context</b> - Available providers can be registered on a JNDI context. The <tt>SyncFactory</tt> will attempt to load <tt>SyncProvider</tt> objects bound to the context and register them with the factory. This context must be supplied to the <code>SyncFactory</code> for the mechanism to function correctly. </li>
</ul></span>
<p> <span>有关如何指定属性文件中的系统属性或属性以及如何配置JNDI上下文的详细信息，请<a href="SyncFactory.html">参见<code>SyncFactory</code></a>类描述。</span> </p>
<p> <span><b>2.3 SyncFactory Provider实例生成策略</b></span> </p>
<p> <span><code>SyncFactory</code>如果提供程序已<code>SyncFactory</code>注册，则生成请求的<code>SyncProvider</code>对象。</span> <span>当断开连接的<code>RowSet</code>对象使用指定的SyncProvider <code>SyncProvider</code>实例化或在运行时使用替代的<code>SyncProvider</code>对象重新<code>SyncProvider</code>时，将遵守<code>SyncProvider</code> 。</span> </p>
<ul>
<li> <span>如果<code>SyncProvider</code>指定对象和<code>SyncFactory</code> <i>没有</i>提及供应商，一个<code>SyncFactoryException</code>被抛出。</span> <p></p></li>
<li> <span>如果指定了<code>SyncProvider</code>对象，并且<code>SyncFactory</code>包含对提供程序的引用，则提供所请求的提供程序。</span> <p></p></li>
<li> <span>如果没有<code>SyncProvider</code>对象，则提供参考实现提供者<code>RIOptimisticProvider</code> 。</span> </li>
</ul>
<p> <span>这些政策在<a href="SyncFactory.html"><code>SyncFactory</code></a>课程中有更详细的<a href="SyncFactory.html">探讨</a> 。</span> </p>
</ul>
<li> <span><a name="impl"><h3>3.0 SyncProvider Implementer's Guide</h3></a></span>
<ul>
<span><a name="impl"><b>3.1 Requirements</b> </a><p><a name="impl"> A compliant <code>SyncProvider</code> implementation that is fully pluggable into the <code>SyncFactory</code> <b>must</b> extend and implement all abstract methods in the </a><a href="SyncProvider.html"><code>SyncProvider</code></a> class. In addition, an implementation <b>must</b> determine the grade, locking and updatable view capabilities defined in the <code>SyncProvider</code> class definition. One or more of the <code>SyncProvider</code> description criteria <b>must</b> be supported. It is expected that vendor implementations will offer a range of grade, locking, and updatable view capabilities. </p></span>
<p> <span>此外， <code>SyncProvider</code>命名约定<b>必须</b>遵循<a href="SyncProvider.html"><code>SyncProvider</code></a>类描述中的详细说明。</span> </p>
<p> <span><b>3.2年级</b></span> </p>
<p> <span>JSR 114定义了一组等级来描述同步的质量，一个<code>SyncProvider</code>对象可以提供一个断开<code>RowSet</code>对象<code>RowSet</code> 。</span> <span>这些等级从最低服务质量列为最高。</span> </p>
<ul>
<li> <span><b>GRADE_NONE</b> - 不提供与始发数据源的同步。</span> <span>一个<code>SyncProvider</code>实现返回此等级将简单的写在改变任何数据<code>RowSet</code>对象的基础数据源，覆盖不管是存在的。</span> <span>没有尝试将原始值与当前值进行比较，以查看是否存在冲突。</span> <span><code>RIXMLProvider</code>是用这个档次实现的。</span> <p></p></li>
<li> <span><b>GRADE_CHECK_MODIFIED_AT_COMMIT</b> - 低级别的乐观同步。</span> <span>一个<code>SyncProvider</code>实现返回此等级将检查行已经过去的同步和正在进行的当前同步之间更改冲突。</span> <span>已修改的始发数据源中的任何更改都不会反映在断开<code>RowSet</code>对象中。</span> <span>如果没有冲突， <code>RowSet</code>对象中的更改将被写入数据源。</span> <span>如果有冲突，则不会改变。</span> <span><code>RIOptimisticProvider</code>实现使用这个等级。</span> <p></p></li>
<li> <span><b>GRADE_CHECK_ALL_AT_COMMIT</b> - 高度的乐观同步。</span> <span>一个<code>SyncProvider</code>实现返回此等级将检查所有的行，包括那些没有在断开更改的行<code>RowSet</code>对象。</span> <span>以这种方式，当同步完成成功时，底层数据源中对行的任何更改将反映在断开<code>RowSet</code>对象中。</span> <p></p></li>
<li> <span><b>GRADE_LOCK_WHEN_MODIFIED</b> - 悲观的同步档次。</span> <span><code>SyncProvider</code>此等级的SyncProvider实现将锁定与<code>RowSet</code>对象中正在更改的行对应的始发数据源中的行，以减少其他进程修改数据源中相同数据的可能性。</span> <p></p></li>
<li> <span><b>GRADE_LOCK_WHEN_LOADED</b> - 较高的悲观同步等级。</span> <span>甲<code>SyncProvider</code>执行返回此等级将锁定受用于填充原始查询整个视图和/或表<code>RowSet</code>对象。</span> </li>
</ul>
<p> <span><b>3.3锁</b></span> </p>
<p> <span>JSR 114定义了一组常量，它们指定是否将任何锁放置在<code>RowSet</code>对象的基础数据源上，如果是这样，则在其上放置锁定的构造。</span> <span>这些锁将保留在数据源上，而<code>RowSet</code>对象与数据源断开连接。</span> </p>
<p> <span>这些常数<b>应该</b>被认为是等级常数的补充。</span> <span>大多数成绩设置的默认设置要求当<code>RowSet</code>对象与其数据源断开连接时，不会保留数据源锁定。</span> <span>等级<code>GRADE_LOCK_WHEN_MODIFIED</code>和<code>GRADE_LOCK_WHEN_LOADED</code>允许断开的<code>RowSet</code>对象对锁定程度进行细粒度控制。</span> </p>
<ul>
<li> <span><b>DATASOURCE_NO_LOCK</b> - 始发数据源上没有锁。</span> <span>这是所有<code>SyncProvider</code>实现的默认锁定设置，除非<code>RowSet</code>对象另有指示。</span> <p></p></li>
<li> <span><b>DATASOURCE_ROW_LOCK</b> - 一个锁被放置在用于填充<code>RowSet</code>对象的原始SQL查询所触摸的行上。</span> <p></p></li>
<li> <span><b>DATASOURCE_TABLE_LOCK</b> - 在用于填充<code>RowSet</code>对象的查询所触及的所有表上都放置一个锁。</span> <p></p></li>
<li> <span><b>DATASOURCE_DB_LOCK</b>在<code>RowSet</code>对象使用的整个数据源上放置一个锁。</span> </li>
</ul>
<p> <span><b>3.4可更新视图</b></span> </p>
<p> <span>可以使用来自SQL <code>VIEW</code>数据<code>RowSet</code>对象。</span> <span>以下常量指示是否<code>SyncProvider</code>对象可以更新表中或从该表中的数据<code>VIEW</code>推导。</span> </p>
<ul>
<li> <span><b>UPDATABLE_VIEW_SYNC</b>表示<code>SyncProvider</code>实现支持同步到<code>VIEW</code>用于填充<code>RowSet</code>对象的SQL <code>VIEW</code>表的表。</span> <p></p></li>
<li> <span><b>NONUPDATABLE_VIEW_SYNC</b>表示一个<code>SyncProvider</code>实现<b>不</b>支持同步从该SQL表或表<code>VIEW</code>用于填充<code>RowSet</code>对象导出。</span> </li>
</ul>
<p> <span><b>3.5使用<code>SyncProvider</code>分级和锁定</b></span> </p>
<p> <span>在下面的示例中，参考<tt>CachedRowSetImpl</tt>实现通过调用<tt>setSyncProvider</tt>方法重新配置其当前的<tt>SyncProvider</tt>对象。</span> <br/></p>
</ul><pre>  <span>CachedRowSetImpl crs = new CachedRowSetImpl();
    crs.setSyncProvider("com.foo.bar.HASyncProvider");</span> </pre>
<span>一个应用程序可以检索一个断开的<tt>RowSet</tt>对象当前正在使用的<code>RowSet</code>对象。</span>
<span>它还可以检索提供者实现的同步级别和当前使用的锁定程度。</span>
<span>此外，应用程序具有设置要使用的锁定程度的灵活性，这可以增加成功同步的可能性。</span>
<span>这些操作显示在以下代码片段中。</span>
<pre>  <span>SyncProvider sync = crs.getSyncProvider();

    switch (sync.getProviderGrade()) {
    case: SyncProvider.GRADE_CHECK_ALL_AT_COMMIT
         //A high grade of optimistic synchronization
    break;
    case: SyncProvider.GRADE_CHECK_MODIFIED_AT_COMMIT 
         //A low grade of optimistic synchronization 
    break;
    case: SyncProvider.GRADE_LOCK_WHEN_LOADED 
         // A pessimistic synchronization grade 
    break;
    case: SyncProvider.GRADE_LOCK_WHEN_MODIFIED 
         // A pessimistic synchronization grade 
    break;
    case: SyncProvider.GRADE_NONE 
      // No synchronization with the originating data source provided
    break;
    }
          
    switch (sync.getDataSourcLock() {
      case: SyncProvider.DATASOURCE_DB_LOCK
       // A lock is placed on the entire datasource that is used by the
       // <code>RowSet</code> object 
       break;

      case: SyncProvider.DATASOURCE_NO_LOCK
       // No locks remain on the  originating data source.
      break;

      case: SyncProvider.DATASOURCE_ROW_LOCK
       // A lock is placed on the rows that are  touched by the original 
       // SQL statement used to populate
       // the RowSet object that is using the SyncProvider
       break;

      case: DATASOURCE_TABLE_LOCK
       // A lock is placed on  all tables that are touched by the original 
       // SQL statement used to populated
       // the RowSet object that is using the SyncProvider
       break;</span> </pre>
<span>它使用的静态实用方法，也可以<code>SyncFactory</code>类确定的名单<code>SyncProvider</code>当前与注册的实现<code>SyncFactory</code> 。</span>
<pre>  <span>Enumeration e = SyncFactory.getRegisteredProviders();</span> </pre>
<h3> <span><a name="resolving">4.0 Resolving Synchronization Conflicts</a></span> </h3> <span><a name="resolving">The interface <code>SyncResolver</code> provides a way for an application to decide manually what to do when a conflict occurs. When the <code>CachedRowSet</code> method <code>acceptChanges</code> finishes and has detected one or more conflicts, it throws a <code>SyncProviderException</code> object. An application can catch the exception and have it retrieve a <code>SyncResolver</code> object by calling the method <code>SyncProviderException.getSyncResolver()</code>. <p> A <code>SyncResolver</code> object, which is a special kind of <code>CachedRowSet</code> object or a <code>JdbcRowSet</code> object that has implemented the <code>SyncResolver</code> interface, examines the conflicts row by row. It is a duplicate of the <code>RowSet</code> object being synchronized except that it contains only the data from the data source this is causing a conflict. All of the other column values are set to <code>null</code>. To navigate from one conflict value to another, a <code>SyncResolver</code> object provides the methods <code>nextConflict</code> and <code>previousConflict</code>. </p><p> The <code>SyncResolver</code> interface also provides methods for doing the following: </p>
<ul>
<li>finding out whether the conflict involved an update, a delete, or an insert </li>
<li>getting the value in the data source that caused the conflict </li>
<li>setting the value that should be in the data source if it needs to be changed or setting the value that should be in the <code>RowSet</code> object if it needs to be changed </li>
</ul> <p> When the <code>CachedRowSet</code> method <code>acceptChanges</code> is called, it delegates to the <code>RowSet</code> object's <code>SyncProvider</code> object. How the writer provided by that <code>SyncProvider</code> object is implemented determines what level (grade) of checking for conflicts will be done. After all checking for conflicts is completed and one or more conflicts has been found, the method <code>acceptChanges</code> throws a <code>SyncProviderException</code> object. The application can catch the exception and use it to obtain a <code>SyncResolver</code> object. </p><p> The application can then use <code>SyncResolver</code> methods to get information about each conflict and decide what to do. If the application logic or the user decides that a value in the <code>RowSet</code> object should be the one to persist, the application or user can overwrite the data source value with it. </p></a></span> <p> <span><a name="resolving">The comment for the <code>SyncResolver</code> interface has more detail.</a> <a name="relspec"></a></span> </p><h3> <span><a name="relspec">5.0 Related Specifications</a></span> </h3> <span><a name="relspec"></a></span>
<ul>
<span><a name="relspec"></a><li><a name="relspec"></a><a href="http://java.sun.com/products/jndi">JNDI 1.3</a> </li></span>
<li> <span><a href="../../../../../technotes/guides/logging/index.html">Java Logging APIs</a></span> </li>
</ul> <span><a name="reldocs"><h3>6.0 Related Documentation</h3></a></span>
<ul>
<span><a name="reldocs"></a><li><a name="reldocs"></a><a href="../../../../../technotes/tools/index.html#basic">System properties</a> </li></span>
<li> <span>资源文件</span> </li>
<li> <span><a href="http://java.sun.com/tutorial/jdbc">DataSource for JDBC Connections</a></span> </li>
</ul></li>
</div>
</div>