<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     javax.net.ssl 
   </div>
<h2 class="title" title="Class SSLServerSocket">Class SSLServerSocket</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li><a href="../../../java/net/ServerSocket.html" title="class in java.net">java.net.ServerSocket</a></li>
<li>
<ul class="inheritance">
<li>javax.net.ssl.SSLServerSocket</li>
</ul> </li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
         All Implemented Interfaces: 
       </dt>
<dd>
<span><a href="../../../java/io/Closeable.html" title="java.io中的接口">Closeable</a> ， <a href="../../../java/lang/AutoCloseable.html" title="java.lang中的接口">AutoCloseable</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public abstract class <span class="typeNameLabel">SSLServerSocket</span>
extends <a href="../../../java/net/ServerSocket.html" title="class in java.net">ServerSocket</a></pre>
<div class="block">
<span>此类扩展了<code>ServerSocket</code> ，并使用安全套接字层（SSL）或传输层安全（TLS）协议等协议提供安全的服务器套接字。</span>
<p> <span>这个类的实例是使用一般创建<code>SSLServerSocketFactory</code> 。</span> <span><code>SSLServerSocket</code>的主要功能是通过<code>accept</code>创建<code>SSLSocket</code> s连接。</span> </p>
<p> <span><code>SSLServerSocket</code>包含几个状态数据，这些数据在套接字创建时由<code>SSLSocket</code> 。</span> <span>这些包括启用的密码套件和协议，无论客户端认证是否必要，以及创建的套接字是否应在客户端或服务器模式下开始握手。</span> <span>创建的<code>SSLSocket</code>的状态可以通过调用适当的方法来覆盖。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.4 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../../java/net/ServerSocket.html" title="java.net中的类"><code>ServerSocket</code></a> ， <a href="../../../javax/net/ssl/SSLSocket.html" title="javax.net.ssl中的类"><code>SSLSocket</code></a></span>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!-- --> </a> <h3>构造方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Constructor Summary table, listing constructors, and an explanation">
<caption>
<span>构造方法</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier</th>
<th class="colLast" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#SSLServerSocket--">SSLServerSocket</a></span>()</code>
<div class="block">
              仅由子类使用。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#SSLServerSocket-int-">SSLServerSocket</a></span>(int port)</code>
<div class="block">
              仅由子类使用。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#SSLServerSocket-int-int-">SSLServerSocket</a></span>(int port, int backlog)</code>
<div class="block">
              仅由子类使用。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#SSLServerSocket-int-int-java.net.InetAddress-">SSLServerSocket</a></span>(int port, int backlog, <a href="../../../java/net/InetAddress.html" title="class in java.net">InetAddress</a> address)</code>
<div class="block">
              仅由子类使用。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t3"><span><a href="javascript:show(4);">抽象方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>abstract <a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#getEnabledCipherSuites--">getEnabledCipherSuites</a></span>()</code>
<div class="block">
              返回当前允许新接受连接使用的密码套件列表。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>abstract <a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#getEnabledProtocols--">getEnabledProtocols</a></span>()</code>
<div class="block">
              返回当前启用以便新接受的连接使用的协议的名称。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>abstract boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#getEnableSessionCreation--">getEnableSessionCreation</a></span>()</code>
<div class="block">
              如果可以通过从该服务器套接字创建的套接字建立新的SSL会话，则返回true。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>abstract boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#getNeedClientAuth--">getNeedClientAuth</a></span>()</code>
<div class="block">
              如果在新的 
             <code>accept</code> ed服务器模式 
             <code>SSLSocket</code>上 
             <i>需要</i>客户端认证，则返回true。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code><a href="../../../javax/net/ssl/SSLParameters.html" title="class in javax.net.ssl">SSLParameters</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#getSSLParameters--">getSSLParameters</a></span>()</code>
<div class="block">
              返回对新接受的连接有效的SSLParameters。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>abstract <a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#getSupportedCipherSuites--">getSupportedCipherSuites</a></span>()</code>
<div class="block">
              返回可以在SSL连接上使用的密码套件的名称。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>abstract <a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#getSupportedProtocols--">getSupportedProtocols</a></span>()</code>
<div class="block">
              返回可以启用的协议的名称。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>abstract boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#getUseClientMode--">getUseClientMode</a></span>()</code>
<div class="block">
              如果接受的连接将处于SSL客户端模式，则返回true。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>abstract boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#getWantClientAuth--">getWantClientAuth</a></span>()</code>
<div class="block">
              如果客户端身份验证将在新接受的服务器模式的连接 
             <i>请求</i> ，则返回true。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#setEnabledCipherSuites-java.lang.String:A-">setEnabledCipherSuites</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a>[] suites)</code>
<div class="block">
              设置允许接受连接使用的密码套件。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#setEnabledProtocols-java.lang.String:A-">setEnabledProtocols</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a>[] protocols)</code>
<div class="block">
              控制哪些特定协议被接受的连接启用。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#setEnableSessionCreation-boolean-">setEnableSessionCreation</a></span>(boolean flag)</code>
<div class="block">
              控制是否可以由从此服务器套接字创建的套接字建立新的SSL会话。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#setNeedClientAuth-boolean-">setNeedClientAuth</a></span>(boolean need)</code>
<div class="block">
              控制 
             <code>accept</code>编辑服务器模式 
             <code>SSLSockets</code>是否最初配置为 
             <i>要求</i>客户端认证。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#setSSLParameters-javax.net.ssl.SSLParameters-">setSSLParameters</a></span>(<a href="../../../javax/net/ssl/SSLParameters.html" title="class in javax.net.ssl">SSLParameters</a> params)</code>
<div class="block">
              将SSLParameters应用于新接受的连接。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#setUseClientMode-boolean-">setUseClientMode</a></span>(boolean mode)</code>
<div class="block">
              控制接受的连接是否处于（默认）SSL服务器模式或SSL客户端模式。 
            </div> </td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLServerSocket.html#setWantClientAuth-boolean-">setWantClientAuth</a></span>(boolean want)</code>
<div class="block">
              控制 
             <code>accept</code> ed服务器模式 
             <code>SSLSockets</code>是否最初配置为 
             <i>请求</i>客户端身份验证。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.net.ServerSocket">
<!-- --> </a> <h3>Methods inherited from class java.net.<a href="../../../java/net/ServerSocket.html" title="class in java.net">ServerSocket</a></h3> <code><a href="../../../java/net/ServerSocket.html#accept--">accept</a>, <a href="../../../java/net/ServerSocket.html#bind-java.net.SocketAddress-">bind</a>, <a href="../../../java/net/ServerSocket.html#bind-java.net.SocketAddress-int-">bind</a>, <a href="../../../java/net/ServerSocket.html#close--">close</a>, <a href="../../../java/net/ServerSocket.html#getChannel--">getChannel</a>, <a href="../../../java/net/ServerSocket.html#getInetAddress--">getInetAddress</a>, <a href="../../../java/net/ServerSocket.html#getLocalPort--">getLocalPort</a>, <a href="../../../java/net/ServerSocket.html#getLocalSocketAddress--">getLocalSocketAddress</a>, <a href="../../../java/net/ServerSocket.html#getReceiveBufferSize--">getReceiveBufferSize</a>, <a href="../../../java/net/ServerSocket.html#getReuseAddress--">getReuseAddress</a>, <a href="../../../java/net/ServerSocket.html#getSoTimeout--">getSoTimeout</a>, <a href="../../../java/net/ServerSocket.html#implAccept-java.net.Socket-">implAccept</a>, <a href="../../../java/net/ServerSocket.html#isBound--">isBound</a>, <a href="../../../java/net/ServerSocket.html#isClosed--">isClosed</a>, <a href="../../../java/net/ServerSocket.html#setPerformancePreferences-int-int-int-">setPerformancePreferences</a>, <a href="../../../java/net/ServerSocket.html#setReceiveBufferSize-int-">setReceiveBufferSize</a>, <a href="../../../java/net/ServerSocket.html#setReuseAddress-boolean-">setReuseAddress</a>, <a href="../../../java/net/ServerSocket.html#setSocketFactory-java.net.SocketImplFactory-">setSocketFactory</a>, <a href="../../../java/net/ServerSocket.html#setSoTimeout-int-">setSoTimeout</a>, <a href="../../../java/net/ServerSocket.html#toString--">toString</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!-- --> </a> <h3>构造方法详细信息</h3> <a name="SSLServerSocket--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>SSLServerSocket</h4> <pre>protected SSLServerSocket()
                   throws <a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></pre>
<div class="block">
<span>仅由子类使用。</span>
<p> <span>使用默认身份验证上下文创建一个未绑定的TCP服务器套接字。</span> </p>
</div>
<dl>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></code> - 如果在创建套接字时发生I / O错误 
           </dd>
</dl> </li>
</ul> <a name="SSLServerSocket-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>SSLServerSocket</h4> <pre>protected SSLServerSocket(int port)
                   throws <a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></pre>
<div class="block">
<span>仅由子类使用。</span>
<p> <span>使用默认身份验证上下文在端口上创建TCP服务器套接字。</span> <span>在系统开始拒绝新的连接请求之前，连接备份默认为排队的五十个连接。</span> </p>
<p> <span>端口号<code>0</code>在任意空闲端口上创建一个套接字。</span> </p>
<p> <span>如果有一个安全管理器，它的<code>checkListen</code>方法<code>port</code>参数作为参数进行调用，以确保允许操作。</span> <span>这可能会导致SecurityException。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>port</code> - 要收听的端口 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></code> - 如果在创建套接字时发生I / O错误 
           </dd>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理器存在，并且其 
            <code>checkListen</code>方法不允许操作。 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果端口参数超出了有效端口值的指定范围（介于0和65535之间），包括0和65535之间。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/SecurityManager.html#checkListen-int-"><code>SecurityManager.checkListen(int)</code></a>
</dd>
</dl> </li>
</ul> <a name="SSLServerSocket-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>SSLServerSocket</h4> <pre>protected SSLServerSocket(int port,
                          int backlog)
                   throws <a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></pre>
<div class="block">
<span>仅由子类使用。</span>
<p> <span>在端口上创建TCP服务器套接字，使用默认身份验证上下文和指定的积压的连接。</span> </p>
<p> <span>端口号<code>0</code>在任意空闲端口上创建一个套接字。</span> </p>
<p> <span><code>backlog</code>参数是套接字上请求的挂起连接的最大数目。</span> <span>其确切语义是实现具体的。</span> <span>特别地，实现可以施加最大长度，或者可以选择忽略参数altogther。</span> <span>提供的值应大于<code>0</code> 。</span> <span>如果小于或等于<code>0</code> ，则将使用实现特定的默认值。</span> </p>
<p> <span>如果有安全管理器，则使用<code>port</code>参数作为参数来调用其<code>checkListen</code>方法，以确保允许操作。</span> <span>这可能会导致SecurityException。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>port</code> - 要收听的端口 
           </dd>
<dd>
<code>backlog</code> - 请求传入连接队列的最大长度。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></code> - 如果在创建套接字时发生I / O错误 
           </dd>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理器存在，并且其 
            <code>checkListen</code>方法不允许操作。 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果端口参数超出了在0到65535之间的有效端口值的指定范围（包括0和65535之间）。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/SecurityManager.html#checkListen-int-"><code>SecurityManager.checkListen(int)</code></a>
</dd>
</dl> </li>
</ul> <a name="SSLServerSocket-int-int-java.net.InetAddress-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>SSLServerSocket</h4> <pre>protected SSLServerSocket(int port,
                          int backlog,
                          <a href="../../../java/net/InetAddress.html" title="class in java.net">InetAddress</a> address)
                   throws <a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></pre>
<div class="block">
<span>仅由子类使用。</span>
<p> <span>在端口上创建TCP服务器套接字，使用默认身份验证上下文和指定的连接积压以及特定的指定网络接口。</span> <span>该构造函数用于多宿主主机，例如用于防火墙或路由器的主机，以控制通过哪个接口提供网络服务。</span> </p>
<p> <span>如果有一个安全管理器，它的<code>checkListen</code>方法被调用，以<code>port</code>参数作为参数，以确保操作是允许的。</span> <span>这可能会导致SecurityException。</span> </p>
<p> <span>端口号<code>0</code>在任意空闲端口上创建一个套接字。</span> </p>
<p> <span><code>backlog</code>参数是套接字上请求的最大挂起连接数。</span> <span>其确切语义是实现具体的。</span> <span>特别地，实现可以施加最大长度，或者可以选择忽略参数altogther。</span> <span>提供的值应大于<code>0</code> 。</span> <span>如果小于或等于<code>0</code> ，则将使用实现特定的默认值。</span> </p>
<p> <span>如果<i>地址</i>为空，它将默认接受任何/所有本地地址上的连接。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>port</code> - 要收听的端口 
           </dd>
<dd>
<code>backlog</code> - 请求传入连接队列的最大长度。 
           </dd>
<dd>
<code>address</code> - 将接受连接的网络接口的地址 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></code> - 如果在创建套接字时发生I / O错误 
           </dd>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理器存在，并且其 
            <code>checkListen</code>方法不允许操作。 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果端口参数在超出指定范围的有效端口值（介于0和65535之间），包括0和65535之间。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/SecurityManager.html#checkListen-int-"><code>SecurityManager.checkListen(int)</code></a>
</dd>
</dl> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="getEnabledCipherSuites--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getEnabledCipherSuites</h4> <pre>public abstract <a href="../../../java/lang/String.html" title="class in java.lang">String</a>[] getEnabledCipherSuites()</pre>
<div class="block">
<span>返回当前允许新接受连接使用的密码套件列表。</span>
<p> <span>如果此列表尚未被明确修改，则系统提供的默认值保证所有启用的密码套件中的最低服务质量。</span> </p>
<p> <span>启用加密套件可能不会被实际使用的原因有几个。</span> <span>例如：服务器套接字可能没有可用的适当的私钥，或者密码套件可能是匿名的，排除了使用客户端认证，而服务器套接字被告知需要这种认证。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             启用了一系列密码套件 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/net/ssl/SSLServerSocket.html#getSupportedCipherSuites--"><code>getSupportedCipherSuites()</code></a> ， 
            <a href="../../../javax/net/ssl/SSLServerSocket.html#setEnabledCipherSuites-java.lang.String:A-"><code>setEnabledCipherSuites(String [])</code></a>
</dd>
</dl> </li>
</ul> <a name="setEnabledCipherSuites-java.lang.String:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setEnabledCipherSuites</h4> <pre>public abstract void setEnabledCipherSuites(<a href="../../../java/lang/String.html" title="class in java.lang">String</a>[] suites)</pre>
<div class="block">
<span>设置允许接受连接使用的密码套件。</span>
<p> <span>密码套件必须由getSupportedCipherSuites（）列为受支持的。</span> <span>成功调用此方法后，只能启用<code>suites</code>参数中列出的<code>suites</code> 。</span> </p>
<p> <span>即使启用了在ServerSocket认证上下文中不可用的认证信息的套件也不会被使用。</span> </p>
<p> <span><code>SSLSocket</code>从<code>accept()</code>返回，继承了这个设置。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>suites</code> - 要启用的所有密码套件的名称 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 当不支持由参数命名的一个或多个密码时，或当参数为空时。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/net/ssl/SSLServerSocket.html#getSupportedCipherSuites--"><code>getSupportedCipherSuites()</code></a> ， 
            <a href="../../../javax/net/ssl/SSLServerSocket.html#getEnabledCipherSuites--"><code>getEnabledCipherSuites()</code></a>
</dd>
</dl> </li>
</ul> <a name="getSupportedCipherSuites--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getSupportedCipherSuites</h4> <pre>public abstract <a href="../../../java/lang/String.html" title="class in java.lang">String</a>[] getSupportedCipherSuites()</pre>
<div class="block">
<span>返回可以在SSL连接上使用的密码套件的名称。</span>
<p> <span>通常，默认情况下实际上只能启用这些子集，因为此列表可能包括不符合这些默认值的服务质量要求的密码套件。</span> <span>这样的密码套件在专门的应用中是有用的。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一组加密套件名称 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/net/ssl/SSLServerSocket.html#getEnabledCipherSuites--"><code>getEnabledCipherSuites()</code></a> ， 
            <a href="../../../javax/net/ssl/SSLServerSocket.html#setEnabledCipherSuites-java.lang.String:A-"><code>setEnabledCipherSuites(String [])</code></a>
</dd>
</dl> </li>
</ul> <a name="getSupportedProtocols--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getSupportedProtocols</h4> <pre>public abstract <a href="../../../java/lang/String.html" title="class in java.lang">String</a>[] getSupportedProtocols()</pre>
<div class="block">
            返回可以启用的协议的名称。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             支持一组协议名称 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/net/ssl/SSLServerSocket.html#getEnabledProtocols--"><code>getEnabledProtocols()</code></a> ， 
            <a href="../../../javax/net/ssl/SSLServerSocket.html#setEnabledProtocols-java.lang.String:A-"><code>setEnabledProtocols(String [])</code></a>
</dd>
</dl> </li>
</ul> <a name="getEnabledProtocols--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getEnabledProtocols</h4> <pre>public abstract <a href="../../../java/lang/String.html" title="class in java.lang">String</a>[] getEnabledProtocols()</pre>
<div class="block">
            返回当前启用以便新接受的连接使用的协议的名称。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一组协议名称 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/net/ssl/SSLServerSocket.html#getSupportedProtocols--"><code>getSupportedProtocols()</code></a> ， 
            <a href="../../../javax/net/ssl/SSLServerSocket.html#setEnabledProtocols-java.lang.String:A-"><code>setEnabledProtocols(String [])</code></a>
</dd>
</dl> </li>
</ul> <a name="setEnabledProtocols-java.lang.String:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setEnabledProtocols</h4> <pre>public abstract void setEnabledProtocols(<a href="../../../java/lang/String.html" title="class in java.lang">String</a>[] protocols)</pre>
<div class="block">
<span>控制哪些特定协议被接受的连接启用。</span>
<p> <span>协议必须被getSupportedProtocols（）列为受支持。</span> <span>成功调用此方法后，只能启用protocols参数中列出的<code>protocols</code> 。</span> </p>
<p> <span><code>SSLSocket</code>从<code>accept()</code>返回，继承了这个设置。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>protocols</code> - 要启用的所有协议的名称。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 当一个或多个由参数命名的协议不受支持或协议参数为空时。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/net/ssl/SSLServerSocket.html#getEnabledProtocols--"><code>getEnabledProtocols()</code></a> ， 
            <a href="../../../javax/net/ssl/SSLServerSocket.html#getSupportedProtocols--"><code>getSupportedProtocols()</code></a>
</dd>
</dl> </li>
</ul> <a name="setNeedClientAuth-boolean-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setNeedClientAuth</h4> <pre>public abstract void setNeedClientAuth(boolean need)</pre>
<div class="block">
<span>控制<code>accept</code> ed服务器模式<code>SSLSockets</code>是否最初配置为<i>需要</i>客户端认证。</span>
<p> <span>套接字的客户端验证设置是以下之一：</span> </p>
<ul>
<li> <span>需要客户端身份验证</span> </li>
<li> <span>客户端认证请求</span> </li>
<li> <span>不需要客户端认证</span> </li>
</ul>
<p> <span>与<a href="../../../javax/net/ssl/SSLServerSocket.html#setWantClientAuth-boolean-"><code>setWantClientAuth(boolean)</code></a>不同，如果设置了接受的套接字选项，并且客户端选择不提供有关其自身的认证信息， <i>则协商将停止，并且连接将被删除</i> 。</span> </p>
<p> <span>调用此方法将覆盖此方法或<a href="../../../javax/net/ssl/SSLServerSocket.html#setWantClientAuth-boolean-"><code>setWantClientAuth(boolean)</code></a>所做的任何以前的设置。</span> </p>
<p> <span>可以通过调用<a href="../../../javax/net/ssl/SSLSocket.html#setNeedClientAuth-boolean-"><code>SSLSocket.setNeedClientAuth(boolean)</code></a>或<a href="../../../javax/net/ssl/SSLSocket.html#setWantClientAuth-boolean-"><code>SSLSocket.setWantClientAuth(boolean)</code></a>来覆盖初始继承的设置。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>need</code> - 如果需要客户端验证，则设置为true;如果不需要客户端验证，则设置为false。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/net/ssl/SSLServerSocket.html#getNeedClientAuth--"><code>getNeedClientAuth()</code></a> ， 
            <a href="../../../javax/net/ssl/SSLServerSocket.html#setWantClientAuth-boolean-"><code>setWantClientAuth(boolean)</code></a> ， 
            <a href="../../../javax/net/ssl/SSLServerSocket.html#getWantClientAuth--"><code>getWantClientAuth()</code></a> ， 
            <a href="../../../javax/net/ssl/SSLServerSocket.html#setUseClientMode-boolean-"><code>setUseClientMode(boolean)</code></a>
</dd>
</dl> </li>
</ul> <a name="getNeedClientAuth--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getNeedClientAuth</h4> <pre>public abstract boolean getNeedClientAuth()</pre>
<div class="block">
<span>如果新的<code>accept</code>服务器模式<code>SSLSocket</code> s <i>需要</i>客户端认证，则返回true。</span>
<p> <span>可以通过调用<a href="../../../javax/net/ssl/SSLSocket.html#setNeedClientAuth-boolean-"><code>SSLSocket.setNeedClientAuth(boolean)</code></a>或<a href="../../../javax/net/ssl/SSLSocket.html#setWantClientAuth-boolean-"><code>SSLSocket.setWantClientAuth(boolean)</code></a>来覆盖初始继承的设置。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             如果需要客户端验证，则为true;如果不需要客户端验证，则为false。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/net/ssl/SSLServerSocket.html#setNeedClientAuth-boolean-"><code>setNeedClientAuth(boolean)</code></a> ， 
            <a href="../../../javax/net/ssl/SSLServerSocket.html#setWantClientAuth-boolean-"><code>setWantClientAuth(boolean)</code></a> ， 
            <a href="../../../javax/net/ssl/SSLServerSocket.html#getWantClientAuth--"><code>getWantClientAuth()</code></a> ， 
            <a href="../../../javax/net/ssl/SSLServerSocket.html#setUseClientMode-boolean-"><code>setUseClientMode(boolean)</code></a>
</dd>
</dl> </li>
</ul> <a name="setWantClientAuth-boolean-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setWantClientAuth</h4> <pre>public abstract void setWantClientAuth(boolean want)</pre>
<div class="block">
<span>控制是否<code>accept</code> ED服务器模式<code>SSLSockets</code>最初将配置为<i>请求</i>客户端验证。</span>
<p> <span>套接字的客户端验证设置是以下之一：</span> </p>
<ul>
<li> <span>需要客户端身份验证</span> </li>
<li> <span>客户端认证请求</span> </li>
<li> <span>不需要客户端认证</span> </li>
</ul>
<p> <span>与<a href="../../../javax/net/ssl/SSLServerSocket.html#setNeedClientAuth-boolean-"><code>setNeedClientAuth(boolean)</code></a>不同，如果设置了接受的套接字选项，并且客户端选择不提供有关其自身的认证信息， <i>则协商将继续进行</i> 。</span> </p>
<p> <span>调用此方法将覆盖此方法或<a href="../../../javax/net/ssl/SSLServerSocket.html#setNeedClientAuth-boolean-"><code>setNeedClientAuth(boolean)</code></a>所做的任何以前的设置。</span> </p>
<p> <span>最初的继承设置可能会被调用<a href="../../../javax/net/ssl/SSLSocket.html#setNeedClientAuth-boolean-"><code>SSLSocket.setNeedClientAuth(boolean)</code></a>或<a href="../../../javax/net/ssl/SSLSocket.html#setWantClientAuth-boolean-"><code>SSLSocket.setWantClientAuth(boolean)</code>覆盖</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>want</code> - 如果客户端认证被请求，设置为true，如果不需要客户端认证，则设置为false。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/net/ssl/SSLServerSocket.html#getWantClientAuth--"><code>getWantClientAuth()</code></a> ， 
            <a href="../../../javax/net/ssl/SSLServerSocket.html#setNeedClientAuth-boolean-"><code>setNeedClientAuth(boolean)</code></a> ， 
            <a href="../../../javax/net/ssl/SSLServerSocket.html#getNeedClientAuth--"><code>getNeedClientAuth()</code></a> ， 
            <a href="../../../javax/net/ssl/SSLServerSocket.html#setUseClientMode-boolean-"><code>setUseClientMode(boolean)</code></a>
</dd>
</dl> </li>
</ul> <a name="getWantClientAuth--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getWantClientAuth</h4> <pre>public abstract boolean getWantClientAuth()</pre>
<div class="block">
<span>如果客户端身份验证将在新接受的服务器模式的连接<i>请求</i> ，则返回true。</span>
<p> <span>可以通过调用<a href="../../../javax/net/ssl/SSLSocket.html#setNeedClientAuth-boolean-"><code>SSLSocket.setNeedClientAuth(boolean)</code></a>或<a href="../../../javax/net/ssl/SSLSocket.html#setWantClientAuth-boolean-"><code>SSLSocket.setWantClientAuth(boolean)</code></a>来覆盖初始继承的设置。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             如果客户端认证被请求，则为true;如果不需要客户端认证，则为false。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/net/ssl/SSLServerSocket.html#setWantClientAuth-boolean-"><code>setWantClientAuth(boolean)</code></a> ， 
            <a href="../../../javax/net/ssl/SSLServerSocket.html#setNeedClientAuth-boolean-"><code>setNeedClientAuth(boolean)</code></a> ， 
            <a href="../../../javax/net/ssl/SSLServerSocket.html#getNeedClientAuth--"><code>getNeedClientAuth()</code></a> ， 
            <a href="../../../javax/net/ssl/SSLServerSocket.html#setUseClientMode-boolean-"><code>setUseClientMode(boolean)</code></a>
</dd>
</dl> </li>
</ul> <a name="setUseClientMode-boolean-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setUseClientMode</h4> <pre>public abstract void setUseClientMode(boolean mode)</pre>
<div class="block">
<span>控制接受的连接是否处于（默认）SSL服务器模式或SSL客户端模式。</span>
<p> <span>服务器通常认证自己，客户端不需要这样做。</span> </p>
<p> <span>在极少数情况下，TCP服务器需要在新接受的连接上以SSL客户端模式运行。</span> <span>例如，FTP客户端获取服务器套接字，并从服务器收听反向连接。</span> <span>FTP客户端将以“客户端”模式使用SSLServerSocket接受反向连接，而FTP服务器使用禁用“客户端”模式的SSLSocket启动连接。</span> <span>在结果握手期间，现有的SSL会话可能被重用。</span> </p>
<p> <span><code>SSLSocket</code>从<code>accept()</code>返回继承此设置。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>mode</code> - 如果新接受的连接应使用SSL客户端模式，则为true。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/net/ssl/SSLServerSocket.html#getUseClientMode--"><code>getUseClientMode()</code></a>
</dd>
</dl> </li>
</ul> <a name="getUseClientMode--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getUseClientMode</h4> <pre>public abstract boolean getUseClientMode()</pre>
<div class="block">
            如果接受的连接将处于SSL客户端模式，则返回true。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             如果连接应该使用SSL客户端模式，则为true。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/net/ssl/SSLServerSocket.html#setUseClientMode-boolean-"><code>setUseClientMode(boolean)</code></a>
</dd>
</dl> </li>
</ul> <a name="setEnableSessionCreation-boolean-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setEnableSessionCreation</h4> <pre>public abstract void setEnableSessionCreation(boolean flag)</pre>
<div class="block">
<span>控制是否可以由从此服务器套接字创建的套接字建立新的SSL会话。</span>
<p> <span><code>SSLSocket</code>从<code>accept()</code>返回继承此设置。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>flag</code> - true表示可以创建会话;</span>
<span>这是默认值。</span>
<span>false表示必须恢复现有会话。</span>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/net/ssl/SSLServerSocket.html#getEnableSessionCreation--"><code>getEnableSessionCreation()</code></a>
</dd>
</dl> </li>
</ul> <a name="getEnableSessionCreation--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getEnableSessionCreation</h4> <pre>public abstract boolean getEnableSessionCreation()</pre>
<div class="block">
            如果可以通过从该服务器套接字创建的套接字建立新的SSL会话，则返回true。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>true表示可以创建会话;</span>
<span>这是默认值。</span>
<span>false表示必须恢复现有会话</span>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/net/ssl/SSLServerSocket.html#setEnableSessionCreation-boolean-"><code>setEnableSessionCreation(boolean)</code></a>
</dd>
</dl> </li>
</ul> <a name="getSSLParameters--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getSSLParameters</h4> <pre>public <a href="../../../javax/net/ssl/SSLParameters.html" title="class in javax.net.ssl">SSLParameters</a> getSSLParameters()</pre>
<div class="block">
<span>返回对新接受的连接有效的SSLParameters。</span>
<span>返回的SSLParameters的密码和协议始终不为空。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             对新接受的连接有效的SSLParameters 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.7 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/net/ssl/SSLServerSocket.html#setSSLParameters-javax.net.ssl.SSLParameters-"><code>setSSLParameters(SSLParameters)</code></a>
</dd>
</dl> </li>
</ul> <a name="setSSLParameters-javax.net.ssl.SSLParameters-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>setSSLParameters</h4> <pre>public void setSSLParameters(<a href="../../../javax/net/ssl/SSLParameters.html" title="class in javax.net.ssl">SSLParameters</a> params)</pre>
<div class="block">
<span>将SSLParameters应用于新接受的连接。</span>
<p> <span>意即：</span> </p>
<ul>
<li> <span>如果<code>params.getCipherSuites()</code>为非空，则使用该值调用<code>setEnabledCipherSuites()</code> 。</span> </li>
<li> <span>如果<code>params.getProtocols()</code>不为空，则使用该值调用<code>setEnabledProtocols()</code> 。</span> </li>
<li> <span>如果<code>params.getNeedClientAuth()</code>或<code>params.getWantClientAuth()</code>返回<code>true</code> ， <code>setWantClientAuth(true)</code>分别调用<code>setNeedClientAuth(true)</code>和setWantClientAuth(true);</span> <span>否则<code>setWantClientAuth(false)</code> 。</span> </li>
<li> <span>如果<code>params.getServerNames()</code>不为空，套接字将使用该值配置其服务器名称。</span> </li>
<li> <span>如果<code>params.getSNIMatchers()</code>为非空值，则套接字将使用该值配置其SNI匹配器。</span> </li>
</ul>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>params</code> - 参数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果setEnabledCipherSuites（）或setEnabledProtocols（）调用失败 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.7 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/net/ssl/SSLServerSocket.html#getSSLParameters--"><code>getSSLParameters()</code></a>
</dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>