<div class="header">
<div class="subTitle">
     javax.print 
   </div>
<h2 class="title" title="Class DocFlavor">Class DocFlavor</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>javax.print.DocFlavor</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
         All Implemented Interfaces: 
       </dt>
<dd>
<span><a href="../../java/io/Serializable.html" title="java.io中的接口">Serializable</a> ， <a href="../../java/lang/Cloneable.html" title="java.lang中的接口">Cloneable</a></span>
</dd>
</dl>
<dl>
<dt>
        已知直接子类：
       </dt>
<dd>
<span><a href="../../javax/print/DocFlavor.BYTE_ARRAY.html" title="javax.print中的类">DocFlavor.BYTE_ARRAY</a> ， <a href="../../javax/print/DocFlavor.CHAR_ARRAY.html" title="javax.print中的类">DocFlavor.CHAR_ARRAY</a> ， <a href="../../javax/print/DocFlavor.INPUT_STREAM.html" title="javax.print中的类">DocFlavor.INPUT_STREAM</a> ， <a href="../../javax/print/DocFlavor.READER.html" title="javax.print中的类">DocFlavor.READER</a> ， <a href="../../javax/print/DocFlavor.SERVICE_FORMATTED.html" title="javax.print中的类">DocFlavor.SERVICE_FORMATTED</a> ， <a href="../../javax/print/DocFlavor.STRING.html" title="javax.print中的类">DocFlavor.STRING</a> ， <a href="../../javax/print/DocFlavor.URL.html" title="javax.print中的类">DocFlavor.URL</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public class <span class="typeNameLabel">DocFlavor</span>
extends <a href="../../java/lang/Object.html" title="class in java.lang">Object</a>
implements <a href="../../java/io/Serializable.html" title="interface in java.io">Serializable</a>, <a href="../../java/lang/Cloneable.html" title="interface in java.lang">Cloneable</a></pre>
<div class="block">
<span>类<code>DocFlavor</code>封装了一个对象，它指定在其中的打印数据被提供给一个格式<a href="../../javax/print/DocPrintJob.html" title="javax.print中的接口"><code>DocPrintJob</code></a> 。</span>
<span>“Doc”是一个简短易懂的术语，意思是“一张打印数据”。</span>
<span>打印数据格式或“doc flavor”包含两件事：</span>
<ul>
<li> <span><b>MIME类型。</b></span> <span>这是一种多用途互联网邮件扩展（MIME）媒体类型（定义在<a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>和<a href="http://www.ietf.org/rfc/rfc2046.txt">RFC 2046</a> ），它指定如何解释打印数据。</span> <span>如果未指定首选名称，文本数据的字符集应为IANA MIME首选名称，或其规范名称。</span> <span>另外，可以识别早期版本的Java平台支持的几个历史名称。</span> <span>有关Java平台上支持的字符<a href="../../java/lang/package-summary.html#charenc">编码</a>的更多信息，请参阅<a href="../../java/lang/package-summary.html#charenc">character encodings</a> 。</span> <p></p></li>
<li> <span><b>表示类名。</b></span> <span>这指定了由<a href="../../java/lang/Class.html#getName--"><code>Class.getName()</code></a>方法返回的实际打印数据来自的对象的类的完全限定名称。</span> <span>（因此，对于类名<code>byte[]</code>是<code>"[B"</code> ，为<code>char[]</code>它是<code>"[C"</code> 。）</span> </li>
</ul>
<p> <span>甲<code>DocPrintJob</code>通过接口的方式获得其打印数据<a href="../../javax/print/Doc.html" title="javax.print中的接口"><code>Doc</code></a> 。</span> <span>一个<code>Doc</code>对象让<code>DocPrintJob</code>确定客户端可以提供的doc风格。</span> <span>一个<code>Doc</code>对象也让<code>DocPrintJob</code>获取一个doc flavor的表示类的实例，然后<code>DocPrintJob</code>从中获取实际的打印数据。</span> </p>
<p></p>
<hr/>
<h3> <span>客户格式打印数据</span> </h3>
<span>有两大类的打印数据，客户端格式的打印数据和服务格式的打印数据。</span>
<p> <span>对于<b>客户端格式的打印数据</b> ，客户端确定或知道打印数据格式。</span> <span>例如，客户端可能具有JPEG编码图像，HTML代码的URL或包含某些编码中的纯文本的磁盘文件，可能是从外部源获得的，并且需要一种方式来将打印服务描述为数据格式。</span> </p>
<p> <span>doc flavor的表示类是JPS <code>DocPrintJob</code>从客户端获取一系列字符或字节的管道。</span> <span>doc flavor的MIME类型是告诉如何解释字符或字节序列的标准媒体类型之一。</span> <span>有关标准媒体类型的列表，请参阅互联网号码分配机构（IANA's） <a href="http://www.iana.org/assignments/media-types/">Media Types Directory</a> 。</span> <span>界面<a href="../../javax/print/Doc.html" title="javax.print中的接口"><code>Doc</code></a>提供了两个实用操作， <a href="../../javax/print/Doc.html#getReaderForText--"><code>getReaderForText</code></a>和<a href="../../javax/print/Doc.html#getStreamForBytes--"><code>getStreamForBytes()</code></a> ，以帮助一个<code>Doc</code>对象的客户端提取客户端格式的打印数据。</span> </p>
<p> <span>对于客户端格式的打印数据，打印数据表示类通常是以下之一（尽管允许其他表示类）：</span> </p>
<ul>
<li> <span>字符数组（ <code>char[]</code> ） - 打印数据由数组中的Unicode字符组成。</span> <p></p></li>
<li> <span><code>String</code> - 打印数据由字符串中的Unicode字符组成。</span> <p></p></li>
<li> <span>字符流（ <a href="../../java/io/Reader.html" title="java.io中的类"><code>java.io.Reader</code></a> ） - 打印数据由从流到流末尾读取的Unicode字符组成。</span> <p></p></li>
<li> <span>字节数组（ <code>byte[]</code> ） - 打印数据由数组中的字节组成。</span> <span>字节编码在由doc flavor的MIME类型指定的字符集中。</span> <span>如果MIME类型未指定字符集，则默认字符集为US-ASCII。</span> <p></p></li>
<li> <span>字节流（ <a href="../../java/io/InputStream.html" title="java.io中的类"><code>java.io.InputStream</code></a> ） - 打印数据由从流到流结尾处读取的字节组成。</span> <span>字节编码在由doc flavor的MIME类型指定的字符集中。</span> <span>如果MIME类型未指定字符集，则默认字符集为US-ASCII。</span> </li>
<li> <span>统一资源定位器（ <a href="../../java/net/URL.html" title="java.net中的类"><code>URL</code></a> ） - 打印数据由从URL位置读取的字节组成。</span> <span>字节编码在由doc flavor的MIME类型指定的字符集中。</span> <span>如果MIME类型未指定字符集，则默认字符集为US-ASCII。</span> <p> <span>当表示类是URL时，打印服务本身直接从其URL地址访问和下载文档，而不涉及客户端。</span> <span>该服务可以是在不同环境中执行的某种形式的网络打印服务。</span> <span>这意味着您不应该使用URL打印数据风格来打印客户端可以看到但打印机看不到的受限URL的文档。</span> <span>这也意味着您不应该使用URL打印数据风格来打印存储在本地文件中的文档，该文档在客户端可访问的URL处不可用。</span> <span>例如，HTTP服务器或FTP服务器不提供的文件。</span> <span>要打印此类文档，请让客户端在URL或文件上打开输入流，并使用输入流数据。</span> </p></li>
</ul>
<p></p>
<hr/>
<h3> <span>默认和平台编码</span> </h3>
<p> <span>对于doc flavor的MIME类型不包含<code>charset</code>参数的字节打印数据，Java Print Service实例假定默认情况下为US-ASCII字符集。</span> <span>这符合<a href="http://www.ietf.org/rfc/rfc2046.txt">RFC 2046</a> ，它表示默认字符集是US-ASCII。</span> <span>请注意，US-ASCII是UTF-8的一个子集，因此如果未来的RFC以兼容的方式将UTF-8默认为默认格式，将来可能会扩大。</span> </p>
<p> <span>另请注意，这不同于将Java字节流解释为文本数据时Java运行时的行为。</span> <span>这假定用户区域设置的默认编码。</span> <span>因此，当将本地编码中的文件假脱机到Java打印服务时，正确指定编码很重要。</span> <span>在英文语言环境中工作的开发人员应特别注意这一点，因为它们的平台编码对应于默认的mime字符集。</span> <span>通过这个巧合，特定的情况可以在没有指定平台数据的编码的情况下工作。</span> </p>
<p> <span>Java虚拟机的每个实例都具有在虚拟机启动期间确定的默认字符编码，并且通常取决于底层操作系统使用的语言环境和字符集。</span> <span>在分布式环境中，不能保证两个VM共享相同的默认编码。</span> <span>因此，希望将平台编码的文本数据从主机平台流式传输到Java Print Service实例的客户端必须显式声明该字符集，而不依赖于默认值。</span> </p>
<p> <span>首选形式是编码的官方IANA主要名称。</span> <span>流文本数据的应用程序应该始终指定mime类型中的字符集，这样就需要获得主机平台对存储在该平台编码中的数据（例如文件）的编码。</span> <span>可以从<a href="../../javax/print/DocFlavor.html#hostEncoding"><code>DocFlavor.hostEncoding</code></a>获得<a href="../../javax/print/DocFlavor.html#hostEncoding">与之对应的</a>适用于MIME类型的<a href="../../javax/print/DocFlavor.html#hostEncoding">CharSet，</a>这可能并不总是主要的IANA名称，但是该VM被保证被理解。</span> <span>对于常见的风味，可以使用预定义的* HOST DocFlavors。</span> </p>
<p></p>
<p> <span>有关Java平台支持的字符<a href="../../java/lang/package-summary.html#charenc">编码</a>的更多信息，请参阅<a href="../../java/lang/package-summary.html#charenc">character encodings</a> 。</span> </p>
<p></p>
<hr/>
<h3> <span>推荐DocFlavors</span> </h3>
<p> <span>Java Print Service API没有定义任何强制支持的DocFlavors。</span> <span>但是，以下是Java Print Service实例可能支持客户端格式打印数据的MIME类型的一些示例。</span> <span>DocFlavor类内的嵌套类声明了这些示例文档的预定义静态常量DocFlavor对象;</span> <span>DocFlavor类的构造函数可用于创建任意的doc风格。</span> </p>
<ul>
<li> <span>预格式文本</span> <p></p><span>  MIME-Type Description   <code>"text/plain"</code> Plain text in the default character set (US-ASCII)   <code>"text/plain; charset=<i>xxx</i>"</code> Plain text in character set <i>xxx</i> <code>"text/html"</code> HyperText Markup Language in the default character set (US-ASCII)   <code>"text/html; charset=<i>xxx</i>"</code> HyperText Markup Language in character set <i>xxx</i> </span>
<table border="1" cellpadding="0" cellspacing="0" summary="MIME-Types and their descriptions">
</table><p> <span>一般来说，预先格式化的文本打印数据可以在面向字符的表示类（字符数组，字符串，读取器）中或在面向字节的表示类（字节数组，InputStream，URL）中提供。</span> </p><p></p></li>
<li> <span>预格式化页面描述语言（PDL）文档</span> <p></p><span>  MIME-Type Description   <code>"application/pdf"</code> Portable Document Format document   <code>"application/postscript"</code> PostScript document   <code>"application/vnd.hp-PCL"</code> Printer Control Language document  </span>
<table border="1" cellpadding="0" cellspacing="0" summary="MIME-Types and their descriptions">
</table><p> <span>一般来说，预先格式化的PDL打印数据是以面向字节的表示类（字节数组，InputStream，URL）提供的。</span> </p><p></p></li>
<li> <span>预格式化图像</span> <p></p><span>  MIME-Type Description   <code>"image/gif"</code> Graphics Interchange Format image   <code>"image/jpeg"</code> Joint Photographic Experts Group image   <code>"image/png"</code> Portable Network Graphics image  </span>
<table border="1" cellpadding="0" cellspacing="0" summary="MIME-Types and their descriptions">
</table><p> <span>一般来说，预格式化的图像打印数据提供在面向字节的表示类（字节数组，InputStream，URL）中。</span> </p><p></p></li>
<li> <span>预格式自动印刷数据</span> <p></p><span>  MIME-Type Description   <code>"application/octet-stream"</code> The print data format is unspecified (just an octet stream)  </span>
<table border="1" cellpadding="0" cellspacing="0" summary="MIME-Types and their descriptions">
</table><p> <span>打印机决定如何解释打印数据;</span> <span>这种“自动感应”的工作方式取决于实现。</span> <span>一般来说，预格式化的自动印刷数据是以字节为导向的表示类（字节数组，InputStream，URL）提供的。</span> </p></li>
</ul>
<p></p>
<hr/>
<h3> <span>服务格式打印数据</span> </h3>
<p> <span>对于<b>服务格式的打印数据</b> ，Java Print Service实例确定打印数据格式。</span> <span>doc flavor的表示类表示一个接口，它的方法是<code>DocPrintJob</code>调用来确定要打印的内容，例如可渲染图像接口或Java可打印接口。</span> <span>doc flavor的MIME类型是特殊值<code>"application/x-java-jvm-local-objectref"</code>指示客户端将提供对实现名为表示类的接口的Java对象的引用。</span> <span>这个MIME类型只是一个占位符;</span> <span>重要的是打印数据表示类。</span> </p>
<p> <span>对于服务格式化的打印数据，打印数据表示类通常是以下之一（尽管允许其他表示类）。</span> <span>DocFlavor类内的嵌套类声明了这些示例文档的预定义静态常量DocFlavor对象;</span> <span>DocFlavor类的构造函数可用于创建任意的doc风格。</span> </p>
<ul>
<li> <span>渲染图像对象-客户端提供一个实现接口的对象<a href="../../java/awt/image/renderable/RenderableImage.html" title="java.awt.image.renderable中的接口"><code>RenderableImage</code></a> 。</span> <span>打印机调用该界面中的方法来获取要打印的图像。</span> <p></p></li>
<li> <span>可打印的对象-客户端提供一个实现了接口的对象<a href="../../java/awt/print/Printable.html" title="java.awt.print中的接口"><code>Printable</code></a> 。</span> <span>打印机调用该界面中的方法逐个获取要打印的页面。</span> <span>对于每个页面，打印机提供图形上下文，无论客户端在图形上下文中绘制什么都可以打印出来。</span> <p></p></li>
<li> <span>分页对象-客户端提供一个实现了接口的对象<a href="../../java/awt/print/Pageable.html" title="java.awt.print中的接口"><code>Pageable</code></a> 。</span> <span>打印机调用该界面中的方法逐个获取要打印的页面。</span> <span>对于每个页面，打印机提供图形上下文，无论客户端在图形上下文中绘制什么都可以打印出来。</span> </li>
</ul>
<p></p>
<hr/>
<p></p>
<hr/>
<h3> <span>预定义文件风味</span> </h3>
<span>Java Print Service实例<b><i>不需要</i></b>支持以下打印数据格式和打印数据表示类。</span>
<span>实际上，使用这个类的开发人员<b>不</b>应该假定特定的打印服务支持与这些预定义的doc口味对应的文档类型。</span>
<span>始终查询打印服务以确定它支持哪些文档。</span>
<span>但是，鼓励具有支持这些文档风格的打印服务的开发人员参考在此创建的预定义单例实例。</span>
<ul>
<li> <span>通过字节流提供的纯文本打印数据。</span> <span>具体来说，建议支持以下doc风格：</span> <br/> <span>Â· <code>("text/plain", "java.io.InputStream")</code></span> <br/> <span>Â· <code>("text/plain; charset=us-ascii", "java.io.InputStream")</code></span> <br/> <span>Â· <code>("text/plain; charset=utf-8", "java.io.InputStream")</code></span> <p></p></li>
<li> <span>可渲染的图像对象。</span> <span>具体来说，建议支持以下doc风格：</span> <br/> <span>Â· <code>("application/x-java-jvm-local-objectref", "java.awt.image.renderable.RenderableImage")</code></span> </li>
</ul>
<p> <span>允许Java Print Service实例支持任何其他文档风格（或无）除了上述强制性文件外，在实现的选择。</span> </p>
<p> <span>支持上述文档口味是可取的，因此打印客户端可以依赖于能够在任何JPS打印机上打印，而不管打印机支持哪种文档。</span> <span>如果打印机不支持客户端的首选文档风格，客户端至少可以打印纯文本，或者客户端可以将其数据转换为可渲染图像并打印图像。</span> </p>
<p> <span>此外，每个Java Print Service实例都必须满足处理纯文本打印数据的这些要求：</span> </p>
<ul>
<li> <span>字符对回车换行（CR-LF）表示“转到下一行的列1”。</span> </li>
<li> <span>回车（CR）字符本身表示“转到下一行的第1列”。</span> </li>
<li> <span>换行（LF）字符本身表示“转到下一行的第1列”。</span> </li>
<li></li>
</ul>
<p> <span>客户端必须自己执行所有不符合上述要求的纯文本打印数据格式。</span> </p>
<p></p>
<h3> <span>设计理由</span> </h3>
<p> <span>javax.print.data包中的DocFlavor类与类别<a href="../../java/awt/datatransfer/DataFlavor.html" title="java.awt.datatransfer中的类"><code>DataFlavor</code></a>类似。</span> <span>类别<code>DataFlavor</code>没有用于Java打印服务（JPS）API，原因有三个原因，这些原因都是根植于允许其他打印服务API共享的JPS API，可能需要在不包含所有Java的Java配置文件中运行平台，标准版。</span> </p>
<ol type="1">
<li> <span>JPS API旨在用于不支持AWT的Java配置文件中。</span> <p></p></li>
<li> <span>java.awt.datatransfer.DataFlavor类的<code>java.awt.datatransfer.DataFlavor</code>不能保证等同的数据风格将具有相同的序列化表示。</span> <span>DocFlavor可以在需要的服务中使用。</span> <p></p></li>
<li> <span>java.awt.datatransfer.DataFlavor课程的<code>java.awt.datatransfer.DataFlavor</code>包括人类可呈现的名称作为序列化表示的一部分。</span> <span>这不适合作为服务匹配约束的一部分。</span> </li>
</ol>
<p> <span>DocFlavor类的序列化表示使用以下MIME类型字符串的规范形式。</span> <span>因此，具有MIME类型不同但具有相同（具有相同规范形式）的MIME类型的两个doc风格可能被认为是相等的。</span> </p>
<ul>
<li> <span>媒体类型，媒体子类型和参数被保留，但所有注释和空白字符都将被丢弃。</span> </li>
<li> <span>介质类型，介质子类型和参数名称将转换为小写。</span> </li>
<li> <span>参数值保留其原始大小写，但文本媒体类型的字符集参数值将转换为小写。</span> </li>
<li> <span>排除周围参数值的字符串。</span> </li>
<li> <span>引用参数值内的反斜杠字符被删除。</span> </li>
<li> <span>参数按参数名称的升序排列。</span> </li>
</ul>
<p> <span>DocFlavor类的序列化表示还包含表示类（一个String对象）的全限定类<i>名</i> ，而不是表示类本身（一个Class对象）。</span> <span>这允许客户端检查Java Print Service实例支持的文档风格，而无需加载表示类，这对于有限的资源客户端可能是有问题的。</span> </p>
<p></p>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../serialized-form.html#javax.print.DocFlavor">Serialized Form</a>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!-- --> </a> <h3>Nested Class Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption>
<span>Nested Classes</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Class and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/print/DocFlavor.BYTE_ARRAY.html" title="class in javax.print">DocFlavor.BYTE_ARRAY</a></span></code>
<div class="block">
              DocFlavor.BYTE_ARRAY类提供了预定义的静态常量DocFlavor对象，例如使用字节数组（ 
             <code>byte[]</code> ）作为打印数据表示类的doc风格。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/print/DocFlavor.CHAR_ARRAY.html" title="class in javax.print">DocFlavor.CHAR_ARRAY</a></span></code>
<div class="block">
              DocFlavor.CHAR_ARRAY类提供了预定义的静态常量DocFlavor对象，例如使用字符数组（ 
             <code>char[]</code> ）作为打印数据表示类的doc风格。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/print/DocFlavor.INPUT_STREAM.html" title="class in javax.print">DocFlavor.INPUT_STREAM</a></span></code>
<div class="block">
<span>DocFlavor.INPUT_STREAM类提供了预定义的静态常量DocFlavor对象，例如使用字节流（ <a href="../../java/io/InputStream.html" title="java.io中的类"><code>java.io.InputStream</code></a> ）作为打印数据表示类的doc风格。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/print/DocFlavor.READER.html" title="class in javax.print">DocFlavor.READER</a></span></code>
<div class="block">
<span>DocFlavor.READER类提供了预定义的静态常量DocFlavor对象，例如使用字符流（ <a href="../../java/io/Reader.html" title="java.io中的类"><code>java.io.Reader</code></a> ）作为打印数据表示类的doc风格。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/print/DocFlavor.SERVICE_FORMATTED.html" title="class in javax.print">DocFlavor.SERVICE_FORMATTED</a></span></code>
<div class="block">
              DocFlavor.SERVICE_FORMATTED类提供了预定义的静态常量DocFlavor对象，例如用于服务格式化打印数据的doc风格。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/print/DocFlavor.STRING.html" title="class in javax.print">DocFlavor.STRING</a></span></code>
<div class="block">
<span>DocFlavor.STRING类提供了预定义的静态常量DocFlavor对象，例如使用字符串（ <a href="../../java/lang/String.html" title="java.lang中的类"><code>java.lang.String</code></a> ）作为打印数据表示类的doc风格。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/print/DocFlavor.URL.html" title="class in javax.print">DocFlavor.URL</a></span></code>
<div class="block">
              DocFlavor.URL类提供了预定义的静态常量DocFlavor对象。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!-- --> </a> <h3>Field Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Field Summary table, listing fields, and an explanation">
<caption>
<span>Fields</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/print/DocFlavor.html#hostEncoding">hostEncoding</a></span></code>
<div class="block">
              代表主机操作系统编码的字符串。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!-- --> </a> <h3>构造方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Constructor Summary table, listing constructors, and an explanation">
<caption>
<span>构造方法</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../javax/print/DocFlavor.html#DocFlavor-java.lang.String-java.lang.String-">DocFlavor</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> mimeType, <a href="../../java/lang/String.html" title="class in java.lang">String</a> className)</code>
<div class="block">
              从给定的MIME类型和表示类名称构造一个新的doc flavor对象。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/print/DocFlavor.html#equals-java.lang.Object-">equals</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> obj)</code>
<div class="block">
              确定此文档flavor对象是否等于给定对象。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code><a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/print/DocFlavor.html#getMediaSubtype--">getMediaSubtype</a></span>()</code>
<div class="block">
              返回此文档flavor对象的媒体子类型（从MIME类型）。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code><a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/print/DocFlavor.html#getMediaType--">getMediaType</a></span>()</code>
<div class="block">
              返回此文档flavor对象的媒体类型（从MIME类型）。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code><a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/print/DocFlavor.html#getMimeType--">getMimeType</a></span>()</code>
<div class="block">
              根据规范表单返回此doc风格对象的MIME类型字符串。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code><a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/print/DocFlavor.html#getParameter-java.lang.String-">getParameter</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> paramName)</code>
<div class="block">
              返回 
             <code>String</code>表示MIME参数。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code><a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/print/DocFlavor.html#getRepresentationClassName--">getRepresentationClassName</a></span>()</code>
<div class="block">
              返回此文档flavor对象的表示类的名称。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/print/DocFlavor.html#hashCode--">hashCode</a></span>()</code>
<div class="block">
              返回此文档风格对象的哈希码。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code><a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/print/DocFlavor.html#toString--">toString</a></span>()</code>
<div class="block">
              将此 
             <code>DocFlavor</code>转换为字符串。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../java/lang/Object.html#clone--">clone</a>, <a href="../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../java/lang/Object.html#notify--">notify</a>, <a href="../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../java/lang/Object.html#wait--">wait</a>, <a href="../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!-- --> </a> <h3>字段详细信息</h3> <a name="hostEncoding">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>hostEncoding</h4> <pre>public static final <a href="../../java/lang/String.html" title="class in java.lang">String</a> hostEncoding</pre>
<div class="block">
<span>代表主机操作系统编码的字符串。</span>
<span>这将遵循<i>RFC 2278: IANA Charset Registration Procedures</i>中记录的<a href="http://www.ietf.org/rfc/rfc2278.txt">惯例，</a>除了返回历史名称以与以前版本的Java平台兼容。</span>
<span>从方法返回的值仅对返回它的VM有效，用于DocFlavor。</span>
<span>这是执行VM中所有“HOST”预定义DocFlavors的字符集。</span>
</div> </li>
</ul> </li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!-- --> </a> <h3>构造方法详细信息</h3> <a name="DocFlavor-java.lang.String-java.lang.String-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>DocFlavor</h4> <pre>public DocFlavor(<a href="../../java/lang/String.html" title="class in java.lang">String</a> mimeType,
                 <a href="../../java/lang/String.html" title="class in java.lang">String</a> className)</pre>
<div class="block">
<span>从给定的MIME类型和表示类名称构造一个新的doc flavor对象。</span>
<span>给定的MIME类型被转换为规范形式并在内部存储。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>mimeType</code> - MIME媒体类型字符串。 
           </dd>
<dd>
<code>className</code> - 完全限定代表类名称。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - （未选中的异常）如果 
            <code>mimeType</code>为空或 
            <code>className</code>为空，则抛出。 
           </dd>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - （未检查异常）如果 
            <code>mimeType</code>不符合MIME媒体类型字符串的语法，则抛出。 
           </dd>
</dl> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="getMimeType--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getMimeType</h4> <pre>public <a href="../../java/lang/String.html" title="class in java.lang">String</a> getMimeType()</pre>
<div class="block">
<span>根据规范表单返回此doc风格对象的MIME类型字符串。</span>
<span>每个参数值都用引号括起来。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             mime类型 
           </dd>
</dl> </li>
</ul> <a name="getMediaType--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getMediaType</h4> <pre>public <a href="../../java/lang/String.html" title="class in java.lang">String</a> getMediaType()</pre>
<div class="block">
            返回此文档flavor对象的媒体类型（从MIME类型）。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             媒体类型 
           </dd>
</dl> </li>
</ul> <a name="getMediaSubtype--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getMediaSubtype</h4> <pre>public <a href="../../java/lang/String.html" title="class in java.lang">String</a> getMediaSubtype()</pre>
<div class="block">
            返回此文档flavor对象的媒体子类型（从MIME类型）。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             媒体子类型 
           </dd>
</dl> </li>
</ul> <a name="getParameter-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getParameter</h4> <pre>public <a href="../../java/lang/String.html" title="class in java.lang">String</a> getParameter(<a href="../../java/lang/String.html" title="class in java.lang">String</a> paramName)</pre>
<div class="block">
<span>返回<code>String</code>表示MIME参数。</span>
<span>Mime类型可能包括通常可选的参数。</span>
<span>文本类型的字符集是一个很有用的例子。</span>
<span>这个方便方法将返回指定参数的值，如果在这个风格的mime类型中指定了这个参数。</span>
<p></p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>paramName</code> - 参数的名称。</span>
<span>在执行匹配之前，此名称将内部转换为规范小写格式。</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             表示mime参数的字符串，如果该参数不在mime类型字符串中，则返回null。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果paramName为null。 
           </dd>
</dl> </li>
</ul> <a name="getRepresentationClassName--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getRepresentationClassName</h4> <pre>public <a href="../../java/lang/String.html" title="class in java.lang">String</a> getRepresentationClassName()</pre>
<div class="block">
            返回此文档flavor对象的表示类的名称。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             代表类的名称。 
           </dd>
</dl> </li>
</ul> <a name="toString--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toString</h4> <pre>public <a href="../../java/lang/String.html" title="class in java.lang">String</a> toString()</pre>
<div class="block">
            将此 
           <code>DocFlavor</code>转换为字符串。 
          </div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../java/lang/Object.html#toString--">toString</a></code>在 
            <code><a href="../../java/lang/Object.html" title="class in java.lang">Object</a></code>类 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>基于规范形式的MIME类型字符串。</span>
<span>每个参数值都用引号括起来。</span>
<span>“class =”参数附加到MIME类型字符串以指示表示类名称。</span>
</dd>
</dl> </li>
</ul> <a name="hashCode--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>hashCode</h4> <pre>public int hashCode()</pre>
<div class="block">
            返回此文档风格对象的哈希码。 
          </div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../java/lang/Object.html#hashCode--">hashCode</a></code>在 
            <code><a href="../../java/lang/Object.html" title="class in java.lang">Object</a></code>类 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             该对象的哈希码值。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Object.html#equals-java.lang.Object-"><code>Object.equals(java.lang.Object)</code></a> ， 
            <a href="../../java/lang/System.html#identityHashCode-java.lang.Object-"><code>System.identityHashCode(java.lang.Object)</code></a>
</dd>
</dl> </li>
</ul> <a name="equals-java.lang.Object-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>equals</h4> <pre>public boolean equals(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> obj)</pre>
<div class="block">
<span>确定此文档flavor对象是否等于给定对象。</span>
<span>如果给定的对象不为null，则两者相等，是<code>DocFlavor</code>的实例，具有与此doc风格对象的MIME类型相同的MIME类型（即，MIME类型具有相同的媒体类型，媒体子类型和参数），并具有与此doc风格对象相同的表示类名称。</span>
<span>因此，如果两个doc风格对象的MIME类型在注释之外是相同的，那么它们被认为是相等的。</span>
<span>但是，MIME类型为“text / plain”和“text / plain; charset = US-ASCII”的两个doc风格对象即使表示相同的媒体类型也不相等，因为纯文本的默认字符集为US-ASCII）。</span>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../java/lang/Object.html#equals-java.lang.Object-">equals</a></code>在 
            <code><a href="../../java/lang/Object.html" title="class in java.lang">Object</a></code>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>obj</code> - 测试对象。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             如果此文档flavor对象等于 
            <code>obj</code> ，则为true，否则为false。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/lang/Object.html#hashCode--"><code>Object.hashCode()</code></a> ， <a href="../../java/util/HashMap.html" title="java.util中的类"><code>HashMap</code></a></span>
</dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>