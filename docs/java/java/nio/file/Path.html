<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.nio.file 
   </div>
<h2 class="title" title="Interface Path">Interface Path</h2>
</div><div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
         All Superinterfaces: 
       </dt>
<dd>
<span><a href="../../../java/lang/Comparable.html" title="java.lang中的接口">Comparable</a> &lt; <a href="../../../java/nio/file/Path.html" title="java.nio.file中的接口">Path</a> &gt;， <a href="../../../java/lang/Iterable.html" title="java.lang中的接口">Iterable</a> &lt; <a href="../../../java/nio/file/Path.html" title="java.nio.file中的接口">Path</a> &gt;， <a href="../../../java/nio/file/Watchable.html" title="java.nio.file中的接口">Watchable</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public interface <span class="typeNameLabel">Path</span>
extends <a href="../../../java/lang/Comparable.html" title="interface in java.lang">Comparable</a>&lt;<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a>&gt;, <a href="../../../java/lang/Iterable.html" title="interface in java.lang">Iterable</a>&lt;<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a>&gt;, <a href="../../../java/nio/file/Watchable.html" title="interface in java.nio.file">Watchable</a></pre>
<div class="block">
<span>可用于在文件系统中定位文件的对象。</span>
<span>它通常表示系统相关的文件路径。</span>
<p> <span>A <code>Path</code>表示一个分层的路径，由一个特殊分隔符或分隔符分隔的目录和文件名元素序列组成。</span> <span>也可以存在标识文件系统层次结构的<em>根组件</em> 。</span> <span>距离目录层次结构根目录<em>最远</em>的名称元素是文件或目录的名称。</span> <span>其他名称元素是目录名称。</span> <span>A <code>Path</code>可以表示根，根和序列的名称，或简单的一个或多个名称元素。</span> <span>如果<code>Path</code>仅由一个空的名称元素组成，则认为是空的<i>路径</i> 。</span> <span>使用<i>空路径</i>访问文件等同于访问文件系统的默认目录。</span> <span><code>Path</code>定义<a href="../../../java/nio/file/Path.html#getFileName--"><code>getFileName</code></a> ， <a href="../../../java/nio/file/Path.html#getParent--"><code>getParent</code></a> ， <a href="../../../java/nio/file/Path.html#getRoot--"><code>getRoot</code></a>和<a href="../../../java/nio/file/Path.html#subpath-int-int-"><code>subpath</code></a>方法来访问路径部件或它的名称元素的子序列。</span> </p>
<p> <span>除了访问路径的组件之外， <code>Path</code>还定义了组合路径的<a href="../../../java/nio/file/Path.html#resolve-java.nio.file.Path-"><code>resolve</code></a>和<a href="../../../java/nio/file/Path.html#resolveSibling-java.nio.file.Path-"><code>resolveSibling</code></a>方法。</span> <span>可以用于构建两个路径之间的相对路径的<a href="../../../java/nio/file/Path.html#relativize-java.nio.file.Path-"><code>relativize</code></a>方法。</span> <span>路径可以是<a href="../../../java/nio/file/Path.html#compareTo-java.nio.file.Path-"><code>compared</code></a> ，并使用<a href="../../../java/nio/file/Path.html#startsWith-java.nio.file.Path-"><code>startsWith</code></a>和<a href="../../../java/nio/file/Path.html#endsWith-java.nio.file.Path-"><code>endsWith</code></a>方法相互测试。</span> </p>
<p> <span>此接口扩展了<a href="../../../java/nio/file/Watchable.html" title="java.nio.file中的接口"><code>Watchable</code></a>接口，使得路径位于的目录可以是<a href="../../../java/nio/file/Path.html#register-java.nio.file.WatchService-java.nio.file.WatchEvent.Kind:A-java.nio.file.WatchEvent.Modifier...-"><code>registered</code></a> ，带有一个<a href="../../../java/nio/file/WatchService.html" title="java.nio.file中的接口"><code>WatchService</code></a>和<a href="../../../java/nio/file/WatchService.html" title="java.nio.file中的接口">目录</a>中的条目。</span> </p>
<p> <span><b>警告：</b>此接口仅用于开发自定义文件系统实现的那些实现。</span> <span>方法可能会在以后的版本添加到此界面。</span> </p>
<h2> <span>访问文件</span> </h2>
<p> <span>路径可以与<a href="../../../java/nio/file/Files.html" title="java.nio.file中的类"><code>Files</code></a>类一起使用，以对文件，目录和其他类型的文件进行操作。</span> <span>例如，假设我们想要一个<a href="../../../java/io/BufferedReader.html" title="java.io中的类"><code>BufferedReader</code></a>从文件“ <code>access.log</code> ”中读取文本。</span> <span>该文件位于相对于当前工作目录的目录“ <code>logs</code> ”中，并且是UTF-8编码的。</span> </p>
<pre>  <span>Path path = FileSystems.getDefault().getPath("logs", "access.log");
     BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8);</span> </pre>
<span><a name="interop"></a></span>
<h2> <span>互操作性</span> </h2>
<p> <span>与默认<a href="../../../java/nio/file/spi/FileSystemProvider.html" title="java.nio.file.spi中的类"><code>provider</code>相关联</a>的路径通常可以与<a href="../../../java/io/File.html" title="java.io中的类"><code>java.io.File</code></a>类进行互操作。</span> <span>由其他提供商创建的路径不可能与由java.io.File表示的抽象路径名称互<code>java.io.File</code> 。</span> <span>该<a href="../../../java/io/File.html#toPath--"><code>toPath</code></a>方法可以被用于获得<code>Path</code>从由A表示的抽象路径名<code>java.io.File</code>对象。</span> <span>所产生的<code>Path</code>可以用于与<code>java.io.File</code>对象相同的文件操作。</span> <span>此外， <a href="../../../java/nio/file/Path.html#toFile--"><code>toFile</code></a>方法是有用的构建<code>File</code>从<code>String</code>一个的表示<code>Path</code> 。</span> </p>
<h2> <span>并发性</span> </h2>
<p> <span>该接口的实现是不可变且安全的，可供多个并行线程使用。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.7 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../../java/nio/file/Paths.html" title="java.nio.file中的类"><code>Paths</code></a></span>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t3"><span><a href="javascript:show(4);">抽象方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#compareTo-java.nio.file.Path-">compareTo</a></span>(<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> other)</code>
<div class="block">
              比较两个抽象的路径词典。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#endsWith-java.nio.file.Path-">endsWith</a></span>(<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> other)</code>
<div class="block">
              测试此路径是否以给定的路径结束。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#endsWith-java.lang.String-">endsWith</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> other)</code>
<div class="block">
              测试此路径是否以 
             <code>Path</code>结束，通过转换给定的路径字符串，完全按照 
             <a href="../../../java/nio/file/Path.html#endsWith-java.nio.file.Path-"><code>endsWith(Path)</code></a>方法指定的方式构建。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#equals-java.lang.Object-">equals</a></span>(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> other)</code>
<div class="block">
              测试此路径与给定对象的相等性。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#getFileName--">getFileName</a></span>()</code>
<div class="block">
              将此路径表示的文件或目录的名称返回为 
             <code>Path</code>对象。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code><a href="../../../java/nio/file/FileSystem.html" title="class in java.nio.file">FileSystem</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#getFileSystem--">getFileSystem</a></span>()</code>
<div class="block">
              返回创建此对象的文件系统。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#getName-int-">getName</a></span>(int index)</code>
<div class="block">
              返回此路径的名称元素作为 
             <code>Path</code>对象。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#getNameCount--">getNameCount</a></span>()</code>
<div class="block">
              返回路径中的名称元素的数量。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#getParent--">getParent</a></span>()</code>
<div class="block">
              返回 
             <em>父路径</em> ，或 
             <code>null</code>如果此路径没有父。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#getRoot--">getRoot</a></span>()</code>
<div class="block">
              返回此路径的根组分作为 
             <code>Path</code>对象，或 
             <code>null</code>如果该路径不具有根组件。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#hashCode--">hashCode</a></span>()</code>
<div class="block">
              计算此路径的哈希码。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#isAbsolute--">isAbsolute</a></span>()</code>
<div class="block">
              告诉这条路是否是绝对的。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code><a href="../../../java/util/Iterator.html" title="interface in java.util">Iterator</a>&lt;<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#iterator--">iterator</a></span>()</code>
<div class="block">
              返回此路径的名称元素的迭代器。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#normalize--">normalize</a></span>()</code>
<div class="block">
              返回一个路径，该路径是冗余名称元素的消除。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code><a href="../../../java/nio/file/WatchKey.html" title="interface in java.nio.file">WatchKey</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#register-java.nio.file.WatchService-java.nio.file.WatchEvent.Kind...-">register</a></span>(<a href="../../../java/nio/file/WatchService.html" title="interface in java.nio.file">WatchService</a> watcher, <a href="../../../java/nio/file/WatchEvent.Kind.html" title="interface in java.nio.file">WatchEvent.Kind</a>&lt;?&gt;... events)</code>
<div class="block">
              使用手表服务注册此路径所在的文件。 
            </div> </td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code><a href="../../../java/nio/file/WatchKey.html" title="interface in java.nio.file">WatchKey</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#register-java.nio.file.WatchService-java.nio.file.WatchEvent.Kind:A-java.nio.file.WatchEvent.Modifier...-">register</a></span>(<a href="../../../java/nio/file/WatchService.html" title="interface in java.nio.file">WatchService</a> watcher, <a href="../../../java/nio/file/WatchEvent.Kind.html" title="interface in java.nio.file">WatchEvent.Kind</a>&lt;?&gt;[] events, <a href="../../../java/nio/file/WatchEvent.Modifier.html" title="interface in java.nio.file">WatchEvent.Modifier</a>... modifiers)</code>
<div class="block">
              使用手表服务注册此路径所在的文件。 
            </div> </td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#relativize-java.nio.file.Path-">relativize</a></span>(<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> other)</code>
<div class="block">
              构造此路径和给定路径之间的相对路径。 
            </div> </td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#resolve-java.nio.file.Path-">resolve</a></span>(<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> other)</code>
<div class="block">
              根据这条路径解决给定的路径。 
            </div> </td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#resolve-java.lang.String-">resolve</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> other)</code>
<div class="block">
              一个给定的路径字符串转换为 
             <code>Path</code>并解析它针对此 
             <code>Path</code>在完全按规定的方式 
             <a href="../../../java/nio/file/Path.html#resolve-java.nio.file.Path-"><code>resolve</code></a>方法。 
            </div> </td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#resolveSibling-java.nio.file.Path-">resolveSibling</a></span>(<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> other)</code>
<div class="block">
              根据此路径的 
             <a href="../../../java/nio/file/Path.html#getParent--"><code>parent</code></a>路径解决给定的路径。 
            </div> </td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#resolveSibling-java.lang.String-">resolveSibling</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> other)</code>
<div class="block">
              将给定的路径字符串转换为 
             <code>Path</code> ，并按照 
             <a href="../../../java/nio/file/Path.html#resolveSibling-java.nio.file.Path-"><code>resolveSibling</code></a>方法指定的方式将其解析为该路径的 
             <a href="../../../java/nio/file/Path.html#getParent--"><code>parent</code></a>路径。 
            </div> </td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#startsWith-java.nio.file.Path-">startsWith</a></span>(<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> other)</code>
<div class="block">
              测试此路径是否以给定的路径开始。 
            </div> </td>
</tr>
<tr class="altColor" id="i22">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#startsWith-java.lang.String-">startsWith</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> other)</code>
<div class="block">
              测试此路径是否以 
             <code>Path</code> ，通过转换给定的路径字符串，按照 
             <a href="../../../java/nio/file/Path.html#startsWith-java.nio.file.Path-"><code>startsWith(Path)</code></a>方法指定的方式构建。 
            </div> </td>
</tr>
<tr class="rowColor" id="i23">
<td class="colFirst"><code><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#subpath-int-int-">subpath</a></span>(int beginIndex, int endIndex)</code>
<div class="block">
              返回一个相对的 
             <code>Path</code> ，它是该路径的名称元素的子序列。 
            </div> </td>
</tr>
<tr class="altColor" id="i24">
<td class="colFirst"><code><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#toAbsolutePath--">toAbsolutePath</a></span>()</code>
<div class="block">
              返回表示此路径的绝对路径的 
             <code>Path</code>对象。 
            </div> </td>
</tr>
<tr class="rowColor" id="i25">
<td class="colFirst"><code><a href="../../../java/io/File.html" title="class in java.io">File</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#toFile--">toFile</a></span>()</code>
<div class="block">
<span>返回表示此路径的<a href="../../../java/io/File.html" title="java.io中的类"><code>File</code></a>对象。</span>
</div> </td>
</tr>
<tr class="altColor" id="i26">
<td class="colFirst"><code><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#toRealPath-java.nio.file.LinkOption...-">toRealPath</a></span>(<a href="../../../java/nio/file/LinkOption.html" title="enum in java.nio.file">LinkOption</a>... options)</code>
<div class="block">
              返回现有文件的 
             <em>真实</em>路径。 
            </div> </td>
</tr>
<tr class="rowColor" id="i27">
<td class="colFirst"><code><a href="../../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#toString--">toString</a></span>()</code>
<div class="block">
              返回此路径的字符串表示形式。 
            </div> </td>
</tr>
<tr class="altColor" id="i28">
<td class="colFirst"><code><a href="../../../java/net/URI.html" title="class in java.net">URI</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/file/Path.html#toUri--">toUri</a></span>()</code>
<div class="block">
              返回一个URI来表示此路径。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Iterable">
<!-- --> </a> <h3>Methods inherited from interface java.lang.<a href="../../../java/lang/Iterable.html" title="interface in java.lang">Iterable</a></h3> <code><a href="../../../java/lang/Iterable.html#forEach-java.util.function.Consumer-">forEach</a>, <a href="../../../java/lang/Iterable.html#spliterator--">spliterator</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="getFileSystem--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getFileSystem</h4> <pre><a href="../../../java/nio/file/FileSystem.html" title="class in java.nio.file">FileSystem</a> getFileSystem()</pre>
<div class="block">
            返回创建此对象的文件系统。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             创建此对象的文件系统 
           </dd>
</dl> </li>
</ul> <a name="isAbsolute--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isAbsolute</h4> <pre>boolean isAbsolute()</pre>
<div class="block">
<span>告诉这条路是否是绝对的。</span>
<p> <span>绝对路径是完整的，因为它不需要与其他路径信息组合以便定位文件。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果，只有这个路径是绝对的 
           </dd>
</dl> </li>
</ul> <a name="getRoot--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getRoot</h4> <pre><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> getRoot()</pre>
<div class="block">
            返回此路径的根组分作为 
           <code>Path</code>对象，或 
           <code>null</code>如果该路径不具有根组件。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个表示此路径的根组件的路径，或 
            <code>null</code>
</dd>
</dl> </li>
</ul> <a name="getFileName--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getFileName</h4> <pre><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> getFileName()</pre>
<div class="block">
<span>将此路径表示的文件或目录的名称返回为<code>Path</code>对象。</span>
<span>文件名是目录层次结构中根目录中<em>最远的</em>元素。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个表示文件或目录的名称的路径，如果此路径具有零个元素， 
            <code>null</code>
</dd>
</dl> </li>
</ul> <a name="getParent--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getParent</h4> <pre><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> getParent()</pre>
<div class="block">
<span>返回<em>父路径</em> ，如果此路径没有<em>父级</em> ，则返回<code>null</code> 。</span>
<p> <span>此路径对象的父对象由此路径的根组件（如果有）以及路径中的每个元素组成，除了距离目录层次结构中<em>最远</em>的根。</span> <span>此方法不访问文件系统;</span> <span>路径或其父可能不存在。</span> <span>此外，该方法不会消除诸如“。”之类的特殊名称。</span> <span>和“..”，可以在一些实现中使用。</span> <span>例如，在UNIX上，“ <code>/a/b/c</code> ”的父级为“ <code>/a/b</code> ”，父级为<code>"x/y/.</code> “为” <code>x/y</code> “，该方法可与<a href="../../../java/nio/file/Path.html#normalize--"><code>normalize</code></a>方法一起使用，以消除冗余名称，对于<em>类似shell的</em>导航为需要。</span> </p>
<p> <span>如果此路径具有一个或多个元素，并且没有根组件，则此方法等效于评估表达式：</span> </p>
<blockquote>
<span><pre>
 subpath(0, getNameCount()-1);
 </pre></span>
</blockquote>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             路径表示路径的父节点 
           </dd>
</dl> </li>
</ul> <a name="getNameCount--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getNameCount</h4> <pre>int getNameCount()</pre>
<div class="block">
            返回路径中的名称元素的数量。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             路径中的元素数，或 
            <code>0</code>如果此路径仅表示根组件 
           </dd>
</dl> </li>
</ul> <a name="getName-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getName</h4> <pre><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> getName(int index)</pre>
<div class="block">
<span>返回此路径的名称元素作为<code>Path</code>对象。</span>
<p> <span><code>index</code>参数是要返回的名称元素的索引。</span> <span>目录层次结构中<em>最靠近</em>根的元素具有索引<code>0</code> 。</span> <span><em>离</em>根<em>最远</em>的元素有索引<a href="../../../java/nio/file/Path.html#getNameCount--"><code>count</code></a> <code>-1</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>index</code> - 元素的索引 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             名称元素 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>index</code>为负数，则 
            <code>index</code>大于或等于元素数，或该路径具有零名称元素 
           </dd>
</dl> </li>
</ul> <a name="subpath-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>subpath</h4> <pre><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> subpath(int beginIndex,
             int endIndex)</pre>
<div class="block">
<span>返回一个相对的<code>Path</code> ，它是该路径的名称元素的子序列。</span>
<p> <span><code>beginIndex</code>和<code>endIndex</code>参数指定名称元素的子序列。</span> <span>目录层次结构中<em>最靠近</em>根目录的名称具有索引<code>0</code> 。</span> <span>距离根距离<em>最远</em>的名称有索引<a href="../../../java/nio/file/Path.html#getNameCount--"><code>count</code></a> <code>-1</code> 。</span> <span>返回的<code>Path</code>对象的名称元素从<code>beginIndex</code>开始，并扩展到索引<code>endIndex-1</code>处的元素。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>beginIndex</code> - 第一个元素的索引（包括） 
           </dd>
<dd>
<code>endIndex</code> - 最后一个元素的索引，独占 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个新的 
            <code>Path</code>对象，这是Path中名称元素的一个 
            <code>Path</code>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果<code>beginIndex</code>为负数，或大于或等于元素数量。</span>
<span>如果<code>endIndex</code>小于或等于<code>beginIndex</code> ，或大于元素数量。</span>
</dd>
</dl> </li>
</ul> <a name="startsWith-java.nio.file.Path-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>startsWith</h4> <pre>boolean startsWith(<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> other)</pre>
<div class="block">
<span>测试此路径是否以给定的路径开始。</span>
<p> <span>这条道路给定的路径<em>开始后</em> ，如果这个路径的根组件给定的路径的根组件<em>开始</em> ，这条路径具有相同名称元素作为给定的路径开始。</span> <span>如果给定路径具有比此路径更多的名称元素，则返回<code>false</code> 。</span> </p>
<p> <span>该路径的根组件是否以给定路径的根组件开头是文件系统特定的。</span> <span>如果此路径没有根组件，并且给定路径具有根组件，则此路径不以给定路径开始。</span> </p>
<p> <span>如果给定的路径与不同关联<code>FileSystem</code>这个路径再<code>false</code>返回。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>other</code> - 给定的路径 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span><code>true</code>如果这个路径从给定的路径开始;</span>
<span>否则<code>false</code></span>
</dd>
</dl> </li>
</ul> <a name="startsWith-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>startsWith</h4> <pre>boolean startsWith(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> other)</pre>
<div class="block">
<span>测试此路径是否以<code>Path</code> ，通过转换给定的路径字符串，完全按照<a href="../../../java/nio/file/Path.html#startsWith-java.nio.file.Path-"><code>startsWith(Path)</code></a>方法指定的方式构建。</span>
<span>例如，在UNIX上，路径“ <code>foo/bar</code> ”以“ <code>foo</code> ”和“ <code>foo/bar</code> ” <code>foo/bar</code> 。</span>
<span>它不以“ <code>f</code> ”或“ <code>fo</code> ” <code>fo</code> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>other</code> - 给定的路径字符串 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span><code>true</code>如果这个路径从给定的路径开始;</span>
<span>否则<code>false</code></span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/nio/file/InvalidPathException.html" title="class in java.nio.file">InvalidPathException</a></code> - 如果路径字符串不能转换为路径。 
           </dd>
</dl> </li>
</ul> <a name="endsWith-java.nio.file.Path-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>endsWith</h4> <pre>boolean endsWith(<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> other)</pre>
<div class="block">
<span>测试此路径是否以给定的路径结束。</span>
<p> <span>如果给定路径具有<em>N个</em>元素，并且没有根组件，并且该路径具有<em>N个</em>或更多个元素，则如果从距离根最远的元素开始的每个路径的最后<em>N个</em>元素相等，则该路径以给定路径结束。</span> </p>
<p> <span>如果给定路径具有根组件，则如果此路径的根组件以给定路径的根组件结束，则该路径以给定路径<em>结束</em> ，并且两个路径的相应元素相等。</span> <span>该路径的根组件是否以给定路径的根组件结束是文件系统特定的。</span> <span>如果此路径没有根组件，并且给定路径具有根组件，则此路径不以给定路径结束。</span> </p>
<p> <span>如果给定的路径与不同关联<code>FileSystem</code>这个路径再<code>false</code>返回。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>other</code> - 给定的路径 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span><code>true</code>如果此路径以给定路径结束;</span>
<span>否则<code>false</code></span>
</dd>
</dl> </li>
</ul> <a name="endsWith-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>endsWith</h4> <pre>boolean endsWith(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> other)</pre>
<div class="block">
<span>测试此路径是否以<code>Path</code>结束，通过转换给定的路径字符串，按照<a href="../../../java/nio/file/Path.html#endsWith-java.nio.file.Path-"><code>endsWith(Path)</code></a>方法指定的方式构建。</span>
<span>例如，在UNIX上，路径“ <code>foo/bar</code> ”以“ <code>foo/bar</code> ”和“ <code>bar</code> ” <code>bar</code> 。</span>
<span>它不以“ <code>r</code> ”或“ <code>/bar</code> ” <code>/bar</code> 。</span>
<span>需要注意的是，后隔板不考虑，所以调用的是这种方法<code>Path</code> “ <code>foo/bar</code> ”与<code>String</code> “ <code>bar/</code> ”返回<code>true</code> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>other</code> - 给定的路径字符串 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span><code>true</code>如果此路径以给定路径结束;</span>
<span>否则<code>false</code></span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/nio/file/InvalidPathException.html" title="class in java.nio.file">InvalidPathException</a></code> - 如果路径字符串不能转换为路径。 
           </dd>
</dl> </li>
</ul> <a name="normalize--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>normalize</h4> <pre><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> normalize()</pre>
<div class="block">
<span>返回一个路径，该路径是冗余名称元素的消除。</span>
<p> <span>该方法的精确定义是依赖于实现的，但通常来说，该方法源自此路径，不包含<em>冗余</em>名称元素的路径。</span> <span>在许多文件系统中，“ <code>.</code> ”和“ <code>..</code> ”是用于指示当前目录和父目录的特殊名称。</span> <span>在这样的文件系统中，所有出现的“ <code>.</code> ”都被认为是冗余的。</span> <span>如果“ <code>..</code> ”前面有一个非“ <code>..</code> ”的名称，那么这两个名称都被认为是冗余的（识别这些名称的过程被重复，直到它不再适用）。</span> </p>
<p> <span>此方法不访问文件系统;</span> <span>该路径可能找不到存在的文件。</span> <span>从路径中删除“ <code>..</code> ”和前面的名称可能导致定位与原始路径不同的文件的路径。</span> <span>当前面的名称是符号链接时，可能会出现这种情况。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>生成的路径或此路径，如果它不包含冗余的名称元素;</span>
<span>如果此路径具有根组件并且所有名称元素都是冗余的，则返回空路径</span>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/nio/file/Path.html#getParent--"><code>getParent()</code></a> ， 
            <a href="../../../java/nio/file/Path.html#toRealPath-java.nio.file.LinkOption...-"><code>toRealPath(java.nio.file.LinkOption...)</code></a>
</dd>
</dl> </li>
</ul> <a name="resolve-java.nio.file.Path-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>resolve</h4> <pre><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> resolve(<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> other)</pre>
<div class="block">
<span>根据这条路径解决给定的路径。</span>
<p> <span>如果<code>other</code>参数是<a href="../../../java/nio/file/Path.html#isAbsolute--"><code>absolute</code></a>路径，那么这个方法平常返回<code>other</code> 。</span> <span>如果<code>other</code>是一个<i>空的路径，</i>那么这个方法平常返回这个路径。</span> <span>否则，此方法将此路径视为目录，并根据此路径解析给定路径。</span> <span>在最简单的情况下，给定的路径不具有<a href="../../../java/nio/file/Path.html#getRoot--"><code>root</code></a>部件，在这种情况下该方法<em>加入</em>给定的路径向此路径，并返回所得到的路径<a href="../../../java/nio/file/Path.html#endsWith-java.nio.file.Path-"><code>ends</code></a>与给定的路径。</span> <span>在给定路径具有根组件的地方，则分辨率高度依赖于实现，因此未指定。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>other</code> - 解决此路径的路径 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             结果路径 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/nio/file/Path.html#relativize-java.nio.file.Path-"><code>relativize(java.nio.file.Path)</code></a>
</dd>
</dl> </li>
</ul> <a name="resolve-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>resolve</h4> <pre><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> resolve(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> other)</pre>
<div class="block">
<span>一个给定的路径字符串转换为<code>Path</code>并解析它针对此<code>Path</code>在完全按规定的方式<a href="../../../java/nio/file/Path.html#resolve-java.nio.file.Path-"><code>resolve</code></a>方法。</span>
<span>例如，假设名称分隔符为“ <code>/</code> ”，路径表示“ <code>foo/bar</code> ”，则使用路径字符串“ <code>gus</code> ”调用此方法将导致<code>Path</code> “ <code>foo/bar/gus</code> ”。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>other</code> - 要解决此路径的路径字符串 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             结果路径 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/nio/file/InvalidPathException.html" title="class in java.nio.file">InvalidPathException</a></code> - 如果路径字符串不能转换为路径。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/nio/file/FileSystem.html#getPath-java.lang.String-java.lang.String...-"><code>FileSystem.getPath(java.lang.String, java.lang.String...)</code></a>
</dd>
</dl> </li>
</ul> <a name="resolveSibling-java.nio.file.Path-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>resolveSibling</h4> <pre><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> resolveSibling(<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> other)</pre>
<div class="block">
<span>根据此路径的<a href="../../../java/nio/file/Path.html#getParent--"><code>parent</code></a>路径解决给定的路径。</span>
<span>如果文件名需要<i>替换</i>为其他文件名，这是非常有用的。</span>
<span>例如，假设名称分隔符为“ <code>/</code> ”，路径为“ <code>dir1/dir2/foo</code> ”，则使用<code>Path</code> “ <code>bar</code> ”调用此方法将导致<code>Path</code> “ <code>dir1/dir2/bar</code> ”。</span>
<span>如果此路径没有父路径，或<code>other</code>为<a href="../../../java/nio/file/Path.html#isAbsolute--"><code>absolute</code></a> ，则此方法返回<code>other</code> 。</span>
<span>如果<code>other</code>是一个空的路径，那么这个方法返回这个路径的父，或者这个路径没有父的空路径。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>other</code> - 解决此路径父级的路径 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             结果路径 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/nio/file/Path.html#resolve-java.nio.file.Path-"><code>resolve(Path)</code></a>
</dd>
</dl> </li>
</ul> <a name="resolveSibling-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>resolveSibling</h4> <pre><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> resolveSibling(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> other)</pre>
<div class="block">
            将给定的路径字符串转换为 
           <code>Path</code> ，并按照 
           <a href="../../../java/nio/file/Path.html#resolveSibling-java.nio.file.Path-"><code>resolveSibling</code></a>方法指定的方式将其解析为该路径的 
           <a href="../../../java/nio/file/Path.html#getParent--"><code>parent</code></a>路径。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>other</code> - 要解决此路径父级的路径字符串 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             结果路径 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/nio/file/InvalidPathException.html" title="class in java.nio.file">InvalidPathException</a></code> - 如果路径字符串不能转换为路径。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/nio/file/FileSystem.html#getPath-java.lang.String-java.lang.String...-"><code>FileSystem.getPath(java.lang.String, java.lang.String...)</code></a>
</dd>
</dl> </li>
</ul> <a name="relativize-java.nio.file.Path-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>relativize</h4> <pre><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> relativize(<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> other)</pre>
<div class="block">
<span>构造此路径和给定路径之间的相对路径。</span>
<p> <span>相对性是逆<a href="../../../java/nio/file/Path.html#resolve-java.nio.file.Path-"><code>resolution</code></a> 。</span> <span>该方法尝试构建一个<a href="../../../java/nio/file/Path.html#isAbsolute--"><code>relative</code></a>路径，当路径<a href="../../../java/nio/file/Path.html#resolve-java.nio.file.Path-"><code>resolved</code></a>针对该路径生成与给定路径相同的文件路径。</span> <span>例如，在UNIX上，如果此路径为<code>"/a/b"</code> ，给定路径为<code>"/a/b/c/d"</code>则相应的路径为<code>"c/d"</code> 。</span> <span>在此路径和给定路径中没有<a href="../../../java/nio/file/Path.html#getRoot--"><code>root</code></a>组件的情况下，可以构建相对路径。</span> <span>如果只有一个路径具有根组件，则不能构造相对路径。</span> <span>如果两个路径都有一个根组件，那么如果可以构造一个相对路径，那么它是依赖于实现的。</span> <span>如果此路径和给定路径为<a href="../../../java/nio/file/Path.html#equals-java.lang.Object-"><code>equal</code>，</a>则返回<i>空路径</i> 。</span> </p>
<p> <span>对于任何两个<a href="../../../java/nio/file/Path.html#normalize--"><code>normalized</code></a>路径<i>p</i>和<i>q</i> ，其中<i>q</i>没有根组件，</span> </p>
<blockquote>
<span><i>p</i> <tt>.relativize(</tt> <i>p</i> <tt>.resolve(</tt> <i>q</i> <tt>)).equals(</tt> <i>q</i> <tt>)</tt></span>
</blockquote>
<p> <span>当支持符号链接时，生成的路径是否在针对此路径解析时产生一个可用于定位<a href="../../../java/nio/file/Files.html#isSameFile-java.nio.file.Path-java.nio.file.Path-"><code>same</code></a>文件的路径，因为<code>other</code>是依赖于实现的。</span> <span>例如，如果此路径为<code>"/a/b"</code> ，给定路径为<code>"/a/x"</code>则所得的相对路径可能为<code>"../x"</code> 。</span> <span>如果<code>"b"</code>是符号链接，那么执行依赖，如果<code>"a/b/../x"</code>将找到与<code>"/a/x"</code>相同的文件。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>other</code> - 相对于此路径的路径 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             所生成的相对路径，或两条路径相等的空路径 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
            <code>other</code>不是 
            <code>Path</code>可以在这种路径相对化 
           </dd>
</dl> </li>
</ul> <a name="toUri--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toUri</h4> <pre><a href="../../../java/net/URI.html" title="class in java.net">URI</a> toUri()</pre>
<div class="block">
<span>返回一个URI来表示此路径。</span>
<p> <span>该方法构造一个绝对的<a href="../../../java/net/URI.html" title="java.net中的类"><code>URI</code></a> ，其中<a href="../../../java/net/URI.html#getScheme--"><code>scheme</code></a>等于标识提供程序的URI方案。</span> <span>方案具体部分的确切形式依赖于提供商。</span> </p>
<p> <span>在默认提供程序的情况下，URI是具有绝对的<a href="../../../java/net/URI.html#getPath--"><code>path</code></a>组件的<a href="../../../java/net/URI.html#getPath--">层次</a>结构。</span> <span>查询和片段组件未定义。</span> <span>是否定义了权限组件是否依赖于实现。</span> <span>不能保证<code>URI</code>可以用来构建一个<a href="../../../java/io/File.html" title="java.io中的类"><code>java.io.File</code></a> 。</span> <span>特别地，如果该路径表示通用命名约定（UNC）路径，则可以在所得到的URI的权限组件中编码UNC服务器名称。</span> <span>在默认提供程序的情况下，文件存在，并且可以确定该文件是目录，则生成的<code>URI</code>将以斜杠结尾。</span> </p>
<p> <span>默认提供商为<a href="../../../java/io/File.html" title="java.io中的类"><code>File</code></a>类提供了类似<em>的往返</em>保证。</span> <span>对于给定的<code>Path</code> <i>p</i>它是有保证的</span> </p>
<blockquote>
<span><tt> <a href="../../../java/nio/file/Paths.html#get-java.net.URI-"><code>Paths.get</code></a>(</tt> <i>p</i> <tt>.toUri()).equals(</tt> <i>p</i> <tt>.<a href="../../../java/nio/file/Path.html#toAbsolutePath--"><code>toAbsolutePath</code></a>())</tt></span>
</blockquote>
<span>只要原<code>Path</code> ，该<code>URI</code> ，新<code>Path</code>都在（可能是不同的调用）相同的Java虚拟机创建。</span>
<span>其他提供者是否提供任何保证是提供者特定的，因此未指定。</span>
<p> <span>当构建文件系统以访问文件的内容作为文件系统时，如果返回的URI表示文件系统中的给定路径，则它是高度实现特定的，或者它表示对包含文件系统的URI进行编码的<em>复合</em> URI 。</span> <span>此版本中未定义复合URI的格式;</span> <span>这样的方案可以在将来的版本中添加。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             表示此路径的URI 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/io/IOError.html" title="class in java.io">IOError</a></code> - 如果获取绝对路径发生I / O错误，或者构造文件系统以文件系统访问文件的内容，并且无法获取封闭文件系统的URI 
           </dd>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 在默认提供程序和安全管理器的情况下， 
            <a href="../../../java/nio/file/Path.html#toAbsolutePath--"><code>toAbsolutePath</code></a>方法会引发安全异常。 
           </dd>
</dl> </li>
</ul> <a name="toAbsolutePath--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toAbsolutePath</h4> <pre><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> toAbsolutePath()</pre>
<div class="block">
<span>返回表示此路径的绝对路径的<code>Path</code>对象。</span>
<p> <span>如果这个路径已经是<a href="../../../java/nio/file/Path.html#isAbsolute--"><code>absolute</code>，</a>那么这个方法只是返回这个路径。</span> <span>否则，此方法通过依赖于实现方式来解析路径，通常通过解析文件系统默认目录的路径。</span> <span>根据实现情况，如果文件系统不可访问，此方法可能会导致I / O错误。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Path</code>绝对路径的 
            <code>Path</code>对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/io/IOError.html" title="class in java.io">IOError</a></code> - 如果发生I / O错误 
           </dd>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 在默认提供程序的情况下，安装了一个安全管理器，并且此路径不是绝对的，那么将调用安全管理器的 
            <a href="../../../java/lang/SecurityManager.html#checkPropertyAccess-java.lang.String-"><code>checkPropertyAccess</code></a>方法来检查对系统属性的访问权限 
            <code>user.dir</code>
</dd>
</dl> </li>
</ul> <a name="toRealPath-java.nio.file.LinkOption...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toRealPath</h4> <pre><a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> toRealPath(<a href="../../../java/nio/file/LinkOption.html" title="enum in java.nio.file">LinkOption</a>... options)
         throws <a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></pre>
<div class="block">
<span>返回现有文件的<em>真实</em>路径。</span>
<p> <span>这种方法的精确定义是依赖于实现的，但通常来说，它源于此路径， <a href="../../../java/nio/file/Path.html#isAbsolute--"><code>absolute</code></a>路径将<a href="../../../java/nio/file/Files.html#isSameFile-java.nio.file.Path-java.nio.file.Path-"><code>same</code></a>文件定位为此路径，但具有表示目录和文件的实际名称的名称元素。</span> <span>例如，在文件系统上的文件名比较不区分大小写的情况下，名称元素表示实际情况下的名称。</span> <span>此外，生成的路径具有删除的冗余名称元素。</span> </p>
<p> <span>如果这个路径是相对的，那么首先获得它的绝对路径，好像通过调用<a href="../../../java/nio/file/Path.html#toAbsolutePath--"><code>toAbsolutePath</code></a>方法。</span> </p>
<p> <span><code>options</code>阵列可用于指示如何处理符号链接。</span> <span>默认情况下，符号链接被解析为最终目标。</span> <span>如果选项<a href="../../../java/nio/file/LinkOption.html#NOFOLLOW_LINKS"><code>NOFOLLOW_LINKS</code></a>存在，则此方法不能解析符号链接。</span> <span>一些实现允许诸如“ <code>..</code> ”之类的特殊名称来引用父目录。</span> <span>当导出<em>实际路径</em>时，“ <code>..</code> ”（或等效的）前面有一个非“ <code>..</code> ”名称，那么实现通常会导致两个名称被删除。</span> <span>当不解析符号链接并且前面的名称是一个符号链接时，只有当它保证生成的路径将找到与该路径相同的文件时，这些名称才被删除。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>options</code> - 表示如何处理符号链接的选项 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             绝对路径代表由该对象定位的文件的 
            <em>真实</em>路径 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></code> - 如果文件不存在或发生I / O错误 
           </dd>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 在默认提供程序和安全管理器的情况下，调用其 
            <a href="../../../java/lang/SecurityManager.html#checkRead-java.lang.String-"><code>checkRead</code></a>方法来检查对该文件的读取访问，并且此路径不是绝对的，其 
            <a href="../../../java/lang/SecurityManager.html#checkPropertyAccess-java.lang.String-"><code>checkPropertyAccess</code></a>方法被调用以检查对系统属性的访问 
            <code>user.dir</code>
</dd>
</dl> </li>
</ul> <a name="toFile--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toFile</h4> <pre><a href="../../../java/io/File.html" title="class in java.io">File</a> toFile()</pre>
<div class="block">
<span>返回一个表示此路径的<a href="../../../java/io/File.html" title="java.io中的类"><code>File</code></a>对象。</span>
<span>在这个<code>Path</code>与默认提供程序相关联的情况下，该方法相当于返回一个<code>File</code>对象，该对象使用该路径的<code>String</code>表示。</span>
<p> <span>如果这个路径是通过调用创建<code>File</code> <a href="../../../java/io/File.html#toPath--"><code>toPath</code></a>方法那么就不能保证<code>File</code>通过这个方法返回的对象是<a href="../../../java/nio/file/Path.html#equals-java.lang.Object-"><code>equal</code></a>到原来<code>File</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个表示此路径的 
            <code>File</code>对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此 
            <code>Path</code>未与默认提供程序相关联 
           </dd>
</dl> </li>
</ul> <a name="register-java.nio.file.WatchService-java.nio.file.WatchEvent.Kind:A-java.nio.file.WatchEvent.Modifier...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>register</h4> <pre><a href="../../../java/nio/file/WatchKey.html" title="interface in java.nio.file">WatchKey</a> register(<a href="../../../java/nio/file/WatchService.html" title="interface in java.nio.file">WatchService</a> watcher,
                  <a href="../../../java/nio/file/WatchEvent.Kind.html" title="interface in java.nio.file">WatchEvent.Kind</a>&lt;?&gt;[] events,
                  <a href="../../../java/nio/file/WatchEvent.Modifier.html" title="interface in java.nio.file">WatchEvent.Modifier</a>... modifiers)
           throws <a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></pre>
<div class="block">
<span>使用手表服务注册此路径所在的文件。</span>
<p> <span>在此版本中，此路径定位存在的目录。</span> <span>该目录已注册到手表服务，以便可以观看目录中的条目。</span> <span><code>events</code>参数是要注册的事件，可能包含以下事件：</span> </p>
<ul>
<li> <span><a href="../../../java/nio/file/StandardWatchEventKinds.html#ENTRY_CREATE"><code>ENTRY_CREATE</code></a> - 创建或移动到目录中的条目</span> </li>
<li> <span><a href="../../../java/nio/file/StandardWatchEventKinds.html#ENTRY_DELETE"><code>ENTRY_DELETE</code></a> - 条目删除或移出目录</span> </li>
<li> <span><a href="../../../java/nio/file/StandardWatchEventKinds.html#ENTRY_MODIFY"><code>ENTRY_MODIFY</code></a> - 目录中的条目已修改</span> </li>
</ul>
<p> <span>该<a href="../../../java/nio/file/WatchEvent.html#context--"><code>context</code></a>这些事件是由位于此路径的目录，并定位所创建，删除或修改目录项的路径之间的相对路径。</span> </p>
<p> <span>该组事件可能包括未由枚举<a href="../../../java/nio/file/StandardWatchEventKinds.html" title="java.nio.file中的类"><code>StandardWatchEventKinds</code></a>定义的附加实现特定事件</span> </p>
<p> <span>该<code>modifiers</code>参数指定有资格如何目录登记<em>修饰</em> 。</span> <span>此版本未定义任何<em>标准</em>修饰符。</span> <span>它可能包含实现特定的修饰符。</span> </p>
<p> <span>如果文件通过符号链接注册到手表服务，那么如果手表在注册后继续依赖于符号链接的存在，那么它是具体的实现。</span> </p>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../../java/nio/file/Watchable.html#register-java.nio.file.WatchService-java.nio.file.WatchEvent.Kind:A-java.nio.file.WatchEvent.Modifier...-">register</a></code>在界面 
            <code><a href="../../../java/nio/file/Watchable.html" title="interface in java.nio.file">Watchable</a></code>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>watcher</code> - 要注册该对象的监视服务 
           </dd>
<dd>
<code>events</code> - 应该注册此对象的事件 
           </dd>
<dd>
<code>modifiers</code> - 修改器（如果有）修改对象注册的方式 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             表示使用给定的监视服务注册此对象的键 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果指定了不支持的事件或修饰符 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果指定了事件或修饰符的无效组合 
           </dd>
<dd>
<code><a href="../../../java/nio/file/ClosedWatchServiceException.html" title="class in java.nio.file">ClosedWatchServiceException</a></code> - 如果手表服务关闭 
           </dd>
<dd>
<code><a href="../../../java/nio/file/NotDirectoryException.html" title="class in java.nio.file">NotDirectoryException</a></code> - 如果该文件被注册以观看目录中的条目，并且该文件不是目录 
            <i>（可选的特定异常）</i>
</dd>
<dd>
<code><a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生I / O错误 
           </dd>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 在默认提供程序和安全管理器的情况下，调用 
            <a href="../../../java/lang/SecurityManager.html#checkRead-java.lang.String-"><code>checkRead</code></a>方法来检查对该文件的读取访问。 
           </dd>
</dl> </li>
</ul> <a name="register-java.nio.file.WatchService-java.nio.file.WatchEvent.Kind...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>register</h4> <pre><a href="../../../java/nio/file/WatchKey.html" title="interface in java.nio.file">WatchKey</a> register(<a href="../../../java/nio/file/WatchService.html" title="interface in java.nio.file">WatchService</a> watcher,
                  <a href="../../../java/nio/file/WatchEvent.Kind.html" title="interface in java.nio.file">WatchEvent.Kind</a>&lt;?&gt;... events)
           throws <a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></pre>
<div class="block">
<span>使用手表服务注册此路径所在的文件。</span>
<p> <span>调用此方法的行为方式与调用完全相同</span> </p>
<pre>  <span>watchable.<a href="../../../java/nio/file/Path.html#register-java.nio.file.WatchService-java.nio.file.WatchEvent.Kind:A-java.nio.file.WatchEvent.Modifier...-"><code>register</code></a>(watcher, events, new WatchEvent.Modifier[0]);</span> </pre>
<p> <span><b>使用示例：</b>假设我们要注册一个目录来创建，删除和修改事件：</span> </p>
<pre>  <span>Path dir = ...
     WatchService watcher = ...

     WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);</span> </pre>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../../java/nio/file/Watchable.html#register-java.nio.file.WatchService-java.nio.file.WatchEvent.Kind...-">register</a></code>在界面 
            <code><a href="../../../java/nio/file/Watchable.html" title="interface in java.nio.file">Watchable</a></code>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>watcher</code> - 要注册此对象的手表服务 
           </dd>
<dd>
<code>events</code> - 应该注册此对象的事件 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             表示使用指定监视服务注册此对象的键 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果指定不支持的事件 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果指定了无效的事件组合 
           </dd>
<dd>
<code><a href="../../../java/nio/file/ClosedWatchServiceException.html" title="class in java.nio.file">ClosedWatchServiceException</a></code> - 如果手表服务关闭 
           </dd>
<dd>
<code><a href="../../../java/nio/file/NotDirectoryException.html" title="class in java.nio.file">NotDirectoryException</a></code> - 如果该文件已注册以观看目录中的条目，并且该文件不是目录 
            <i>（可选的特殊异常）</i>
</dd>
<dd>
<code><a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生I / O错误 
           </dd>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果是默认提供程序，并安装了安全管理器，则会调用 
            <a href="../../../java/lang/SecurityManager.html#checkRead-java.lang.String-"><code>checkRead</code></a>方法来检查对该文件的读取访问。 
           </dd>
</dl> </li>
</ul> <a name="iterator--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>iterator</h4> <pre><a href="../../../java/util/Iterator.html" title="interface in java.util">Iterator</a>&lt;<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a>&gt; iterator()</pre>
<div class="block">
<span>返回此路径的名称元素的迭代器。</span>
<p> <span>迭代器返回的第一个元素表示最接近目录层次结构中根的名称元素，第二个元素是下一个元素，依此类推。</span> <span>返回的最后一个元素是由此路径表示的文件或目录的名称。</span> <span><a href="../../../java/nio/file/Path.html#getRoot--"><code>root</code></a>组件（如果存在）不由迭代器返回。</span> </p>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../../java/lang/Iterable.html#iterator--">iterator</a></code>在界面 
            <code><a href="../../../java/lang/Iterable.html" title="interface in java.lang">Iterable</a>&lt;<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a>&gt;</code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个路径的名称元素的迭代器。 
           </dd>
</dl> </li>
</ul> <a name="compareTo-java.nio.file.Path-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>compareTo</h4> <pre>int compareTo(<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> other)</pre>
<div class="block">
<span>比较两个抽象的路径词典。</span>
<span>由此方法定义的排序是提供者特定的，在默认提供程序的情况下，具体为平台。</span>
<span>此方法不访问文件系统，并且不需要文件存在。</span>
<p> <span>该方法可能不用于比较与不同文件系统提供程序相关联的路径。</span> </p>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../../java/lang/Comparable.html#compareTo-T-">compareTo</a></code>在界面 
            <code><a href="../../../java/lang/Comparable.html" title="interface in java.lang">Comparable</a>&lt;<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a>&gt;</code>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>other</code> - 与此路径相比较的路径。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             如果参数为此路径的参数为 
            <a href="../../../java/nio/file/Path.html#equals-java.lang.Object-"><code>equal</code></a> ，则为零，如果此路径在字典上小于参数，则该值小于零，或者如果此路径在字典上大于参数，则该值大于零 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果路径与不同的提供者相关联 
           </dd>
</dl> </li>
</ul> <a name="equals-java.lang.Object-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>equals</h4> <pre>boolean equals(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> other)</pre>
<div class="block">
<span>测试此路径与给定对象的相等性。</span>
<p> <span>如果给定的对象不是路径，或者是与不同的FileSystem相关<code>FileSystem</code>的路径，则此方法返回<code>false</code> 。</span> </p>
<p> <span>两条路径是否相等取决于文件系统的实现。</span> <span>在某些情况下，不考虑情况比较路径，而其他路径是区分大小写的。</span> <span>该方法不访问文件系统，并且不需要该文件。</span> <span>如果需要，可以使用<a href="../../../java/nio/file/Files.html#isSameFile-java.nio.file.Path-java.nio.file.Path-"><code>isSameFile</code></a>方法来检查两个路径是否找到相同的文件。</span> </p>
<p> <span>这种方法满足的总承包<a href="../../../java/lang/Object.html#equals-java.lang.Object-"><code>Object.equals</code></a>方法。</span> </p>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a></code>在类别 
            <code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>other</code> - 要比较此对象的对象 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果，并且只有当给定的对象是一个 
            <code>Path</code>是相同的这个 
            <code>Path</code>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../../java/lang/Object.html#hashCode--"><code>Object.hashCode()</code></a> ， <a href="../../../java/util/HashMap.html" title="java.util中的类"><code>HashMap</code></a></span>
</dd>
</dl> </li>
</ul> <a name="hashCode--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>hashCode</h4> <pre>int hashCode()</pre>
<div class="block">
<span>计算此路径的哈希码。</span>
<p> <span>哈希码基于路径的组成部分，并满足<a href="../../../java/lang/Object.html#hashCode--"><code>Object.hashCode</code></a>方法的一般合同。</span> </p>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../../java/lang/Object.html#hashCode--">hashCode</a></code>在类别 
            <code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             该路径的哈希码值 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/Object.html#equals-java.lang.Object-"><code>Object.equals(java.lang.Object)</code></a> ， 
            <a href="../../../java/lang/System.html#identityHashCode-java.lang.Object-"><code>System.identityHashCode(java.lang.Object)</code></a>
</dd>
</dl> </li>
</ul> <a name="toString--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>toString</h4> <pre><a href="../../../java/lang/String.html" title="class in java.lang">String</a> toString()</pre>
<div class="block">
<span>返回此路径的字符串表示形式。</span>
<p> <span>如果通过使用<a href="../../../java/nio/file/FileSystem.html#getPath-java.lang.String-java.lang.String...-"><code>getPath</code></a>方法转换路径字符串创建此路径，则此方法返回的路径字符串可能与用于创建路径的原始字符串不同。</span> </p>
<p> <span>返回的路径字符串使用默认名称<a href="../../../java/nio/file/FileSystem.html#getSeparator--"><code>separator</code></a>来分隔路径中的名称。</span> </p>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../../java/lang/Object.html#toString--">toString</a></code>在类别 
            <code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             该路径的字符串表示形式 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>