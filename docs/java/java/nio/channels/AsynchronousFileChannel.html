<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.nio.channels 
   </div>
<h2 class="title" title="Class AsynchronousFileChannel">Class AsynchronousFileChannel</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.nio.channels.AsynchronousFileChannel</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
         All Implemented Interfaces: 
       </dt>
<dd>
<span><a href="../../../java/io/Closeable.html" title="java.io中的接口">Closeable</a> ， <a href="../../../java/lang/AutoCloseable.html" title="java.lang中的接口">AutoCloseable</a> ， <a href="../../../java/nio/channels/AsynchronousChannel.html" title="java.nio.channels中的接口">AsynchronousChannel</a> ， <a href="../../../java/nio/channels/Channel.html" title="java.nio.channels中的接口">Channel</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public abstract class <span class="typeNameLabel">AsynchronousFileChannel</span>
extends <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>
implements <a href="../../../java/nio/channels/AsynchronousChannel.html" title="interface in java.nio.channels">AsynchronousChannel</a></pre>
<div class="block">
<span>用于读取，写入和操作文件的异步通道。</span>
<p> <span>当通过调用<a href="../../../java/nio/channels/AsynchronousFileChannel.html#open-java.nio.file.Path-java.util.Set-java.util.concurrent.ExecutorService-java.nio.file.attribute.FileAttribute...-">此类</a>定义的<a href="../../../java/nio/channels/AsynchronousFileChannel.html#open-java.nio.file.Path-java.util.Set-java.util.concurrent.ExecutorService-java.nio.file.attribute.FileAttribute...-"><code>open</code></a>方法之一来打开文件时，将创建异步文件通道。</span> <span>该文件包含可以读写的可变长度的字节序列，当前大小可以是<a href="../../../java/nio/channels/AsynchronousFileChannel.html#size--"><code>queried</code></a> 。</span> <span>当字节写入超过其当前大小时，文件的大小会增加;</span> <span>文件大小在<code>truncated</code>时会<a href="../../../java/nio/channels/AsynchronousFileChannel.html#truncate-long-">减小</a> 。</span> </p>
<p> <span>异步文件通道在文件中没有<i>当前位置</i> 。</span> <span>而是将文件位置指定给启动异步操作的每个读写方法。</span> <span>A <a href="../../../java/nio/channels/CompletionHandler.html" title="java.nio.channels中的接口"><code>CompletionHandler</code></a>被指定为参数，并被调用以消耗I / O操作的结果。</span> <span>该类还定义了启动异步操作的读取和写入方法，返回一个<a href="../../../java/util/concurrent/Future.html" title="java.util.concurrent中的接口"><code>Future</code></a>以表示待处理的操作结果。</span> <span><code>Future</code>可用于检查操作是否完成，等待其完成，并检索结果。</span> </p>
<p> <span>除了读写操作之外，此类还定义了以下操作：</span> </p>
<ul>
<li><p> <span>对文件进行的更新可能是<a href="../../../java/nio/channels/AsynchronousFileChannel.html#force-boolean-">底层</a>存储设备的<code><i>forced out</i></code>，以确保在系统崩溃时数据不会丢失。</span> </p></li>
<li><p> <span>文件的一个区域可能是其他程序访问的<a href="../../../java/nio/channels/AsynchronousFileChannel.html#lock-long-long-boolean-A-java.nio.channels.CompletionHandler-"><code><i>locked</i></code></a> 。</span> </p></li>
</ul>
<p> <span>一个<code>AsynchronousFileChannel</code>与线程池相关的其中将任务提交到处理I / O事件和派遣消耗I / O操作的通道上的结果完成处理程序。</span> <span>在通道上启动的I / O操作的完成处理程序保证由线程池中的一个线程调用（这样可以确保完成处理程序由具有预期<em>标识</em>的线程运行）。</span> <span>I / O操作立即完成，并且启动线程本身是线程池中的一个线程，则完成处理程序可以由启动线程直接调用。</span> <span>当<code>AsynchronousFileChannel</code>而不指定线程池然后此信道与可与其它信道共享的系统有关的默认线程池相关联的创建。</span> <span>默认线程池由<a href="../../../java/nio/channels/AsynchronousChannelGroup.html" title="java.nio.channels中的类"><code>AsynchronousChannelGroup</code></a>类定义的系统属性<a href="../../../java/nio/channels/AsynchronousChannelGroup.html" title="java.nio.channels中的类">配置</a> 。</span> </p>
<p> <span>这种类型的通道可以安全地被多个并发线程使用。</span> <span><a href="../../../java/nio/channels/Channel.html#close--"><code>close</code></a>方法可以随时调用，由<a href="../../../java/nio/channels/Channel.html" title="java.nio.channels中的接口"><code>Channel</code></a>接口指定。</span> <span>这导致通道上的所有未完成的异步<a href="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels中的类">操作</a>都完成，但是异常<a href="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels中的类"><code>AsynchronousCloseException</code></a> 。</span> <span>多个读写操作可能同时出现。</span> <span>当多个读写操作未完成时，未指定I / O操作的顺序和调用完成处理程序的顺序;</span> <span>它们并不特别保证按照操作开始的顺序执行。</span> <span>该<a href="../../../java/nio/ByteBuffer.html" title="java.nio中的类"><code>ByteBuffers</code></a>读取或写入时使用的是用于多个并发I / O操作中使用是安全的。</span> <span>此外，在I / O操作开始之后，应注意确保缓冲区在操作完成后才被访问。</span> </p>
<p> <span>与<a href="../../../java/nio/channels/FileChannel.html" title="java.nio.channels中的类"><code>FileChannel</code>一样</a> ，由该类的实例提供的文件的视图保证与同一程序中的其他实例提供的同一文件的其他视图一致。</span> <span>但是，由于这个类的一个实例提供的视图可能与也可能不一致，这是由于由底层操作系统执行的缓存和由网络文件系统协议引起的延迟而由其他同时运行的程序所看到的。</span> <span>无论这些其他程序的编写语言如何，以及它们是在同一台机器还是在其他机器上运行，都是如此。</span> <span>任何这种不一致的确切性质是系统依赖性的，因此是未指定的。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.7 
       </dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!-- --> </a> <h3>构造方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Constructor Summary table, listing constructors, and an explanation">
<caption>
<span>构造方法</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier</th>
<th class="colLast" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/channels/AsynchronousFileChannel.html#AsynchronousFileChannel--">AsynchronousFileChannel</a></span>()</code>
<div class="block">
              初始化此类的新实例。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t1"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t3"><span><a href="javascript:show(4);">抽象方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/channels/AsynchronousFileChannel.html#force-boolean-">force</a></span>(boolean metaData)</code>
<div class="block">
              强制将此通道文件的任何更新写入包含该通道的存储设备。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code><a href="../../../java/util/concurrent/Future.html" title="interface in java.util.concurrent">Future</a>&lt;<a href="../../../java/nio/channels/FileLock.html" title="class in java.nio.channels">FileLock</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/channels/AsynchronousFileChannel.html#lock--">lock</a></span>()</code>
<div class="block">
              获取此通道文件的排他锁。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>&lt;A&gt; void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/channels/AsynchronousFileChannel.html#lock-A-java.nio.channels.CompletionHandler-">lock</a></span>(A attachment, <a href="../../../java/nio/channels/CompletionHandler.html" title="interface in java.nio.channels">CompletionHandler</a>&lt;<a href="../../../java/nio/channels/FileLock.html" title="class in java.nio.channels">FileLock</a>,? super A&gt; handler)</code>
<div class="block">
              获取此通道文件的排他锁。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>abstract <a href="../../../java/util/concurrent/Future.html" title="interface in java.util.concurrent">Future</a>&lt;<a href="../../../java/nio/channels/FileLock.html" title="class in java.nio.channels">FileLock</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/channels/AsynchronousFileChannel.html#lock-long-long-boolean-">lock</a></span>(long position, long size, boolean shared)</code>
<div class="block">
              获取此通道文件的给定区域的锁定。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>abstract &lt;A&gt; void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/channels/AsynchronousFileChannel.html#lock-long-long-boolean-A-java.nio.channels.CompletionHandler-">lock</a></span>(long position, long size, boolean shared, A attachment, <a href="../../../java/nio/channels/CompletionHandler.html" title="interface in java.nio.channels">CompletionHandler</a>&lt;<a href="../../../java/nio/channels/FileLock.html" title="class in java.nio.channels">FileLock</a>,? super A&gt; handler)</code>
<div class="block">
              获取此通道文件的给定区域的锁定。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>static <a href="../../../java/nio/channels/AsynchronousFileChannel.html" title="class in java.nio.channels">AsynchronousFileChannel</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/channels/AsynchronousFileChannel.html#open-java.nio.file.Path-java.nio.file.OpenOption...-">open</a></span>(<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> file, <a href="../../../java/nio/file/OpenOption.html" title="interface in java.nio.file">OpenOption</a>... options)</code>
<div class="block">
              打开或创建用于读取和/或写入的文件，返回异步文件通道以访问该文件。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>static <a href="../../../java/nio/channels/AsynchronousFileChannel.html" title="class in java.nio.channels">AsynchronousFileChannel</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/channels/AsynchronousFileChannel.html#open-java.nio.file.Path-java.util.Set-java.util.concurrent.ExecutorService-java.nio.file.attribute.FileAttribute...-">open</a></span>(<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> file, <a href="../../../java/util/Set.html" title="interface in java.util">Set</a>&lt;? extends <a href="../../../java/nio/file/OpenOption.html" title="interface in java.nio.file">OpenOption</a>&gt; options, <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a> executor, <a href="../../../java/nio/file/attribute/FileAttribute.html" title="interface in java.nio.file.attribute">FileAttribute</a>&lt;?&gt;... attrs)</code>
<div class="block">
              打开或创建用于读取和/或写入的文件，返回异步文件通道以访问该文件。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>abstract <a href="../../../java/util/concurrent/Future.html" title="interface in java.util.concurrent">Future</a>&lt;<a href="../../../java/lang/Integer.html" title="class in java.lang">Integer</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/channels/AsynchronousFileChannel.html#read-java.nio.ByteBuffer-long-">read</a></span>(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a> dst, long position)</code>
<div class="block">
              从给定的文件位置开始，从该通道读取一个字节序列到给定的缓冲区。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>abstract &lt;A&gt; void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/channels/AsynchronousFileChannel.html#read-java.nio.ByteBuffer-long-A-java.nio.channels.CompletionHandler-">read</a></span>(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a> dst, long position, A attachment, <a href="../../../java/nio/channels/CompletionHandler.html" title="interface in java.nio.channels">CompletionHandler</a>&lt;<a href="../../../java/lang/Integer.html" title="class in java.lang">Integer</a>,? super A&gt; handler)</code>
<div class="block">
              从给定的文件位置开始，从该通道读取一个字节序列到给定的缓冲区。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>abstract long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/channels/AsynchronousFileChannel.html#size--">size</a></span>()</code>
<div class="block">
              返回此通道文件的当前大小。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>abstract <a href="../../../java/nio/channels/AsynchronousFileChannel.html" title="class in java.nio.channels">AsynchronousFileChannel</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/channels/AsynchronousFileChannel.html#truncate-long-">truncate</a></span>(long size)</code>
<div class="block">
              将此频道的文件截断为给定大小。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code><a href="../../../java/nio/channels/FileLock.html" title="class in java.nio.channels">FileLock</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/channels/AsynchronousFileChannel.html#tryLock--">tryLock</a></span>()</code>
<div class="block">
              尝试获取此频道文件的排他锁。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>abstract <a href="../../../java/nio/channels/FileLock.html" title="class in java.nio.channels">FileLock</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/channels/AsynchronousFileChannel.html#tryLock-long-long-boolean-">tryLock</a></span>(long position, long size, boolean shared)</code>
<div class="block">
              尝试获取此通道文件的给定区域的锁定。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>abstract <a href="../../../java/util/concurrent/Future.html" title="interface in java.util.concurrent">Future</a>&lt;<a href="../../../java/lang/Integer.html" title="class in java.lang">Integer</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/channels/AsynchronousFileChannel.html#write-java.nio.ByteBuffer-long-">write</a></span>(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a> src, long position)</code>
<div class="block">
              从给定的缓冲区向给定的文件位置开始，向该通道写入一个字节序列。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>abstract &lt;A&gt; void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/nio/channels/AsynchronousFileChannel.html#write-java.nio.ByteBuffer-long-A-java.nio.channels.CompletionHandler-">write</a></span>(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a> src, long position, A attachment, <a href="../../../java/nio/channels/CompletionHandler.html" title="interface in java.nio.channels">CompletionHandler</a>&lt;<a href="../../../java/lang/Integer.html" title="class in java.lang">Integer</a>,? super A&gt; handler)</code>
<div class="block">
              从给定的缓冲区向给定的文件位置开始，向该通道写入一个字节序列。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#toString--">toString</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.nio.channels.AsynchronousChannel">
<!-- --> </a> <h3>Methods inherited from interface java.nio.channels.<a href="../../../java/nio/channels/AsynchronousChannel.html" title="interface in java.nio.channels">AsynchronousChannel</a></h3> <code><a href="../../../java/nio/channels/AsynchronousChannel.html#close--">close</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.nio.channels.Channel">
<!-- --> </a> <h3>Methods inherited from interface java.nio.channels.<a href="../../../java/nio/channels/Channel.html" title="interface in java.nio.channels">Channel</a></h3> <code><a href="../../../java/nio/channels/Channel.html#isOpen--">isOpen</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!-- --> </a> <h3>构造方法详细信息</h3> <a name="AsynchronousFileChannel--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>AsynchronousFileChannel</h4> <pre>protected AsynchronousFileChannel()</pre>
<div class="block">
            初始化此类的新实例。 
          </div> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="open-java.nio.file.Path-java.util.Set-java.util.concurrent.ExecutorService-java.nio.file.attribute.FileAttribute...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>open</h4> <pre>public static <a href="../../../java/nio/channels/AsynchronousFileChannel.html" title="class in java.nio.channels">AsynchronousFileChannel</a> open(<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> file,
                                           <a href="../../../java/util/Set.html" title="interface in java.util">Set</a>&lt;? extends <a href="../../../java/nio/file/OpenOption.html" title="interface in java.nio.file">OpenOption</a>&gt; options,
                                           <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a> executor,
                                           <a href="../../../java/nio/file/attribute/FileAttribute.html" title="interface in java.nio.file.attribute">FileAttribute</a>&lt;?&gt;... attrs)
                                    throws <a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></pre>
<div class="block">
<span>打开或创建用于读取和/或写入的文件，返回异步文件通道以访问该文件。</span>
<p> <span><code>options</code>参数确定文件的打开方式。</span> <span><a href="../../../java/nio/file/StandardOpenOption.html#READ"><code>READ</code></a>和<a href="../../../java/nio/file/StandardOpenOption.html#WRITE"><code>WRITE</code></a>选项确定文件是否应打开以供读取和/或写入。</span> <span>如果数组中没有包含任何选项，则打开一个现有文件进行阅读。</span> </p>
<p> <span>除了<code>READ</code>和<code>WRITE</code> ，还可能存在以下选项：</span> </p>
<span>  Option Description    <a href="../../../java/nio/file/StandardOpenOption.html#TRUNCATE_EXISTING"><code>TRUNCATE_EXISTING</code></a>   When opening an existing file, the file is first truncated to a size of 0 bytes. This option is ignored when the file is opened only for reading.    <a href="../../../java/nio/file/StandardOpenOption.html#CREATE_NEW"><code>CREATE_NEW</code></a>   If this option is present then a new file is created, failing if the file already exists. When creating a file the check for the existence of the file and the creation of the file if it does not exist is atomic with respect to other file system operations. This option is ignored when the file is opened only for reading.     <a href="../../../java/nio/file/StandardOpenOption.html#CREATE"><code>CREATE</code></a>   If this option is present then an existing file is opened if it exists, otherwise a new file is created. When creating a file the check for the existence of the file and the creation of the file if it does not exist is atomic with respect to other file system operations. This option is ignored if the <code>CREATE_NEW</code> option is also present or the file is opened only for reading.     <a href="../../../java/nio/file/StandardOpenOption.html#DELETE_ON_CLOSE"><code>DELETE_ON_CLOSE</code></a>   When this option is present then the implementation makes a <em>best effort</em> attempt to delete the file when closed by the the <a href="../../../java/nio/channels/AsynchronousChannel.html#close--"><code>close</code></a> method. If the <code>close</code> method is not invoked then a <em>best effort</em> attempt is made to delete the file when the Java virtual machine terminates.    <a href="../../../java/nio/file/StandardOpenOption.html#SPARSE"><code>SPARSE</code></a>   When creating a new file this option is a <em>hint</em> that the new file will be sparse. This option is ignored when not creating a new file.     <a href="../../../java/nio/file/StandardOpenOption.html#SYNC"><code>SYNC</code></a>   Requires that every update to the file's content or metadata be written synchronously to the underlying storage device. (see <a href="../file/package-summary.html#integrity"> Synchronized I/O file integrity</a>).     <a href="../../../java/nio/file/StandardOpenOption.html#DSYNC"><code>DSYNC</code></a>   Requires that every update to the file's content be written synchronously to the underlying storage device. (see <a href="../file/package-summary.html#integrity"> Synchronized I/O file integrity</a>).   </span>
<table border="1" cellpadding="5" summary="">
</table>
<p> <span>实施还可以支持其他选项。</span> </p>
<p> <span><code>executor</code>参数是<a href="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent中的接口"><code>ExecutorService</code></a> ，其中<a href="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent中的接口">提交</a>的任务用于处理I / O事件，并为结果通道启动的操作发送完成结果。</span> <span>这些任务的性质是高度实现具体的，因此在配置<code>Executor</code>时应该小心。</span> <span>最小应该支持一个无界的工作队列，不应该在<a href="../../../java/util/concurrent/Executor.html#execute-java.lang.Runnable-"><code>execute</code></a>方法的调用者线程上运行任务。</span> <span>在通道打开时关闭执行程序服务会导致未指定的行为。</span> </p>
<p> <span><code>attrs</code>参数是一个可选的文件<a href="../../../java/nio/file/attribute/FileAttribute.html" title="java.nio.file.attribute中的接口"><code>file-attributes</code></a>数组，用于在创建文件时以<a href="../../../java/nio/file/attribute/FileAttribute.html" title="java.nio.file.attribute中的接口">原子</a>方式设置。</span> </p>
<p> <span>新的信道是通过调用创建<a href="../../../java/nio/file/spi/FileSystemProvider.html#newFileChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-"><code>newFileChannel</code></a>上创建该提供商方法<code>Path</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>file</code> - 打开或创建文件的路径 
           </dd>
<dd>
<code>options</code> - 指定文件打开方式的选项 
           </dd>
<dd>
<code>executor</code> - 线程池或 
            <code>null</code>将通道与默认线程池相关联 
           </dd>
<dd>
<code>attrs</code> - 创建文件时以原子方式设置的文件属性的可选列表 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个新的异步文件通道 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果集合包含无效的选项组合 
           </dd>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> -如果 
            <code>file</code>已与不支持创建异步文件信道，或不支持的打开选项提供商相关联的指定，或阵列包含可以在创建文件时不被原子地设置一个属性 
           </dd>
<dd>
<code><a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生I / O错误 
           </dd>
<dd>
<span><code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安装了一个安全管理器，并且它拒绝执行所需的未指定的权限。</span>
<span>在默认提供程序的情况下，调用<a href="../../../java/lang/SecurityManager.html#checkRead-java.lang.String-"><code>SecurityManager.checkRead(String)</code></a>方法以检查文件是否打开以进行读取。</span>
<span>如果文件被打开来写入，则调用<a href="../../../java/lang/SecurityManager.html#checkWrite-java.lang.String-"><code>SecurityManager.checkWrite(String)</code></a>方法来检查写访问</span>
</dd>
</dl> </li>
</ul> <a name="open-java.nio.file.Path-java.nio.file.OpenOption...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>open</h4> <pre>public static <a href="../../../java/nio/channels/AsynchronousFileChannel.html" title="class in java.nio.channels">AsynchronousFileChannel</a> open(<a href="../../../java/nio/file/Path.html" title="interface in java.nio.file">Path</a> file,
                                           <a href="../../../java/nio/file/OpenOption.html" title="interface in java.nio.file">OpenOption</a>... options)
                                    throws <a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></pre>
<div class="block">
<span>打开或创建用于读取和/或写入的文件，返回异步文件通道以访问该文件。</span>
<p> <span>调用此方法的行为方式与调用完全相同</span> </p>
<pre>  <span>ch.<a href="../../../java/nio/channels/AsynchronousFileChannel.html#open-java.nio.file.Path-java.util.Set-java.util.concurrent.ExecutorService-java.nio.file.attribute.FileAttribute...-"><code>open</code></a>(file, opts, null, new FileAttribute&lt;?&gt;[0]);</span> </pre>
<span>其中<code>opts</code>是一个<code>Set</code> ，其中<code>opts</code>为此方法指定的选项。</span>
<p> <span>所产生的通道与默认线程池相关联，任务被提交到处理I / O事件并发送到完成处理程序，该处理程序消耗在最终通道上执行的异步操作的结果。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>file</code> - 打开或创建文件的路径 
           </dd>
<dd>
<code>options</code> - 指定文件打开方式的选项 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个新的异步文件通道 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果集合包含无效的选项组合 
           </dd>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> -如果 
            <code>file</code>与不支持创建文件通道的提供者，或者不支持的开放式选项关联指定 
           </dd>
<dd>
<code><a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生I / O错误 
           </dd>
<dd>
<span><code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安装了一个安全管理器，并且拒绝执行所需的未指定的权限。</span>
<span>在默认提供程序的情况下，调用<a href="../../../java/lang/SecurityManager.html#checkRead-java.lang.String-"><code>SecurityManager.checkRead(String)</code></a>方法以检查文件是否打开以进行读取。</span>
<span>如果打开文件写入，则调用<a href="../../../java/lang/SecurityManager.html#checkWrite-java.lang.String-"><code>SecurityManager.checkWrite(String)</code></a>方法来检查写访问</span>
</dd>
</dl> </li>
</ul> <a name="size--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>size</h4> <pre>public abstract long size()
                   throws <a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></pre>
<div class="block">
            返回此通道文件的当前大小。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             该通道文件的当前大小，以字节为单位 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/nio/channels/ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此通道关闭 
           </dd>
<dd>
<code><a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他I / O错误 
           </dd>
</dl> </li>
</ul> <a name="truncate-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>truncate</h4> <pre>public abstract <a href="../../../java/nio/channels/AsynchronousFileChannel.html" title="class in java.nio.channels">AsynchronousFileChannel</a> truncate(long size)
                                          throws <a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></pre>
<div class="block">
<span>将此频道的文件截断为给定大小。</span>
<p> <span>如果给定的大小小于文件的当前大小，则文件将被截断，丢弃超出文件新端的任何字节。</span> <span>如果给定的大小大于或等于文件的当前大小，则该文件不会被修改。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>size</code> - 新的大小，非负字节数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             此文件通道 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/nio/channels/NonWritableChannelException.html" title="class in java.nio.channels">NonWritableChannelException</a></code> - 如果此通道未打开以进行写入 
           </dd>
<dd>
<code><a href="../../../java/nio/channels/ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此通道关闭 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果新尺寸为负 
           </dd>
<dd>
<code><a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他I / O错误 
           </dd>
</dl> </li>
</ul> <a name="force-boolean-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>force</h4> <pre>public abstract void force(boolean metaData)
                    throws <a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></pre>
<div class="block">
<span>强制将此通道文件的任何更新写入包含该通道的存储设备。</span>
<p> <span>如果此通道的文件驻留在本地存储设备上，那么当该方法返回时，将保证自创建该通道以来创建的该文件所做的所有更改，或自上次调用该方法以来，都将写入该设备。</span> <span>这对于确保系统崩溃时不会丢失关键信息非常有用。</span> </p>
<p> <span>如果文件不在本地设备上，则不会提供此类保证。</span> </p>
<p> <span><code>metaData</code>参数可用于限制此方法执行所需的I / O操作数。</span> <span>传递<code>false</code>该参数表示只更新文件的内容需要被写入存储设备;</span> <span>通过<code>true</code>表示必须写入文件的内容和元数据的更新，通常需要至少一个I / O操作。</span> <span>该参数实际上是否具有任何效果取决于底层操作系统，因此未指定。</span> </p>
<p> <span>调用此方法可能会导致I / O操作发生，即使通道仅打开读取。</span> <span>例如，某些操作系统将最后访问时间作为文件的元数据的一部分进行维护，并且每次读取文件时都会更新此时间。</span> <span>这是否实际上是系统依赖的，因此是未指定的。</span> </p>
<p> <span>此方法只能通过此类中定义的方法强制对此通道文件进行的更改。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>metaData</code> - 如果<code>true</code>那么需要这种方法强制更改文件的内容和要写入存储的元数据;</span>
<span>否则，它只需要强制更改内容</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/nio/channels/ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此通道关闭 
           </dd>
<dd>
<code><a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他I / O错误 
           </dd>
</dl> </li>
</ul> <a name="lock-long-long-boolean-java.lang.Object-java.nio.channels.CompletionHandler-">
<!-- --> </a><a name="lock-long-long-boolean-A-java.nio.channels.CompletionHandler-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>lock</h4> <pre>public abstract &lt;A&gt; void lock(long position,
                              long size,
                              boolean shared,
                              A attachment,
                              <a href="../../../java/nio/channels/CompletionHandler.html" title="interface in java.nio.channels">CompletionHandler</a>&lt;<a href="../../../java/nio/channels/FileLock.html" title="class in java.nio.channels">FileLock</a>,? super A&gt; handler)</pre>
<div class="block">
<span>获取此通道文件的给定区域的锁定。</span>
<p> <span>该方法启动一个操作，以获取此通道文件的给定区域的锁定。</span> <span><code>handler</code>参数是在获取锁定时（或操作失败）时调用的完成处理程序。</span> <span>结果传递给完成处理程序是由此产生的<code>FileLock</code> 。</span> </p>
<p> <span>由<code>position</code>和<code>size</code>区域不需要包含在实际的底层文件内，甚至与实际的底层文件重叠。</span> <span>锁定区域的大小固定;</span> <span>如果锁定区域最初包含文件的结尾，并且文件增长超出该区域，那么该文件的新部分将不会被该锁覆盖。</span> <span>如果文件的大小增加，并且整个文件都需要锁定，则应该锁定从零开始并且不小于文件的预期最大大小的区域。</span> <span>双参数<a href="../../../java/nio/channels/AsynchronousFileChannel.html#lock-A-java.nio.channels.CompletionHandler-"><code>lock(Object,CompletionHandler)</code></a>方法简单地锁定一个大小为<a href="../../../java/lang/Long.html#MAX_VALUE"><code>Long.MAX_VALUE</code></a>的区域。</span> <span>如果与该请求的区域重叠的锁已被该Java虚拟机保存，或者已调用此方法来锁定重叠区域，并且该操作尚未完成，则该方法将抛出<a href="../../../java/nio/channels/OverlappingFileLockException.html" title="java.nio.channels中的类"><code>OverlappingFileLockException</code></a> 。</span> </p>
<p> <span>某些操作系统不支持以异步方式获取文件锁的机制。</span> <span>因此，实现可以获取后台线程中的文件锁或从相关线程池中的线程执行的任务获取。</span> <span>如果有许多锁定操作未完成，那么可能会在Java虚拟机中消耗线程无限期。</span> </p>
<p> <span>某些操作系统不支持共享锁，在这种情况下，共享锁的请求将自动转换为独占锁的请求。</span> <span>新获取的锁是共享的还是独占的都可以通过调用生成的锁对象的<a href="../../../java/nio/channels/FileLock.html#isShared--"><code>isShared</code></a>方法进行测试。</span> </p>
<p> <span>文件锁代表整个Java虚拟机。</span> <span>它们不适用于通过同一虚拟机中的多个线程来控制对文件的访问。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>A</code> - 
            <code>A</code>的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>position</code> - 锁定区域要启动的位置;</span>
<span>必须是非负的</span>
</dd>
<dd>
<span><code>size</code> - 锁定区域的大小;</span>
<span>必须是非负数，并且总和<code>position</code> + <code>size</code>必须是非负数</span>
</dd>
<dd>
<span><code>shared</code> - <code>true</code>以请求共享锁，在这种情况下，该通道必须打开才能读取（可能写入）;</span>
<span><code>false</code>要求排他锁，在这种情况下，该通道必须打开才能写入（可能读取）</span>
</dd>
<dd>
<span><code>attachment</code> - 要附加到I / O操作的对象;</span>
<span>可以<code>null</code></span>
</dd>
<dd>
<code>handler</code> - 消耗结果的处理程序 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/nio/channels/OverlappingFileLockException.html" title="class in java.nio.channels">OverlappingFileLockException</a></code> - 如果与该请求区域重叠的锁已由该Java虚拟机保留，或者已经有一个挂起尝试锁定重叠区域 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果参数的前提条件不成立 
           </dd>
<dd>
<code><a href="../../../java/nio/channels/NonReadableChannelException.html" title="class in java.nio.channels">NonReadableChannelException</a></code> - 如果 
            <code>shared</code>是真的，但这个频道没有打开阅读 
           </dd>
<dd>
<code><a href="../../../java/nio/channels/NonWritableChannelException.html" title="class in java.nio.channels">NonWritableChannelException</a></code> - 如果 
            <code>shared</code>为false，但此通道未打开以进行写入 
           </dd>
</dl> </li>
</ul> <a name="lock-java.lang.Object-java.nio.channels.CompletionHandler-">
<!-- --> </a><a name="lock-A-java.nio.channels.CompletionHandler-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>lock</h4> <pre>public final &lt;A&gt; void lock(A attachment,
                           <a href="../../../java/nio/channels/CompletionHandler.html" title="interface in java.nio.channels">CompletionHandler</a>&lt;<a href="../../../java/nio/channels/FileLock.html" title="class in java.nio.channels">FileLock</a>,? super A&gt; handler)</pre>
<div class="block">
<span>获取此通道文件的排他锁。</span>
<p> <span>该方法启动一个操作，以获取此通道文件的给定区域的锁定。</span> <span><code>handler</code>参数是一个在获取锁定时调用的完成处理程序（或操作失败）。</span> <span>结果传递给完成处理程序是由此产生的<code>FileLock</code> 。</span> </p>
<p> <span>调用此方法的形式为<code>ch.lock(att,handler)</code>行为方式与调用完全相同</span> </p>
<pre>  <span>ch.<a href="../../../java/nio/channels/AsynchronousFileChannel.html#lock-long-long-boolean-A-java.nio.channels.CompletionHandler-"><code>lock</code></a>(0L, Long.MAX_VALUE, false, att, handler)</span> </pre>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>A</code> - 
            <code>A</code>的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>attachment</code> - 要附加到I / O操作的对象;</span>
<span>可以是<code>null</code></span>
</dd>
<dd>
<code>handler</code> - 消费结果的处理程序 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/nio/channels/OverlappingFileLockException.html" title="class in java.nio.channels">OverlappingFileLockException</a></code> - 如果此Java虚拟机已经保存了锁定，或者已经有一个挂起尝试锁定一个区域 
           </dd>
<dd>
<code><a href="../../../java/nio/channels/NonWritableChannelException.html" title="class in java.nio.channels">NonWritableChannelException</a></code> - 如果此通道未打开以进行写入 
           </dd>
</dl> </li>
</ul> <a name="lock-long-long-boolean-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>lock</h4> <pre>public abstract <a href="../../../java/util/concurrent/Future.html" title="interface in java.util.concurrent">Future</a>&lt;<a href="../../../java/nio/channels/FileLock.html" title="class in java.nio.channels">FileLock</a>&gt; lock(long position,
                                      long size,
                                      boolean shared)</pre>
<div class="block">
<span>获取此通道文件的给定区域的锁定。</span>
<p> <span>该方法启动一个操作，以获取此通道文件的给定区域的锁定。</span> <span>该方法的行为方式与<a href="../../../java/nio/channels/AsynchronousFileChannel.html#lock-long-long-boolean-A-java.nio.channels.CompletionHandler-"><code>lock(long, long, boolean, Object, CompletionHandler)</code></a>方法完全相同，不同的是，该方法不是指定完成处理程序，而是返回一个<code>Future</code>待处理结果的<code>Future</code> 。</span> <span><code>Future</code>的<a href="../../../java/util/concurrent/Future.html#get--"><code>get</code></a>方法返回<a href="../../../java/nio/channels/FileLock.html" title="java.nio.channels中的类"><code>FileLock</code></a>成功完成。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>position</code> - 锁定区域要启动的位置;</span>
<span>必须是非负的</span>
</dd>
<dd>
<span><code>size</code> - 锁定区域的大小;</span>
<span>必须是非负数，并且总和<code>position</code> + <code>size</code>必须是非负数</span>
</dd>
<dd>
<span><code>shared</code> - <code>true</code>以请求共享锁，在这种情况下，该通道必须打开才能读取（可能写入）;</span>
<span><code>false</code>要求排他锁，在这种情况下，此通道必须打开以进行写入（可能读取）</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             表示待处理结果的 
            <code>Future</code>对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/nio/channels/OverlappingFileLockException.html" title="class in java.nio.channels">OverlappingFileLockException</a></code> - 如果此Java虚拟机已经保留了锁定，或者已经有一个暂停尝试锁定一个区域 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果参数的前提条件不成立 
           </dd>
<dd>
<code><a href="../../../java/nio/channels/NonReadableChannelException.html" title="class in java.nio.channels">NonReadableChannelException</a></code> - 如果 
            <code>shared</code>是真的，但这个频道没有打开阅读 
           </dd>
<dd>
<code><a href="../../../java/nio/channels/NonWritableChannelException.html" title="class in java.nio.channels">NonWritableChannelException</a></code> - 如果 
            <code>shared</code>为假，但此通道未打开以进行写入 
           </dd>
</dl> </li>
</ul> <a name="lock--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>lock</h4> <pre>public final <a href="../../../java/util/concurrent/Future.html" title="interface in java.util.concurrent">Future</a>&lt;<a href="../../../java/nio/channels/FileLock.html" title="class in java.nio.channels">FileLock</a>&gt; lock()</pre>
<div class="block">
<span>获取此通道文件的排他锁。</span>
<p> <span>此方法启动一个操作来获取该通道文件的排他锁。</span> <span>该方法返回一个<code>Future</code>表示该操作的待处理结果。</span> <span><code>Future</code>的<a href="../../../java/util/concurrent/Future.html#get--"><code>get</code></a>方法在<a href="../../../java/nio/channels/FileLock.html" title="java.nio.channels中的类">成功完成</a>后返回<code>FileLock</code>。</span> </p>
<p> <span>调用此方法的行为方式与调用完全相同</span> </p>
<pre>  <span>ch.<a href="../../../java/nio/channels/AsynchronousFileChannel.html#lock-long-long-boolean-"><code>lock</code></a>(0L, Long.MAX_VALUE, false)</span> </pre>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             表示待处理结果的 
            <code>Future</code>对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/nio/channels/OverlappingFileLockException.html" title="class in java.nio.channels">OverlappingFileLockException</a></code> - 如果此Java虚拟机已经保持锁定，或者已经有一个暂停尝试锁定一个区域 
           </dd>
<dd>
<code><a href="../../../java/nio/channels/NonWritableChannelException.html" title="class in java.nio.channels">NonWritableChannelException</a></code> - 如果这个频道没有开放写作 
           </dd>
</dl> </li>
</ul> <a name="tryLock-long-long-boolean-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>tryLock</h4> <pre>public abstract <a href="../../../java/nio/channels/FileLock.html" title="class in java.nio.channels">FileLock</a> tryLock(long position,
                                 long size,
                                 boolean shared)
                          throws <a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></pre>
<div class="block">
<span>尝试获取此通道文件的给定区域的锁定。</span>
<p> <span>此方法不阻止。</span> <span>调用总是立即返回，要么获取了请求的区域的锁定，要么没有这样做。</span> <span>如果由于重叠锁由另一个程序持有而无法获取锁定，则返回<code>null</code> 。</span> <span>如果由于任何其他原因无法获取锁，则抛出适当的异常。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>position</code> - 锁定区域要启动的位置;</span>
<span>必须是非负的</span>
</dd>
<dd>
<span><code>size</code> - 锁定区域的大小;</span>
<span>必须是非负数，并且总和<code>position</code> + <code>size</code>必须是非负数</span>
</dd>
<dd>
<code>shared</code> - 
            <code>true</code>要求共享锁， 
            <code>false</code>要求排他锁 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             表示新获取的锁的锁定对象，如果由于另一个程序持有重叠的锁而无法获取锁， 
            <code>null</code> null 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果参数的前提条件不成立 
           </dd>
<dd>
<code><a href="../../../java/nio/channels/ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此通道关闭 
           </dd>
<dd>
<code><a href="../../../java/nio/channels/OverlappingFileLockException.html" title="class in java.nio.channels">OverlappingFileLockException</a></code> - 如果与该请求区域重叠的锁已由该Java虚拟机保留，或者该方法中已经阻止了另一个线程，并尝试锁定同一文件的重叠区域 
           </dd>
<dd>
<code><a href="../../../java/nio/channels/NonReadableChannelException.html" title="class in java.nio.channels">NonReadableChannelException</a></code> - 如果 
            <code>shared</code>是真的，但这个频道没有打开阅读 
           </dd>
<dd>
<code><a href="../../../java/nio/channels/NonWritableChannelException.html" title="class in java.nio.channels">NonWritableChannelException</a></code> - 如果 
            <code>shared</code>为false，但此通道未打开以进行写入 
           </dd>
<dd>
<code><a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他I / O错误 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/nio/channels/AsynchronousFileChannel.html#lock-A-java.nio.channels.CompletionHandler-"><code>lock(Object,CompletionHandler)</code></a> ， 
            <a href="../../../java/nio/channels/AsynchronousFileChannel.html#lock-long-long-boolean-A-java.nio.channels.CompletionHandler-"><code>lock(long,long,boolean,Object,CompletionHandler)</code></a> ， 
            <a href="../../../java/nio/channels/AsynchronousFileChannel.html#tryLock--"><code>tryLock()</code></a>
</dd>
</dl> </li>
</ul> <a name="tryLock--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>tryLock</h4> <pre>public final <a href="../../../java/nio/channels/FileLock.html" title="class in java.nio.channels">FileLock</a> tryLock()
                       throws <a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></pre>
<div class="block">
<span>尝试获取此频道文件的排他锁。</span>
<p> <span>调用此方法的形式为<code>ch.tryLock()</code>行为方式与调用完全相同</span> </p>
<pre>  <span>ch.<a href="../../../java/nio/channels/AsynchronousFileChannel.html#tryLock-long-long-boolean-"><code>tryLock</code></a>(0L, Long.MAX_VALUE, false)</span> </pre>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             表示新获取的锁的锁定对象，如果由于另一个程序持有重叠的锁而无法获取锁， 
            <code>null</code> null 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/nio/channels/ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此通道关闭 
           </dd>
<dd>
<code><a href="../../../java/nio/channels/OverlappingFileLockException.html" title="class in java.nio.channels">OverlappingFileLockException</a></code> - 如果与该请求区域重叠的锁已由该Java虚拟机保留，或者该方法中已阻止另一个线程，并尝试锁定重叠区域 
           </dd>
<dd>
<code><a href="../../../java/nio/channels/NonWritableChannelException.html" title="class in java.nio.channels">NonWritableChannelException</a></code> - 如果 
            <code>shared</code>为false，但此通道未打开以进行写入 
           </dd>
<dd>
<code><a href="../../../java/io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他I / O错误 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/nio/channels/AsynchronousFileChannel.html#lock-A-java.nio.channels.CompletionHandler-"><code>lock(Object,CompletionHandler)</code></a> ， 
            <a href="../../../java/nio/channels/AsynchronousFileChannel.html#lock-long-long-boolean-A-java.nio.channels.CompletionHandler-"><code>lock(long,long,boolean,Object,CompletionHandler)</code></a> ， 
            <a href="../../../java/nio/channels/AsynchronousFileChannel.html#tryLock-long-long-boolean-"><code>tryLock(long,long,boolean)</code></a>
</dd>
</dl> </li>
</ul> <a name="read-java.nio.ByteBuffer-long-java.lang.Object-java.nio.channels.CompletionHandler-">
<!-- --> </a><a name="read-java.nio.ByteBuffer-long-A-java.nio.channels.CompletionHandler-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>read</h4> <pre>public abstract &lt;A&gt; void read(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a> dst,
                              long position,
                              A attachment,
                              <a href="../../../java/nio/channels/CompletionHandler.html" title="interface in java.nio.channels">CompletionHandler</a>&lt;<a href="../../../java/lang/Integer.html" title="class in java.lang">Integer</a>,? super A&gt; handler)</pre>
<div class="block">
<span>从给定的文件位置开始，从该通道读取一个字节序列到给定的缓冲区。</span>
<p> <span>该方法从给定的文件位置开始从该通道读取字节序列到给定的缓冲区。</span> <span>读取的结果是读取的字节数或<code>-1</code>如果给定位置大于或等于尝试读取时文件的大小。</span> </p>
<p> <span>此方法的工作原理与<a href="../../../java/nio/channels/AsynchronousByteChannel.html#read-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-"><code>AsynchronousByteChannel.read(ByteBuffer,Object,CompletionHandler)</code></a>方法相同，只是从给定的文件位置开始读取字节。</span> <span>如果给定的文件位置大于尝试读取时的文件大小，则不会读取任何字节。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>A</code> - 
            <code>A</code>的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>dst</code> - 要传输字节的缓冲区 
           </dd>
<dd>
<span><code>position</code> - 传输开始的文件位置;</span>
<span>必须是非负的</span>
</dd>
<dd>
<span><code>attachment</code> - 要附加到I / O操作的对象;</span>
<span>可以是<code>null</code></span>
</dd>
<dd>
<code>handler</code> - 消费结果的处理程序 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果位置为负或缓冲区为只读 
           </dd>
<dd>
<code><a href="../../../java/nio/channels/NonReadableChannelException.html" title="class in java.nio.channels">NonReadableChannelException</a></code> - 如果此通道未打开阅读 
           </dd>
</dl> </li>
</ul> <a name="read-java.nio.ByteBuffer-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>read</h4> <pre>public abstract <a href="../../../java/util/concurrent/Future.html" title="interface in java.util.concurrent">Future</a>&lt;<a href="../../../java/lang/Integer.html" title="class in java.lang">Integer</a>&gt; read(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a> dst,
                                     long position)</pre>
<div class="block">
<span>从给定的文件位置开始，从该通道读取一个字节序列到给定的缓冲区。</span>
<p> <span>该方法从给定的文件位置开始从该通道读取字节序列到给定的缓冲区。</span> <span>此方法返回一个<code>Future</code>表示操作的待处理结果。</span> <span><code>Future</code>的<a href="../../../java/util/concurrent/Future.html#get--"><code>get</code></a>方法返回读取的字节数或<code>-1</code>如果给定的位置大于或等于尝试读取时文件的大小。</span> </p>
<p> <span>该方法的工作原理与<a href="../../../java/nio/channels/AsynchronousByteChannel.html#read-java.nio.ByteBuffer-"><code>AsynchronousByteChannel.read(ByteBuffer)</code></a>方法相同，只是从给定文件位置开始读取字节。</span> <span>如果给定的文件位置大于尝试读取时的文件大小，则不会读取任何字节。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>dst</code> - 要传输字节的缓冲区 
           </dd>
<dd>
<span><code>position</code> - 传输开始的文件位置;</span>
<span>必须是非负的</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             表示待处理结果的 
            <code>Future</code>对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果位置为负或缓冲区为只读 
           </dd>
<dd>
<code><a href="../../../java/nio/channels/NonReadableChannelException.html" title="class in java.nio.channels">NonReadableChannelException</a></code> - 如果此频道未打开阅读 
           </dd>
</dl> </li>
</ul> <a name="write-java.nio.ByteBuffer-long-java.lang.Object-java.nio.channels.CompletionHandler-">
<!-- --> </a><a name="write-java.nio.ByteBuffer-long-A-java.nio.channels.CompletionHandler-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>write</h4> <pre>public abstract &lt;A&gt; void write(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a> src,
                               long position,
                               A attachment,
                               <a href="../../../java/nio/channels/CompletionHandler.html" title="interface in java.nio.channels">CompletionHandler</a>&lt;<a href="../../../java/lang/Integer.html" title="class in java.lang">Integer</a>,? super A&gt; handler)</pre>
<div class="block">
<span>从给定的缓冲区向给定的文件位置开始，向该通道写入一个字节序列。</span>
<p> <span>该方法的工作原理与<a href="../../../java/nio/channels/AsynchronousByteChannel.html#write-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-"><code>AsynchronousByteChannel.write(ByteBuffer,Object,CompletionHandler)</code></a>方法相同，只是字节从给定文件位置开始写入。</span> <span>如果给定的位置大于文件的大小，则在尝试写入时，该文件将生长以适应新的字节;</span> <span>未指定上一个文件结尾和新写入的字节之间的任何字节的值。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>A</code> - 
            <code>A</code>的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>src</code> - 要传输字节的缓冲区 
           </dd>
<dd>
<span><code>position</code> - 传输开始的文件位置;</span>
<span>必须是非负的</span>
</dd>
<dd>
<span><code>attachment</code> - 要附加到I / O操作的对象;</span>
<span>可以是<code>null</code></span>
</dd>
<dd>
<code>handler</code> - 消费结果的处理程序 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果位置为负 
           </dd>
<dd>
<code><a href="../../../java/nio/channels/NonWritableChannelException.html" title="class in java.nio.channels">NonWritableChannelException</a></code> - 如果这个频道没有开放写作 
           </dd>
</dl> </li>
</ul> <a name="write-java.nio.ByteBuffer-long-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>write</h4> <pre>public abstract <a href="../../../java/util/concurrent/Future.html" title="interface in java.util.concurrent">Future</a>&lt;<a href="../../../java/lang/Integer.html" title="class in java.lang">Integer</a>&gt; write(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a> src,
                                      long position)</pre>
<div class="block">
<span>从给定的缓冲区向给定的文件位置开始，向该通道写入一个字节序列。</span>
<p> <span>该方法从给定的缓冲区开始向该通道写入字节序列，从给定的文件位置开始。</span> <span>该方法返回一个<code>Future</code> ，表示写入操作的待处理结果。</span> <span><code>Future</code>的<a href="../../../java/util/concurrent/Future.html#get--"><code>get</code></a>方法返回写入的字节数。</span> </p>
<p> <span>该方法的工作原理与<a href="../../../java/nio/channels/AsynchronousByteChannel.html#write-java.nio.ByteBuffer-"><code>AsynchronousByteChannel.write(ByteBuffer)</code></a>方法相同，只是字节从给定文件位置开始写入。</span> <span>如果给定的位置大于文件的大小，则在尝试写入时，该文件将生长以适应新的字节;</span> <span>未指定上一个文件结尾和新写入的字节之间的任何字节的值。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>src</code> - 要传输字节的缓冲区 
           </dd>
<dd>
<span><code>position</code> - 传输开始的文件位置;</span>
<span>必须是非负的</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             表示待处理结果的 
            <code>Future</code>对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果位置为负 
           </dd>
<dd>
<code><a href="../../../java/nio/channels/NonWritableChannelException.html" title="class in java.nio.channels">NonWritableChannelException</a></code> - 如果这个频道没有开放写作 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>