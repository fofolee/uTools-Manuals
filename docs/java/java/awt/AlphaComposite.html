<div class="header">
<div class="subTitle">
     java.awt 
   </div>
<h2 class="title" title="Class AlphaComposite">Class AlphaComposite</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.awt.AlphaComposite</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
         All Implemented Interfaces: 
       </dt>
<dd>
<span><a href="../../java/awt/Composite.html" title="java.awt中的接口">Composite</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public final class <span class="typeNameLabel">AlphaComposite</span>
extends <a href="../../java/lang/Object.html" title="class in java.lang">Object</a>
implements <a href="../../java/awt/Composite.html" title="interface in java.awt">Composite</a></pre>
<div class="block">
<span><code>AlphaComposite</code>类实现了基本的alpha合成规则，用于组合源和目标颜色，以实现图形和图像的混合和透明效果。</span>
<span>该类实施的具体规则是T.Porter和T.Duff（“Compositing Digital Images”，SIGGRAPH 84,253-259）中描述的12个规则的基本集合。</span>
<span>本文档的其余部分假定您熟悉该文章中概述的定义和概念。</span>
<p> <span>该类扩展了由波特和达夫定义的标准方程，以包括一个附加因素。</span> <span><code>AlphaComposite</code>类的一个实例可以包含一个alpha值，用于在混合方程中使用之前修改每个源像素的不透明度或覆盖率。</span> </p>
<p> <span>重要的是要注意，由波特和达夫纸定义的方程式都被定义为对由其对应的α分量预乘的颜色分量进行操作。</span> <span>由于<code>ColorModel</code>和<code>Raster</code>类允许以预乘或非预乘形式存储像素数据，所以在应用方程之前，所有输入数据必须被归一化为预乘形式，并且所有结果可能需要调整回目标所需的形式在存储像素值之前。</span> </p>
<p> <span>还要注意，这个类只定义了纯粹数学意义上的颜色和alpha值的组合方程式。</span> <span>其方程的准确应用取决于数据从其来源检索并存储在其目的地的方式。</span> <span>见<a href="#caveats">Implementation Caveats</a>了解更多信息。</span> </p>
<p> <span>Porter和Duff论文中的混合方程的描述中使用了以下因素：</span> </p>
<blockquote>
<span>
<table summary="layout">
<tbody>
<tr>
<th align="left">Factor  </th>
<th align="left">Definition </th>
</tr>
<tr>
<td><em>A<sub>s</sub></em></td>
<td>the alpha component of the source pixel </td>
</tr>
<tr>
<td><em>C<sub>s</sub></em></td>
<td>a color component of the source pixel in premultiplied form </td>
</tr>
<tr>
<td><em>A<sub>d</sub></em></td>
<td>the alpha component of the destination pixel </td>
</tr>
<tr>
<td><em>C<sub>d</sub></em></td>
<td>a color component of the destination pixel in premultiplied form </td>
</tr>
<tr>
<td><em>F<sub>s</sub></em></td>
<td>the fraction of the source pixel that contributes to the output </td>
</tr>
<tr>
<td><em>F<sub>d</sub></em></td>
<td>the fraction of the destination pixel that contributes to the output </td>
</tr>
<tr>
<td><em>A<sub>r</sub></em></td>
<td>the alpha component of the result </td>
</tr>
<tr>
<td><em>C<sub>r</sub></em></td>
<td>a color component of the result in premultiplied form </td>
</tr>
</tbody>
</table></span>
</blockquote>
<p> <span>使用这些因素，Porter和Duff定义了12种选择混合因子<em>F <sub>s</sub></em>和<em>F <sub>d</sub></em>以产生12种期望的视觉效果的方式。</span> <span>用于确定<em>F <sub>s</sub></em>和<em>F <sub>d</sub></em>的方程式在指定视觉效果的12个静态场的描述中给出。</span> <span>例如，<code>SRC_OVER</code>的<a href="#SRC_OVER">描述</a>规定<em>F <sub>s</sub></em> = 1和<em>F <sub>d</sub></em> =（1- <em>A <sub>s</sub></em> ）。</span> <span>一旦确定混合因子的一组方程是已知的，则可以使用以下一组方程将其应用于每个像素以产生结果：</span> </p>
<pre>  <span><em>F<sub>s</sub></em> = <em>f</em>(<em>A<sub>d</sub></em>)
      <em>F<sub>d</sub></em> = <em>f</em>(<em>A<sub>s</sub></em>)
      <em>A<sub>r</sub></em> = <em>A<sub>s</sub></em>*<em>F<sub>s</sub></em> + <em>A<sub>d</sub></em>*<em>F<sub>d</sub></em>
      <em>C<sub>r</sub></em> = <em>C<sub>s</sub></em>*<em>F<sub>s</sub></em> + <em>C<sub>d</sub></em>*<em>F<sub>d</sub></em></span> </pre>
<p> <span>以下因素将用于讨论我们在波特和达夫论文中对混合方程的扩展：</span> </p>
<blockquote>
<span>
<table summary="layout">
<tbody>
<tr>
<th align="left">Factor  </th>
<th align="left">Definition </th>
</tr>
<tr>
<td><em>C<sub>sr</sub></em> </td>
<td>one of the raw color components of the source pixel </td>
</tr>
<tr>
<td><em>C<sub>dr</sub></em> </td>
<td>one of the raw color components of the destination pixel </td>
</tr>
<tr>
<td><em>A<sub>ac</sub></em> </td>
<td>the "extra" alpha component from the AlphaComposite instance </td>
</tr>
<tr>
<td><em>A<sub>sr</sub></em> </td>
<td>the raw alpha component of the source pixel </td>
</tr>
<tr>
<td><em>A<sub>dr</sub></em></td>
<td>the raw alpha component of the destination pixel </td>
</tr>
<tr>
<td><em>A<sub>df</sub></em> </td>
<td>the final alpha component stored in the destination </td>
</tr>
<tr>
<td><em>C<sub>df</sub></em> </td>
<td>the final raw color component stored in the destination </td>
</tr>
</tbody>
</table></span>
</blockquote>
<h3> <span>准备输入</span> </h3>
<p> <span><code>AlphaComposite</code>类定义了一个应用于源alpha的附加alpha值。</span> <span>仿佛隐式SRC_IN规则的由两个原始源α和通过在所述α的原始源颜色乘以第一施加到源极的像素对的像素与所指示的阿尔法此值被应用于<code>AlphaComposite</code> 。</span> <span>这导致了用于生成波特和Duff混合方程中使用的α的以下等式：</span> </p>
<pre>  <span><em>A<sub>s</sub></em> = <em>A<sub>sr</sub></em> * <em>A<sub>ac</sub></em></span> </pre>
<span>所有原始源颜色组件都需要<code>AlphaComposite</code>实例中的alpha。</span>
<span>另外，如果源不是预乘式形式，则颜色分量也需要乘以源alpha。</span>
<span>因此，用于产生Porter和Duff方程的源颜色分量的方程取决于源像素是否被预乘：</span>
<pre>  <span><em>C<sub>s</sub></em> = <em>C<sub>sr</sub></em> * <em>A<sub>sr</sub></em> * <em>A<sub>ac</sub></em>     (if source is not premultiplied)
      <em>C<sub>s</sub></em> = <em>C<sub>sr</sub></em> * <em>A<sub>ac</sub></em>           (if source is premultiplied)</span> </pre>
<span>不需要对目的地alpha进行调整：</span>
<pre>  <span><em>A<sub>d</sub></em> = <em>A<sub>dr</sub></em></span> </pre>
<p> <span>目的色组件只有在不是预加载形式时才需要调整：</span> </p>
<pre>  <span><em>C<sub>d</sub></em> = <em>C<sub>dr</sub></em> * <em>A<sub>d</sub></em>    (if destination is not premultiplied)
      <em>C<sub>d</sub></em> = <em>C<sub>dr</sub></em>         (if destination is premultiplied)</span> </pre>
<h3> <span>应用混合方程</span> </h3>
<p> <span>调整后的<em>A <sub>s</sub></em> ， <em>A <sub>d</sub></em> ， <em>C <sub>s</sub></em>和<em>C <sub>d</sub></em>用于标准Porter和Duff方程中，以计算混合因子<em>F <sub>s</sub></em>和<em>F <sub>d</sub></em> ，然后计算得到的预乘积分量<em>A <sub>r</sub></em>和<em>C <sub>r</sub></em> 。</span> </p>
<h3> <span>准备结果</span> </h3>
<p> <span>如果要将其存储回保存未预乘数据的目标缓冲区，则使用以下等式，才需要调整结果：</span> </p>
<pre>  <span><em>A<sub>df</sub></em> = <em>A<sub>r</sub></em>
      <em>C<sub>df</sub></em> = <em>C<sub>r</sub></em>                 (if dest is premultiplied)
      <em>C<sub>df</sub></em> = <em>C<sub>r</sub></em> / <em>A<sub>r</sub></em>            (if dest is not premultiplied)</span> </pre>
<span>请注意，由于如果所得到的alpha为零，则除法是未定义的，因此省略了这种情况下的划分，以避免“除以零”，并将颜色分量保留为全零。</span>
<h3> <span>绩效注意事项</span> </h3>
<p> <span>由于性能的原因，优选的是<code>Raster</code>传递给对象<code>compose</code>一个的方法<a href="../../java/awt/CompositeContext.html" title="java.awt中的接口"><code>CompositeContext</code></a>由所创建的对象<code>AlphaComposite</code>类已经预乘数据。</span> <span>但是，如果源<code>Raster</code>或目的地<code>Raster</code>尚未预乘，则在合成操作之前和之后执行适当的转换。</span> </p>
<h3> <span><a name="caveats">Implementation Caveats</a></span> </h3>
<ul>
<li> <span>许多来源，例如<code>BufferedImage</code>类中列出的一些不透明图像类型，不会为其像素存储alpha值。</span> <span>这些资源为其所有像素提供了一个1.0的alpha。</span> </li>
<li> <span>许多目的地也没有地方存储由这个类执行的混合计算产生的alpha值。</span> <span>因此，这样的目的地隐含地丢弃了该类产生的所得到的alpha值。</span> <span>建议这样的目的地应将其存储的颜色值视为非预乘数，并在存储颜色值和舍弃Alpha值之前将所得到的颜色值除以所得到的alpha值。</span> </li>
<li> <span>结果的准确性取决于像素在目的地中的存储方式。</span> <span>每种颜色和alpha组件提供至少8位存储的图像格式至少足以用作几到十几个合成操作的序列的目的地。</span> <span>在舍入误差占主导地位的情况下，每个组件的存储容量少于8位的映像格式在一个或两个合成操作中的用途有限。</span> <span>不分开存储颜色分量的图像格式不是任何类型的半透明混合的好选择。</span> <span>例如， <code>BufferedImage.TYPE_BYTE_INDEXED</code>不应该用作混合操作的目的地，因为每个操作都可能引入大的错误，因为需要从受限调色板中选择一个像素以匹配混合方程的结果。</span> </li>
<li> <span>几乎所有格式都将像素作为离散整数存储，而不是上述参考方程式中使用的浮点值。</span> <span>该实现可以将整数像素值缩放到范围为0.0到1.0的浮点值，或者使用完全在整数域中运行的等式的稍微修改后的版本，并且产生与参考方程式的类似结果。</span> <p> <span>通常，整数值与浮点值相关，使得整数0等于浮点值0.0和整数2 ^ <em>n</em> -1（其中<em>n</em>是表示中的位数）等于1.0。</span> <span>对于8位表示，这意味着0x00表示0.0，0xff表示1.0。</span> </p></li>
<li> <span>内部实现可以近似一些方程，并且还可以消除一些步骤以避免不必要的操作。</span> <span>例如，考虑使用非预乘α值的离散整数图像，每个组件使用8位存储。</span> <span>几乎透明的黑色红色的存储值可能是：</span> <pre>  <span>(A, R, G, B) = (0x01, 0xb0, 0x00, 0x00)</span> </pre><p> <span>如果正在使用整数数学，并且该值在<a href="#SRC"><code>SRC</code></a>模式下被合成，没有额外的alpha，则数学将表明结果为（整数格式）：</span> </p><pre>  <span>(A, R, G, B) = (0x01, 0x01, 0x00, 0x00)</span> </pre><p> <span>请注意，始终处于预乘形式的中间值只允许整数红色分量为0x00或0x01。</span> <span>当我们尝试将这个结果存储回到不预乘的目的地时，除去alpha将给我们非常多的红色值的选择很少。</span> <span>在这种情况下，在没有快捷方式的情况下执行整数空间的数学的实现可能最终得到以下的最终像素值：</span> </p><pre>  <span>(A, R, G, B) = (0x01, 0xff, 0x00, 0x00)</span> </pre><p> <span>（请注意，0x01除以0x01给出1.0，这相当于8位存储格式的值0xff）</span> </p><p> <span>或者，使用浮点数学的实现可以产生更准确的结果，并且最终返回到原始像素值，几乎没有（如果有的话）舍入误差。</span> <span>或者，使用整数数学的实现可能会决定，如果在浮点空间中执行时，方程式可以转换为颜色值上的虚拟NOP，则可以将不受影响的像素传输到目标位置，并完全避免所有的数学运算。</span> </p><p> <span>这些实现都试图遵循相同的方程，但是使用整数和浮点数学以及简化或全方程的不同权衡。</span> <span>为了解决这种差异，最好只期望结果的预乘形式在实现和图像格式之间匹配。</span> <span>在这种情况下，以预乘方式表达的两个答案将等同于：</span> </p><pre>  <span>(A, R, G, B) = (0x01, 0x01, 0x00, 0x00)</span> </pre><p> <span>所以他们都会相配。</span> </p></li>
<li> <span>由于简化计算效率的方程式的技术，当在非预乘的目的地遇到0.0的结果α值时，一些实现可能会不同。</span> <span>请注意，如果分母（α）为0，则在SRC规则的情况下，通过alpha删除除法的简化在技术上是无效的。但是，由于只有在以预乘方式查看结果时，才应该预期结果是准确的， α的α基本上使得所得到的颜色成分无关紧要，因此在这种情况下不应期待确切的行为。</span> </li>
</ul>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/awt/Composite.html" title="java.awt中的接口"><code>Composite</code></a> ， <a href="../../java/awt/CompositeContext.html" title="java.awt中的接口"><code>CompositeContext</code></a></span>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!-- --> </a> <h3>Field Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Field Summary table, listing fields, and an explanation">
<caption>
<span>Fields</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#Clear">Clear</a></span></code>
<div class="block">
<code>AlphaComposite</code>对象实现不透明的CLEAR规则，其alpha为1.0f。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#CLEAR">CLEAR</a></span></code>
<div class="block">
              目的地的颜色和alpha都被清除（Porter-Duff Clear规则）。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#Dst">Dst</a></span></code>
<div class="block">
<code>AlphaComposite</code>对象实现不透明的DST规则，alpha为1.0f。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#DST">DST</a></span></code>
<div class="block">
              目的地保持不变（Porter-Duff目的地规则）。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#DST_ATOP">DST_ATOP</a></span></code>
<div class="block">
              位于源头的目的地的一部分在源上合成，并替换目的地（Porter-Duff Destination Atop Source规则）。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#DST_IN">DST_IN</a></span></code>
<div class="block">
              位于源代码内的目的地部分将替换目的地（Porter-Duff Destination In Source规则）。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#DST_OUT">DST_OUT</a></span></code>
<div class="block">
              位于源代码之外的目的地的一部分将替换目的地（Porter-Duff Destination Held Out By Source规则）。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#DST_OVER">DST_OVER</a></span></code>
<div class="block">
              目的地在源上合成，结果将替换目的地（Porter-Duff Destination Over Source规则）。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#DstAtop">DstAtop</a></span></code>
<div class="block">
<code>AlphaComposite</code>对象实现不透明的DST_ATOP规则，alpha为1.0f。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#DstIn">DstIn</a></span></code>
<div class="block">
<code>AlphaComposite</code>对象实现不透明的DST_IN规则，其alpha为1.0f。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#DstOut">DstOut</a></span></code>
<div class="block">
<code>AlphaComposite</code>对象实现不透明的DST_OUT规则，alpha为1.0f。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#DstOver">DstOver</a></span></code>
<div class="block">
<code>AlphaComposite</code>对象实现不透明的DST_OVER规则，其alpha为1.0f。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#Src">Src</a></span></code>
<div class="block">
<code>AlphaComposite</code>对象实现不透明的SRC规则，alpha为1.0f。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#SRC">SRC</a></span></code>
<div class="block">
              源被复制到目的地（Porter-Duff源规则）。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#SRC_ATOP">SRC_ATOP</a></span></code>
<div class="block">
              位于目的地内部的源的部分被合成到目的地（Porter-Duff Source Atop Destination rule）上。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#SRC_IN">SRC_IN</a></span></code>
<div class="block">
              位于目的地内部的源的一部分将替换目的地（Porter-Duff Source In Destination规则）。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#SRC_OUT">SRC_OUT</a></span></code>
<div class="block">
              位于目的地外部的源的部分取代了目的地（Porter-Duff Source Held Out By Destination规则）。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#SRC_OVER">SRC_OVER</a></span></code>
<div class="block">
              源在目的地（Porter-Duff Source Over Destination规则）上合成。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#SrcAtop">SrcAtop</a></span></code>
<div class="block">
<code>AlphaComposite</code>对象实现的alpha值为1.0f的不透明SRC_ATOP规则。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#SrcIn">SrcIn</a></span></code>
<div class="block">
<code>AlphaComposite</code>对象实现了alphaf为1.0f的不透明SRC_IN规则。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#SrcOut">SrcOut</a></span></code>
<div class="block">
<code>AlphaComposite</code>实现不透明的SRC_OUT规则，其alpha为1.0f。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#SrcOver">SrcOver</a></span></code>
<div class="block">
<code>AlphaComposite</code>对象实现的alpha值为1.0f的不透明SRC_OVER规则。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#Xor">Xor</a></span></code>
<div class="block">
<code>AlphaComposite</code>实现不透明XOR规则，对象的alpha为1.0f。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#XOR">XOR</a></span></code>
<div class="block">
              位于目的地外部的源的部分与位于源外的目标的部分（Porter-Duff Source Xor Destination rule）组合。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t1"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code><a href="../../java/awt/CompositeContext.html" title="interface in java.awt">CompositeContext</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#createContext-java.awt.image.ColorModel-java.awt.image.ColorModel-java.awt.RenderingHints-">createContext</a></span>(<a href="../../java/awt/image/ColorModel.html" title="class in java.awt.image">ColorModel</a> srcColorModel, <a href="../../java/awt/image/ColorModel.html" title="class in java.awt.image">ColorModel</a> dstColorModel, <a href="../../java/awt/RenderingHints.html" title="class in java.awt">RenderingHints</a> hints)</code>
<div class="block">
              创建合成操作的上下文。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code><a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#derive-float-">derive</a></span>(float alpha)</code>
<div class="block">
              返回一个类似的使用指定alpha值的 
             <code>AlphaComposite</code>对象。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code><a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#derive-int-">derive</a></span>(int rule)</code>
<div class="block">
              返回使用指定的合成规则的类似的 
             <code>AlphaComposite</code>对象。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#equals-java.lang.Object-">equals</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> obj)</code>
<div class="block">
              确定指定的对象是否等于此 
             <code>AlphaComposite</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#getAlpha--">getAlpha</a></span>()</code>
<div class="block">
              返回此值的alpha值 
             <code>AlphaComposite</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>static <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#getInstance-int-">getInstance</a></span>(int rule)</code>
<div class="block">
              使用指定的规则创建一个 
             <code>AlphaComposite</code>对象。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>static <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#getInstance-int-float-">getInstance</a></span>(int rule, float alpha)</code>
<div class="block">
              使用指定的规则创建一个 
             <code>AlphaComposite</code>对象，并将常量alpha与源的alpha进行乘法。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#getRule--">getRule</a></span>()</code>
<div class="block">
              返回此的合成规则 
             <code>AlphaComposite</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/AlphaComposite.html#hashCode--">hashCode</a></span>()</code>
<div class="block">
              返回此复合的哈希码。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../java/lang/Object.html#clone--">clone</a>, <a href="../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../java/lang/Object.html#notify--">notify</a>, <a href="../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../java/lang/Object.html#toString--">toString</a>, <a href="../../java/lang/Object.html#wait--">wait</a>, <a href="../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!-- --> </a> <h3>字段详细信息</h3> <a name="CLEAR">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>CLEAR</h4> <pre><a href="../../java/lang/annotation/Native.html" title="annotation in java.lang.annotation">@Native</a>
public static final int CLEAR</pre>
<div class="block">
<span>目的地的颜色和alpha都被清除（Porter-Duff Clear规则）。</span>
<span>源和目的地都不用作输入。</span>
<p> <span><em>F <sub>s</sub></em> = 0， <em>F <sub>d</sub></em> = 0，因此：</span> </p>
<pre>  <span><em>A<sub>r</sub></em> = 0
  <em>C<sub>r</sub></em> = 0</span> </pre>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.awt.AlphaComposite.CLEAR">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="SRC">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>SRC</h4> <pre><a href="../../java/lang/annotation/Native.html" title="annotation in java.lang.annotation">@Native</a>
public static final int SRC</pre>
<div class="block">
<span>源被复制到目的地（Porter-Duff源规则）。</span>
<span>目的地不用作输入。</span>
<p> <span><em>F <sub>s</sub></em> = 1， <em>F <sub>d</sub></em> = 0，因此：</span> </p>
<pre>  <span><em>A<sub>r</sub></em> = <em>A<sub>s</sub></em>
  <em>C<sub>r</sub></em> = <em>C<sub>s</sub></em></span> </pre>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.awt.AlphaComposite.SRC">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="DST">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>DST</h4> <pre><a href="../../java/lang/annotation/Native.html" title="annotation in java.lang.annotation">@Native</a>
public static final int DST</pre>
<div class="block">
<span>目的地保持不变（Porter-Duff目的地规则）。</span>
<p> <span><em>F <sub>s</sub></em> = 0且<em>F <sub>d</sub></em> = 1，因此：</span> </p>
<pre>  <span><em>A<sub>r</sub></em> = <em>A<sub>d</sub></em>
  <em>C<sub>r</sub></em> = <em>C<sub>d</sub></em></span> </pre>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.awt.AlphaComposite.DST">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="SRC_OVER">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>SRC_OVER</h4> <pre><a href="../../java/lang/annotation/Native.html" title="annotation in java.lang.annotation">@Native</a>
public static final int SRC_OVER</pre>
<div class="block">
<span>源在目的地（Porter-Duff Source Over Destination规则）上合成。</span>
<p> <span><em>F <sub>s</sub></em> = 1， <em>F <sub>d</sub></em> =（1- <em>A <sub>s</sub></em> ），因此：</span> </p>
<pre>  <span><em>A<sub>r</sub></em> = <em>A<sub>s</sub></em> + <em>A<sub>d</sub></em>*(1-<em>A<sub>s</sub></em>)
  <em>C<sub>r</sub></em> = <em>C<sub>s</sub></em> + <em>C<sub>d</sub></em>*(1-<em>A<sub>s</sub></em>)</span> </pre>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.awt.AlphaComposite.SRC_OVER">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="DST_OVER">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>DST_OVER</h4> <pre><a href="../../java/lang/annotation/Native.html" title="annotation in java.lang.annotation">@Native</a>
public static final int DST_OVER</pre>
<div class="block">
<span>目的地在源上合成，结果将替换目的地（Porter-Duff Destination Over Source规则）。</span>
<p> <span><em>F <sub>s</sub></em> =（1- <em>A <sub>d</sub></em> ）和<em>F <sub>d</sub></em> = 1，因此：</span> </p>
<pre>  <span><em>A<sub>r</sub></em> = <em>A<sub>s</sub></em>*(1-<em>A<sub>d</sub></em>) + <em>A<sub>d</sub></em>
  <em>C<sub>r</sub></em> = <em>C<sub>s</sub></em>*(1-<em>A<sub>d</sub></em>) + <em>C<sub>d</sub></em></span> </pre>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.awt.AlphaComposite.DST_OVER">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="SRC_IN">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>SRC_IN</h4> <pre><a href="../../java/lang/annotation/Native.html" title="annotation in java.lang.annotation">@Native</a>
public static final int SRC_IN</pre>
<div class="block">
<span>位于目的地内部的源的一部分将替换目的地（Porter-Duff Source In Destination规则）。</span>
<p> <span><em>F <sub>s</sub></em> = <em>A <sub>d</sub></em> ， <em>F <sub>d</sub></em> = 0，因此：</span> </p>
<pre>  <span><em>A<sub>r</sub></em> = <em>A<sub>s</sub></em>*<em>A<sub>d</sub></em>
  <em>C<sub>r</sub></em> = <em>C<sub>s</sub></em>*<em>A<sub>d</sub></em></span> </pre>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.awt.AlphaComposite.SRC_IN">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="DST_IN">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>DST_IN</h4> <pre><a href="../../java/lang/annotation/Native.html" title="annotation in java.lang.annotation">@Native</a>
public static final int DST_IN</pre>
<div class="block">
<span>位于源代码内的目的地部分将替换目的地（Porter-Duff Destination In Source规则）。</span>
<p> <span><em>F <sub>s</sub></em> = 0， <em>F <sub>d</sub></em> = <em>A <sub>s</sub></em> ，因此：</span> </p>
<pre>  <span><em>A<sub>r</sub></em> = <em>A<sub>d</sub></em>*<em>A<sub>s</sub></em>
  <em>C<sub>r</sub></em> = <em>C<sub>d</sub></em>*<em>A<sub>s</sub></em></span> </pre>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.awt.AlphaComposite.DST_IN">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="SRC_OUT">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>SRC_OUT</h4> <pre><a href="../../java/lang/annotation/Native.html" title="annotation in java.lang.annotation">@Native</a>
public static final int SRC_OUT</pre>
<div class="block">
<span>位于目的地外部的源的部分取代了目的地（Porter-Duff Source Held Out By Destination规则）。</span>
<p> <span><em>F <sub>s</sub></em> =（1- <em>A <sub>d</sub></em> ）且<em>F <sub>d</sub></em> = 0，因此：</span> </p>
<pre>  <span><em>A<sub>r</sub></em> = <em>A<sub>s</sub></em>*(1-<em>A<sub>d</sub></em>)
  <em>C<sub>r</sub></em> = <em>C<sub>s</sub></em>*(1-<em>A<sub>d</sub></em>)</span> </pre>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.awt.AlphaComposite.SRC_OUT">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="DST_OUT">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>DST_OUT</h4> <pre><a href="../../java/lang/annotation/Native.html" title="annotation in java.lang.annotation">@Native</a>
public static final int DST_OUT</pre>
<div class="block">
<span>位于源代码之外的目的地的一部分将替换目的地（Porter-Duff Destination Held Out By Source规则）。</span>
<p> <span><em>F <sub>s</sub></em> = 0， <em>F <sub>d</sub></em> =（1- <em>A <sub>s</sub></em> ），因此：</span> </p>
<pre>  <span><em>A<sub>r</sub></em> = <em>A<sub>d</sub></em>*(1-<em>A<sub>s</sub></em>)
  <em>C<sub>r</sub></em> = <em>C<sub>d</sub></em>*(1-<em>A<sub>s</sub></em>)</span> </pre>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.awt.AlphaComposite.DST_OUT">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="SRC_ATOP">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>SRC_ATOP</h4> <pre><a href="../../java/lang/annotation/Native.html" title="annotation in java.lang.annotation">@Native</a>
public static final int SRC_ATOP</pre>
<div class="block">
<span>位于目的地内部的源的部分被合成到目的地（Porter-Duff Source Atop Destination rule）上。</span>
<p> <span><em>F <sub>s</sub></em> = <em>A <sub>d</sub></em>和<em>F <sub>d</sub></em> =（1- <em>A <sub>s</sub></em> ），因此：</span> </p>
<pre>  <span><em>A<sub>r</sub></em> = <em>A<sub>s</sub></em>*<em>A<sub>d</sub></em> + <em>A<sub>d</sub></em>*(1-<em>A<sub>s</sub></em>) = <em>A<sub>d</sub></em>
  <em>C<sub>r</sub></em> = <em>C<sub>s</sub></em>*<em>A<sub>d</sub></em> + <em>C<sub>d</sub></em>*(1-<em>A<sub>s</sub></em>)</span> </pre>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.awt.AlphaComposite.SRC_ATOP">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="DST_ATOP">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>DST_ATOP</h4> <pre><a href="../../java/lang/annotation/Native.html" title="annotation in java.lang.annotation">@Native</a>
public static final int DST_ATOP</pre>
<div class="block">
<span>位于源头的目的地的一部分在源上合成，并替换目的地（Porter-Duff Destination Atop Source规则）。</span>
<p> <span><em>F <sub>s</sub></em> =（1- <em>A <sub>d</sub></em> ）， <em>F <sub>d</sub></em> = <em>A <sub>s</sub></em> ，因此：</span> </p>
<pre>  <span><em>A<sub>r</sub></em> = <em>A<sub>s</sub></em>*(1-<em>A<sub>d</sub></em>) + <em>A<sub>d</sub></em>*<em>A<sub>s</sub></em> = <em>A<sub>s</sub></em>
  <em>C<sub>r</sub></em> = <em>C<sub>s</sub></em>*(1-<em>A<sub>d</sub></em>) + <em>C<sub>d</sub></em>*<em>A<sub>s</sub></em></span> </pre>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.awt.AlphaComposite.DST_ATOP">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="XOR">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>XOR</h4> <pre><a href="../../java/lang/annotation/Native.html" title="annotation in java.lang.annotation">@Native</a>
public static final int XOR</pre>
<div class="block">
<span>位于目的地外部的源的部分与位于源外的目标的部分（Porter-Duff Source Xor Destination rule）组合。</span>
<p> <span><em>F <sub>s</sub></em> =（1- <em>A <sub>d</sub></em> ）和<em>F <sub>d</sub></em> =（1- <em>A <sub>s</sub></em> ），因此：</span> </p>
<pre>  <span><em>A<sub>r</sub></em> = <em>A<sub>s</sub></em>*(1-<em>A<sub>d</sub></em>) + <em>A<sub>d</sub></em>*(1-<em>A<sub>s</sub></em>)
  <em>C<sub>r</sub></em> = <em>C<sub>s</sub></em>*(1-<em>A<sub>d</sub></em>) + <em>C<sub>d</sub></em>*(1-<em>A<sub>s</sub></em>)</span> </pre>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.awt.AlphaComposite.XOR">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="Clear">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>Clear</h4> <pre>public static final <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a> Clear</pre>
<div class="block">
<code>AlphaComposite</code>对象实现不透明的CLEAR规则，其alpha为1.0f。 
          </div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/AlphaComposite.html#CLEAR"><code>CLEAR</code></a>
</dd>
</dl> </li>
</ul> <a name="Src">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>Src</h4> <pre>public static final <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a> Src</pre>
<div class="block">
<code>AlphaComposite</code>对象实现的不透明的SRC规则的alpha为1.0f。 
          </div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/AlphaComposite.html#SRC"><code>SRC</code></a>
</dd>
</dl> </li>
</ul> <a name="Dst">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>Dst</h4> <pre>public static final <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a> Dst</pre>
<div class="block">
<code>AlphaComposite</code>对象实现不透明的DST规则，alpha为1.0f。 
          </div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/AlphaComposite.html#DST"><code>DST</code></a>
</dd>
</dl> </li>
</ul> <a name="SrcOver">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>SrcOver</h4> <pre>public static final <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a> SrcOver</pre>
<div class="block">
<code>AlphaComposite</code>对象实现不透明的SRC_OVER规则，其alpha为1.0f。 
          </div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/AlphaComposite.html#SRC_OVER"><code>SRC_OVER</code></a>
</dd>
</dl> </li>
</ul> <a name="DstOver">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>DstOver</h4> <pre>public static final <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a> DstOver</pre>
<div class="block">
<code>AlphaComposite</code>对象实现不透明的DST_OVER规则，其alpha为1.0f。 
          </div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/AlphaComposite.html#DST_OVER"><code>DST_OVER</code></a>
</dd>
</dl> </li>
</ul> <a name="SrcIn">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>SrcIn</h4> <pre>public static final <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a> SrcIn</pre>
<div class="block">
<code>AlphaComposite</code>对象实现了不透明的SRC_IN规则，其alpha为1.0f。 
          </div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/AlphaComposite.html#SRC_IN"><code>SRC_IN</code></a>
</dd>
</dl> </li>
</ul> <a name="DstIn">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>DstIn</h4> <pre>public static final <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a> DstIn</pre>
<div class="block">
<code>AlphaComposite</code>对象实现不透明的DST_IN规则，其alpha为1.0f。 
          </div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/AlphaComposite.html#DST_IN"><code>DST_IN</code></a>
</dd>
</dl> </li>
</ul> <a name="SrcOut">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>SrcOut</h4> <pre>public static final <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a> SrcOut</pre>
<div class="block">
<code>AlphaComposite</code>对象实现的alpha值为1.0f的不透明SRC_OUT规则。 
          </div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/AlphaComposite.html#SRC_OUT"><code>SRC_OUT</code></a>
</dd>
</dl> </li>
</ul> <a name="DstOut">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>DstOut</h4> <pre>public static final <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a> DstOut</pre>
<div class="block">
<code>AlphaComposite</code>对象实现不透明的DST_OUT规则，alpha为1.0f。 
          </div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/AlphaComposite.html#DST_OUT"><code>DST_OUT</code></a>
</dd>
</dl> </li>
</ul> <a name="SrcAtop">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>SrcAtop</h4> <pre>public static final <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a> SrcAtop</pre>
<div class="block">
<code>AlphaComposite</code>对象实现的alpha值为1.0f的不透明SRC_ATOP规则。 
          </div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/AlphaComposite.html#SRC_ATOP"><code>SRC_ATOP</code></a>
</dd>
</dl> </li>
</ul> <a name="DstAtop">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>DstAtop</h4> <pre>public static final <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a> DstAtop</pre>
<div class="block">
<code>AlphaComposite</code>对象实现不透明的DST_ATOP规则，其alpha值为1.0f。 
          </div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/AlphaComposite.html#DST_ATOP"><code>DST_ATOP</code></a>
</dd>
</dl> </li>
</ul> <a name="Xor">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>Xor</h4> <pre>public static final <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a> Xor</pre>
<div class="block">
<code>AlphaComposite</code>实现不透明XOR规则的对象，其alpha为1.0f。 
          </div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/AlphaComposite.html#XOR"><code>XOR</code></a>
</dd>
</dl> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="getInstance-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getInstance</h4> <pre>public static <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a> getInstance(int rule)</pre>
<div class="block">
            用指定的规则创建一个 
           <code>AlphaComposite</code>对象。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>rule</code> - 合成规则 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
            <code>rule</code>不是以下之一： 
            <a href="../../java/awt/AlphaComposite.html#CLEAR"><code>CLEAR</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#SRC"><code>SRC</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#DST"><code>DST</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#SRC_OVER"><code>SRC_OVER</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#DST_OVER"><code>DST_OVER</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#SRC_IN"><code>SRC_IN</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#DST_IN"><code>DST_IN</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#SRC_OUT"><code>SRC_OUT</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#DST_OUT"><code>DST_OUT</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#SRC_ATOP"><code>SRC_ATOP</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#DST_ATOP"><code>DST_ATOP</code></a> ，或 
            <a href="../../java/awt/AlphaComposite.html#XOR"><code>XOR</code></a>
</dd>
</dl> </li>
</ul> <a name="getInstance-int-float-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getInstance</h4> <pre>public static <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a> getInstance(int rule,
                                         float alpha)</pre>
<div class="block">
<span>使用指定的规则创建一个<code>AlphaComposite</code>对象，并将常量alpha与源的alpha进行乘法。</span>
<span>在与目的地合成之前，源与指定的alpha相乘。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>rule</code> - 合成规则 
           </dd>
<dd>
<span><code>alpha</code> - 要与源的alpha <code>alpha</code>的常数α。</span>
<span><code>alpha</code>必须是包含范围[0.0，1.0]中的浮点数。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
            <code>alpha</code>大于1.0小于0.0或，或者如果 
            <code>rule</code>不是以下之一： 
            <a href="../../java/awt/AlphaComposite.html#CLEAR"><code>CLEAR</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#SRC"><code>SRC</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#DST"><code>DST</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#SRC_OVER"><code>SRC_OVER</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#DST_OVER"><code>DST_OVER</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#SRC_IN"><code>SRC_IN</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#DST_IN"><code>DST_IN</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#SRC_OUT"><code>SRC_OUT</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#DST_OUT"><code>DST_OUT</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#SRC_ATOP"><code>SRC_ATOP</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#DST_ATOP"><code>DST_ATOP</code></a> ，或 
            <a href="../../java/awt/AlphaComposite.html#XOR"><code>XOR</code></a>
</dd>
</dl> </li>
</ul> <a name="createContext-java.awt.image.ColorModel-java.awt.image.ColorModel-java.awt.RenderingHints-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>createContext</h4> <pre>public <a href="../../java/awt/CompositeContext.html" title="interface in java.awt">CompositeContext</a> createContext(<a href="../../java/awt/image/ColorModel.html" title="class in java.awt.image">ColorModel</a> srcColorModel,
                                      <a href="../../java/awt/image/ColorModel.html" title="class in java.awt.image">ColorModel</a> dstColorModel,
                                      <a href="../../java/awt/RenderingHints.html" title="class in java.awt">RenderingHints</a> hints)</pre>
<div class="block">
<span>创建合成操作的上下文。</span>
<span>上下文包含用于执行合成操作的状态。</span>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../java/awt/Composite.html#createContext-java.awt.image.ColorModel-java.awt.image.ColorModel-java.awt.RenderingHints-">createContext</a></code>在界面 
            <code><a href="../../java/awt/Composite.html" title="interface in java.awt">Composite</a></code>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>srcColorModel</code> - 源的<a href="../../java/awt/image/ColorModel.html" title="java.awt.image中的类"><code>ColorModel</code></a></span>
</dd>
<dd>
<code>dstColorModel</code> - 
            <code>ColorModel</code>的ColorModel 
           </dd>
<dd>
<code>hints</code> - 上下文对象用于在渲染替代方案之间进行选择的提示 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             用于执行合成操作的 
            <code>CompositeContext</code>对象。 
           </dd>
</dl> </li>
</ul> <a name="getAlpha--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getAlpha</h4> <pre>public float getAlpha()</pre>
<div class="block">
<span>返回这个<code>AlphaComposite</code>的alpha值。</span>
<span>如果此<code>AlphaComposite</code>没有Alpha值，则返回1.0。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个 
            <code>AlphaComposite</code>的alpha值。 
           </dd>
</dl> </li>
</ul> <a name="getRule--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getRule</h4> <pre>public int getRule()</pre>
<div class="block">
            返回此的合成规则 
           <code>AlphaComposite</code> 。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个的合成规则 
            <code>AlphaComposite</code> 。 
           </dd>
</dl> </li>
</ul> <a name="derive-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>derive</h4> <pre>public <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a> derive(int rule)</pre>
<div class="block">
<span>返回使用指定的合成规则的类似的<code>AlphaComposite</code>对象。</span>
<span>如果此对象已使用指定的合成规则，则返回此对象。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>rule</code> - 合成规则 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>AlphaComposite</code>对象派生的 
            <code>AlphaComposite</code>对象使用指定的合成规则。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
            <code>rule</code>不是以下之一： 
            <a href="../../java/awt/AlphaComposite.html#CLEAR"><code>CLEAR</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#SRC"><code>SRC</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#DST"><code>DST</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#SRC_OVER"><code>SRC_OVER</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#DST_OVER"><code>DST_OVER</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#SRC_IN"><code>SRC_IN</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#DST_IN"><code>DST_IN</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#SRC_OUT"><code>SRC_OUT</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#DST_OUT"><code>DST_OUT</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#SRC_ATOP"><code>SRC_ATOP</code></a> ， 
            <a href="../../java/awt/AlphaComposite.html#DST_ATOP"><code>DST_ATOP</code></a> ，或 
            <a href="../../java/awt/AlphaComposite.html#XOR"><code>XOR</code></a>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="derive-float-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>derive</h4> <pre>public <a href="../../java/awt/AlphaComposite.html" title="class in java.awt">AlphaComposite</a> derive(float alpha)</pre>
<div class="block">
<span>返回使用指定的alpha值的类似的<code>AlphaComposite</code>对象。</span>
<span>如果此对象已经具有指定的alpha值，则返回此对象。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>alpha</code> - 要与源的alpha <code>alpha</code>的常数α。</span>
<span><code>alpha</code>必须是包含范围[0.0，1.0]中的浮点数。</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>AlphaComposite</code>对象派生 
            <code>AlphaComposite</code>对象使用指定的alpha值。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>alpha</code>小于0.0或大于1.0 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="hashCode--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>hashCode</h4> <pre>public int hashCode()</pre>
<div class="block">
            返回此复合的哈希码。 
          </div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../java/lang/Object.html#hashCode--">hashCode</a></code>在类别 
            <code><a href="../../java/lang/Object.html" title="class in java.lang">Object</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             此复合的哈希码。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Object.html#equals-java.lang.Object-"><code>Object.equals(java.lang.Object)</code></a> ， 
            <a href="../../java/lang/System.html#identityHashCode-java.lang.Object-"><code>System.identityHashCode(java.lang.Object)</code></a>
</dd>
</dl> </li>
</ul> <a name="equals-java.lang.Object-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>equals</h4> <pre>public boolean equals(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> obj)</pre>
<div class="block">
<span>确定指定的对象是否等于此<code>AlphaComposite</code> 。</span>
<p> <span>当且仅当参数不是<code>null</code>并且具有与<code>AlphaComposite</code>对象具有相同合成规则和alpha值的<code>AlphaComposite</code>对象时，结果为<code>true</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../java/lang/Object.html#equals-java.lang.Object-">equals</a></code>在类别 
            <code><a href="../../java/lang/Object.html" title="class in java.lang">Object</a></code>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>obj</code> - 
            <code>Object</code>测试平等 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span><code>true</code>如果<code>obj</code>于此<code>AlphaComposite</code> ;</span>
<span><code>false</code>否则。</span>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/lang/Object.html#hashCode--"><code>Object.hashCode()</code></a> ， <a href="../../java/util/HashMap.html" title="java.util中的类"><code>HashMap</code></a></span>
</dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>