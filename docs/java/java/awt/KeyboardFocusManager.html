<div class="header">
<div class="subTitle">
     java.awt 
   </div>
<h2 class="title" title="Class KeyboardFocusManager">Class KeyboardFocusManager</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.awt.KeyboardFocusManager</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
         All Implemented Interfaces: 
       </dt>
<dd>
<span><a href="../../java/awt/KeyEventDispatcher.html" title="java.awt中的接口">KeyEventDispatcher</a> ， <a href="../../java/awt/KeyEventPostProcessor.html" title="java.awt中的接口">KeyEventPostProcessor</a></span>
</dd>
</dl>
<dl>
<dt>
        已知直接子类：
       </dt>
<dd>
<span><a href="../../java/awt/DefaultKeyboardFocusManager.html" title="java.awt中的类">DefaultKeyboardFocusManager</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public abstract class <span class="typeNameLabel">KeyboardFocusManager</span>
extends <a href="../../java/lang/Object.html" title="class in java.lang">Object</a>
implements <a href="../../java/awt/KeyEventDispatcher.html" title="interface in java.awt">KeyEventDispatcher</a>, <a href="../../java/awt/KeyEventPostProcessor.html" title="interface in java.awt">KeyEventPostProcessor</a></pre>
<div class="block">
<span>KeyboardFocusManager负责管理主动和关注的Windows以及当前焦点所有者。</span>
<span>焦点所有者被定义为通常将接收用户生成的所有KeyEvent的应用程序中的组件。</span>
<span>关注的窗口是焦点所有者的或包含焦点所有者的窗口。</span>
<span>只有框架或对话框可以是活动窗口。</span>
<span>本地窗口系统可以表示活动窗口或其具有特殊装饰的儿童，例如突出显示的标题栏。</span>
<span>活动窗口始终是聚焦的窗口，或者是聚焦窗口的所有者的第一个框架或对话框。</span>
<p> <span>KeyboardFocusManager是客户端代码查询焦点所有者并启动焦点更改的集中位置，以及所有FocusEvents，与焦点相关的WindowEvent和KeyEvents的事件调度程序。</span> </p>
<p> <span>一些浏览器将不同代码库中的小程序分割成单独的上下文，并在这些上下文之间建立墙壁。</span> <span>在这种情况下，每个上下文将会有一个KeyboardFocusManager。</span> <span>其他浏览器将所有小程序放入相同的上下文中，这意味着所有小程序都将只有一个全局的KeyboardFocusManager。</span> <span>这种行为是依赖于实现的。</span> <span>有关更多信息，请参阅浏览器的文档。</span> <span>不管有多少上下文可能存在，但是，根据ClassLoader，永远不会有多个焦点所有者，关注窗口或活动窗口。</span> </p>
<p> <span>请参阅<a href="http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html">How to Use the Focus Subsystem</a> ，在<em>Java教程</em>一节，以及<a href="../../java/awt/doc-files/FocusSpec.html">Focus Specification</a>以获取更多信息。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.4 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/awt/Window.html" title="java.awt中的类"><code>Window</code></a> ， <a href="../../java/awt/Frame.html" title="java.awt中的类"><code>Frame</code></a> ， <a href="../../java/awt/Dialog.html" title="java.awt中的类"><code>Dialog</code></a> ， <a href="../../java/awt/event/FocusEvent.html" title="java.awt.event中的类"><code>FocusEvent</code></a> ， <a href="../../java/awt/event/WindowEvent.html" title="java.awt.event中的类"><code>WindowEvent</code></a> ， <a href="../../java/awt/event/KeyEvent.html" title="java.awt.event中的类"><code>KeyEvent</code></a></span>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!-- --> </a> <h3>Field Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Field Summary table, listing fields, and an explanation">
<caption>
<span>Fields</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#BACKWARD_TRAVERSAL_KEYS">BACKWARD_TRAVERSAL_KEYS</a></span></code>
<div class="block">
              后向聚焦遍历键的标识符。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#DOWN_CYCLE_TRAVERSAL_KEYS">DOWN_CYCLE_TRAVERSAL_KEYS</a></span></code>
<div class="block">
              Down Cycle的标识符聚焦遍历键。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#FORWARD_TRAVERSAL_KEYS">FORWARD_TRAVERSAL_KEYS</a></span></code>
<div class="block">
              正向聚焦遍历键的标识符。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#UP_CYCLE_TRAVERSAL_KEYS">UP_CYCLE_TRAVERSAL_KEYS</a></span></code>
<div class="block">
              上传周期聚焦遍历键的标识符。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!-- --> </a> <h3>构造方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Constructor Summary table, listing constructors, and an explanation">
<caption>
<span>构造方法</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#KeyboardFocusManager--">KeyboardFocusManager</a></span>()</code>
<div class="block">
              初始化KeyboardFocusManager。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t1"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t3"><span><a href="javascript:show(4);">抽象方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#addKeyEventDispatcher-java.awt.KeyEventDispatcher-">addKeyEventDispatcher</a></span>(<a href="../../java/awt/KeyEventDispatcher.html" title="interface in java.awt">KeyEventDispatcher</a> dispatcher)</code>
<div class="block">
              将KeyEventDispatcher添加到此KeyboardFocusManager的调度程序链中。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#addKeyEventPostProcessor-java.awt.KeyEventPostProcessor-">addKeyEventPostProcessor</a></span>(<a href="../../java/awt/KeyEventPostProcessor.html" title="interface in java.awt">KeyEventPostProcessor</a> processor)</code>
<div class="block">
              将KeyEventPostProcessor添加到此KeyboardFocusManager的后处理器链。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#addPropertyChangeListener-java.beans.PropertyChangeListener-">addPropertyChangeListener</a></span>(<a href="../../java/beans/PropertyChangeListener.html" title="interface in java.beans">PropertyChangeListener</a> listener)</code>
<div class="block">
              将PropertyChangeListener添加到侦听器列表。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#addPropertyChangeListener-java.lang.String-java.beans.PropertyChangeListener-">addPropertyChangeListener</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> propertyName, <a href="../../java/beans/PropertyChangeListener.html" title="interface in java.beans">PropertyChangeListener</a> listener)</code>
<div class="block">
              将PropertyChangeListener添加到特定属性的侦听器列表中。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#addVetoableChangeListener-java.lang.String-java.beans.VetoableChangeListener-">addVetoableChangeListener</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> propertyName, <a href="../../java/beans/VetoableChangeListener.html" title="interface in java.beans">VetoableChangeListener</a> listener)</code>
<div class="block">
              将VetoableChangeListener添加到特定属性的侦听器列表中。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#addVetoableChangeListener-java.beans.VetoableChangeListener-">addVetoableChangeListener</a></span>(<a href="../../java/beans/VetoableChangeListener.html" title="interface in java.beans">VetoableChangeListener</a> listener)</code>
<div class="block">
              将VetoableChangeListener添加到侦听器列表。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#clearFocusOwner--">clearFocusOwner</a></span>()</code>
<div class="block">
              如果焦点所有者存在并驻留在与调用线程相同的上下文中，则清除Java和本机级别的焦点所有者，否则该方法将静默返回。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#clearGlobalFocusOwner--">clearGlobalFocusOwner</a></span>()</code>
<div class="block">
              在Java和本机级别清除全局焦点所有者。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>protected abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#dequeueKeyEvents-long-java.awt.Component-">dequeueKeyEvents</a></span>(long after, <a href="../../java/awt/Component.html" title="class in java.awt">Component</a> untilFocused)</code>
<div class="block">
              由AWT调用以通知KeyboardFocusManager它应该取消KeyEvents的延迟调度。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>protected abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#discardKeyEvents-java.awt.Component-">discardKeyEvents</a></span>(<a href="../../java/awt/Component.html" title="class in java.awt">Component</a> comp)</code>
<div class="block">
              由AWT调用以通知KeyboardFocusManager它应该取消KeyEvents的延迟调度。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>abstract boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#dispatchEvent-java.awt.AWTEvent-">dispatchEvent</a></span>(<a href="../../java/awt/AWTEvent.html" title="class in java.awt">AWTEvent</a> e)</code>
<div class="block">
              该方法由AWT事件调度程序调用，请求当前的KeyboardFocusManager代表它发送指定的事件。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>abstract boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#dispatchKeyEvent-java.awt.event.KeyEvent-">dispatchKeyEvent</a></span>(<a href="../../java/awt/event/KeyEvent.html" title="class in java.awt.event">KeyEvent</a> e)</code>
<div class="block">
              典型地，该方法将被调用 
             <code>dispatchEvent</code>如果在调度程序链没有其他的KeyEventDispatcher调度KeyEvent，或者如果没有注册其他KeyEventDispatcher。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#downFocusCycle--">downFocusCycle</a></span>()</code>
<div class="block">
              当焦点所有者是当前焦点循环根的容器时，将焦点向下移动当前焦点所有者的一个焦点遍历循环。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#downFocusCycle-java.awt.Container-">downFocusCycle</a></span>(<a href="../../java/awt/Container.html" title="class in java.awt">Container</a> aContainer)</code>
<div class="block">
              将焦点向下移动一个焦点遍历周期。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>protected abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#enqueueKeyEvents-long-java.awt.Component-">enqueueKeyEvents</a></span>(long after, <a href="../../java/awt/Component.html" title="class in java.awt">Component</a> untilFocused)</code>
<div class="block">
              由AWT调用，通知KeyboardFocusManager它应该延迟调度KeyEvents，直到指定的Component成为焦点所有者。 
            </div> </td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#firePropertyChange-java.lang.String-java.lang.Object-java.lang.Object-">firePropertyChange</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> propertyName, <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> oldValue, <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> newValue)</code>
<div class="block">
              触发PropertyChangeEvent以响应绑定属性的更改。 
            </div> </td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#fireVetoableChange-java.lang.String-java.lang.Object-java.lang.Object-">fireVetoableChange</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> propertyName, <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> oldValue, <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> newValue)</code>
<div class="block">
              触发PropertyChangeEvent以响应否决权属性的更改。 
            </div> </td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#focusNextComponent--">focusNextComponent</a></span>()</code>
<div class="block">
              在当前焦点所有者之后聚焦组件。 
            </div> </td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#focusNextComponent-java.awt.Component-">focusNextComponent</a></span>(<a href="../../java/awt/Component.html" title="class in java.awt">Component</a> aComponent)</code>
<div class="block">
              将组件聚焦在aComponent之后，通常基于FocusTraversalPolicy。 
            </div> </td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#focusPreviousComponent--">focusPreviousComponent</a></span>()</code>
<div class="block">
              将组件聚焦到当前焦点所有者之前。 
            </div> </td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#focusPreviousComponent-java.awt.Component-">focusPreviousComponent</a></span>(<a href="../../java/awt/Component.html" title="class in java.awt">Component</a> aComponent)</code>
<div class="block">
              在组件之前聚焦组件，通常基于FocusTraversalPolicy。 
            </div> </td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code><a href="../../java/awt/Window.html" title="class in java.awt">Window</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#getActiveWindow--">getActiveWindow</a></span>()</code>
<div class="block">
              如果活动窗口与调用线程处于相同的上下文中，则返回活动窗口。 
            </div> </td>
</tr>
<tr class="altColor" id="i22">
<td class="colFirst"><code><a href="../../java/awt/Container.html" title="class in java.awt">Container</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#getCurrentFocusCycleRoot--">getCurrentFocusCycleRoot</a></span>()</code>
<div class="block">
              如果当前焦点循环根与调用线程处于相同的上下文中，则返回当前焦点循环根。 
            </div> </td>
</tr>
<tr class="rowColor" id="i23">
<td class="colFirst"><code>static <a href="../../java/awt/KeyboardFocusManager.html" title="class in java.awt">KeyboardFocusManager</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#getCurrentKeyboardFocusManager--">getCurrentKeyboardFocusManager</a></span>()</code>
<div class="block">
              返回调用线程上下文的当前KeyboardFocusManager实例。 
            </div> </td>
</tr>
<tr class="altColor" id="i24">
<td class="colFirst"><code><a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;<a href="../../java/awt/AWTKeyStroke.html" title="class in java.awt">AWTKeyStroke</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#getDefaultFocusTraversalKeys-int-">getDefaultFocusTraversalKeys</a></span>(int id)</code>
<div class="block">
              返回给定遍历操作的一组默认焦点遍历键。 
            </div> </td>
</tr>
<tr class="rowColor" id="i25">
<td class="colFirst"><code><a href="../../java/awt/FocusTraversalPolicy.html" title="class in java.awt">FocusTraversalPolicy</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#getDefaultFocusTraversalPolicy--">getDefaultFocusTraversalPolicy</a></span>()</code>
<div class="block">
              返回默认的FocusTraversalPolicy。 
            </div> </td>
</tr>
<tr class="altColor" id="i26">
<td class="colFirst"><code><a href="../../java/awt/Window.html" title="class in java.awt">Window</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#getFocusedWindow--">getFocusedWindow</a></span>()</code>
<div class="block">
              如果集中的窗口与调用线程处于相同的上下文中，则返回关注的窗口。 
            </div> </td>
</tr>
<tr class="rowColor" id="i27">
<td class="colFirst"><code><a href="../../java/awt/Component.html" title="class in java.awt">Component</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#getFocusOwner--">getFocusOwner</a></span>()</code>
<div class="block">
              如果焦点所有者与调用线程处于相同的上下文中，则返回焦点所有者。 
            </div> </td>
</tr>
<tr class="altColor" id="i28">
<td class="colFirst"><code>protected <a href="../../java/awt/Window.html" title="class in java.awt">Window</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#getGlobalActiveWindow--">getGlobalActiveWindow</a></span>()</code>
<div class="block">
              返回活动窗口，即使调用线程与活动窗口处于不同的上下文中。 
            </div> </td>
</tr>
<tr class="rowColor" id="i29">
<td class="colFirst"><code>protected <a href="../../java/awt/Container.html" title="class in java.awt">Container</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#getGlobalCurrentFocusCycleRoot--">getGlobalCurrentFocusCycleRoot</a></span>()</code>
<div class="block">
              返回当前焦点循环根，即使调用线程与当前焦点循环根不同。 
            </div> </td>
</tr>
<tr class="altColor" id="i30">
<td class="colFirst"><code>protected <a href="../../java/awt/Window.html" title="class in java.awt">Window</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#getGlobalFocusedWindow--">getGlobalFocusedWindow</a></span>()</code>
<div class="block">
              返回聚焦窗口，即使调用线程与聚焦窗口处于不同的上下文中。 
            </div> </td>
</tr>
<tr class="rowColor" id="i31">
<td class="colFirst"><code>protected <a href="../../java/awt/Component.html" title="class in java.awt">Component</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#getGlobalFocusOwner--">getGlobalFocusOwner</a></span>()</code>
<div class="block">
              即使调用线程与焦点所有者的上下文不同，返回焦点所有者。 
            </div> </td>
</tr>
<tr class="altColor" id="i32">
<td class="colFirst"><code>protected <a href="../../java/awt/Component.html" title="class in java.awt">Component</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#getGlobalPermanentFocusOwner--">getGlobalPermanentFocusOwner</a></span>()</code>
<div class="block">
              返回永久焦点所有者，即使调用线程与永久焦点所有者处于不同的上下文中。 
            </div> </td>
</tr>
<tr class="rowColor" id="i33">
<td class="colFirst"><code>protected <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;<a href="../../java/awt/KeyEventDispatcher.html" title="interface in java.awt">KeyEventDispatcher</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#getKeyEventDispatchers--">getKeyEventDispatchers</a></span>()</code>
<div class="block">
              将此KeyboardFocusManager的KeyEventDispatcher链作为列表返回。 
            </div> </td>
</tr>
<tr class="altColor" id="i34">
<td class="colFirst"><code>protected <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;<a href="../../java/awt/KeyEventPostProcessor.html" title="interface in java.awt">KeyEventPostProcessor</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#getKeyEventPostProcessors--">getKeyEventPostProcessors</a></span>()</code>
<div class="block">
              将此KeyboardFocusManager的KeyEventPostProcessor链返回为列表。 
            </div> </td>
</tr>
<tr class="rowColor" id="i35">
<td class="colFirst"><code><a href="../../java/awt/Component.html" title="class in java.awt">Component</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#getPermanentFocusOwner--">getPermanentFocusOwner</a></span>()</code>
<div class="block">
              如果永久焦点所有者与调用线程处于相同的上下文中，则返回永久焦点所有者。 
            </div> </td>
</tr>
<tr class="altColor" id="i36">
<td class="colFirst"><code><a href="../../java/beans/PropertyChangeListener.html" title="interface in java.beans">PropertyChangeListener</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#getPropertyChangeListeners--">getPropertyChangeListeners</a></span>()</code>
<div class="block">
              返回在此键盘焦点管理器上注册的所有属性更改侦听器的数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i37">
<td class="colFirst"><code><a href="../../java/beans/PropertyChangeListener.html" title="interface in java.beans">PropertyChangeListener</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#getPropertyChangeListeners-java.lang.String-">getPropertyChangeListeners</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> propertyName)</code>
<div class="block">
              返回与named属性相关 
             <code>PropertyChangeListener</code>的所有 
             <code>PropertyChangeListener</code> s的数组。 
            </div> </td>
</tr>
<tr class="altColor" id="i38">
<td class="colFirst"><code><a href="../../java/beans/VetoableChangeListener.html" title="interface in java.beans">VetoableChangeListener</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#getVetoableChangeListeners--">getVetoableChangeListeners</a></span>()</code>
<div class="block">
              返回在此键盘焦点管理器上注册的所有否决变更监听器的数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i39">
<td class="colFirst"><code><a href="../../java/beans/VetoableChangeListener.html" title="interface in java.beans">VetoableChangeListener</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#getVetoableChangeListeners-java.lang.String-">getVetoableChangeListeners</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> propertyName)</code>
<div class="block">
              返回与named属性相关 
             <code>VetoableChangeListener</code>的所有 
             <code>VetoableChangeListener</code>的数组。 
            </div> </td>
</tr>
<tr class="altColor" id="i40">
<td class="colFirst"><code>abstract boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#postProcessKeyEvent-java.awt.event.KeyEvent-">postProcessKeyEvent</a></span>(<a href="../../java/awt/event/KeyEvent.html" title="class in java.awt.event">KeyEvent</a> e)</code>
<div class="block">
              此方法将由 
             <code>dispatchKeyEvent</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i41">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#processKeyEvent-java.awt.Component-java.awt.event.KeyEvent-">processKeyEvent</a></span>(<a href="../../java/awt/Component.html" title="class in java.awt">Component</a> focusedComponent, <a href="../../java/awt/event/KeyEvent.html" title="class in java.awt.event">KeyEvent</a> e)</code>
<div class="block">
              当且仅当KeyEvent表示指定的focusComponent的焦点遍历键时，此方法启动焦点遍历操作。 
            </div> </td>
</tr>
<tr class="altColor" id="i42">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#redispatchEvent-java.awt.Component-java.awt.AWTEvent-">redispatchEvent</a></span>(<a href="../../java/awt/Component.html" title="class in java.awt">Component</a> target, <a href="../../java/awt/AWTEvent.html" title="class in java.awt">AWTEvent</a> e)</code>
<div class="block">
              重新分配AWTEvent，AWT事件调度程序将不会递归地请求KeyboardFocusManager或任何已安装的KeyEventDispatchers再次发送事件。 
            </div> </td>
</tr>
<tr class="rowColor" id="i43">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#removeKeyEventDispatcher-java.awt.KeyEventDispatcher-">removeKeyEventDispatcher</a></span>(<a href="../../java/awt/KeyEventDispatcher.html" title="interface in java.awt">KeyEventDispatcher</a> dispatcher)</code>
<div class="block">
              删除之前添加到此KeyboardFocusManager调度程序链的KeyEventDispatcher。 
            </div> </td>
</tr>
<tr class="altColor" id="i44">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#removeKeyEventPostProcessor-java.awt.KeyEventPostProcessor-">removeKeyEventPostProcessor</a></span>(<a href="../../java/awt/KeyEventPostProcessor.html" title="interface in java.awt">KeyEventPostProcessor</a> processor)</code>
<div class="block">
              从此KeyboardFocusManager的后处理器链中删除以前添加的KeyEventPostProcessor。 
            </div> </td>
</tr>
<tr class="rowColor" id="i45">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#removePropertyChangeListener-java.beans.PropertyChangeListener-">removePropertyChangeListener</a></span>(<a href="../../java/beans/PropertyChangeListener.html" title="interface in java.beans">PropertyChangeListener</a> listener)</code>
<div class="block">
              从侦听器列表中移除PropertyChangeListener。 
            </div> </td>
</tr>
<tr class="altColor" id="i46">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#removePropertyChangeListener-java.lang.String-java.beans.PropertyChangeListener-">removePropertyChangeListener</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> propertyName, <a href="../../java/beans/PropertyChangeListener.html" title="interface in java.beans">PropertyChangeListener</a> listener)</code>
<div class="block">
              从侦听器列表中为特定属性移除PropertyChangeListener。 
            </div> </td>
</tr>
<tr class="rowColor" id="i47">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#removeVetoableChangeListener-java.lang.String-java.beans.VetoableChangeListener-">removeVetoableChangeListener</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> propertyName, <a href="../../java/beans/VetoableChangeListener.html" title="interface in java.beans">VetoableChangeListener</a> listener)</code>
<div class="block">
              从侦听器列表中为特定属性删除VetoableChangeListener。 
            </div> </td>
</tr>
<tr class="altColor" id="i48">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#removeVetoableChangeListener-java.beans.VetoableChangeListener-">removeVetoableChangeListener</a></span>(<a href="../../java/beans/VetoableChangeListener.html" title="interface in java.beans">VetoableChangeListener</a> listener)</code>
<div class="block">
              从侦听器列表中删除VetoableChangeListener。 
            </div> </td>
</tr>
<tr class="rowColor" id="i49">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#setCurrentKeyboardFocusManager-java.awt.KeyboardFocusManager-">setCurrentKeyboardFocusManager</a></span>(<a href="../../java/awt/KeyboardFocusManager.html" title="class in java.awt">KeyboardFocusManager</a> newManager)</code>
<div class="block">
              为调用线程的上下文设置当前的KeyboardFocusManager实例。 
            </div> </td>
</tr>
<tr class="altColor" id="i50">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#setDefaultFocusTraversalKeys-int-java.util.Set-">setDefaultFocusTraversalKeys</a></span>(int id, <a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;? extends <a href="../../java/awt/AWTKeyStroke.html" title="class in java.awt">AWTKeyStroke</a>&gt; keystrokes)</code>
<div class="block">
              设置给定遍历操作的默认焦点遍历键。 
            </div> </td>
</tr>
<tr class="rowColor" id="i51">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#setDefaultFocusTraversalPolicy-java.awt.FocusTraversalPolicy-">setDefaultFocusTraversalPolicy</a></span>(<a href="../../java/awt/FocusTraversalPolicy.html" title="class in java.awt">FocusTraversalPolicy</a> defaultPolicy)</code>
<div class="block">
              设置默认的FocusTraversalPolicy。 
            </div> </td>
</tr>
<tr class="altColor" id="i52">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#setGlobalActiveWindow-java.awt.Window-">setGlobalActiveWindow</a></span>(<a href="../../java/awt/Window.html" title="class in java.awt">Window</a> activeWindow)</code>
<div class="block">
              设置活动窗口。 
            </div> </td>
</tr>
<tr class="rowColor" id="i53">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#setGlobalCurrentFocusCycleRoot-java.awt.Container-">setGlobalCurrentFocusCycleRoot</a></span>(<a href="../../java/awt/Container.html" title="class in java.awt">Container</a> newFocusCycleRoot)</code>
<div class="block">
              设置当前焦点循环根。 
            </div> </td>
</tr>
<tr class="altColor" id="i54">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#setGlobalFocusedWindow-java.awt.Window-">setGlobalFocusedWindow</a></span>(<a href="../../java/awt/Window.html" title="class in java.awt">Window</a> focusedWindow)</code>
<div class="block">
              设置聚焦窗口。 
            </div> </td>
</tr>
<tr class="rowColor" id="i55">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#setGlobalFocusOwner-java.awt.Component-">setGlobalFocusOwner</a></span>(<a href="../../java/awt/Component.html" title="class in java.awt">Component</a> focusOwner)</code>
<div class="block">
              设置焦点所有者。 
            </div> </td>
</tr>
<tr class="altColor" id="i56">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#setGlobalPermanentFocusOwner-java.awt.Component-">setGlobalPermanentFocusOwner</a></span>(<a href="../../java/awt/Component.html" title="class in java.awt">Component</a> permanentFocusOwner)</code>
<div class="block">
              设置永久焦点所有者。 
            </div> </td>
</tr>
<tr class="rowColor" id="i57">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#upFocusCycle--">upFocusCycle</a></span>()</code>
<div class="block">
              将焦点移动到当前焦点所有者的一个焦点遍历周期。 
            </div> </td>
</tr>
<tr class="altColor" id="i58">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/awt/KeyboardFocusManager.html#upFocusCycle-java.awt.Component-">upFocusCycle</a></span>(<a href="../../java/awt/Component.html" title="class in java.awt">Component</a> aComponent)</code>
<div class="block">
              将焦点移动到一个焦点遍历周期。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../java/lang/Object.html#clone--">clone</a>, <a href="../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../java/lang/Object.html#notify--">notify</a>, <a href="../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../java/lang/Object.html#toString--">toString</a>, <a href="../../java/lang/Object.html#wait--">wait</a>, <a href="../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!-- --> </a> <h3>字段详细信息</h3> <a name="FORWARD_TRAVERSAL_KEYS">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>FORWARD_TRAVERSAL_KEYS</h4> <pre>public static final int FORWARD_TRAVERSAL_KEYS</pre>
<div class="block">
            正向聚焦遍历键的标识符。 
          </div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#setDefaultFocusTraversalKeys-int-java.util.Set-"><code>setDefaultFocusTraversalKeys(int, java.util.Set&lt;? extends java.awt.AWTKeyStroke&gt;)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getDefaultFocusTraversalKeys-int-"><code>getDefaultFocusTraversalKeys(int)</code></a> ， 
            <a href="../../java/awt/Component.html#setFocusTraversalKeys-int-java.util.Set-"><code>Component.setFocusTraversalKeys(int, java.util.Set&lt;? extends java.awt.AWTKeyStroke&gt;)</code></a> ， 
            <a href="../../java/awt/Component.html#getFocusTraversalKeys-int-"><code>Component.getFocusTraversalKeys(int)</code></a> ， 
            <a href="../../constant-values.html#java.awt.KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="BACKWARD_TRAVERSAL_KEYS">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>BACKWARD_TRAVERSAL_KEYS</h4> <pre>public static final int BACKWARD_TRAVERSAL_KEYS</pre>
<div class="block">
            后向聚焦遍历键的标识符。 
          </div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#setDefaultFocusTraversalKeys-int-java.util.Set-"><code>setDefaultFocusTraversalKeys(int, java.util.Set&lt;? extends java.awt.AWTKeyStroke&gt;)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getDefaultFocusTraversalKeys-int-"><code>getDefaultFocusTraversalKeys(int)</code></a> ， 
            <a href="../../java/awt/Component.html#setFocusTraversalKeys-int-java.util.Set-"><code>Component.setFocusTraversalKeys(int, java.util.Set&lt;? extends java.awt.AWTKeyStroke&gt;)</code></a> ， 
            <a href="../../java/awt/Component.html#getFocusTraversalKeys-int-"><code>Component.getFocusTraversalKeys(int)</code></a> ， 
            <a href="../../constant-values.html#java.awt.KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="UP_CYCLE_TRAVERSAL_KEYS">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>UP_CYCLE_TRAVERSAL_KEYS</h4> <pre>public static final int UP_CYCLE_TRAVERSAL_KEYS</pre>
<div class="block">
            上传周期聚焦遍历键的标识符。 
          </div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#setDefaultFocusTraversalKeys-int-java.util.Set-"><code>setDefaultFocusTraversalKeys(int, java.util.Set&lt;? extends java.awt.AWTKeyStroke&gt;)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getDefaultFocusTraversalKeys-int-"><code>getDefaultFocusTraversalKeys(int)</code></a> ， 
            <a href="../../java/awt/Component.html#setFocusTraversalKeys-int-java.util.Set-"><code>Component.setFocusTraversalKeys(int, java.util.Set&lt;? extends java.awt.AWTKeyStroke&gt;)</code></a> ， 
            <a href="../../java/awt/Component.html#getFocusTraversalKeys-int-"><code>Component.getFocusTraversalKeys(int)</code></a> ， 
            <a href="../../constant-values.html#java.awt.KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="DOWN_CYCLE_TRAVERSAL_KEYS">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>DOWN_CYCLE_TRAVERSAL_KEYS</h4> <pre>public static final int DOWN_CYCLE_TRAVERSAL_KEYS</pre>
<div class="block">
            Down Cycle的标识符聚焦遍历键。 
          </div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#setDefaultFocusTraversalKeys-int-java.util.Set-"><code>setDefaultFocusTraversalKeys(int, java.util.Set&lt;? extends java.awt.AWTKeyStroke&gt;)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getDefaultFocusTraversalKeys-int-"><code>getDefaultFocusTraversalKeys(int)</code></a> ， 
            <a href="../../java/awt/Component.html#setFocusTraversalKeys-int-java.util.Set-"><code>Component.setFocusTraversalKeys(int, java.util.Set&lt;? extends java.awt.AWTKeyStroke&gt;)</code></a> ， 
            <a href="../../java/awt/Component.html#getFocusTraversalKeys-int-"><code>Component.getFocusTraversalKeys(int)</code></a> ， 
            <a href="../../constant-values.html#java.awt.KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS">Constant Field Values</a>
</dd>
</dl> </li>
</ul> </li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!-- --> </a> <h3>构造方法详细信息</h3> <a name="KeyboardFocusManager--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>KeyboardFocusManager</h4> <pre>public KeyboardFocusManager()</pre>
<div class="block">
            初始化KeyboardFocusManager。 
          </div> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="getCurrentKeyboardFocusManager--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getCurrentKeyboardFocusManager</h4> <pre>public static <a href="../../java/awt/KeyboardFocusManager.html" title="class in java.awt">KeyboardFocusManager</a> getCurrentKeyboardFocusManager()</pre>
<div class="block">
            返回调用线程上下文的当前KeyboardFocusManager实例。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个线程的上下文的KeyboardFocusManager 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#setCurrentKeyboardFocusManager-java.awt.KeyboardFocusManager-"><code>setCurrentKeyboardFocusManager(java.awt.KeyboardFocusManager)</code></a>
</dd>
</dl> </li>
</ul> <a name="setCurrentKeyboardFocusManager-java.awt.KeyboardFocusManager-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setCurrentKeyboardFocusManager</h4> <pre>public static void setCurrentKeyboardFocusManager(<a href="../../java/awt/KeyboardFocusManager.html" title="class in java.awt">KeyboardFocusManager</a> newManager)
                                           throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>为调用线程的上下文设置当前的KeyboardFocusManager实例。</span>
<span>如果指定为null，则将使用DefaultKeyboardFocusManager的新实例替换当前的KeyboardFocusManager。</span>
<p> <span>如果安装了SecurityManager，则调用线程必须被授予AWTPermission“replaceKeyboardFocusManager”才能替换当前的KeyboardFocusManager。</span> <span>如果未授予此权限，则此方法将抛出SecurityException，并且当前的KeyboardFocusManager将不会更改。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>newManager</code> - 这个线程上下文的新KeyboardFocusManager 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果调用线程没有权限替换当前的KeyboardFocusManager 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/awt/KeyboardFocusManager.html#getCurrentKeyboardFocusManager--"><code>getCurrentKeyboardFocusManager()</code></a> ， <a href="../../java/awt/DefaultKeyboardFocusManager.html" title="java.awt中的类"><code>DefaultKeyboardFocusManager</code></a></span>
</dd>
</dl> </li>
</ul> <a name="getFocusOwner--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getFocusOwner</h4> <pre>public <a href="../../java/awt/Component.html" title="class in java.awt">Component</a> getFocusOwner()</pre>
<div class="block">
<span>如果焦点所有者与调用线程处于相同的上下文中，则返回焦点所有者。</span>
<span>焦点所有者被定义为通常将接收用户生成的所有KeyEvent的应用程序中的组件。</span>
<span>如果为焦点所有者启用了焦点遍历键，则映射到焦点所有者焦点遍历键的KeyEvent将不会被传送。</span>
<span>此外，KeyEventDispatchers可能会在到达焦点所有者之前重新定位或使用KeyEvent。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             焦点所有者，如果焦点所有者不是调用线程的上下文的成员，则为null 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#getGlobalFocusOwner--"><code>getGlobalFocusOwner()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#setGlobalFocusOwner-java.awt.Component-"><code>setGlobalFocusOwner(java.awt.Component)</code></a>
</dd>
</dl> </li>
</ul> <a name="getGlobalFocusOwner--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getGlobalFocusOwner</h4> <pre>protected <a href="../../java/awt/Component.html" title="class in java.awt">Component</a> getGlobalFocusOwner()
                                 throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>即使调用线程与焦点所有者的上下文不同，返回焦点所有者。</span>
<span>焦点所有者被定义为通常将接收用户生成的所有KeyEvent的应用程序中的组件。</span>
<span>如果为焦点所有者启用了焦点遍历键，则映射到焦点所有者焦点遍历键的KeyEvent将不会被传送。</span>
<span>此外，KeyEventDispatchers可能会在到达焦点所有者之前重新定位或使用KeyEvent。</span>
<p> <span>如果此KeyboardFocusManager不是调用线程的上下文的当前KeyboardFocusManager，则此方法将抛出SecurityException。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             焦点所有者 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果此KeyboardFocusManager不是调用线程上下文的当前KeyboardFocusManager，并且调用线程没有“replaceKeyboardFocusManager”权限 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#getFocusOwner--"><code>getFocusOwner()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#setGlobalFocusOwner-java.awt.Component-"><code>setGlobalFocusOwner(java.awt.Component)</code></a>
</dd>
</dl> </li>
</ul> <a name="setGlobalFocusOwner-java.awt.Component-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setGlobalFocusOwner</h4> <pre>protected void setGlobalFocusOwner(<a href="../../java/awt/Component.html" title="class in java.awt">Component</a> focusOwner)
                            throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>设置焦点所有者。</span>
<span>如果组件不可对焦，操作将被取消。</span>
<span>焦点所有者被定义为通常将接收用户生成的所有KeyEvent的应用程序中的组件。</span>
<span>如果为焦点所有者启用了焦点遍历键，则映射到焦点所有者焦点遍历键的KeyEvent将不会被传送。</span>
<span>此外，KeyEventDispatchers可能会在到达焦点所有者之前重新定位或使用KeyEvent。</span>
<p> <span>此方法实际上并没有将焦点设置为指定的组件。</span> <span>它仅存储getFocusOwner()后续返回的<code>getFocusOwner()</code> 。</span> <span>使用<code>Component.requestFocus()</code>或<code>Component.requestFocusInWindow()</code>更改焦点所有者，但受到平台限制。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>focusOwner</code> - 焦点所有者 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果此KeyboardFocusManager不是调用线程的上下文的当前KeyboardFocusManager，并且调用线程没有“replaceKeyboardFocusManager”权限 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#getFocusOwner--"><code>getFocusOwner()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getGlobalFocusOwner--"><code>getGlobalFocusOwner()</code></a> ， 
            <a href="../../java/awt/Component.html#requestFocus--"><code>Component.requestFocus()</code></a> ， 
            <a href="../../java/awt/Component.html#requestFocusInWindow--"><code>Component.requestFocusInWindow()</code></a> ， 
            <a href="../../java/awt/Component.html#isFocusable--"><code>Component.isFocusable()</code></a>
</dd>
</dl> </li>
</ul> <a name="clearFocusOwner--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>clearFocusOwner</h4> <pre>public void clearFocusOwner()</pre>
<div class="block">
<span>如果焦点所有者存在并驻留在与调用线程相同的上下文中，则清除Java和本机级别的焦点所有者，否则该方法将静默返回。</span>
<p> <span>焦点所有者组件将收到一个永久的FOCUS_LOST事件。</span> <span>此操作完成后，本机窗口系统将丢弃所有用户生成的KeyEvent，直到用户选择新组件来接收焦点，或者通过调用<code>requestFocus()</code>指定了一个<code>requestFocus()</code> 。</span> <span>此操作不会更改聚焦或活动的Windows。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/Component.html#requestFocus--"><code>Component.requestFocus()</code></a> ， 
            <a href="../../java/awt/event/FocusEvent.html#FOCUS_LOST"><code>FocusEvent.FOCUS_LOST</code></a>
</dd>
</dl> </li>
</ul> <a name="clearGlobalFocusOwner--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>clearGlobalFocusOwner</h4> <pre>public void clearGlobalFocusOwner()
                           throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>在Java和本机级别清除全局焦点所有者。</span>
<span>如果存在焦点所有者，该组件将收到一个永久的FOCUS_LOST事件。</span>
<span>完成此操作后，本机窗口系统将丢弃所有用户生成的KeyEvent，直到用户选择新的组件来接收焦点，或者通过调用<code>requestFocus()</code>指定了一个<code>requestFocus()</code> 。</span>
<span>此操作不会更改聚焦或活动的Windows。</span>
<p> <span>如果安装了SecurityManager，则调用线程必须被授予“replaceKeyboardFocusManager”AWTPermission。</span> <span>如果未授予此权限，则此方法将抛出SecurityException异常，并且不会清除当前焦点所有者。</span> </p>
<p> <span>此方法仅供KeyboardFocusManager设置为当前KeyboardFocusManager用于调用线程的上下文。</span> <span>它不是一般客户使用。</span> </p>
</div>
<dl>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果调用线程没有“replaceKeyboardFocusManager”权限 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#clearFocusOwner--"><code>clearFocusOwner()</code></a> ， 
            <a href="../../java/awt/Component.html#requestFocus--"><code>Component.requestFocus()</code></a> ， 
            <a href="../../java/awt/event/FocusEvent.html#FOCUS_LOST"><code>FocusEvent.FOCUS_LOST</code></a>
</dd>
</dl> </li>
</ul> <a name="getPermanentFocusOwner--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getPermanentFocusOwner</h4> <pre>public <a href="../../java/awt/Component.html" title="class in java.awt">Component</a> getPermanentFocusOwner()</pre>
<div class="block">
<span>如果永久焦点所有者与调用线程处于相同的上下文中，则返回永久焦点所有者。</span>
<span>永久焦点所有者被定义为应用程序中接收永久FOCUS_GAINED事件的最后一个组件。</span>
<span>焦点所有者和永久焦点所有者是等效的，除非临时焦点更改目前有效。</span>
<span>在这种情况下，临时焦点变化结束时，永久性焦点所有者将再次成为焦点所有者。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             永久焦点所有者，如果永久焦点所有者不是调用线程的上下文的成员，则为null 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#getGlobalPermanentFocusOwner--"><code>getGlobalPermanentFocusOwner()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#setGlobalPermanentFocusOwner-java.awt.Component-"><code>setGlobalPermanentFocusOwner(java.awt.Component)</code></a>
</dd>
</dl> </li>
</ul> <a name="getGlobalPermanentFocusOwner--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getGlobalPermanentFocusOwner</h4> <pre>protected <a href="../../java/awt/Component.html" title="class in java.awt">Component</a> getGlobalPermanentFocusOwner()
                                          throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>返回永久焦点所有者，即使调用线程与永久焦点所有者处于不同的上下文中。</span>
<span>永久焦点所有者被定义为应用程序中接收永久FOCUS_GAINED事件的最后一个组件。</span>
<span>焦点所有者和永久焦点所有者是等效的，除非临时焦点更改目前有效。</span>
<span>在这种情况下，临时焦点变化结束时，永久性焦点所有者将再次成为焦点所有者。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             永久焦点所有者 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果此KeyboardFocusManager不是调用线程上下文的当前KeyboardFocusManager，并且调用线程没有“replaceKeyboardFocusManager”权限 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#getPermanentFocusOwner--"><code>getPermanentFocusOwner()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#setGlobalPermanentFocusOwner-java.awt.Component-"><code>setGlobalPermanentFocusOwner(java.awt.Component)</code></a>
</dd>
</dl> </li>
</ul> <a name="setGlobalPermanentFocusOwner-java.awt.Component-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setGlobalPermanentFocusOwner</h4> <pre>protected void setGlobalPermanentFocusOwner(<a href="../../java/awt/Component.html" title="class in java.awt">Component</a> permanentFocusOwner)
                                     throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>设置永久焦点所有者。</span>
<span>如果组件不可对焦，操作将被取消。</span>
<span>永久焦点所有者被定义为应用程序中接收永久FOCUS_GAINED事件的最后一个组件。</span>
<span>焦点所有者和永久焦点所有者是等效的，除非临时焦点更改目前有效。</span>
<span>在这种情况下，临时焦点变化结束时，永久性焦点所有者将再次成为焦点所有者。</span>
<p> <span>此方法实际上并没有将焦点设置为指定的组件。</span> <span>它仅存储getPermanentFocusOwner()后续返回的<code>getPermanentFocusOwner()</code> 。</span> <span>使用<code>Component.requestFocus()</code>或<code>Component.requestFocusInWindow()</code>更改焦点所有者，受平台限制。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>permanentFocusOwner</code> - 永久性焦点所有者 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果此KeyboardFocusManager不是调用线程上下文的当前KeyboardFocusManager，并且调用线程没有“replaceKeyboardFocusManager”权限 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#getPermanentFocusOwner--"><code>getPermanentFocusOwner()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getGlobalPermanentFocusOwner--"><code>getGlobalPermanentFocusOwner()</code></a> ， 
            <a href="../../java/awt/Component.html#requestFocus--"><code>Component.requestFocus()</code></a> ， 
            <a href="../../java/awt/Component.html#requestFocusInWindow--"><code>Component.requestFocusInWindow()</code></a> ， 
            <a href="../../java/awt/Component.html#isFocusable--"><code>Component.isFocusable()</code></a>
</dd>
</dl> </li>
</ul> <a name="getFocusedWindow--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getFocusedWindow</h4> <pre>public <a href="../../java/awt/Window.html" title="class in java.awt">Window</a> getFocusedWindow()</pre>
<div class="block">
<span>如果集中的窗口与调用线程处于相同的上下文中，则返回关注的窗口。</span>
<span>关注的窗口是包含焦点所有者的窗口。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             关注的窗口，如果聚焦的窗口不是调用线程的上下文的成员，则为null 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#getGlobalFocusedWindow--"><code>getGlobalFocusedWindow()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#setGlobalFocusedWindow-java.awt.Window-"><code>setGlobalFocusedWindow(java.awt.Window)</code></a>
</dd>
</dl> </li>
</ul> <a name="getGlobalFocusedWindow--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getGlobalFocusedWindow</h4> <pre>protected <a href="../../java/awt/Window.html" title="class in java.awt">Window</a> getGlobalFocusedWindow()
                                 throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>返回聚焦窗口，即使调用线程与聚焦窗口处于不同的上下文中。</span>
<span>关注的窗口是包含焦点所有者的窗口。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             关注窗口 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果此KeyboardFocusManager不是调用线程上下文的当前KeyboardFocusManager，并且调用线程没有“replaceKeyboardFocusManager”权限 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#getFocusedWindow--"><code>getFocusedWindow()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#setGlobalFocusedWindow-java.awt.Window-"><code>setGlobalFocusedWindow(java.awt.Window)</code></a>
</dd>
</dl> </li>
</ul> <a name="setGlobalFocusedWindow-java.awt.Window-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setGlobalFocusedWindow</h4> <pre>protected void setGlobalFocusedWindow(<a href="../../java/awt/Window.html" title="class in java.awt">Window</a> focusedWindow)
                               throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>设置聚焦窗口。</span>
<span>关注的窗口是包含焦点所有者的窗口。</span>
<span>如果指定的对焦窗口不是可调焦窗口，则操作将被取消。</span>
<p> <span>就本地窗口系统而言，此方法实际上并没有改变关注窗口。</span> <span>它仅存储getFocusedWindow()后续返回的<code>getFocusedWindow()</code> 。</span> <span>使用<code>Component.requestFocus()</code>或<code>Component.requestFocusInWindow()</code>更改聚焦的窗口，受平台限制。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>focusedWindow</code> - 聚焦窗口 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果此KeyboardFocusManager不是调用线程上下文的当前KeyboardFocusManager，并且调用线程没有“replaceKeyboardFocusManager”权限 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#getFocusedWindow--"><code>getFocusedWindow()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getGlobalFocusedWindow--"><code>getGlobalFocusedWindow()</code></a> ， 
            <a href="../../java/awt/Component.html#requestFocus--"><code>Component.requestFocus()</code></a> ， 
            <a href="../../java/awt/Component.html#requestFocusInWindow--"><code>Component.requestFocusInWindow()</code></a> ， 
            <a href="../../java/awt/Window.html#isFocusableWindow--"><code>Window.isFocusableWindow()</code></a>
</dd>
</dl> </li>
</ul> <a name="getActiveWindow--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getActiveWindow</h4> <pre>public <a href="../../java/awt/Window.html" title="class in java.awt">Window</a> getActiveWindow()</pre>
<div class="block">
<span>如果活动窗口与调用线程处于相同的上下文中，则返回活动窗口。</span>
<span>只有框架或对话框可以是活动窗口。</span>
<span>本地窗口系统可以表示活动窗口或其具有特殊装饰的儿童，例如突出显示的标题栏。</span>
<span>活动窗口始终是聚焦的窗口，或者是聚焦窗口的所有者的第一个框架或对话框。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             活动窗口，如果活动窗口不是调用线程的上下文的成员，则为null 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#getGlobalActiveWindow--"><code>getGlobalActiveWindow()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#setGlobalActiveWindow-java.awt.Window-"><code>setGlobalActiveWindow(java.awt.Window)</code></a>
</dd>
</dl> </li>
</ul> <a name="getGlobalActiveWindow--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getGlobalActiveWindow</h4> <pre>protected <a href="../../java/awt/Window.html" title="class in java.awt">Window</a> getGlobalActiveWindow()
                                throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>返回活动窗口，即使调用线程与活动窗口处于不同的上下文中。</span>
<span>只有框架或对话框可以是活动窗口。</span>
<span>本地窗口系统可以表示活动窗口或其具有特殊装饰的儿童，例如突出显示的标题栏。</span>
<span>活动窗口始终是聚焦的窗口，或者是聚焦窗口的所有者的第一个框架或对话框。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             活动窗口 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果此KeyboardFocusManager不是调用线程上下文的当前KeyboardFocusManager，并且调用线程没有“replaceKeyboardFocusManager”权限 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#getActiveWindow--"><code>getActiveWindow()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#setGlobalActiveWindow-java.awt.Window-"><code>setGlobalActiveWindow(java.awt.Window)</code></a>
</dd>
</dl> </li>
</ul> <a name="setGlobalActiveWindow-java.awt.Window-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setGlobalActiveWindow</h4> <pre>protected void setGlobalActiveWindow(<a href="../../java/awt/Window.html" title="class in java.awt">Window</a> activeWindow)
                              throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>设置活动窗口。</span>
<span>只有框架或对话框可以是活动窗口。</span>
<span>本地窗口系统可以表示活动窗口或其具有特殊装饰的儿童，例如突出显示的标题栏。</span>
<span>活动窗口始终是聚焦的窗口，或者是聚焦窗口的所有者的第一个框架或对话框。</span>
<p> <span>就本地窗口系统而言，此方法实际上并不会更改活动窗口。</span> <span>它仅存储getActiveWindow()后续返回的<code>getActiveWindow()</code> 。</span> <span>使用<code>Component.requestFocus()</code>或<code>Component.requestFocusInWindow()</code>更改活动窗口，受平台限制。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>activeWindow</code> - 活动窗口 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果此KeyboardFocusManager不是调用线程上下文的当前KeyboardFocusManager，并且调用线程没有“replaceKeyboardFocusManager”权限 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#getActiveWindow--"><code>getActiveWindow()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getGlobalActiveWindow--"><code>getGlobalActiveWindow()</code></a> ， 
            <a href="../../java/awt/Component.html#requestFocus--"><code>Component.requestFocus()</code></a> ， 
            <a href="../../java/awt/Component.html#requestFocusInWindow--"><code>Component.requestFocusInWindow()</code></a>
</dd>
</dl> </li>
</ul> <a name="getDefaultFocusTraversalPolicy--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getDefaultFocusTraversalPolicy</h4> <pre>public <a href="../../java/awt/FocusTraversalPolicy.html" title="class in java.awt">FocusTraversalPolicy</a> getDefaultFocusTraversalPolicy()</pre>
<div class="block">
<span>返回默认的FocusTraversalPolicy。</span>
<span>顶级组件在创建时使用此值来通过显式调用Container.setFocusTraversalPolicy来初始化自己的焦点遍历策略。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>默认的FocusTraversalPolicy。</span>
<span>将永远不会返回null。</span>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#setDefaultFocusTraversalPolicy-java.awt.FocusTraversalPolicy-"><code>setDefaultFocusTraversalPolicy(java.awt.FocusTraversalPolicy)</code></a> ， 
            <a href="../../java/awt/Container.html#setFocusTraversalPolicy-java.awt.FocusTraversalPolicy-"><code>Container.setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)</code></a> ， 
            <a href="../../java/awt/Container.html#getFocusTraversalPolicy--"><code>Container.getFocusTraversalPolicy()</code></a>
</dd>
</dl> </li>
</ul> <a name="setDefaultFocusTraversalPolicy-java.awt.FocusTraversalPolicy-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setDefaultFocusTraversalPolicy</h4> <pre>public void setDefaultFocusTraversalPolicy(<a href="../../java/awt/FocusTraversalPolicy.html" title="class in java.awt">FocusTraversalPolicy</a> defaultPolicy)</pre>
<div class="block">
<span>设置默认的FocusTraversalPolicy。</span>
<span>顶级组件在创建时使用此值来通过显式调用Container.setFocusTraversalPolicy来初始化自己的焦点遍历策略。</span>
<span>注意：此调用不会影响已创建的组件，因为它们的策略已初始化。</span>
<span>只有新组件将使用此策略作为其默认策略。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>defaultPolicy</code> - 新的默认FocusTraversalPolicy 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果defaultPolicy为空 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#getDefaultFocusTraversalPolicy--"><code>getDefaultFocusTraversalPolicy()</code></a> ， 
            <a href="../../java/awt/Container.html#setFocusTraversalPolicy-java.awt.FocusTraversalPolicy-"><code>Container.setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)</code></a> ， 
            <a href="../../java/awt/Container.html#getFocusTraversalPolicy--"><code>Container.getFocusTraversalPolicy()</code></a>
</dd>
</dl> </li>
</ul> <a name="setDefaultFocusTraversalKeys-int-java.util.Set-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setDefaultFocusTraversalKeys</h4> <pre>public void setDefaultFocusTraversalKeys(int id,
                                         <a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;? extends <a href="../../java/awt/AWTKeyStroke.html" title="class in java.awt">AWTKeyStroke</a>&gt; keystrokes)</pre>
<div class="block">
<span>设置给定遍历操作的默认焦点遍历键。</span>
<span>此遍历键<code>Set</code>将在所有影响<code>Window</code> S作没有这样<code>Set</code>自己的明确定义。</span>
<span>这<code>Set</code>也将被继承，递归，任何孩子<code>Component</code>那些<code>Windows</code>有没有这样<code>Set</code>其自身的明确定义。</span>
<p> <span>默认焦点遍历键的默认值与实现相关。</span> <span>Sun建议特定本地平台的所有实现使用相同的默认值。</span> <span>Windows和Unix的建议如下。</span> <span>这些建议用于Sun AWT实现。</span> </p>
<span>  Identifier Meaning Default   <code>KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS</code> Normal forward keyboard traversal <code>TAB</code> on <code>KEY_PRESSED</code>, <code>CTRL-TAB</code> on <code>KEY_PRESSED</code> <code>KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS</code> Normal reverse keyboard traversal <code>SHIFT-TAB</code> on <code>KEY_PRESSED</code>, <code>CTRL-SHIFT-TAB</code> on <code>KEY_PRESSED</code> <code>KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS</code> Go up one focus traversal cycle none   <code>KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS</code> Go down one focus traversal cycle none  </span>
<table border="1" summary="Recommended default values for focus traversal keys">
</table>
<span>要禁用遍历键，请使用空的<code>Set</code> ;</span>
<span><code>Collections.EMPTY_SET</code> Collections.EMPTY_SET。</span>
<p> <span>使用<code>AWTKeyStroke</code> API，客户端代码可以指定哪两个特定的<code>KeyEvent</code> s， <code>KEY_PRESSED</code>或<code>KEY_RELEASED</code> ，将进行重点遍历操作。</span> <span>然而，无论<code>KeyEvent</code>哪个<code>KeyEvent</code> ，与所有<code>KeyEvent</code> s相关的所有<code>KeyEvent</code> s相关的重点遍历密钥，包括相关的<code>KEY_TYPED</code>事件将被消费，并且不会发送到任何<code>Component</code> 。</span> <span>指定<code>KEY_TYPED</code>事件映射到焦点遍历操作是一个运行时错误，或将同一事件映射到多个默认焦点遍历操作。</span> </p>
<p> <span>这种方法可能抛出<code>ClassCastException</code>如有<code>Object</code>在<code>keystrokes</code>不是<code>AWTKeyStroke</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>id</code> -一个 
            <code>KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS</code> ， 
            <code>KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS</code> ， 
            <code>KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS</code> ，或 
            <code>KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS</code>
</dd>
<dd>
<code>keystrokes</code> - 指定操作的 
            <code>AWTKeyStroke</code>的集合 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果ID不是一个 
            <code>KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS</code> ， 
            <code>KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS</code> ， 
            <code>KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS</code> ，或 
            <code>KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS</code> ，或按键为 
            <code>null</code> ，或者击键包含 
            <code>null</code> ，或者击键表示 
            <code>KEY_TYPED</code>事件，或者击键已映射为别的默认焦点遍历操作 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#getDefaultFocusTraversalKeys-int-"><code>getDefaultFocusTraversalKeys(int)</code></a> ， 
            <a href="../../java/awt/Component.html#setFocusTraversalKeys-int-java.util.Set-"><code>Component.setFocusTraversalKeys(int, java.util.Set&lt;? extends java.awt.AWTKeyStroke&gt;)</code></a> ， 
            <a href="../../java/awt/Component.html#getFocusTraversalKeys-int-"><code>Component.getFocusTraversalKeys(int)</code></a>
</dd>
</dl> </li>
</ul> <a name="getDefaultFocusTraversalKeys-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getDefaultFocusTraversalKeys</h4> <pre>public <a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;<a href="../../java/awt/AWTKeyStroke.html" title="class in java.awt">AWTKeyStroke</a>&gt; getDefaultFocusTraversalKeys(int id)</pre>
<div class="block">
<span>返回给定遍历操作的一组默认焦点遍历键。</span>
<span>这个遍历密钥集将在所有没有自己显式定义的这样的组的Windows上生效。</span>
<span>该集合也将被那些没有自己明确定义的这样的组的那些Windows的任何子组件递归递归。</span>
<span>（有关每个操作的完整说明，请参阅<code>setDefaultFocusTraversalKeys</code> ）</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>id</code> - 
            <code>id</code>之一，KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS，KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS或KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span><code>Set</code>的<code>AWTKeyStroke</code> s为指定的操作;</span>
<span><code>Set</code>将不可修改，可能为空;</span>
<span><code>null</code>永远不会退回</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果id不是KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS，KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS，KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS或KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS中的一个 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#setDefaultFocusTraversalKeys-int-java.util.Set-"><code>setDefaultFocusTraversalKeys(int, java.util.Set&lt;? extends java.awt.AWTKeyStroke&gt;)</code></a> ， 
            <a href="../../java/awt/Component.html#setFocusTraversalKeys-int-java.util.Set-"><code>Component.setFocusTraversalKeys(int, java.util.Set&lt;? extends java.awt.AWTKeyStroke&gt;)</code></a> ， 
            <a href="../../java/awt/Component.html#getFocusTraversalKeys-int-"><code>Component.getFocusTraversalKeys(int)</code></a>
</dd>
</dl> </li>
</ul> <a name="getCurrentFocusCycleRoot--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getCurrentFocusCycleRoot</h4> <pre>public <a href="../../java/awt/Container.html" title="class in java.awt">Container</a> getCurrentFocusCycleRoot()</pre>
<div class="block">
<span>如果当前焦点循环根与调用线程处于相同的上下文中，则返回当前焦点循环根。</span>
<span>如果焦点所有者本身是焦点循环根，那么对于哪些组件表示在正常聚焦遍历期间聚焦的下一个和以前的组件可能是不明确的。</span>
<span>在这种情况下，当前的焦点循环根用于区分可能性。</span>
<p> <span>此方法仅供KeyboardFocusManagers和焦点实施使用。</span> <span>它不是一般客户使用。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             当前焦点循环根，如果当前焦点循环根不是调用线程的上下文的成员，则为null 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#getGlobalCurrentFocusCycleRoot--"><code>getGlobalCurrentFocusCycleRoot()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#setGlobalCurrentFocusCycleRoot-java.awt.Container-"><code>setGlobalCurrentFocusCycleRoot(java.awt.Container)</code></a>
</dd>
</dl> </li>
</ul> <a name="getGlobalCurrentFocusCycleRoot--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getGlobalCurrentFocusCycleRoot</h4> <pre>protected <a href="../../java/awt/Container.html" title="class in java.awt">Container</a> getGlobalCurrentFocusCycleRoot()
                                            throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>返回当前焦点循环根，即使调用线程与当前焦点循环根不同。</span>
<span>如果焦点所有者本身是焦点循环根，那么对于哪些组件表示在正常聚焦遍历期间聚焦的下一个和以前的组件可能是不明确的。</span>
<span>在这种情况下，当前的焦点循环根用于区分可能性。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             当前焦点循环根，如果当前焦点循环根不是调用线程的上下文的成员，则为null 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果此KeyboardFocusManager不是调用线程上下文的当前KeyboardFocusManager，并且调用线程没有“replaceKeyboardFocusManager”权限 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#getCurrentFocusCycleRoot--"><code>getCurrentFocusCycleRoot()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#setGlobalCurrentFocusCycleRoot-java.awt.Container-"><code>setGlobalCurrentFocusCycleRoot(java.awt.Container)</code></a>
</dd>
</dl> </li>
</ul> <a name="setGlobalCurrentFocusCycleRoot-java.awt.Container-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setGlobalCurrentFocusCycleRoot</h4> <pre>public void setGlobalCurrentFocusCycleRoot(<a href="../../java/awt/Container.html" title="class in java.awt">Container</a> newFocusCycleRoot)
                                    throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>设置当前焦点循环根。</span>
<span>如果焦点所有者本身是焦点循环根，那么对于哪些组件表示在正常聚焦遍历期间聚焦的下一个和以前的组件可能是不明确的。</span>
<span>在这种情况下，当前的焦点循环根用于区分可能性。</span>
<p> <span>如果安装了SecurityManager，则调用线程必须被授予“replaceKeyboardFocusManager”AWTPermission。</span> <span>如果未授予此权限，则此方法将抛出SecurityException，并且当前焦点循环根不会被更改。</span> </p>
<p> <span>此方法仅供KeyboardFocusManagers和焦点实施使用。</span> <span>它不是一般客户使用。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>newFocusCycleRoot</code> - 新的焦点循环根 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果调用线程没有“replaceKeyboardFocusManager”权限 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#getCurrentFocusCycleRoot--"><code>getCurrentFocusCycleRoot()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getGlobalCurrentFocusCycleRoot--"><code>getGlobalCurrentFocusCycleRoot()</code></a>
</dd>
</dl> </li>
</ul> <a name="addPropertyChangeListener-java.beans.PropertyChangeListener-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>addPropertyChangeListener</h4> <pre>public void addPropertyChangeListener(<a href="../../java/beans/PropertyChangeListener.html" title="interface in java.beans">PropertyChangeListener</a> listener)</pre>
<div class="block">
<span>将PropertyChangeListener添加到侦听器列表。</span>
<span>监听器已注册到此类的所有绑定属性，包括以下内容：</span>
<ul>
<li> <span>KeyboardFocusManager是否正在管理此应用程序或小程序的浏览器上下文（“manageFocus”）的焦点</span> </li>
<li> <span>焦点所有者（“focusOwner”）</span> </li>
<li> <span>永久焦点所有者（“permanentFocusOwner”）</span> </li>
<li> <span>聚焦窗口（“focusedWindow”）</span> </li>
<li> <span>活动窗口（“activeWindow”）</span> </li>
<li> <span>默认焦点遍历策略（“defaultFocusTraversalPolicy”）</span> </li>
<li> <span>默认设置FORWARD_TRAVERSAL_KEYS（“forwardDefaultFocusTraversalKeys”）</span> </li>
<li> <span>默认设置BACKWARD_TRAVERSAL_KEYS（“backwardDefaultFocusTraversalKeys”）</span> </li>
<li> <span>默认设置UP_CYCLE_TRAVERSAL_KEYS（“upCycleDefaultFocusTraversalKeys”）</span> </li>
<li> <span>默认设置DOWN_CYCLE_TRAVERSAL_KEYS（“downCycleDefaultFocusTraversalKeys”）</span> </li>
<li> <span>当前焦点循环根（“currentFocusCycleRoot”）</span> </li>
</ul>
<span>如果侦听器为空，则不会抛出异常，也不会执行任何操作。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>listener</code> - 要添加的PropertyChangeListener 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#removePropertyChangeListener-java.beans.PropertyChangeListener-"><code>removePropertyChangeListener(java.beans.PropertyChangeListener)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getPropertyChangeListeners--"><code>getPropertyChangeListeners()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#addPropertyChangeListener-java.lang.String-java.beans.PropertyChangeListener-"><code>addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)</code></a>
</dd>
</dl> </li>
</ul> <a name="removePropertyChangeListener-java.beans.PropertyChangeListener-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>removePropertyChangeListener</h4> <pre>public void removePropertyChangeListener(<a href="../../java/beans/PropertyChangeListener.html" title="interface in java.beans">PropertyChangeListener</a> listener)</pre>
<div class="block">
<span>从侦听器列表中移除PropertyChangeListener。</span>
<span>应该使用此方法来删除已为此类的所有绑定属性注册的PropertyChangeListeners。</span>
<p> <span>如果侦听器为空，则不会抛出异常，也不会执行任何操作。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>listener</code> - 要删除的PropertyChangeListener 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#addPropertyChangeListener-java.beans.PropertyChangeListener-"><code>addPropertyChangeListener(java.beans.PropertyChangeListener)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getPropertyChangeListeners--"><code>getPropertyChangeListeners()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#removePropertyChangeListener-java.lang.String-java.beans.PropertyChangeListener-"><code>removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)</code></a>
</dd>
</dl> </li>
</ul> <a name="getPropertyChangeListeners--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getPropertyChangeListeners</h4> <pre>public <a href="../../java/beans/PropertyChangeListener.html" title="interface in java.beans">PropertyChangeListener</a>[] getPropertyChangeListeners()</pre>
<div class="block">
            返回在此键盘焦点管理器上注册的所有属性更改侦听器的数组。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             所有这个键盘焦点管理器的 
            <code>PropertyChangeListener</code> s或一个空数组，如果没有属性更改侦听器当前注册 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#addPropertyChangeListener-java.beans.PropertyChangeListener-"><code>addPropertyChangeListener(java.beans.PropertyChangeListener)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#removePropertyChangeListener-java.beans.PropertyChangeListener-"><code>removePropertyChangeListener(java.beans.PropertyChangeListener)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getPropertyChangeListeners-java.lang.String-"><code>getPropertyChangeListeners(java.lang.String)</code></a>
</dd>
</dl> </li>
</ul> <a name="addPropertyChangeListener-java.lang.String-java.beans.PropertyChangeListener-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>addPropertyChangeListener</h4> <pre>public void addPropertyChangeListener(<a href="../../java/lang/String.html" title="class in java.lang">String</a> propertyName,
                                      <a href="../../java/beans/PropertyChangeListener.html" title="interface in java.beans">PropertyChangeListener</a> listener)</pre>
<div class="block">
<span>将PropertyChangeListener添加到特定属性的侦听器列表中。</span>
<span>指定的属性可能是用户定义的，也可能是以下之一：</span>
<ul>
<li> <span>KeyboardFocusManager是否正在管理此应用程序或小程序的浏览器上下文（“manageFocus”）的焦点</span> </li>
<li> <span>焦点所有者（“focusOwner”）</span> </li>
<li> <span>永久焦点所有者（“permanentFocusOwner”）</span> </li>
<li> <span>聚焦窗口（“focusedWindow”）</span> </li>
<li> <span>活动窗口（“activeWindow”）</span> </li>
<li> <span>默认焦点遍历策略（“defaultFocusTraversalPolicy”）</span> </li>
<li> <span>默认设置FORWARD_TRAVERSAL_KEYS（“forwardDefaultFocusTraversalKeys”）</span> </li>
<li> <span>默认设置BACKWARD_TRAVERSAL_KEYS（“backwardDefaultFocusTraversalKeys”）</span> </li>
<li> <span>默认设置UP_CYCLE_TRAVERSAL_KEYS（“upCycleDefaultFocusTraversalKeys”）</span> </li>
<li> <span>默认设置DOWN_CYCLE_TRAVERSAL_KEYS（“downCycleDefaultFocusTraversalKeys”）</span> </li>
<li> <span>当前焦点循环根（“currentFocusCycleRoot”）</span> </li>
</ul>
<span>如果侦听器为空，则不会抛出异常，也不会执行任何操作。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>propertyName</code> - 上面列出的属性名称之一 
           </dd>
<dd>
<code>listener</code> - 要添加的PropertyChangeListener 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#addPropertyChangeListener-java.beans.PropertyChangeListener-"><code>addPropertyChangeListener(java.beans.PropertyChangeListener)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#removePropertyChangeListener-java.lang.String-java.beans.PropertyChangeListener-"><code>removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getPropertyChangeListeners-java.lang.String-"><code>getPropertyChangeListeners(java.lang.String)</code></a>
</dd>
</dl> </li>
</ul> <a name="removePropertyChangeListener-java.lang.String-java.beans.PropertyChangeListener-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>removePropertyChangeListener</h4> <pre>public void removePropertyChangeListener(<a href="../../java/lang/String.html" title="class in java.lang">String</a> propertyName,
                                         <a href="../../java/beans/PropertyChangeListener.html" title="interface in java.beans">PropertyChangeListener</a> listener)</pre>
<div class="block">
<span>从侦听器列表中为特定属性移除PropertyChangeListener。</span>
<span>应该使用此方法来删除为特定绑定属性注册的PropertyChangeListeners。</span>
<p> <span>如果侦听器为空，则不会抛出异常，也不会执行任何操作。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>propertyName</code> - 有效的属性名称 
           </dd>
<dd>
<code>listener</code> - 要删除的PropertyChangeListener 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#addPropertyChangeListener-java.lang.String-java.beans.PropertyChangeListener-"><code>addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getPropertyChangeListeners-java.lang.String-"><code>getPropertyChangeListeners(java.lang.String)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#removePropertyChangeListener-java.beans.PropertyChangeListener-"><code>removePropertyChangeListener(java.beans.PropertyChangeListener)</code></a>
</dd>
</dl> </li>
</ul> <a name="getPropertyChangeListeners-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getPropertyChangeListeners</h4> <pre>public <a href="../../java/beans/PropertyChangeListener.html" title="interface in java.beans">PropertyChangeListener</a>[] getPropertyChangeListeners(<a href="../../java/lang/String.html" title="class in java.lang">String</a> propertyName)</pre>
<div class="block">
            返回与named属性相关 
           <code>PropertyChangeListener</code>的所有 
           <code>PropertyChangeListener</code>的数组。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             所有与命名属性相关 
            <code>PropertyChangeListener</code> s或没有添加这样的侦听器的空数组。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#addPropertyChangeListener-java.lang.String-java.beans.PropertyChangeListener-"><code>addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#removePropertyChangeListener-java.lang.String-java.beans.PropertyChangeListener-"><code>removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)</code></a>
</dd>
</dl> </li>
</ul> <a name="firePropertyChange-java.lang.String-java.lang.Object-java.lang.Object-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>firePropertyChange</h4> <pre>protected void firePropertyChange(<a href="../../java/lang/String.html" title="class in java.lang">String</a> propertyName,
                                  <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> oldValue,
                                  <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> newValue)</pre>
<div class="block">
<span>触发PropertyChangeEvent以响应绑定属性的更改。</span>
<span>该事件将传递给所有注册的PropertyChangeListeners。</span>
<span>如果oldValue和newValue相同，则不会传递任何事件。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>propertyName</code> - 已更改的属性的名称 
           </dd>
<dd>
<code>oldValue</code> - 该物业的以前的价值 
           </dd>
<dd>
<code>newValue</code> - 该物业的新价值 
           </dd>
</dl> </li>
</ul> <a name="addVetoableChangeListener-java.beans.VetoableChangeListener-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>addVetoableChangeListener</h4> <pre>public void addVetoableChangeListener(<a href="../../java/beans/VetoableChangeListener.html" title="interface in java.beans">VetoableChangeListener</a> listener)</pre>
<div class="block">
<span>将VetoableChangeListener添加到侦听器列表。</span>
<span>监听器已注册该类的所有可判定属性，包括以下内容：</span>
<ul>
<li> <span>焦点所有者（“focusOwner”）</span> </li>
<li> <span>永久焦点所有者（“permanentFocusOwner”）</span> </li>
<li> <span>聚焦窗口（“focusedWindow”）</span> </li>
<li> <span>活动窗口（“activeWindow”）</span> </li>
</ul>
<span>如果侦听器为空，则不会抛出异常，也不会执行任何操作。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>listener</code> - 要添加的VetoableChangeListener 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#removeVetoableChangeListener-java.beans.VetoableChangeListener-"><code>removeVetoableChangeListener(java.beans.VetoableChangeListener)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getVetoableChangeListeners--"><code>getVetoableChangeListeners()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#addVetoableChangeListener-java.lang.String-java.beans.VetoableChangeListener-"><code>addVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener)</code></a>
</dd>
</dl> </li>
</ul> <a name="removeVetoableChangeListener-java.beans.VetoableChangeListener-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>removeVetoableChangeListener</h4> <pre>public void removeVetoableChangeListener(<a href="../../java/beans/VetoableChangeListener.html" title="interface in java.beans">VetoableChangeListener</a> listener)</pre>
<div class="block">
<span>从侦听器列表中删除VetoableChangeListener。</span>
<span>应该使用此方法来删除已为此类的所有可移动属性注册的VetoableChangeListeners。</span>
<p> <span>如果侦听器为空，则不会抛出异常，也不会执行任何操作。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>listener</code> - 要删除的VetoableChangeListener 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#addVetoableChangeListener-java.beans.VetoableChangeListener-"><code>addVetoableChangeListener(java.beans.VetoableChangeListener)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getVetoableChangeListeners--"><code>getVetoableChangeListeners()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#removeVetoableChangeListener-java.lang.String-java.beans.VetoableChangeListener-"><code>removeVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener)</code></a>
</dd>
</dl> </li>
</ul> <a name="getVetoableChangeListeners--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getVetoableChangeListeners</h4> <pre>public <a href="../../java/beans/VetoableChangeListener.html" title="interface in java.beans">VetoableChangeListener</a>[] getVetoableChangeListeners()</pre>
<div class="block">
            返回在此键盘焦点管理器上注册的所有否决变更监听器的数组。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             所有这个键盘焦点经理的 
            <code>VetoableChangeListener</code> s或一个空数组，如果没有否决变更听众当前注册 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#addVetoableChangeListener-java.beans.VetoableChangeListener-"><code>addVetoableChangeListener(java.beans.VetoableChangeListener)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#removeVetoableChangeListener-java.beans.VetoableChangeListener-"><code>removeVetoableChangeListener(java.beans.VetoableChangeListener)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getVetoableChangeListeners-java.lang.String-"><code>getVetoableChangeListeners(java.lang.String)</code></a>
</dd>
</dl> </li>
</ul> <a name="addVetoableChangeListener-java.lang.String-java.beans.VetoableChangeListener-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>addVetoableChangeListener</h4> <pre>public void addVetoableChangeListener(<a href="../../java/lang/String.html" title="class in java.lang">String</a> propertyName,
                                      <a href="../../java/beans/VetoableChangeListener.html" title="interface in java.beans">VetoableChangeListener</a> listener)</pre>
<div class="block">
<span>将VetoableChangeListener添加到特定属性的侦听器列表中。</span>
<span>指定的属性可能是用户定义的，也可能是以下之一：</span>
<ul>
<li> <span>焦点所有者（“focusOwner”）</span> </li>
<li> <span>永久焦点所有者（“permanentFocusOwner”）</span> </li>
<li> <span>聚焦窗口（“focusedWindow”）</span> </li>
<li> <span>活动窗口（“activeWindow”）</span> </li>
</ul>
<span>如果侦听器为空，则不会抛出异常，也不会执行任何操作。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>propertyName</code> - 上面列出的属性名称之一 
           </dd>
<dd>
<code>listener</code> - 要添加的VetoableChangeListener 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#addVetoableChangeListener-java.beans.VetoableChangeListener-"><code>addVetoableChangeListener(java.beans.VetoableChangeListener)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#removeVetoableChangeListener-java.beans.VetoableChangeListener-"><code>removeVetoableChangeListener(java.beans.VetoableChangeListener)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getVetoableChangeListeners--"><code>getVetoableChangeListeners()</code></a>
</dd>
</dl> </li>
</ul> <a name="removeVetoableChangeListener-java.lang.String-java.beans.VetoableChangeListener-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>removeVetoableChangeListener</h4> <pre>public void removeVetoableChangeListener(<a href="../../java/lang/String.html" title="class in java.lang">String</a> propertyName,
                                         <a href="../../java/beans/VetoableChangeListener.html" title="interface in java.beans">VetoableChangeListener</a> listener)</pre>
<div class="block">
<span>从侦听器列表中为特定属性删除VetoableChangeListener。</span>
<span>该方法应用于删除已注册为特定绑定属性的VetoableChangeListeners。</span>
<p> <span>如果侦听器为空，则不会抛出异常，也不会执行任何操作。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>propertyName</code> - 有效的属性名称 
           </dd>
<dd>
<code>listener</code> - 要删除的VetoableChangeListener 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#addVetoableChangeListener-java.beans.VetoableChangeListener-"><code>addVetoableChangeListener(java.beans.VetoableChangeListener)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getVetoableChangeListeners--"><code>getVetoableChangeListeners()</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#removeVetoableChangeListener-java.beans.VetoableChangeListener-"><code>removeVetoableChangeListener(java.beans.VetoableChangeListener)</code></a>
</dd>
</dl> </li>
</ul> <a name="getVetoableChangeListeners-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getVetoableChangeListeners</h4> <pre>public <a href="../../java/beans/VetoableChangeListener.html" title="interface in java.beans">VetoableChangeListener</a>[] getVetoableChangeListeners(<a href="../../java/lang/String.html" title="class in java.lang">String</a> propertyName)</pre>
<div class="block">
            返回与named属性相关 
           <code>VetoableChangeListener</code>的所有 
           <code>VetoableChangeListener</code>的数组。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             所有与命名属性相关 
            <code>VetoableChangeListener</code> s或没有添加这样的侦听器的空数组。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#addVetoableChangeListener-java.lang.String-java.beans.VetoableChangeListener-"><code>addVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#removeVetoableChangeListener-java.lang.String-java.beans.VetoableChangeListener-"><code>removeVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#getVetoableChangeListeners--"><code>getVetoableChangeListeners()</code></a>
</dd>
</dl> </li>
</ul> <a name="fireVetoableChange-java.lang.String-java.lang.Object-java.lang.Object-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fireVetoableChange</h4> <pre>protected void fireVetoableChange(<a href="../../java/lang/String.html" title="class in java.lang">String</a> propertyName,
                                  <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> oldValue,
                                  <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> newValue)
                           throws <a href="../../java/beans/PropertyVetoException.html" title="class in java.beans">PropertyVetoException</a></pre>
<div class="block">
<span>触发PropertyChangeEvent以响应否决权属性的更改。</span>
<span>该事件将交付给所有注册的VetoableChangeListeners。</span>
<span>如果VetoableChangeListener抛出PropertyVetoException，则会触发一个新事件，将所有VetoableChangeListener还原为旧值，然后重新引导异常。</span>
<span>如果oldValue和newValue相同，则不会传递任何事件。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>propertyName</code> - 已更改的属性的名称 
           </dd>
<dd>
<code>oldValue</code> - 该物业的以前的价值 
           </dd>
<dd>
<code>newValue</code> - 该物业的新价值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/beans/PropertyVetoException.html" title="class in java.beans">PropertyVetoException</a></code> - 如果一个 
            <code>VetoableChangeListener</code>投掷 
            <code>PropertyVetoException</code>
</dd>
</dl> </li>
</ul> <a name="addKeyEventDispatcher-java.awt.KeyEventDispatcher-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>addKeyEventDispatcher</h4> <pre>public void addKeyEventDispatcher(<a href="../../java/awt/KeyEventDispatcher.html" title="interface in java.awt">KeyEventDispatcher</a> dispatcher)</pre>
<div class="block">
<span>将KeyEventDispatcher添加到此KeyboardFocusManager的调度程序链中。</span>
<span>此KeyboardFocusManager将请求每个KeyEventDispatcher调度由用户生成的KeyEvents，然后最终分派KeyEvent本身。</span>
<span>KeyEventDispatchers将按照添加的顺序进行通知。</span>
<span>一旦<code>true</code>从其<code>dispatchKeyEvent</code>方法返回<code>true</code> ，通知将停止。</span>
<span>对于可以添加的KeyEventDispatchers的总数以及可以添加特定的KeyEventDispatcher实例的次数没有限制。</span>
<p> <span>如果指定了空调度器，则不会执行任何操作，也不会抛出任何异常。</span> </p>
<p> <span>在多线程应用程序中， <a href="../../java/awt/KeyEventDispatcher.html" title="java.awt中的接口"><code>KeyEventDispatcher</code></a>与其他AWT侦听<a href="../../java/awt/KeyEventDispatcher.html" title="java.awt中的接口">器的</a>行为相同。</span> <span>详见<a href="doc-files/AWTThreadIssues.html#ListenersThreads">AWT Threading Issues</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>dispatcher</code> - 要添加到调度程序链的KeyEventDispatcher 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#removeKeyEventDispatcher-java.awt.KeyEventDispatcher-"><code>removeKeyEventDispatcher(java.awt.KeyEventDispatcher)</code></a>
</dd>
</dl> </li>
</ul> <a name="removeKeyEventDispatcher-java.awt.KeyEventDispatcher-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>removeKeyEventDispatcher</h4> <pre>public void removeKeyEventDispatcher(<a href="../../java/awt/KeyEventDispatcher.html" title="interface in java.awt">KeyEventDispatcher</a> dispatcher)</pre>
<div class="block">
<span>删除之前添加到此KeyboardFocusManager调度程序链的KeyEventDispatcher。</span>
<span>此KeyboardFocusManager本身不能被删除，除非通过调用addKeyEventDispatcher明确重新<code>addKeyEventDispatcher</code> 。</span>
<p> <span>如果指定了一个空调度器，如果指定的调度程序不在调度程序链中，或者如果在未明确重新注册的情况下指定了此KeyboardFocusManager，则不会执行任何操作，也不会引发异常。</span> </p>
<p> <span>在多线程应用程序中， <a href="../../java/awt/KeyEventDispatcher.html" title="java.awt中的接口"><code>KeyEventDispatcher</code></a>与其他AWT侦听<a href="../../java/awt/KeyEventDispatcher.html" title="java.awt中的接口">器的</a>行为相同。</span> <span>详见<a href="doc-files/AWTThreadIssues.html#ListenersThreads">AWT Threading Issues</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>dispatcher</code> - 要从调度程序链中删除的KeyEventDispatcher 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#addKeyEventDispatcher-java.awt.KeyEventDispatcher-"><code>addKeyEventDispatcher(java.awt.KeyEventDispatcher)</code></a>
</dd>
</dl> </li>
</ul> <a name="getKeyEventDispatchers--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getKeyEventDispatchers</h4> <pre>protected <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;<a href="../../java/awt/KeyEventDispatcher.html" title="interface in java.awt">KeyEventDispatcher</a>&gt; getKeyEventDispatchers()</pre>
<div class="block">
<span>将此KeyboardFocusManager的KeyEventDispatcher链作为列表返回。</span>
<span>该列表将不包括此KeyboardFocusManager，除非通过调用<code>addKeyEventDispatcher</code>显式重新<code>addKeyEventDispatcher</code> 。</span>
<span>如果没有其他的KeyEventDispatchers被注册，实现可以自由地返回null或一个长度为0的列表。客户端代码不应该假定一个行为超过另一个，也不应该假定一旦建立的行为将不会改变。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可能为空或空的KeyEventDispatchers列表 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#addKeyEventDispatcher-java.awt.KeyEventDispatcher-"><code>addKeyEventDispatcher(java.awt.KeyEventDispatcher)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#removeKeyEventDispatcher-java.awt.KeyEventDispatcher-"><code>removeKeyEventDispatcher(java.awt.KeyEventDispatcher)</code></a>
</dd>
</dl> </li>
</ul> <a name="addKeyEventPostProcessor-java.awt.KeyEventPostProcessor-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>addKeyEventPostProcessor</h4> <pre>public void addKeyEventPostProcessor(<a href="../../java/awt/KeyEventPostProcessor.html" title="interface in java.awt">KeyEventPostProcessor</a> processor)</pre>
<div class="block">
<span>将KeyEventPostProcessor添加到此KeyboardFocusManager的后处理器链。</span>
<span>在KeyEvent已经被派发到目标的目标之后，KeyboardFocusManager将要求每个KeyEventPostProcessor执行任何必要的后期处理，作为KeyEvent的最终解决方案的一部分。</span>
<span>KeyEventPostProcessors将按照添加的顺序进行通知;</span>
<span>当前的KeyboardFocusManager最后会被通知。</span>
<span>一旦<code>true</code>从其<code>postProcessKeyEvent</code>方法返回<code>true</code> ，通知将停止。</span>
<span>对于可以添加的KeyEventPostProcessors的总数以及可以添加特定的KeyEventPostProcessor实例的次数没有限制。</span>
<p> <span>如果指定了空的后处理器，则不会采取任何操作，也不会抛出任何异常。</span> </p>
<p> <span>在多线程应用程序中， <a href="../../java/awt/KeyEventPostProcessor.html" title="java.awt中的接口"><code>KeyEventPostProcessor</code>的</a>行为与其他AWT侦听器相同。</span> <span>详见<a href="doc-files/AWTThreadIssues.html#ListenersThreads">AWT Threading Issues</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>processor</code> - 要添加到后处理器链的KeyEventPostProcessor 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#removeKeyEventPostProcessor-java.awt.KeyEventPostProcessor-"><code>removeKeyEventPostProcessor(java.awt.KeyEventPostProcessor)</code></a>
</dd>
</dl> </li>
</ul> <a name="removeKeyEventPostProcessor-java.awt.KeyEventPostProcessor-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>removeKeyEventPostProcessor</h4> <pre>public void removeKeyEventPostProcessor(<a href="../../java/awt/KeyEventPostProcessor.html" title="interface in java.awt">KeyEventPostProcessor</a> processor)</pre>
<div class="block">
<span>从此KeyboardFocusManager的后处理器链中删除以前添加的KeyEventPostProcessor。</span>
<span>这个KeyboardFocusManager本身不能从链中完全删除。</span>
<span>只有通过addKeyEventPostProcessor添加的其他<code>addKeyEventPostProcessor</code>可以被删除。</span>
<p> <span>如果指定了空的后处理器，如果指定的后处理器不在后处理器链中，或者如果未指定此KeyboardFocusManager，而不显式添加，则不会执行任何操作，也不会引发任何异常。</span> </p>
<p> <span>在多线程应用程序中， <a href="../../java/awt/KeyEventPostProcessor.html" title="java.awt中的接口"><code>KeyEventPostProcessor</code>的</a>行为与其他AWT侦听器相同。</span> <span>详见<a href="doc-files/AWTThreadIssues.html#ListenersThreads">AWT Threading Issues</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>processor</code> - 从后处理器链中删除的KeyEventPostProcessor 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#addKeyEventPostProcessor-java.awt.KeyEventPostProcessor-"><code>addKeyEventPostProcessor(java.awt.KeyEventPostProcessor)</code></a>
</dd>
</dl> </li>
</ul> <a name="getKeyEventPostProcessors--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getKeyEventPostProcessors</h4> <pre>protected <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;<a href="../../java/awt/KeyEventPostProcessor.html" title="interface in java.awt">KeyEventPostProcessor</a>&gt; getKeyEventPostProcessors()</pre>
<div class="block">
<span>将此KeyboardFocusManager的KeyEventPostProcessor链返回为列表。</span>
<span>该列表将不包括此KeyboardFocusManager，除非通过调用显式添加到<code>addKeyEventPostProcessor</code> 。</span>
<span>如果没有注册KeyEventPostProcessors，实现可以返回null或者一个长度为0的列表。客户端代码不应该假定一个行为超过另一个，也不应该假定一旦建立的行为将不会改变。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可能为空或空的KeyEventPostProcessors列表 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#addKeyEventPostProcessor-java.awt.KeyEventPostProcessor-"><code>addKeyEventPostProcessor(java.awt.KeyEventPostProcessor)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#removeKeyEventPostProcessor-java.awt.KeyEventPostProcessor-"><code>removeKeyEventPostProcessor(java.awt.KeyEventPostProcessor)</code></a>
</dd>
</dl> </li>
</ul> <a name="dispatchEvent-java.awt.AWTEvent-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>dispatchEvent</h4> <pre>public abstract boolean dispatchEvent(<a href="../../java/awt/AWTEvent.html" title="class in java.awt">AWTEvent</a> e)</pre>
<div class="block">
<span>该方法由AWT事件调度程序调用，请求当前的KeyboardFocusManager代表它发送指定的事件。</span>
<span>预计所有的KeyboardFocusManagers将派发所有FocusEvents，所有与焦点相关的WindowEvent和所有KeyEvents。</span>
<span>这些事件应该基于KeyboardFocusManager对焦点所有者和聚焦和活动Windows的概念进行调度，有时覆盖指定AWTEvent的来源。</span>
<span>必须使用<code>redispatchEvent</code>进行<code>redispatchEvent</code> ，以防止AWT事件分派器递归地请求KeyboardFocusManager再次分派事件。</span>
<span>如果此方法返回<code>false</code> ，则AWT事件调度程序将尝试调度事件本身。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>e</code> - 要发送的AWTEvent 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span><code>true</code>如果此方法调度事件;</span>
<span><code>false</code>否则</span>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#redispatchEvent-java.awt.Component-java.awt.AWTEvent-"><code>redispatchEvent(java.awt.Component, java.awt.AWTEvent)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#dispatchKeyEvent-java.awt.event.KeyEvent-"><code>dispatchKeyEvent(java.awt.event.KeyEvent)</code></a>
</dd>
</dl> </li>
</ul> <a name="redispatchEvent-java.awt.Component-java.awt.AWTEvent-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>redispatchEvent</h4> <pre>public final void redispatchEvent(<a href="../../java/awt/Component.html" title="class in java.awt">Component</a> target,
                                  <a href="../../java/awt/AWTEvent.html" title="class in java.awt">AWTEvent</a> e)</pre>
<div class="block">
<span>重新分配AWTEvent，AWT事件调度程序将不会递归地请求KeyboardFocusManager或任何已安装的KeyEventDispatchers再次发送事件。</span>
<span><code>dispatchEvent</code>和客户端定义的KeyEventDispatchers的客户端实现必须调用<code>redispatchEvent(target, e)</code>而不是<code>target.dispatchEvent(e)</code>来分派事件。</span>
<p> <span>此方法仅供KeyboardFocusManagers和KeyEventDispatchers使用。</span> <span>它不是一般客户使用。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>target</code> - 事件应分发到的组件 
           </dd>
<dd>
<code>e</code> - 要发送的事件 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/awt/KeyboardFocusManager.html#dispatchEvent-java.awt.AWTEvent-"><code>dispatchEvent(java.awt.AWTEvent)</code></a> ， <a href="../../java/awt/KeyEventDispatcher.html" title="java.awt中的接口"><code>KeyEventDispatcher</code></a></span>
</dd>
</dl> </li>
</ul> <a name="dispatchKeyEvent-java.awt.event.KeyEvent-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>dispatchKeyEvent</h4> <pre>public abstract boolean dispatchKeyEvent(<a href="../../java/awt/event/KeyEvent.html" title="class in java.awt.event">KeyEvent</a> e)</pre>
<div class="block">
<span>典型地，该方法将被调用<code>dispatchEvent</code>如果在调度程序链没有其他的KeyEventDispatcher调度KeyEvent，或者如果没有注册其他KeyEventDispatcher。</span>
<span>如果此方法的实现返回<code>false</code> ， <code>dispatchEvent</code>可能试图指派KeyEvent本身，或者可能简单地返回<code>false</code> 。</span>
<span>如果<code>true</code>返回， <code>dispatchEvent</code>也应该返回<code>true</code> 。</span>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../java/awt/KeyEventDispatcher.html#dispatchKeyEvent-java.awt.event.KeyEvent-">dispatchKeyEvent</a></code>在接口 
            <code><a href="../../java/awt/KeyEventDispatcher.html" title="interface in java.awt">KeyEventDispatcher</a></code>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>e</code> - 当前KeyboardFocusManager请求此KeyEventDispatcher调度的KeyEvent 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span><code>true</code>如果KeyEvent被调度;</span>
<span><code>false</code>否则</span>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#dispatchEvent-java.awt.AWTEvent-"><code>dispatchEvent(java.awt.AWTEvent)</code></a>
</dd>
</dl> </li>
</ul> <a name="postProcessKeyEvent-java.awt.event.KeyEvent-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>postProcessKeyEvent</h4> <pre>public abstract boolean postProcessKeyEvent(<a href="../../java/awt/event/KeyEvent.html" title="class in java.awt.event">KeyEvent</a> e)</pre>
<div class="block">
<span>此方法将被调用<code>dispatchKeyEvent</code> 。</span>
<span>默认情况下，此方法将通过消耗事件并激活快捷方式来处理映射到AWT <code>MenuShortcut</code>的任何未<code>MenuShortcut</code>的KeyEvents。</span>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../java/awt/KeyEventPostProcessor.html#postProcessKeyEvent-java.awt.event.KeyEvent-">postProcessKeyEvent</a></code>在接口 
            <code><a href="../../java/awt/KeyEventPostProcessor.html" title="interface in java.awt">KeyEventPostProcessor</a></code>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>e</code> - 后期处理的KeyEvent 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>表示没有其他的KeyEventPostProcessor将被通知KeyEvent。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/awt/KeyboardFocusManager.html#dispatchKeyEvent-java.awt.event.KeyEvent-"><code>dispatchKeyEvent(java.awt.event.KeyEvent)</code></a> ， <a href="../../java/awt/MenuShortcut.html" title="java.awt中的类"><code>MenuShortcut</code></a></span>
</dd>
</dl> </li>
</ul> <a name="processKeyEvent-java.awt.Component-java.awt.event.KeyEvent-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>processKeyEvent</h4> <pre>public abstract void processKeyEvent(<a href="../../java/awt/Component.html" title="class in java.awt">Component</a> focusedComponent,
                                     <a href="../../java/awt/event/KeyEvent.html" title="class in java.awt.event">KeyEvent</a> e)</pre>
<div class="block">
<span>当且仅当KeyEvent表示指定的focusComponent的焦点遍历键时，此方法启动焦点遍历操作。</span>
<span>预计focusComponent是当前的焦点所有者，尽管不一定是这样。</span>
<span>如果不是，聚焦遍历将继续进行，就像focusedComponent是当前焦点所有者一样。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>focusedComponent</code> - 组件，它将作为聚焦遍历操作的基础，如果指定的事件表示组件的焦点遍历键 
           </dd>
<dd>
<code>e</code> - 可能代表焦点遍历键的事件 
           </dd>
</dl> </li>
</ul> <a name="enqueueKeyEvents-long-java.awt.Component-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>enqueueKeyEvents</h4> <pre>protected abstract void enqueueKeyEvents(long after,
                                         <a href="../../java/awt/Component.html" title="class in java.awt">Component</a> untilFocused)</pre>
<div class="block">
<span>由AWT调用，通知KeyboardFocusManager它应该延迟调度KeyEvents，直到指定的Component成为焦点所有者。</span>
<span>如果客户端代码请求焦点更改，并且AWT确定此请求可能由本机窗口系统授予，则AWT将调用此方法。</span>
<span>KeyboardFocusManager有责任延迟使用时间戳晚于指定时间戳的KeyEvents调度，直到指定的组件收到FOCUS_GAINED事件，或AWT通过调用<code>dequeueKeyEvents</code>或<code>discardKeyEvents</code>取消延迟请求。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>after</code> - 当前事件的时间戳或当前事件没有时间戳的当前系统时间，或者AWT无法确定当前正在处理哪个事件 
           </dd>
<dd>
<code>untilFocused</code> - 应该在任何待处理的KeyEvent之前收到FOCUS_GAINED事件的组件 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#dequeueKeyEvents-long-java.awt.Component-"><code>dequeueKeyEvents(long, java.awt.Component)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#discardKeyEvents-java.awt.Component-"><code>discardKeyEvents(java.awt.Component)</code></a>
</dd>
</dl> </li>
</ul> <a name="dequeueKeyEvents-long-java.awt.Component-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>dequeueKeyEvents</h4> <pre>protected abstract void dequeueKeyEvents(long after,
                                         <a href="../../java/awt/Component.html" title="class in java.awt">Component</a> untilFocused)</pre>
<div class="block">
<span>由AWT调用以通知KeyboardFocusManager它应该取消KeyEvents的延迟调度。</span>
<span>这是因为排队到呼叫的所有KeyEvent <code>enqueueKeyEvents</code>具有相同时间戳和Component应该被释放正常指派到当前焦点所有者。</span>
<span>如果给定的时间戳小于零，则应取消给具有<b>最早</b>时间戳（如果有）的给定组件的未完成的入队请求。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>after</code> - 在调用enqueueKeyEvents中指定的 
            <code>enqueueKeyEvents</code> ，或任何值&lt;0 
           </dd>
<dd>
<code>untilFocused</code> - 在调用enqueueKeyEvents中指定的 
            <code>enqueueKeyEvents</code>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#enqueueKeyEvents-long-java.awt.Component-"><code>enqueueKeyEvents(long, java.awt.Component)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#discardKeyEvents-java.awt.Component-"><code>discardKeyEvents(java.awt.Component)</code></a>
</dd>
</dl> </li>
</ul> <a name="discardKeyEvents-java.awt.Component-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>discardKeyEvents</h4> <pre>protected abstract void discardKeyEvents(<a href="../../java/awt/Component.html" title="class in java.awt">Component</a> comp)</pre>
<div class="block">
<span>由AWT调用以通知KeyboardFocusManager它应该取消KeyEvents的延迟调度。</span>
<span>这是因为排队的一个或多个调用所有KeyEvent <code>enqueueKeyEvents</code>用相同的组件应该被丢弃。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>comp</code> - 在一次或多次调用 
            <code>enqueueKeyEvents</code>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/awt/KeyboardFocusManager.html#enqueueKeyEvents-long-java.awt.Component-"><code>enqueueKeyEvents(long, java.awt.Component)</code></a> ， 
            <a href="../../java/awt/KeyboardFocusManager.html#dequeueKeyEvents-long-java.awt.Component-"><code>dequeueKeyEvents(long, java.awt.Component)</code></a>
</dd>
</dl> </li>
</ul> <a name="focusNextComponent-java.awt.Component-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>focusNextComponent</h4> <pre>public abstract void focusNextComponent(<a href="../../java/awt/Component.html" title="class in java.awt">Component</a> aComponent)</pre>
<div class="block">
            将组件聚焦在aComponent之后，通常基于FocusTraversalPolicy。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>aComponent</code> - 作为焦点遍历操作的基础的组件 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/awt/FocusTraversalPolicy.html" title="java.awt中的类"><code>FocusTraversalPolicy</code></a></span>
</dd>
</dl> </li>
</ul> <a name="focusPreviousComponent-java.awt.Component-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>focusPreviousComponent</h4> <pre>public abstract void focusPreviousComponent(<a href="../../java/awt/Component.html" title="class in java.awt">Component</a> aComponent)</pre>
<div class="block">
            在组件之前聚焦组件，通常基于FocusTraversalPolicy。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>aComponent</code> - 作为焦点遍历操作的基础的组件 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/awt/FocusTraversalPolicy.html" title="java.awt中的类"><code>FocusTraversalPolicy</code></a></span>
</dd>
</dl> </li>
</ul> <a name="upFocusCycle-java.awt.Component-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>upFocusCycle</h4> <pre>public abstract void upFocusCycle(<a href="../../java/awt/Component.html" title="class in java.awt">Component</a> aComponent)</pre>
<div class="block">
<span>将焦点移动到一个焦点遍历周期。</span>
<span>通常，焦点所有者设置为aComponent的焦点循环根，并将当前焦点循环根设置为新焦点所有者的焦点循环根。</span>
<span>然而，如果aComponent的焦点循环根是Window，那么通常将焦点所有者设置为Window的默认组件进行聚焦，并且当前焦点循环根不变。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>aComponent</code> - 作为焦点遍历操作的基础的组件 
           </dd>
</dl> </li>
</ul> <a name="downFocusCycle-java.awt.Container-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>downFocusCycle</h4> <pre>public abstract void downFocusCycle(<a href="../../java/awt/Container.html" title="class in java.awt">Container</a> aContainer)</pre>
<div class="block">
<span>将焦点向下移动一个焦点遍历周期。</span>
<span>通常，如果aContainer是焦点循环根，则焦点所有者将设置为aContainer的默认组件以进行对焦，并将当前焦点循环根设置为aContainer。</span>
<span>如果aContainer不是焦点循环根，则不会发生焦点遍历操作。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>aContainer</code> - 作为焦点遍历操作的基础的容器 
           </dd>
</dl> </li>
</ul> <a name="focusNextComponent--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>focusNextComponent</h4> <pre>public final void focusNextComponent()</pre>
<div class="block">
            在当前焦点所有者之后聚焦组件。 
          </div> </li>
</ul> <a name="focusPreviousComponent--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>focusPreviousComponent</h4> <pre>public final void focusPreviousComponent()</pre>
<div class="block">
            将组件聚焦到当前焦点所有者之前。 
          </div> </li>
</ul> <a name="upFocusCycle--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>upFocusCycle</h4> <pre>public final void upFocusCycle()</pre>
<div class="block">
<span>将焦点移动到当前焦点所有者的一个焦点遍历周期。</span>
<span>通常，新的焦点所有者设置为当前焦点所有者的焦点循环根，并将当前焦点循环根设置为新焦点所有者的焦点循环根。</span>
<span>但是，如果当前焦点所有者的焦点循环根是Window，则通常将焦点所有者设置为焦点循环根的默认组件以进行对焦，并且当前焦点循环根未更改。</span>
</div> </li>
</ul> <a name="downFocusCycle--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>downFocusCycle</h4> <pre>public final void downFocusCycle()</pre>
<div class="block">
<span>当焦点所有者是当前焦点循环根的容器时，将焦点向下移动当前焦点所有者的一个焦点遍历循环。</span>
<span>通常，焦点所有者设置为当前焦点所有者的默认组件以进行对焦，并将当前焦点循环根设置为当前焦点所有者。</span>
<span>如果当前焦点所有者不是作为焦点循环根的容器，则不会发生焦点遍历操作。</span>
</div> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>