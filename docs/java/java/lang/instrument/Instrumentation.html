<div class="header">
<div class="subTitle">
     compact3 
   </div>
<div class="subTitle">
     java.lang.instrument 
   </div>
<h2 class="title" title="Interface Instrumentation">Interface Instrumentation</h2>
</div><div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre>public interface <span class="typeNameLabel">Instrumentation</span></pre>
<div class="block">
<span>该类提供了用于设计Java编程语言代码所需的服务。</span>
<span>仪器是向方法添加字节码，用于收集工具要使用的数据。</span>
<span>由于这些更改纯粹是加法的，因此这些工具不会修改应用程序的状态或行为。</span>
<span>这种良性工具的示例包括监视代理，剖析器，覆盖分析器和事件记录器。</span>
<p> <span>有两种获取<code>Instrumentation</code>接口实例的方法：</span> </p>
<ol>
<li><p> <span>当以指示代理类的方式启动JVM时。</span> <span>在这种情况下， <code>Instrumentation</code>实例被传递给代理类的<code>premain</code>方法。</span> </p></li>
<li><p> <span>当JVM在JVM启动后的某个时间提供启动代理的机制时。</span> <span>在这种情况下， <code>Instrumentation</code>实例将传递给代理代码的<code>agentmain</code>方法。</span> </p></li>
</ol>
<p> <span>这些机制在package specification中有<a href="../../../java/lang/instrument/package-summary.html">描述</a> 。</span> </p>
<p> <span>一旦代理商获得一个<code>Instrumentation</code>实例，代理可以随时调用实例上的方法。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.5 
       </dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t3"><span><a href="javascript:show(4);">抽象方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/instrument/Instrumentation.html#addTransformer-java.lang.instrument.ClassFileTransformer-">addTransformer</a></span>(<a href="../../../java/lang/instrument/ClassFileTransformer.html" title="interface in java.lang.instrument">ClassFileTransformer</a> transformer)</code>
<div class="block">
              注册提供的变压器。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/instrument/Instrumentation.html#addTransformer-java.lang.instrument.ClassFileTransformer-boolean-">addTransformer</a></span>(<a href="../../../java/lang/instrument/ClassFileTransformer.html" title="interface in java.lang.instrument">ClassFileTransformer</a> transformer, boolean canRetransform)</code>
<div class="block">
              注册提供的变压器。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/instrument/Instrumentation.html#appendToBootstrapClassLoaderSearch-java.util.jar.JarFile-">appendToBootstrapClassLoaderSearch</a></span>(<a href="../../../java/util/jar/JarFile.html" title="class in java.util.jar">JarFile</a> jarfile)</code>
<div class="block">
              指定具有由引导类加载器定义的检测类的JAR文件。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/instrument/Instrumentation.html#appendToSystemClassLoaderSearch-java.util.jar.JarFile-">appendToSystemClassLoaderSearch</a></span>(<a href="../../../java/util/jar/JarFile.html" title="class in java.util.jar">JarFile</a> jarfile)</code>
<div class="block">
              指定具有由系统类加载器定义的检测类的JAR文件。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code><a href="../../../java/lang/Class.html" title="class in java.lang">类</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/instrument/Instrumentation.html#getAllLoadedClasses--">getAllLoadedClasses</a></span>()</code>
<div class="block">
              返回当前由JVM加载的所有类的数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code><a href="../../../java/lang/Class.html" title="class in java.lang">类</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/instrument/Instrumentation.html#getInitiatedClasses-java.lang.ClassLoader-">getInitiatedClasses</a></span>(<a href="../../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> loader)</code>
<div class="block">
              返回一个 
             <code>loader</code>是起始加载器的所有类的数组。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/instrument/Instrumentation.html#getObjectSize-java.lang.Object-">getObjectSize</a></span>(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> objectToSize)</code>
<div class="block">
              返回指定对象所消耗的存储量的实现特定近似值。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/instrument/Instrumentation.html#isModifiableClass-java.lang.Class-">isModifiableClass</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; theClass)</code>
<div class="block">
              确定课程是否可以通过 
             <a href="../../../java/lang/instrument/Instrumentation.html#retransformClasses-java.lang.Class...-">retransformation</a>或 
             <a href="../../../java/lang/instrument/Instrumentation.html#redefineClasses-java.lang.instrument.ClassDefinition...-">redefinition进行修改</a> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/instrument/Instrumentation.html#isNativeMethodPrefixSupported--">isNativeMethodPrefixSupported</a></span>()</code>
<div class="block">
              返回当前JVM配置是否支持 
             <a href="../../../java/lang/instrument/Instrumentation.html#setNativeMethodPrefix-java.lang.instrument.ClassFileTransformer-java.lang.String-">setting a native method prefix</a> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/instrument/Instrumentation.html#isRedefineClassesSupported--">isRedefineClassesSupported</a></span>()</code>
<div class="block">
              返回当前的JVM配置是否支持重新定义类。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/instrument/Instrumentation.html#isRetransformClassesSupported--">isRetransformClassesSupported</a></span>()</code>
<div class="block">
              返回当前JVM配置是否支持对类进行重新传输。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/instrument/Instrumentation.html#redefineClasses-java.lang.instrument.ClassDefinition...-">redefineClasses</a></span>(<a href="../../../java/lang/instrument/ClassDefinition.html" title="class in java.lang.instrument">ClassDefinition</a>... definitions)</code>
<div class="block">
              使用提供的类文件重新定义提供的一组类。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/instrument/Instrumentation.html#removeTransformer-java.lang.instrument.ClassFileTransformer-">removeTransformer</a></span>(<a href="../../../java/lang/instrument/ClassFileTransformer.html" title="interface in java.lang.instrument">ClassFileTransformer</a> transformer)</code>
<div class="block">
              注销提供的变压器。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/instrument/Instrumentation.html#retransformClasses-java.lang.Class...-">retransformClasses</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;... classes)</code>
<div class="block">
              重新转换提供的一组类。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/instrument/Instrumentation.html#setNativeMethodPrefix-java.lang.instrument.ClassFileTransformer-java.lang.String-">setNativeMethodPrefix</a></span>(<a href="../../../java/lang/instrument/ClassFileTransformer.html" title="interface in java.lang.instrument">ClassFileTransformer</a> transformer, <a href="../../../java/lang/String.html" title="class in java.lang">String</a> prefix)</code>
<div class="block">
              此方法通过允许使用应用于名称的前缀进行重试来修改本机方法解析的故障处理。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="addTransformer-java.lang.instrument.ClassFileTransformer-boolean-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>addTransformer</h4> <pre>void addTransformer(<a href="../../../java/lang/instrument/ClassFileTransformer.html" title="interface in java.lang.instrument">ClassFileTransformer</a> transformer,
                    boolean canRetransform)</pre>
<div class="block">
<span>注册提供的变压器。</span>
<span>所有未来的类定义将被变压器看到，除了任何已注册的变压器所依赖的类的定义。</span>
<span>当类被加载时，当它们是<a href="../../../java/lang/instrument/Instrumentation.html#redefineClasses-java.lang.instrument.ClassDefinition...-">redefined</a>时<a href="../../../java/lang/instrument/Instrumentation.html#redefineClasses-java.lang.instrument.ClassDefinition...-">调用变压器</a> 。</span>
<span>如果<code>canRetransform</code>为真， <a href="../../../java/lang/instrument/Instrumentation.html#retransformClasses-java.lang.Class...-">则为retransformed</a> 。</span>
<span>有关变换调用的顺序，请参阅<a href="../../../java/lang/instrument/ClassFileTransformer.html#transform-java.lang.ClassLoader-java.lang.String-java.lang.Class-java.security.ProtectionDomain-byte:A-"><code>ClassFileTransformer.transform</code></a> 。</span>
<span>如果变压器在执行过程中引发异常，则JVM依然会调用其他已注册的变压器。</span>
<span>相同的变压器可能不止一次添加，但强烈不鼓励 - 通过创建一个新的变压器类实例来避免这种情况。</span>
<p> <span>此方法旨在用于检测使用中，当在所描述的<a href="../../../java/lang/instrument/Instrumentation.html" title="java.lang.instrument中的接口">class specification</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>transformer</code> - 要注册的变压器 
           </dd>
<dd>
<code>canRetransform</code> - 可以将该变压器的转换重新转换 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果通过一个 
            <code>null</code>变压器 
           </dd>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果 
            <code>canRetransform</code>为true并且JVM的当前配置不允许转发（ 
            <a href="../../../java/lang/instrument/Instrumentation.html#isRetransformClassesSupported--"><code>isRetransformClassesSupported()</code></a>为假） 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="addTransformer-java.lang.instrument.ClassFileTransformer-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>addTransformer</h4> <pre>void addTransformer(<a href="../../../java/lang/instrument/ClassFileTransformer.html" title="interface in java.lang.instrument">ClassFileTransformer</a> transformer)</pre>
<div class="block">
<span>注册提供的变压器。</span>
<p> <span>与<code>addTransformer(transformer, false)</code>相同。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>transformer</code> - 要注册的变压器 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果通过一个 
            <code>null</code>变压器 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/instrument/Instrumentation.html#addTransformer-java.lang.instrument.ClassFileTransformer-boolean-"><code>addTransformer(ClassFileTransformer,boolean)</code></a>
</dd>
</dl> </li>
</ul> <a name="removeTransformer-java.lang.instrument.ClassFileTransformer-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>removeTransformer</h4> <pre>boolean removeTransformer(<a href="../../../java/lang/instrument/ClassFileTransformer.html" title="interface in java.lang.instrument">ClassFileTransformer</a> transformer)</pre>
<div class="block">
<span>注销提供的变压器。</span>
<span>未来类定义将不会显示给变压器。</span>
<span>删除最新添加的变压器匹配实例。</span>
<span>由于类加载的多线程性质，变压器可以在其被移除之后接收呼叫。</span>
<span>应该防范变形金刚来预期这种情况。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>transformer</code> - 要注销的变压器 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             如果发现和移除变压器，则为真，如果没有找到变压器，则为真 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果通过一个 
            <code>null</code>变压器 
           </dd>
</dl> </li>
</ul> <a name="isRetransformClassesSupported--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isRetransformClassesSupported</h4> <pre>boolean isRetransformClassesSupported()</pre>
<div class="block">
<span>返回当前JVM配置是否支持对类进行重新传输。</span>
<span>转载已加载类的能力是JVM的可选功能。</span>
<span>如果重转换将仅被支持<code>Can-Retransform-Classes</code>清单属性被设置为<code>true</code>在代理JAR文件（如在所描述的<a href="../../../java/lang/instrument/package-summary.html">package specification</a> ）和JVM支持此功能。</span>
<span>在单个JVM的单个实例化过程中，对此方法的多次调用将始终返回相同的答案。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             如果当前的JVM配置支持重新传递类，则为true，否则为false。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/instrument/Instrumentation.html#retransformClasses-java.lang.Class...-"><code>retransformClasses(java.lang.Class&lt;?&gt;...)</code></a>
</dd>
</dl> </li>
</ul> <a name="retransformClasses-java.lang.Class...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>retransformClasses</h4> <pre>void retransformClasses(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;... classes)
                 throws <a href="../../../java/lang/instrument/UnmodifiableClassException.html" title="class in java.lang.instrument">UnmodifiableClassException</a></pre>
<div class="block">
<span>重新转换提供的一组类。</span>
<p> <span>此功能有助于已加载类的检测。</span> <span>当初始加载类或者当它们是<a href="../../../java/lang/instrument/Instrumentation.html#redefineClasses-java.lang.instrument.ClassDefinition...-">redefined</a>时，初始类文件字节可以用<code>ClassFileTransformer</code>进行<a href="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument中的接口">转换</a> 。</span> <span>此函数重新运行转换过程（无论以前是否发生转换）。</span> <span>此转发遵循以下步骤：</span> </p>
<ul>
<li> <span>从初始类文件字节开始</span> </li>
<li> <span>对于添加了<code>canRetransform</code>的每个变压器，在最后一个类加载或重新定义期间由<a href="../../../java/lang/instrument/ClassFileTransformer.html#transform-java.lang.ClassLoader-java.lang.String-java.lang.Class-java.security.ProtectionDomain-byte:A-"><code>transform</code></a>返回的字节被重新用作转换的输出;</span> <span>请注意，这相当于重新应用以前的转换，未改变;</span> <span>除了<a href="../../../java/lang/instrument/ClassFileTransformer.html#transform-java.lang.ClassLoader-java.lang.String-java.lang.Class-java.security.ProtectionDomain-byte:A-"><code>transform</code></a>不被调用</span> </li>
<li> <span>对于添加了<code>canRetransform</code>的每个变压器，在这些变压器中调用<a href="../../../java/lang/instrument/ClassFileTransformer.html#transform-java.lang.ClassLoader-java.lang.String-java.lang.Class-java.security.ProtectionDomain-byte:A-"><code>transform</code></a>方法</span> </li>
<li> <span>转换的类文件字节作为类的新定义安装</span> </li>
</ul>
<p> <span><a href="../../../java/lang/instrument/ClassFileTransformer.html#transform-java.lang.ClassLoader-java.lang.String-java.lang.Class-java.security.ProtectionDomain-byte:A-"><code>transform</code></a>方法描述了<a href="../../../java/lang/instrument/ClassFileTransformer.html#transform-java.lang.ClassLoader-java.lang.String-java.lang.Class-java.security.ProtectionDomain-byte:A-">转换顺序</a> 。</span> <span>在重新编码无法转换的自动重新应用中使用相同的顺序。</span> </p>
<p> <span>初始类文件字节表示传递给<a href="../../../java/lang/ClassLoader.html#defineClass-byte:A-int-int-"><code>ClassLoader.defineClass</code></a>或<a href="../../../java/lang/instrument/Instrumentation.html#redefineClasses-java.lang.instrument.ClassDefinition...-"><code>redefineClasses</code></a> （在应用任何转换之前）的字节，但它们可能不完全匹配。</span> <span>常量池可能不具有相同的布局或内容。</span> <span>常量池可能有更多或更少的条目。</span> <span>常量池条目可能有不同的顺序;</span> <span>然而，方法的字节码中的常量池索引将对应。</span> <span>某些属性可能不存在。</span> <span>如果订单无意义，例如方法的顺序，订单可能不会被保留。</span> </p>
<p> <span>该方法对一组进行操作，以允许同时对多个类进行相互依赖的更改（类A的重新转换可能需要对类B进行重新转换）。</span> </p>
<p> <span>如果重新转换的方法具有活动堆栈帧，则这些活动帧将继续运行原始方法的字节码。</span> <span>重新构建的方法将用于新的调用。</span> </p>
<p> <span>该方法不会导致任何初始化，除了在常规JVM语义下会发生。</span> <span>换句话说，重新定义一个类并不会导致它的初始化器被运行。</span> <span>静态变量的值将保持在调用之前。</span> </p>
<p> <span>转载类的实例不受影响。</span> </p>
<p> <span>重新转换可能会改变方法体，常量池和属性。</span> <span>重新传输不能添加，删除或重命名字段或方法，更改方法的签名或更改继承。</span> <span>这些限制可能在将来的版本中解除。</span> <span>类文件字节不会被检查，验证和安装，直到应用转换为止，如果结果字节错误，则此方法将抛出异常。</span> </p>
<p> <span>如果此方法抛出异常，则不会重新创建任何类。</span> </p>
<p> <span>此方法旨在用于检测使用中，当在所描述的<a href="../../../java/lang/instrument/Instrumentation.html" title="java.lang.instrument中的接口">class specification</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>classes</code> - 要转发的类的数组;</span>
<span>允许零长度数组，在这种情况下，此方法什么也不做</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/instrument/UnmodifiableClassException.html" title="class in java.lang.instrument">UnmodifiableClassException</a></code> - 如果指定的类不能被修改（ 
            <a href="../../../java/lang/instrument/Instrumentation.html#isModifiableClass-java.lang.Class-"><code>isModifiableClass(java.lang.Class&lt;?&gt;)</code></a>将返回 
            <code>false</code> ） 
           </dd>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果JVM的当前配置不允许重新传输（ 
            <a href="../../../java/lang/instrument/Instrumentation.html#isRetransformClassesSupported--"><code>isRetransformClassesSupported()</code></a>为false）或重新尝试进行不受支持的更改 
           </dd>
<dd>
<code><a href="../../../java/lang/ClassFormatError.html" title="class in java.lang">ClassFormatError</a></code> - 如果数据不包含有效的类 
           </dd>
<dd>
<code><a href="../../../java/lang/NoClassDefFoundError.html" title="class in java.lang">NoClassDefFoundError</a></code> - 如果类文件中的名称不等于类的名称 
           </dd>
<dd>
<code><a href="../../../java/lang/UnsupportedClassVersionError.html" title="class in java.lang">UnsupportedClassVersionError</a></code> - 如果不支持类文件版本号 
           </dd>
<dd>
<code><a href="../../../java/lang/ClassCircularityError.html" title="class in java.lang">ClassCircularityError</a></code> - 如果新类包含循环 
           </dd>
<dd>
<code><a href="../../../java/lang/LinkageError.html" title="class in java.lang">LinkageError</a></code> - 如果发生链接错误 
           </dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果提供的类数组或其任何组件是 
            <code>null</code> 。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../../java/lang/instrument/Instrumentation.html#isRetransformClassesSupported--"><code>isRetransformClassesSupported()</code></a> ， <a href="../../../java/lang/instrument/Instrumentation.html#addTransformer-java.lang.instrument.ClassFileTransformer-boolean-"><code>addTransformer(java.lang.instrument.ClassFileTransformer, boolean)</code></a> ， <a href="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument中的接口"><code>ClassFileTransformer</code></a></span>
</dd>
</dl> </li>
</ul> <a name="isRedefineClassesSupported--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isRedefineClassesSupported</h4> <pre>boolean isRedefineClassesSupported()</pre>
<div class="block">
<span>返回当前的JVM配置是否支持重新定义类。</span>
<span>重新定义已加载类的功能是JVM的可选功能。</span>
<span>如果重新定义将仅被支持<code>Can-Redefine-Classes</code>清单属性被设置为<code>true</code>在代理JAR文件（如在所描述的<a href="../../../java/lang/instrument/package-summary.html">package specification</a> ）和JVM支持此功能。</span>
<span>在单个JVM的单个实例化过程中，对此方法的多次调用将始终返回相同的答案。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             如果当前的JVM配置支持重新定义类，则为true，否则为false。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/instrument/Instrumentation.html#redefineClasses-java.lang.instrument.ClassDefinition...-"><code>redefineClasses(java.lang.instrument.ClassDefinition...)</code></a>
</dd>
</dl> </li>
</ul> <a name="redefineClasses-java.lang.instrument.ClassDefinition...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>redefineClasses</h4> <pre>void redefineClasses(<a href="../../../java/lang/instrument/ClassDefinition.html" title="class in java.lang.instrument">ClassDefinition</a>... definitions)
              throws <a href="../../../java/lang/ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a>,
                     <a href="../../../java/lang/instrument/UnmodifiableClassException.html" title="class in java.lang.instrument">UnmodifiableClassException</a></pre>
<div class="block">
<span>使用提供的类文件重新定义提供的一组类。</span>
<p> <span>该方法用于替换类的定义，而不引用现有的类文件字节，就像从源进行重新编译以进行修复和继续调试时一样。</span> <span>在现有的类文件字节要转换的地方（例如，在字节码仪器中）应该使用<a href="../../../java/lang/instrument/Instrumentation.html#retransformClasses-java.lang.Class...-"><code>retransformClasses</code></a> 。</span> </p>
<p> <span>该方法对一组进行操作，以便同时允许多个类的相互依赖的更改（A类的重新定义可能需要重新定义B类）。</span> </p>
<p> <span>如果重新定义的方法具有活动堆栈帧，则这些活动帧将继续运行原始方法的字节码。</span> <span>重新定义的方法将用于新的调用。</span> </p>
<p> <span>该方法不会导致任何初始化，除了在常规JVM语义下会发生。</span> <span>换句话说，重新定义一个类并不会导致它的初始化器被运行。</span> <span>静态变量的值将保持在调用之前。</span> </p>
<p> <span>重新定义的类的实例不受影响。</span> </p>
<p> <span>重新定义可能会改变方法体，常量池和属性。</span> <span>重定义不能添加，删除或重命名字段或方法，更改方法的签名或更改继承。</span> <span>这些限制可能在将来的版本中解除。</span> <span>类文件字节不会被检查，验证和安装，直到应用转换为止，如果结果字节错误，则此方法将抛出异常。</span> </p>
<p> <span>如果此方法抛出异常，则不会重新定义任何类。</span> </p>
<p> <span>此方法旨在用于检测使用中，当在所描述的<a href="../../../java/lang/instrument/Instrumentation.html" title="java.lang.instrument中的接口">class specification</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>definitions</code> - 重新定义相应定义的类的数组;</span>
<span>允许零长度数组，在这种情况下，此方法什么也不做</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/instrument/UnmodifiableClassException.html" title="class in java.lang.instrument">UnmodifiableClassException</a></code> - 如果指定的类不能被修改（ 
            <a href="../../../java/lang/instrument/Instrumentation.html#isModifiableClass-java.lang.Class-"><code>isModifiableClass(java.lang.Class&lt;?&gt;)</code></a>将返回 
            <code>false</code> ） 
           </dd>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果JVM的当前配置不允许重新定义（ 
            <a href="../../../java/lang/instrument/Instrumentation.html#isRedefineClassesSupported--"><code>isRedefineClassesSupported()</code></a>为false）或重新定义尝试进行不受支持的更改 
           </dd>
<dd>
<code><a href="../../../java/lang/ClassFormatError.html" title="class in java.lang">ClassFormatError</a></code> - 如果数据不包含有效的类 
           </dd>
<dd>
<code><a href="../../../java/lang/NoClassDefFoundError.html" title="class in java.lang">NoClassDefFoundError</a></code> - 如果类文件中的名称不等于类的名称 
           </dd>
<dd>
<code><a href="../../../java/lang/UnsupportedClassVersionError.html" title="class in java.lang">UnsupportedClassVersionError</a></code> - 如果不支持类文件版本号 
           </dd>
<dd>
<code><a href="../../../java/lang/ClassCircularityError.html" title="class in java.lang">ClassCircularityError</a></code> - 如果新类包含圆形 
           </dd>
<dd>
<code><a href="../../../java/lang/LinkageError.html" title="class in java.lang">LinkageError</a></code> - 如果发生链接错误 
           </dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果提供的定义数组或其任何组件是 
            <code>null</code>
</dd>
<dd>
<code><a href="../../../java/lang/ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a></code> - 永远不能抛出（仅出于兼容性原因出现） 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../../java/lang/instrument/Instrumentation.html#isRedefineClassesSupported--"><code>isRedefineClassesSupported()</code></a> ， <a href="../../../java/lang/instrument/Instrumentation.html#addTransformer-java.lang.instrument.ClassFileTransformer-boolean-"><code>addTransformer(java.lang.instrument.ClassFileTransformer, boolean)</code></a> ， <a href="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument中的接口"><code>ClassFileTransformer</code></a></span>
</dd>
</dl> </li>
</ul> <a name="isModifiableClass-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isModifiableClass</h4> <pre>boolean isModifiableClass(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; theClass)</pre>
<div class="block">
<span>确定课程是否可以通过<a href="../../../java/lang/instrument/Instrumentation.html#retransformClasses-java.lang.Class...-">retransformation</a>或<a href="../../../java/lang/instrument/Instrumentation.html#redefineClasses-java.lang.instrument.ClassDefinition...-">redefinition进行修改</a> 。</span>
<span>如果类是可修改的，那么此方法返回<code>true</code> 。</span>
<span>如果类不可修改，则此方法返回<code>false</code> 。</span>
<p> <span>对于要转载的类， <a href="../../../java/lang/instrument/Instrumentation.html#isRetransformClassesSupported--"><code>isRetransformClassesSupported()</code></a>也必须是真的。</span> <span>但价值<code>isRetransformClassesSupported()</code>不影响此函数返回的值。</span> <span>对于要重新定义的类， <a href="../../../java/lang/instrument/Instrumentation.html#isRedefineClassesSupported--"><code>isRedefineClassesSupported()</code></a>也必须是真的。</span> <span>但价值<code>isRedefineClassesSupported()</code>不影响此函数返回的值。</span> </p>
<p> <span>原始类（例如， <code>java.lang.Integer.TYPE</code> ）和数组类永远都不可修改。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>theClass</code> - 检查可修改的类 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             参数类是否可修改 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果指定的类是 
            <code>null</code> 。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/instrument/Instrumentation.html#retransformClasses-java.lang.Class...-"><code>retransformClasses(java.lang.Class&lt;?&gt;...)</code></a> ， 
            <a href="../../../java/lang/instrument/Instrumentation.html#isRetransformClassesSupported--"><code>isRetransformClassesSupported()</code></a> ， 
            <a href="../../../java/lang/instrument/Instrumentation.html#redefineClasses-java.lang.instrument.ClassDefinition...-"><code>redefineClasses(java.lang.instrument.ClassDefinition...)</code></a> ， 
            <a href="../../../java/lang/instrument/Instrumentation.html#isRedefineClassesSupported--"><code>isRedefineClassesSupported()</code></a>
</dd>
</dl> </li>
</ul> <a name="getAllLoadedClasses--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getAllLoadedClasses</h4> <pre><a href="../../../java/lang/Class.html" title="class in java.lang">类</a>[] getAllLoadedClasses()</pre>
<div class="block">
            返回当前由JVM加载的所有类的数组。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个包含JVM加载的所有类的数组，如果没有，则为零长度 
           </dd>
</dl> </li>
</ul> <a name="getInitiatedClasses-java.lang.ClassLoader-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getInitiatedClasses</h4> <pre><a href="../../../java/lang/Class.html" title="class in java.lang">类</a>[] getInitiatedClasses(<a href="../../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> loader)</pre>
<div class="block">
<span>返回<code>loader</code>是起始加载程序的所有类的数组。</span>
<span>如果提供的加载程序是<code>null</code> ，则返回由引导类加载器启动的类。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>loader</code> - 将返回其启动的类列表的加载程序 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个包含加载器是启动加载器的所有类的数组，如果没有，则为零长度 
           </dd>
</dl> </li>
</ul> <a name="getObjectSize-java.lang.Object-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getObjectSize</h4> <pre>long getObjectSize(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> objectToSize)</pre>
<div class="block">
<span>返回指定对象所消耗的存储量的实现特定近似值。</span>
<span>结果可能包括一些或全部对象的开销，因此对于实现之间的比较而言不是有用的。</span>
<span>在JVM的单次调用期间，估计可能会发生变化。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>objectToSize</code> - 对象的大小 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定对象所消耗的存储量的实现特定近似 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果提供的对象是 
            <code>null</code> 。 
           </dd>
</dl> </li>
</ul> <a name="appendToBootstrapClassLoaderSearch-java.util.jar.JarFile-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>appendToBootstrapClassLoaderSearch</h4> <pre>void appendToBootstrapClassLoaderSearch(<a href="../../../java/util/jar/JarFile.html" title="class in java.util.jar">JarFile</a> jarfile)</pre>
<div class="block">
<span>指定具有由引导类加载器定义的检测类的JAR文件。</span>
<p> <span>当虚拟机的内置类加载器，被称为“引导类加载器”，未成功搜索的一类，在条目<a href="../../../java/util/jar/JarFile.html" title="java.util.jar中的类"><code>JAR file</code></a>会被搜索。</span> </p>
<p> <span>该方法可以被多次使用，以按照调用此方法的顺序添加要搜索的多个JAR文件。</span> </p>
<p> <span>代理应该注意确保JAR不包含除了引导类加载器为了进行检测而定义的类之外的任何类或资源。</span> <span>不遵守此警告可能导致难以诊断的意外行为。</span> <span>例如，假设有一个加载器L，并且用于委托的L''s parent是引导类加载器。</span> <span>此外，类C中由L定义的类的方法引用非公共访问器类C $ 1。</span> <span>如果JAR文件包含C $ 1类，则引导类加载器的委派将导致C $ 1由引导类加载器定义。</span> <span>在此示例中， <code>IllegalAccessError</code>将被抛出，可能导致应用程序失败。</span> <span>避免这些类型问题的一种方法是使用检测类的唯一包名称。</span> </p>
<p> <span><cite>The Java™ Virtual Machine Specification</cite>指定后续尝试解析Java虚拟机先前未成功尝试解析的符号引用始终会失败，并导致与初始解析尝试结果相同的错误。</span> <span>因此，如果JAR文件包含与Java虚拟机未成功尝试解析引用的类对应的条目，则后续尝试解析该引用将失败，并且与初始尝试相同。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>jarfile</code> - 引导类加载程序无法搜索类时要搜索的JAR文件。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>jarfile</code>是 
            <code>null</code> 。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../../java/lang/instrument/Instrumentation.html#appendToSystemClassLoaderSearch-java.util.jar.JarFile-"><code>appendToSystemClassLoaderSearch(java.util.jar.JarFile)</code></a> ， <a href="../../../java/lang/ClassLoader.html" title="java.lang中的类"><code>ClassLoader</code></a> ， <a href="../../../java/util/jar/JarFile.html" title="java.util.jar中的类"><code>JarFile</code></a></span>
</dd>
</dl> </li>
</ul> <a name="appendToSystemClassLoaderSearch-java.util.jar.JarFile-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>appendToSystemClassLoaderSearch</h4> <pre>void appendToSystemClassLoaderSearch(<a href="../../../java/util/jar/JarFile.html" title="class in java.util.jar">JarFile</a> jarfile)</pre>
<div class="block">
<span>指定具有由系统类加载器定义的检测类的JAR文件。</span>
<span>当用于委派的系统类加载器（参见<a href="../../../java/lang/ClassLoader.html#getSystemClassLoader--"><code>getSystemClassLoader()</code></a> ）不成功地搜索类时，也将搜索<a href="../../../java/util/jar/JarFile.html" title="java.util.jar中的类"><code>JarFile</code></a>中的条目。</span>
<p> <span>该方法可以被多次使用，以按照调用此方法的顺序添加要搜索的多个JAR文件。</span> </p>
<p> <span>代理应该注意确保JAR不包含系统类加载器为了进行检测而定义的任何类或资源。</span> <span>不遵守此警告可能导致难以诊断的意外行为（参见<a href="../../../java/lang/instrument/Instrumentation.html#appendToBootstrapClassLoaderSearch-java.util.jar.JarFile-"><code>appendToBootstrapClassLoaderSearch</code></a> ）。</span> </p>
<p> <span>系统类加载器支持添加，如果它实现了一个命名的方法要被搜索的JAR文件<code>appendToClassPathForInstrumentation</code>其中采用类型的单个参数<code>java.lang.String</code> 。</span> <span>该方法不需要具有<code>public</code>访问权限。</span> <span>通过调用获得的JAR文件的名称<a href="../../../java/util/zip/ZipFile.html#getName--"><code>getName()</code></a>上的方法<code>jarfile</code>并且这被设置为参数的<code>appendToClassPathForInstrumentation</code>方法。</span> </p>
<p> <span><cite>The Java™ Virtual Machine Specification</cite>指定后续尝试解析Java虚拟机先前未成功尝试解析的符号引用始终会失败，并导致与初始解析尝试结果相同的错误。</span> <span>因此，如果JAR文件包含与Java虚拟机未成功尝试解析引用的类对应的条目，则后续尝试解析该引用将失败，并且与初始尝试相同。</span> </p>
<p> <span>此方法不会更改<code>java.class.path</code> <a href="../../../java/lang/System.html#getProperties--"><code>system property</code></a>的值。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>jarfile</code> - 当系统类加载程序不成功搜索类时要搜索的JAR文件。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果系统类加载器不支持追加要搜索的JAR文件。 
           </dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>jarfile</code>是 
            <code>null</code> 。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../../java/lang/instrument/Instrumentation.html#appendToBootstrapClassLoaderSearch-java.util.jar.JarFile-"><code>appendToBootstrapClassLoaderSearch(java.util.jar.JarFile)</code></a> ， <a href="../../../java/lang/ClassLoader.html#getSystemClassLoader--"><code>ClassLoader.getSystemClassLoader()</code></a> ， <a href="../../../java/util/jar/JarFile.html" title="java.util.jar中的类"><code>JarFile</code></a></span>
</dd>
</dl> </li>
</ul> <a name="isNativeMethodPrefixSupported--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isNativeMethodPrefixSupported</h4> <pre>boolean isNativeMethodPrefixSupported()</pre>
<div class="block">
<span>返回当前JVM配置是否支持<a href="../../../java/lang/instrument/Instrumentation.html#setNativeMethodPrefix-java.lang.instrument.ClassFileTransformer-java.lang.String-">setting a native method prefix</a> 。</span>
<span>设置本机方法前缀的功能是JVM的可选功能。</span>
<span>设置本机方法前缀，如果将仅被支持<code>Can-Set-Native-Method-Prefix</code>清单属性被设置为<code>true</code>在代理JAR文件（如在所描述的<a href="../../../java/lang/instrument/package-summary.html">package specification</a> ）和JVM支持此功能。</span>
<span>在单个JVM的单个实例化过程中，对此方法的多次调用将始终返回相同的答案。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             如果当前的JVM配置支持设置本机方法前缀，则为true，否则为false。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/instrument/Instrumentation.html#setNativeMethodPrefix-java.lang.instrument.ClassFileTransformer-java.lang.String-"><code>setNativeMethodPrefix(java.lang.instrument.ClassFileTransformer, java.lang.String)</code></a>
</dd>
</dl> </li>
</ul> <a name="setNativeMethodPrefix-java.lang.instrument.ClassFileTransformer-java.lang.String-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>setNativeMethodPrefix</h4> <pre>void setNativeMethodPrefix(<a href="../../../java/lang/instrument/ClassFileTransformer.html" title="interface in java.lang.instrument">ClassFileTransformer</a> transformer,
                           <a href="../../../java/lang/String.html" title="class in java.lang">String</a> prefix)</pre>
<div class="block">
<span>此方法通过允许使用应用于名称的前缀进行重试来修改本机方法解析的故障处理。</span>
<span>当与<a href="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument中的接口"><code>ClassFileTransformer</code></a>一起使用时，它可以对本地方法进行检测。</span>
<p> <span>由于本地方法无法直接进行检测（它们没有字节码），因此必须使用可以进行检测的非本地方法来包装。</span> <span>例如，如果我们有：</span> </p>
<pre>  <span>native boolean foo(int x);</span> </pre>
<p> <span>我们可以转换类文件（在类的初始定义中使用ClassFileTransformer），以便这将变为：</span> </p>
<pre>  <span>boolean foo(int x) {
     <i>... record entry to foo ...</i>
     return wrapped_foo(x);
   }

   native boolean wrapped_foo(int x);</span> </pre>
<p> <span>其中<code>foo</code>成为具有附加前缀“wrapped_”的实际本机方法的包装器。</span> <span>请注意，“wrapped_”将是一个不好的前缀选择，因为它可能构成现有方法的名称，因此像“$$$ MyAgentWrapped $$$ _”会更好，但会使这些示例变得更不可读。</span> </p>
<p> <span>包装器将允许在本地方法调用中收集数据，但现在问题就是将包装方法与本地实现相关联。</span> <span>也就是说，方法<code>wrapped_foo</code>需要解决到foo的本机<code>foo</code> ，这可能是：</span> </p>
<pre>  <span>Java_somePackage_someClass_foo(JNIEnv* env, jint x)</span> </pre>
<p> <span>此功能允许指定前缀并发生正确的分辨率。</span> <span>具体来说，当标准分辨率失败时，会考虑前缀来重试分辨率。</span> <span>分辨率有两种方式，使用JNI功能显示<code>RegisterNatives</code>和正常的自动分辨率。</span> <span>对于<code>RegisterNatives</code> ，JVM将尝试此关联：</span> </p>
<pre>  <span><code> method(foo) -&gt; nativeImplementation(foo) </code></span> </pre>
<p> <span>当此失败时，将以方法名称前面的指定前缀重新执行解析，得到正确的解析度：</span> </p>
<pre>  <span><code> method(wrapped_foo) -&gt; nativeImplementation(foo) </code></span> </pre>
<p> <span>为了自动解析，JVM将尝试：</span> </p>
<pre>  <span><code> method(wrapped_foo) -&gt; nativeImplementation(wrapped_foo) </code></span> </pre>
<p> <span>当此失败时，将重新执行解析，并从实现名称中删除指定的前缀，得到正确的解析度：</span> </p>
<pre>  <span><code> method(wrapped_foo) -&gt; nativeImplementation(foo) </code></span> </pre>
<p> <span>请注意，由于前缀仅在标准分辨率失败时使用，因此本地方法可以选择性地进行包装。</span> </p>
<p> <span>由于每个<code>ClassFileTransformer</code>都可以对字节码进行自己的转换，因此可以应用多层包装。</span> <span>因此，每个变压器需要自己的前缀。</span> <span>由于按照顺序应用转换，所以应用前缀将以相同的顺序应用（参见<a href="../../../java/lang/instrument/Instrumentation.html#addTransformer-java.lang.instrument.ClassFileTransformer-boolean-"><code>addTransformer</code></a> ）。</span> <span>因此，如果三个变压器应用封装， <code>foo</code>可能会变成<code>$trans3_$trans2_$trans1_foo</code> 。</span> <span>但是，如果说第二个变压器没有应用<code>foo</code>的封装， <code>foo</code>只是<code>$trans3_$trans1_foo</code> 。</span> <span>为了能够有效地确定前缀的顺序，只有当它的非本地包装存在时才应用中间前缀。</span> <span>因此，在最后一个例子中，尽管<code>$trans1_foo</code>不是本地方法，但<code>$trans1_</code>前缀是<code>$trans1_foo</code>存在的。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>transformer</code> - 使用此前缀包装的ClassFileTransformer。 
           </dd>
<dd>
<span><code>prefix</code> - 重试本机方法解析失败时应用于包装本地方法的前缀。</span>
<span>如果前缀为<code>null</code>或空字符串，则不会为此变压器重试本机方法分辨率失败。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果通过一个 
            <code>null</code>变压器。 
           </dd>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果JVM的当前配置不允许设置本机方法前缀（ 
            <a href="../../../java/lang/instrument/Instrumentation.html#isNativeMethodPrefixSupported--"><code>isNativeMethodPrefixSupported()</code></a>为假）。 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果变压器未注册（见 
            <a href="../../../java/lang/instrument/Instrumentation.html#addTransformer-java.lang.instrument.ClassFileTransformer-boolean-"><code>addTransformer</code></a> ）。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>