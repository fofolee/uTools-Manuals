<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.lang 
   </div>
<h2 class="title" title="Class Class">Class Class&lt;T&gt;</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.lang.Class&lt;T&gt;</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<span><code>T</code> - 由此<code>类</code>对象建模的类的类型。</span>
<span>例如， <code>String.class</code>的类型是<code>Class&lt;String&gt;</code> 。</span>
<span>如果正在建模的类是未知的，请使用<code>Class&lt;?&gt;</code> 。</span>
</dd>
</dl>
<dl>
<dt>
         All Implemented Interfaces: 
       </dt>
<dd>
<span><a href="../../java/io/Serializable.html" title="java.io中的接口">Serializable</a> ， <a href="../../java/lang/reflect/AnnotatedElement.html" title="java.lang.reflect中的接口">AnnotatedElement</a> ， <a href="../../java/lang/reflect/GenericDeclaration.html" title="java.lang.reflect中的接口">GenericDeclaration</a> ， <a href="../../java/lang/reflect/Type.html" title="java.lang.reflect中的接口">Type</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public final class <span class="typeNameLabel">Class&lt;T&gt;</span>
extends <a href="../../java/lang/Object.html" title="class in java.lang">Object</a>
implements <a href="../../java/io/Serializable.html" title="interface in java.io">Serializable</a>, <a href="../../java/lang/reflect/GenericDeclaration.html" title="interface in java.lang.reflect">GenericDeclaration</a>, <a href="../../java/lang/reflect/Type.html" title="interface in java.lang.reflect">Type</a>, <a href="../../java/lang/reflect/AnnotatedElement.html" title="interface in java.lang.reflect">AnnotatedElement</a></pre>
<div class="block">
<span>Class类的<code>类</code>表示正在运行的Java应用程序中的类和接口。</span>
<span>枚举是一种类，一个注释是一种界面。</span>
<span>每个数组也属于一个反映为<code>类</code>对象的类，该对象由具有相同元素类型和维数的所有数组共享。</span>
<span>原始Java类型（ <code>boolean</code> ， <code>byte</code> ， <code>char</code> ， <code>short</code> ， <code>int</code> ， <code>long</code> ， <code>float</code>和<code>double</code> ），和关键字<code>void</code>也表示为<code>类</code>对象。</span>
<p> <span><code>类</code>没有公共构造函数。</span> <span>相反， <code>类</code>对象由Java虚拟机自动构建，因为加载了类，并且通过调用类加载器中的<code>defineClass</code>方法。</span> </p>
<p> <span>以下示例使用<code>类</code>对象来打印对象的类名称：</span> </p>
<blockquote>
<span><pre>
     void printClassName(Object obj) {
         System.out.println("The class of " + obj +
                            " is " + obj.getClass().getName());
     }
 </pre></span>
</blockquote>
<p> <span>也可以使用类文字获取<code>类</code>对象作为命名类型（或为void）。</span> <span>参见<cite>The Java™ Language Specification</cite>第15.8.2节。</span> <span>例如：</span> </p>
<blockquote>
<span><code>System.out.println("The name of class Foo is: "+Foo.class.getName());</code></span>
</blockquote>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         JDK1.0 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/ClassLoader.html#defineClass-byte:A-int-int-"><code>ClassLoader.defineClass(byte[], int, int)</code></a> ， 
        <a href="../../serialized-form.html#java.lang.Class">Serialized Form</a>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t1"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>&lt;U&gt; <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;? extends U&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#asSubclass-java.lang.Class-">asSubclass</a></span>(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;U&gt; clazz)</code>
<div class="block">
<code>类</code>这个 
             <code>类</code>对象来表示由指定的类对象表示的类的子类。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code><a href="../../java/lang/Class.html" title="type parameter in Class">T</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#cast-java.lang.Object-">cast</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> obj)</code>
<div class="block">
              施放一个目的是通过本表示的类或接口 
             <code>类</code>对象。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#desiredAssertionStatus--">desiredAssertionStatus</a></span>()</code>
<div class="block">
              如果要在调用此方法时初始化该类，则返回将分配给此类的断言状态。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>static <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#forName-java.lang.String-">forName</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> className)</code>
<div class="block">
              返回与给定字符串名称的类或接口相关联的 
             <code>类</code>对象。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>static <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#forName-java.lang.String-boolean-java.lang.ClassLoader-">forName</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name, boolean initialize, <a href="../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> loader)</code>
<div class="block">
              使用给定的类加载器返回与给定字符串名称的类或接口相关联的 
             <code>类</code>对象。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code><a href="../../java/lang/reflect/AnnotatedType.html" title="interface in java.lang.reflect">AnnotatedType</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getAnnotatedInterfaces--">getAnnotatedInterfaces</a></span>()</code>
<div class="block">
              返回一个 
             <code>AnnotatedType</code>对象的数组， 
             <code>AnnotatedType</code>使用类型指定由此 
             <code>AnnotatedType</code>对象表示的实体的超级 
             <code>类</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code><a href="../../java/lang/reflect/AnnotatedType.html" title="interface in java.lang.reflect">AnnotatedType</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getAnnotatedSuperclass--">getAnnotatedSuperclass</a></span>()</code>
<div class="block">
              返回一个 
             <code>AnnotatedType</code>对象，该对象表示使用类型来指定由此 
             <code>类</code>对象表示的实体的 
             <code>类</code>类。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>&lt;A extends <a href="../../java/lang/annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt;<br/>A</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getAnnotation-java.lang.Class-">getAnnotation</a></span>(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;A&gt; annotationClass)</code>
<div class="block">
              返回该元素的，如果这样的注释 
             <em>，</em>否则返回null指定类型的注释。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code><a href="../../java/lang/annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getAnnotations--">getAnnotations</a></span>()</code>
<div class="block">
              返回此元素上 
             <em>存在的</em>注释。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>&lt;A extends <a href="../../java/lang/annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt;<br/>A[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getAnnotationsByType-java.lang.Class-">getAnnotationsByType</a></span>(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;A&gt; annotationClass)</code>
<div class="block">
              返回与此元素相关 
             <em>联的注释</em> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code><a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getCanonicalName--">getCanonicalName</a></span>()</code>
<div class="block">
              返回由Java语言规范定义的基础类的规范名称。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code><a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getClasses--">getClasses</a></span>()</code>
<div class="block">
              返回包含一个数组 
             <code>类</code>表示所有的公共类和由此表示的类的成员接口的对象 
             <code>类</code>对象。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code><a href="../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getClassLoader--">getClassLoader</a></span>()</code>
<div class="block">
              返回类的类加载器。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code><a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getComponentType--">getComponentType</a></span>()</code>
<div class="block">
              返回 
             <code>类</code>数组的组件类型的Class。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code><a href="../../java/lang/reflect/Constructor.html" title="class in java.lang.reflect">Constructor</a>&lt;<a href="../../java/lang/Class.html" title="type parameter in Class">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getConstructor-java.lang.Class...-">getConstructor</a></span>(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;... parameterTypes)</code>
<div class="block">
              返回一个 
             <code>Constructor</code>对象，该对象反映 
             <code>Constructor</code>对象表示的类的指定的公共 
             <code>类</code>函数。 
            </div> </td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code><a href="../../java/lang/reflect/Constructor.html" title="class in java.lang.reflect">Constructor</a>&lt;?&gt;[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getConstructors--">getConstructors</a></span>()</code>
<div class="block">
              返回包含一个数组 
             <code>Constructor</code>对象反射由此表示的类的所有公共构造 
             <code>类</code>对象。 
            </div> </td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code>&lt;A extends <a href="../../java/lang/annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt;<br/>A</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getDeclaredAnnotation-java.lang.Class-">getDeclaredAnnotation</a></span>(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;A&gt; annotationClass)</code>
<div class="block">
              如果这样的注释 
             <em>直接存在</em> ，则返回指定类型的元素注释，否则返回null。 
            </div> </td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code><a href="../../java/lang/annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getDeclaredAnnotations--">getDeclaredAnnotations</a></span>()</code>
<div class="block">
              返回 
             <em>直接存在</em>于此元素上的注释。 
            </div> </td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>&lt;A extends <a href="../../java/lang/annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt;<br/>A[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getDeclaredAnnotationsByType-java.lang.Class-">getDeclaredAnnotationsByType</a></span>(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;A&gt; annotationClass)</code>
<div class="block">
              如果此类注释 
             <em>直接存在</em>或 
             <em>间接存在，</em>则返回该元素的注释（指定类型）。 
            </div> </td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code><a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getDeclaredClasses--">getDeclaredClasses</a></span>()</code>
<div class="block">
              返回一个反映所有被这个 
             <code>类</code>对象表示的类的成员声明的类和 
             <code>类</code>对象的数组。 
            </div> </td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code><a href="../../java/lang/reflect/Constructor.html" title="class in java.lang.reflect">Constructor</a>&lt;<a href="../../java/lang/Class.html" title="type parameter in Class">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getDeclaredConstructor-java.lang.Class...-">getDeclaredConstructor</a></span>(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;... parameterTypes)</code>
<div class="block">
              返回一个 
             <code>Constructor</code>对象，该对象反映 
             <code>Constructor</code>对象表示的类或接口的指定 
             <code>类</code>函数。 
            </div> </td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code><a href="../../java/lang/reflect/Constructor.html" title="class in java.lang.reflect">Constructor</a>&lt;?&gt;[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getDeclaredConstructors--">getDeclaredConstructors</a></span>()</code>
<div class="block">
              返回一个反映 
             <code>Constructor</code>对象表示的类声明的所有 
             <code>Constructor</code>对象的数组 
             <code>类</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i22">
<td class="colFirst"><code><a href="../../java/lang/reflect/Field.html" title="class in java.lang.reflect">Field</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getDeclaredField-java.lang.String-">getDeclaredField</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name)</code>
<div class="block">
              返回一个 
             <code>Field</code>对象，它反映此表示的类或接口的指定已声明字段 
             <code>类</code>对象。 
            </div> </td>
</tr>
<tr class="rowColor" id="i23">
<td class="colFirst"><code><a href="../../java/lang/reflect/Field.html" title="class in java.lang.reflect">Field</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getDeclaredFields--">getDeclaredFields</a></span>()</code>
<div class="block">
              返回的数组 
             <code>Field</code>对象反映此表示的类或接口声明的所有字段 
             <code>类</code>对象。 
            </div> </td>
</tr>
<tr class="altColor" id="i24">
<td class="colFirst"><code><a href="../../java/lang/reflect/Method.html" title="class in java.lang.reflect">方法</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getDeclaredMethod-java.lang.String-java.lang.Class...-">getDeclaredMethod</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name, <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;... parameterTypes)</code>
<div class="block">
              返回一个 
             <code>方法</code>对象，它反映此表示的类或接口的指定声明的方法 
             <code>类</code>对象。 
            </div> </td>
</tr>
<tr class="rowColor" id="i25">
<td class="colFirst"><code><a href="../../java/lang/reflect/Method.html" title="class in java.lang.reflect">方法</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getDeclaredMethods--">getDeclaredMethods</a></span>()</code>
<div class="block">
              返回包含一个数组 
             <code>方法</code>对象反射的类或接口的所有声明的方法，通过此表示 
             <code>类</code>对象，包括公共，保护，默认（包）访问和私有方法，但不包括继承的方法。 
            </div> </td>
</tr>
<tr class="altColor" id="i26">
<td class="colFirst"><code><a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getDeclaringClass--">getDeclaringClass</a></span>()</code>
<div class="block">
              如果由此 
             <code>类</code>对象表示的类或接口是另一个类的成员，则返回表示其声明的类的 
             <code>类</code>对象。 
            </div> </td>
</tr>
<tr class="rowColor" id="i27">
<td class="colFirst"><code><a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getEnclosingClass--">getEnclosingClass</a></span>()</code>
<div class="block">
              返回底层类的即时封闭类。 
            </div> </td>
</tr>
<tr class="altColor" id="i28">
<td class="colFirst"><code><a href="../../java/lang/reflect/Constructor.html" title="class in java.lang.reflect">Constructor</a>&lt;?&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getEnclosingConstructor--">getEnclosingConstructor</a></span>()</code>
<div class="block">
<span>如果此<code>类</code>对象表示构造函数中的本地或匿名类，则返回表示底层类的立即封闭构造函数的<a href="../../java/lang/reflect/Constructor.html" title="class java.lang.reflect"><code>Constructor</code></a>对象。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i29">
<td class="colFirst"><code><a href="../../java/lang/reflect/Method.html" title="class in java.lang.reflect">方法</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getEnclosingMethod--">getEnclosingMethod</a></span>()</code>
<div class="block">
<span>如果此<code>类</code>对象表示方法中的本地或匿名类，则返回表示<a href="../../java/lang/reflect/Method.html" title="class java.lang.reflect">基础</a>类的即时封闭方法的<code>方法</code>对象。</span>
</div> </td>
</tr>
<tr class="altColor" id="i30">
<td class="colFirst"><code><a href="../../java/lang/Class.html" title="type parameter in Class">T</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getEnumConstants--">getEnumConstants</a></span>()</code>
<div class="block">
              返回此枚举类的元素，如果此Class对象不表示枚举类型，则返回null。 
            </div> </td>
</tr>
<tr class="rowColor" id="i31">
<td class="colFirst"><code><a href="../../java/lang/reflect/Field.html" title="class in java.lang.reflect">Field</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getField-java.lang.String-">getField</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name)</code>
<div class="block">
              返回一个 
             <code>Field</code>对象，它反映此表示的类或接口的指定公共成员字段 
             <code>类</code>对象。 
            </div> </td>
</tr>
<tr class="altColor" id="i32">
<td class="colFirst"><code><a href="../../java/lang/reflect/Field.html" title="class in java.lang.reflect">Field</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getFields--">getFields</a></span>()</code>
<div class="block">
              返回包含一个数组 
             <code>Field</code>对象反射由此表示的类或接口的所有可访问的公共字段 
             <code>类</code>对象。 
            </div> </td>
</tr>
<tr class="rowColor" id="i33">
<td class="colFirst"><code><a href="../../java/lang/reflect/Type.html" title="interface in java.lang.reflect">Type</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getGenericInterfaces--">getGenericInterfaces</a></span>()</code>
<div class="block">
              返回 
             <code>Type</code>表示通过由该对象所表示的类或接口直接实现的接口秒。 
            </div> </td>
</tr>
<tr class="altColor" id="i34">
<td class="colFirst"><code><a href="../../java/lang/reflect/Type.html" title="interface in java.lang.reflect">Type</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getGenericSuperclass--">getGenericSuperclass</a></span>()</code>
<div class="block">
              返回 
             <code>Type</code>表示此所表示的实体（类，接口，基本类型或void）的直接超类 
             <code>类</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i35">
<td class="colFirst"><code><a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getInterfaces--">getInterfaces</a></span>()</code>
<div class="block">
              确定由该对象表示的类或接口实现的接口。 
            </div> </td>
</tr>
<tr class="altColor" id="i36">
<td class="colFirst"><code><a href="../../java/lang/reflect/Method.html" title="class in java.lang.reflect">方法</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getMethod-java.lang.String-java.lang.Class...-">getMethod</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name, <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;... parameterTypes)</code>
<div class="block">
              返回一个 
             <code>方法</code>对象，它反映此表示的类或接口的指定公共成员方法 
             <code>类</code>对象。 
            </div> </td>
</tr>
<tr class="rowColor" id="i37">
<td class="colFirst"><code><a href="../../java/lang/reflect/Method.html" title="class in java.lang.reflect">方法</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getMethods--">getMethods</a></span>()</code>
<div class="block">
              返回包含一个数组 
             <code>方法</code>对象反射由此表示的类或接口的所有公共方法 
             <code>类</code>对象，包括那些由类或接口和那些从超类和超接口继承的声明。 
            </div> </td>
</tr>
<tr class="altColor" id="i38">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getModifiers--">getModifiers</a></span>()</code>
<div class="block">
              返回此类或接口的Java语言修饰符，以整数编码。 
            </div> </td>
</tr>
<tr class="rowColor" id="i39">
<td class="colFirst"><code><a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getName--">getName</a></span>()</code>
<div class="block">
              返回由 
             <code>类</code>对象表示的实体（类，接口，数组类，原始类型或空白）的名称，作为 
             <code>String</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i40">
<td class="colFirst"><code><a href="../../java/lang/Package.html" title="class in java.lang">软件包</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getPackage--">getPackage</a></span>()</code>
<div class="block">
              获取此类的包。 
            </div> </td>
</tr>
<tr class="rowColor" id="i41">
<td class="colFirst"><code><a href="../../java/security/ProtectionDomain.html" title="class in java.security">ProtectionDomain</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getProtectionDomain--">getProtectionDomain</a></span>()</code>
<div class="block">
              返回 
             <code>ProtectionDomain</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i42">
<td class="colFirst"><code><a href="../../java/net/URL.html" title="class in java.net">URL</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getResource-java.lang.String-">getResource</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name)</code>
<div class="block">
              查找具有给定名称的资源。 
            </div> </td>
</tr>
<tr class="rowColor" id="i43">
<td class="colFirst"><code><a href="../../java/io/InputStream.html" title="class in java.io">InputStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getResourceAsStream-java.lang.String-">getResourceAsStream</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name)</code>
<div class="block">
              查找具有给定名称的资源。 
            </div> </td>
</tr>
<tr class="altColor" id="i44">
<td class="colFirst"><code><a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getSigners--">getSigners</a></span>()</code>
<div class="block">
              获得这个类的签名者。 
            </div> </td>
</tr>
<tr class="rowColor" id="i45">
<td class="colFirst"><code><a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getSimpleName--">getSimpleName</a></span>()</code>
<div class="block">
              返回源代码中给出的基础类的简单名称。 
            </div> </td>
</tr>
<tr class="altColor" id="i46">
<td class="colFirst"><code><a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;? super <a href="../../java/lang/Class.html" title="type parameter in Class">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getSuperclass--">getSuperclass</a></span>()</code>
<div class="block">
              返回 
             <code>类</code>表示此所表示的实体（类，接口，基本类型或void）的超类 
             <code>类</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i47">
<td class="colFirst"><code><a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getTypeName--">getTypeName</a></span>()</code>
<div class="block">
              为此类型的名称返回一个内容丰富的字符串。 
            </div> </td>
</tr>
<tr class="altColor" id="i48">
<td class="colFirst"><code><a href="../../java/lang/reflect/TypeVariable.html" title="interface in java.lang.reflect">TypeVariable</a>&lt;<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;<a href="../../java/lang/Class.html" title="type parameter in Class">T</a>&gt;&gt;[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#getTypeParameters--">getTypeParameters</a></span>()</code>
<div class="block">
              返回一个 
             <code>TypeVariable</code>对象的数组，它们以声明顺序表示由此 
             <code>GenericDeclaration</code>对象表示的通用声明声明的类型变量。 
            </div> </td>
</tr>
<tr class="rowColor" id="i49">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#isAnnotation--">isAnnotation</a></span>()</code>
<div class="block">
              如果此 
             <code>类</code>对象表示注释类型，则返回true。 
            </div> </td>
</tr>
<tr class="altColor" id="i50">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#isAnnotationPresent-java.lang.Class-">isAnnotationPresent</a></span>(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;? extends <a href="../../java/lang/annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt; annotationClass)</code>
<div class="block">
              如果此元素上 
             <em>存在</em>指定类型的注释，则返回true，否则返回false。 
            </div> </td>
</tr>
<tr class="rowColor" id="i51">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#isAnonymousClass--">isAnonymousClass</a></span>()</code>
<div class="block">
              返回 
             <code>true</code>当且仅当基础类是匿名类时。 
            </div> </td>
</tr>
<tr class="altColor" id="i52">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#isArray--">isArray</a></span>()</code>
<div class="block">
              确定此 
             <code>类</code>对象是否表示数组类。 
            </div> </td>
</tr>
<tr class="rowColor" id="i53">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#isAssignableFrom-java.lang.Class-">isAssignableFrom</a></span>(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; cls)</code>
<div class="block">
              确定由此 
             <code>类</code>对象表示的类或接口是否与由指定的Class 
             <code>类</code>表示的类或接口相同或是超类或 
             <code>类</code>接口。 
            </div> </td>
</tr>
<tr class="altColor" id="i54">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#isEnum--">isEnum</a></span>()</code>
<div class="block">
              当且仅当该类在源代码中被声明为枚举时才返回true。 
            </div> </td>
</tr>
<tr class="rowColor" id="i55">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#isInstance-java.lang.Object-">isInstance</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> obj)</code>
<div class="block">
              确定指定的Object是否与此 
             <code>Object</code>表示的对象分配 
             <code>类</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i56">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#isInterface--">isInterface</a></span>()</code>
<div class="block">
              确定指定 
             <code>类</code>对象表示接口类型。 
            </div> </td>
</tr>
<tr class="rowColor" id="i57">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#isLocalClass--">isLocalClass</a></span>()</code>
<div class="block">
              返回 
             <code>true</code>当且仅当基础类是本地类时。 
            </div> </td>
</tr>
<tr class="altColor" id="i58">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#isMemberClass--">isMemberClass</a></span>()</code>
<div class="block">
              返回 
             <code>true</code>当且仅当基础类是成员类时。 
            </div> </td>
</tr>
<tr class="rowColor" id="i59">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#isPrimitive--">isPrimitive</a></span>()</code>
<div class="block">
              确定指定 
             <code>类</code>对象表示一个基本类型。 
            </div> </td>
</tr>
<tr class="altColor" id="i60">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#isSynthetic--">isSynthetic</a></span>()</code>
<div class="block">
<span>如果这个类是一个合成类，返回<code>true</code> ;</span>
<span>返回<code>false</code>其他。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i61">
<td class="colFirst"><code><a href="../../java/lang/Class.html" title="type parameter in Class">T</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#newInstance--">newInstance</a></span>()</code>
<div class="block">
              创建由此 
             <code>类</code>对象表示的类的新实例。 
            </div> </td>
</tr>
<tr class="altColor" id="i62">
<td class="colFirst"><code><a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#toGenericString--">toGenericString</a></span>()</code>
<div class="block">
              返回描述此 
             <code>类</code>的字符串，包括有关修饰符和类型参数的信息。 
            </div> </td>
</tr>
<tr class="rowColor" id="i63">
<td class="colFirst"><code><a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Class.html#toString--">toString</a></span>()</code>
<div class="block">
              将对象转换为字符串。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../java/lang/Object.html#clone--">clone</a>, <a href="../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../java/lang/Object.html#notify--">notify</a>, <a href="../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../java/lang/Object.html#wait--">wait</a>, <a href="../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="toString--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toString</h4> <pre>public <a href="../../java/lang/String.html" title="class in java.lang">String</a> toString()</pre>
<div class="block">
<span>将对象转换为字符串。</span>
<span>字符串表示是字符串“类”或“接口”，后面加一个空格，然后在返回的格式类的完全限定名<code>getName</code> 。</span>
<span>如果此<code>类</code>对象表示原始类型，则此方法返回原始类型的名称。</span>
<span>如果这个<code>类</code>对象表示void，则此方法返回“void”。</span>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../java/lang/Object.html#toString--">toString</a></code>在类别 
            <code><a href="../../java/lang/Object.html" title="class in java.lang">Object</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个类对象的字符串表示形式。 
           </dd>
</dl> </li>
</ul> <a name="toGenericString--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toGenericString</h4> <pre>public <a href="../../java/lang/String.html" title="class in java.lang">String</a> toGenericString()</pre>
<div class="block">
<span>返回描述此<code>类</code>的字符串，包括有关修饰符和类型参数的信息。</span>
<span>该字符串格式类型修饰符列表，如果有的话，后面的那种类型（基本类型和空字符串<code>class</code> ， <code>枚举</code> ， <code>interface</code> ，或<code>@</code> <code>interface</code> ，如适用），其次是类型的名称，然后是角色括号的类型参数的逗号分隔列表（如果有）。</span>
<span>一个空格用于将修饰符彼此分离，并将任何修饰符与该类型分隔开。</span>
<span>修饰符以规范的顺序发生。</span>
<span>如果没有类型参数，则类型参数列表将被删除。</span>
<p> <span>请注意，由于正在生成关于类型的运行时间表示的信息，因此可能会存在始发源代码上不存在的修饰符或源于源代码的非法。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个描述这个 
            <code>类</code>的字符串，包括有关修饰符和类型参数的信息 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="forName-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>forName</h4> <pre>public static <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; forName(<a href="../../java/lang/String.html" title="class in java.lang">String</a> className)
                        throws <a href="../../java/lang/ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a></pre>
<div class="block">
<span>返回与给定字符串名称的类或接口相关联的<code>类</code>对象。</span>
<span>调用此方法相当于：</span>
<blockquote>
<span><code>Class.forName(className, true, currentLoader)</code></span>
</blockquote>
<span>其中<code>currentLoader</code>表示当前类的定义类加载器。</span>
<p> <span>例如，以下代码片段返回名为<code>java.lang.Thread</code>的类的运行时<code>类</code>描述<code>java.lang.Thread</code> ：</span> </p>
<blockquote>
<span><code>Class t = Class.forName("java.lang.Thread")</code></span>
</blockquote>
<p> <span>对<code>forName("X")</code>的调用导致<code>forName("X")</code>名为<code>X</code>的类。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>className</code> - 所需类的完全限定名称。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             具有指定名称的类的 
            <code>类</code>对象。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/LinkageError.html" title="class in java.lang">LinkageError</a></code> - 如果链接失败 
           </dd>
<dd>
<code><a href="../../java/lang/ExceptionInInitializerError.html" title="class in java.lang">ExceptionInInitializerError</a></code> - 如果由此方法引发的初始化失败 
           </dd>
<dd>
<code><a href="../../java/lang/ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a></code> - 如果该类无法找到 
           </dd>
</dl> </li>
</ul> <a name="forName-java.lang.String-boolean-java.lang.ClassLoader-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>forName</h4> <pre>public static <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; forName(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name,
                               boolean initialize,
                               <a href="../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> loader)
                        throws <a href="../../java/lang/ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a></pre>
<div class="block">
<span>使用给定的类加载器返回与给定字符串名称的类或接口相关联的<code>类</code>对象。</span>
<span>给定类或接口的完全限定名称（以<code>getName</code>返回的格式相同），此方法尝试查找，加载和链接类或接口。</span>
<span>指定的类加载器用于加载类或接口。</span>
<span>如果参数<code>loader</code>为空，则通过引导类加载器加载该类。</span>
<span>只有当<code>initialize</code>参数为<code>true</code>并且尚未被初始化时，该类才被初始化。</span>
<p> <span>如果<code>name</code>表示原始类型或空白，将尝试在名称为<code>name</code>的未命名包中定位用户定义的类。</span> <span>因此，该方法不能用于获取表示原始类型或void的任何<code>类</code>对象。</span> </p>
<p> <span>如果<code>name</code>表示数组类，则会加载数组类的组件类型，但未初始化。</span> </p>
<p> <span>例如，在一个实例方法中，表达式：</span> </p>
<blockquote>
<span><code>Class.forName("Foo")</code></span>
</blockquote>
<span>相当于：</span>
<blockquote>
<span><code>Class.forName("Foo", true, this.getClass().getClassLoader())</code></span>
</blockquote>
<span>请注意，该方法会引发与<em>Java语言规范的第12.2,12.3</em>和12.4节中指定的加载，链接或初始化相关的错误。</span>
<span>请注意，此方法不检查请求的类是否可由其调用者访问。</span>
<p> <span>如果<code>loader</code>是<code>null</code> ，并且安全管理器存在，并且调用者的类加载器不为空，则该方法调用具有<code>RuntimePermission("getClassLoader")</code>权限的安全管理器的<code>checkPermission</code>方法，以确保访问引导类加载器是可行的。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>name</code> - 所需类的完全限定名称 
           </dd>
<dd>
<span><code>initialize</code> - 如果<code>true</code>该类将被初始化。</span>
<span>请参见<em>Java语言规范的</em>第12.4节。</span>
</dd>
<dd>
<code>loader</code> - 类加载器，从该类加载 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             表示所需类的类对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/LinkageError.html" title="class in java.lang">LinkageError</a></code> - 如果链接失败 
           </dd>
<dd>
<code><a href="../../java/lang/ExceptionInInitializerError.html" title="class in java.lang">ExceptionInInitializerError</a></code> - 如果由此方法引发的初始化失败 
           </dd>
<dd>
<code><a href="../../java/lang/ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a></code> - 如果类不能被指定的类加载器定位 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.2 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/lang/Class.html#forName-java.lang.String-"><code>forName(String)</code></a> ， <a href="../../java/lang/ClassLoader.html" title="java.lang中的类"><code>ClassLoader</code></a></span>
</dd>
</dl> </li>
</ul> <a name="newInstance--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newInstance</h4> <pre>public <a href="../../java/lang/Class.html" title="type parameter in Class">T</a> newInstance()
              throws <a href="../../java/lang/InstantiationException.html" title="class in java.lang">InstantiationException</a>,
                     <a href="../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre>
<div class="block">
<span>创建由此<code>类</code>对象表示的类的新实例。</span>
<span>该类被实例化为一个具有空参数列表的<code>new</code>表达式。</span>
<span>如果类尚未初始化，则初始化该类。</span>
<p> <span>请注意，此方法传播由nullary构造函数抛出的任何异常，包括已检查的异常。</span> <span>使用此方法有效地绕过编译器异常检查，否则将由编译器执行。</span> <span><a href="../../java/lang/reflect/Constructor.html#newInstance-java.lang.Object...-"><code>Constructor.newInstance</code></a>方法通过在（检查） <a href="../../java/lang/reflect/InvocationTargetException.html" title="class java.lang.reflect"><code>InvocationTargetException</code></a>中包装构造函数抛出的任何异常来避免此问题。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             由该对象表示的新分配的类的实例。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果类或其nullary构造函数不可访问。 
           </dd>
<dd>
<span><code><a href="../../java/lang/InstantiationException.html" title="class in java.lang">InstantiationException</a></code> - 如果这个<code>类</code>表示抽象类，接口，数组类，原语类型或void;</span>
<span>或者类没有空值构造函数;</span>
<span>或者由于某种其他原因，实例化失败。</span>
</dd>
<dd>
<code><a href="../../java/lang/ExceptionInInitializerError.html" title="class in java.lang">ExceptionInInitializerError</a></code> - 如果由此方法引发的初始化失败。 
           </dd>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果安全管理器 
            <i>，S</i>存在，并且调用者的类加载器是不一样或类加载器的当前类和调用的祖先 
            <a href="../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a>拒绝访问包这个类的。 
           </dd>
</dl> </li>
</ul> <a name="isInstance-java.lang.Object-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isInstance</h4> <pre>public boolean isInstance(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> obj)</pre>
<div class="block">
<span>确定指定的Object是否与此<code>Object</code>表示的对象分配<code>类</code> 。</span>
<span>这种方法是Java语言<code>instanceof</code>操作符的动态等价物。</span>
<span>该方法返回<code>true</code>如果指定<code>Object</code>参数为非空并且可以转换为通过此表示的引用类型<code>类</code>对象不提高一个<code>ClassCastException.</code>它返回<code>false</code>否则。</span>
<p> <span>具体来说，如果<code>类</code>对象表示一个声明的类，如果指定的<code>Object</code>参数是所表示的类（或其任何子类）的实例，则此方法返回<code>true</code> ;</span> <span>它返回<code>false</code>其他。</span> <span>如果此<code>类</code>对象表示数组类，此方法返回<code>true</code>如果指定<code>Object</code>参数可以被转换成通过一个标识转换或通过加宽引用转换阵列类的对象;</span> <span>它返回<code>false</code>其他。</span> <span>如果此<code>类</code>对象表示一个接口，此方法返回<code>true</code>如果类或指定的任何超类<code>Object</code>参数实现此接口;</span> <span>它返回<code>false</code>其他。</span> <span>如果此<code>类</code>对象表示原始类型，则此方法返回<code>false</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>obj</code> - 要检查的对象 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             如果 
            <code>obj</code>是这个类的一个实例，则为true 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
</dl> </li>
</ul> <a name="isAssignableFrom-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isAssignableFrom</h4> <pre>public boolean isAssignableFrom(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; cls)</pre>
<div class="block">
<span>确定由此<code>类</code>对象表示的类或接口是否与由指定的Class <code>类</code>表示的类或接口相同或是超类或<code>类</code>接口。</span>
<span>如果是，则返回<code>true</code> ;</span>
<span>否则返回<code>false</code> 。</span>
<span>如果此<code>类</code>对象表示基本类型，则如果指定的<code>类</code>参数正好是<code>类</code>对象，则此方法返回<code>true</code> ;</span>
<span>否则返回<code>false</code> 。</span>
<p> <span>具体来说，该方法通过标识转换或扩展参考转换来测试由指定的Class <code>类</code>表示的类型是否可以转换为由此<code>类</code>对象表示的类型。</span> <span>有关详细信息，请参阅<em>Java语言规范</em> 5.1.1和5.1.4节。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>cls</code> - 要检查的 
            <code>类</code>对象 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>boolean</code>值表示可以将类型为 
            <code>cls</code>对象分配给此类的对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果指定的Class参数为null。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
</dl> </li>
</ul> <a name="isInterface--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isInterface</h4> <pre>public boolean isInterface()</pre>
<div class="block">
            确定指定 
           <code>类</code>对象表示接口类型。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span><code>true</code>如果此对象表示一个接口;</span>
<span><code>false</code>否则。</span>
</dd>
</dl> </li>
</ul> <a name="isArray--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isArray</h4> <pre>public boolean isArray()</pre>
<div class="block">
            确定此 
           <code>类</code>对象是否表示数组类。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span><code>true</code>如果此对象表示数组类;</span>
<span><code>false</code>否则。</span>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
</dl> </li>
</ul> <a name="isPrimitive--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isPrimitive</h4> <pre>public boolean isPrimitive()</pre>
<div class="block">
<span>确定指定<code>类</code>对象表示一个基本类型。</span>
<p> <span>有九个预定<code>类</code>对象代表八个原始类型和void。</span> <span>这些是由Java虚拟机创建，并且具有相同的名称为他们所代表的基本类型，即<code>boolean</code> ， <code>byte</code> ， <code>char</code> ， <code>short</code> ， <code>int</code> ， <code>long</code> ， <code>float</code>和<code>double</code> 。</span> </p>
<p> <span>这些对象只能通过以下公共静态最终变量访问，并且是该方法返回<code>true</code>的唯一<code>类</code>对象。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             当且仅当此类表示原始类型时才为true 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Boolean.html#TYPE"><code>Boolean.TYPE</code></a> ， 
            <a href="../../java/lang/Character.html#TYPE"><code>Character.TYPE</code></a> ， 
            <a href="../../java/lang/Byte.html#TYPE"><code>Byte.TYPE</code></a> ， 
            <a href="../../java/lang/Short.html#TYPE"><code>Short.TYPE</code></a> ， 
            <a href="../../java/lang/Integer.html#TYPE"><code>Integer.TYPE</code></a> ， 
            <a href="../../java/lang/Long.html#TYPE"><code>Long.TYPE</code></a> ， 
            <a href="../../java/lang/Float.html#TYPE"><code>Float.TYPE</code></a> ， 
            <a href="../../java/lang/Double.html#TYPE"><code>Double.TYPE</code></a> ， 
            <a href="../../java/lang/Void.html#TYPE"><code>Void.TYPE</code></a>
</dd>
</dl> </li>
</ul> <a name="isAnnotation--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isAnnotation</h4> <pre>public boolean isAnnotation()</pre>
<div class="block">
<span>如果此<code>类</code>对象表示注释类型，则返回true。</span>
<span>请注意，如果此方法返回true，则<a href="../../java/lang/Class.html#isInterface--"><code>isInterface()</code></a>也将返回true，因为所有注释类型也是接口。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span><code>true</code>如果此类对象表示注释类型;</span>
<span><code>false</code>否则</span>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="isSynthetic--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isSynthetic</h4> <pre>public boolean isSynthetic()</pre>
<div class="block">
<span>返回<code>true</code>如果这个类是一个合成类;</span>
<span>返回<code>false</code>其他。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>当且仅当此类是由Java语言规范定义的合成类时。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
<dt>
<span class="simpleTagLabel">See <cite> The Java™ Language Specification</cite>:</span>
</dt>
<dd>
             13.1二进制形式 
           </dd>
</dl> </li>
</ul> <a name="getName--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getName</h4> <pre>public <a href="../../java/lang/String.html" title="class in java.lang">String</a> getName()</pre>
<div class="block">
<span>返回由<code>类</code>对象表示的实体的名称（类，接口，数组类，原始类型或void），作为<code>String</code> 。</span>
<p> <span>如果此类对象表示不是数组类型的引用类型，则返回类的二进制名称，如The Java™ Language Specification所<cite>指定</cite> 。</span> </p>
<p> <span>如果此类对象表示一个原始类型或空值，那么返回的名称是一个<code>String</code>等于对应于原始类型或void的Java语言关键字。</span> </p>
<p> <span>如果此类对象表示一个数组类型，则该名称的内部形式由表示数组嵌套深度的一个或多个“ <code>[</code> ”字符前面的元素类型的名称组成。</span> <span>元素类型名称的编码如下：</span> </p>
<blockquote>
<span>
<table summary="Element types and encodings">
<tbody>
<tr>
<th> Element Type </th>
<th>     </th>
<th> Encoding </th>
</tr>
<tr>
<td> boolean </td>
<td>     </td>
<td align="center"> Z </td>
</tr>
<tr>
<td> byte </td>
<td>     </td>
<td align="center"> B </td>
</tr>
<tr>
<td> char </td>
<td>     </td>
<td align="center"> C </td>
</tr>
<tr>
<td> class or interface </td>
<td>     </td>
<td align="center"> L<i>classname</i>; </td>
</tr>
<tr>
<td> double </td>
<td>     </td>
<td align="center"> D </td>
</tr>
<tr>
<td> float </td>
<td>     </td>
<td align="center"> F </td>
</tr>
<tr>
<td> int </td>
<td>     </td>
<td align="center"> I </td>
</tr>
<tr>
<td> long </td>
<td>     </td>
<td align="center"> J </td>
</tr>
<tr>
<td> short </td>
<td>     </td>
<td align="center"> S </td>
</tr>
</tbody>
</table></span>
</blockquote>
<p> <span>类或接口名称<i>classname</i>是上面指定的类的二进制名称。</span> </p>
<p> <span>例子：</span> </p>
<blockquote>
<span><pre>
 String.class.getName()
     returns "java.lang.String"
 byte.class.getName()
     returns "byte"
 (new Object[3]).getClass().getName()
     returns "[Ljava.lang.Object;"
 (new int[3][4][5][6][7][8][9]).getClass().getName()
     returns "[[[[[[[I"
 </pre></span>
</blockquote>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             由该对象表示的类或接口的名称。 
           </dd>
</dl> </li>
</ul> <a name="getClassLoader--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getClassLoader</h4> <pre>public <a href="../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> getClassLoader()</pre>
<div class="block">
<span>返回类的类加载器。</span>
<span>一些实现可能使用null来表示引导类加载器。</span>
<span>如果此类由引导类加载器加载，则此方法将在此类实现中返回null。</span>
<p> <span>如果安全管理器存在，并且调用者的类加载器不为空，并且调用者的类加载器与请求类加载器的类的类加载器不同或者是一个祖先，则该方法调用安全管理器的<code>checkPermission</code>方法具有<code>RuntimePermission("getClassLoader")</code>权限，以确保访问类加载器的类。</span> </p>
<p> <span>如果此对象表示原始类型或空值，则返回null。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             加载由该对象表示的类或接口的类加载器。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理器存在，并且其 
            <code>checkPermission</code>方法拒绝访问该类的类加载器。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/lang/ClassLoader.html" title="java.lang中的类"><code>ClassLoader</code></a> ， <a href="../../java/lang/SecurityManager.html#checkPermission-java.security.Permission-"><code>SecurityManager.checkPermission(java.security.Permission)</code></a> ， <a href="../../java/lang/RuntimePermission.html" title="java.lang中的类"><code>RuntimePermission</code></a></span>
</dd>
</dl> </li>
</ul> <a name="getTypeParameters--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getTypeParameters</h4> <pre>public <a href="../../java/lang/reflect/TypeVariable.html" title="interface in java.lang.reflect">TypeVariable</a>&lt;<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;<a href="../../java/lang/Class.html" title="type parameter in Class">T</a>&gt;&gt;[] getTypeParameters()</pre>
<div class="block">
<span>返回一个<code>TypeVariable</code>对象的数组，它们以声明顺序表示由此<code>GenericDeclaration</code>对象表示的通用声明声明的类型变量。</span>
<span>如果底层通用声明不声明类型变量，则返回长度为0的数组。</span>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../java/lang/reflect/GenericDeclaration.html#getTypeParameters--">getTypeParameters</a></code>在界面 
            <code><a href="../../java/lang/reflect/GenericDeclaration.html" title="interface in java.lang.reflect">GenericDeclaration</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一组 
            <code>TypeVariable</code>对象，表示由此通用声明声明的类型变量 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/reflect/GenericSignatureFormatError.html" title="class in java.lang.reflect">GenericSignatureFormatError</a></code> - 如果此通用声明的通用签名不符合The Java™ Virtual Machine Specification中 
            <cite>指定</cite>的格式 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="getSuperclass--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getSuperclass</h4> <pre>public <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;? super <a href="../../java/lang/Class.html" title="type parameter in Class">T</a>&gt; getSuperclass()</pre>
<div class="block">
<span>返回<code>类</code>表示此所表示的实体（类，接口，基本类型或void）的超类<code>类</code> 。</span>
<span>如果这个<code>类</code>表示<code>Object</code>类，接口，原始类型或void，则返回null。</span>
<span>如果此对象表示数组类，则返回表示<code>Object</code>类的<code>类</code>对象。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             由该对象表示的类的超类。 
           </dd>
</dl> </li>
</ul> <a name="getGenericSuperclass--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getGenericSuperclass</h4> <pre>public <a href="../../java/lang/reflect/Type.html" title="interface in java.lang.reflect">Type</a> getGenericSuperclass()</pre>
<div class="block">
<span>返回<code>Type</code>表示此所表示的实体（类，接口，基本类型或void）的直接超类<code>类</code> 。</span>
<p> <span>如果超类是参数化类型，返回的<code>Type</code>对象必须准确反映源代码中使用的实际类型参数。</span> <span>如果以前没有创建表示超类的参数化类型。</span> <span>有关参数化类型创建过程的语义，请参见<code>ParameterizedType</code>的<a href="../../java/lang/reflect/ParameterizedType.html" title="java.lang.reflect中的接口">声明</a> 。</span> <span>如果这个<code>类</code>表示<code>Object</code>类，接口，原始类型或void，则返回null。</span> <span>如果此对象表示数组类，则返回表示<code>Object</code>类的<code>类</code>对象。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             由该对象表示的类的超类 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/reflect/GenericSignatureFormatError.html" title="class in java.lang.reflect">GenericSignatureFormatError</a></code> - 如果通用类签名不符合The Java™ Virtual Machine Specification中 
            <cite>指定</cite>的格式 
           </dd>
<dd>
<code><a href="../../java/lang/TypeNotPresentException.html" title="class in java.lang">TypeNotPresentException</a></code> - 如果通用超类引用不存在的类型声明 
           </dd>
<dd>
<code><a href="../../java/lang/reflect/MalformedParameterizedTypeException.html" title="class in java.lang.reflect">MalformedParameterizedTypeException</a></code> - 如果通用超类引用了由于任何原因无法实例化的参数化类型 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="getPackage--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getPackage</h4> <pre>public <a href="../../java/lang/Package.html" title="class in java.lang">软件包</a> getPackage()</pre>
<div class="block">
<span>获取此类的包。</span>
<span>该类的类加载器用于查找包。</span>
<span>如果类由引导类加载器加载，则会搜索从CLASSPATH加载的一组程序包，以查找该类的包。</span>
<span>如果此类的类加载器没有创建包对象，则返回Null。</span>
<p> <span>仅当信息在类中附带的清单中定义，并且类加载器使用清单中的属性创建包实例时，软件包才具有版本和规范的属性。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             该类的包，如果从存档或代码库中没有可用的包信息，则为null。 
           </dd>
</dl> </li>
</ul> <a name="getInterfaces--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getInterfaces</h4> <pre>public <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;[] getInterfaces()</pre>
<div class="block">
<span>确定由该对象表示的类或接口实现的接口。</span>
<p> <span>如果此对象表示一个类，则返回值是包含表示该类实现的所有接口的对象的数组。</span> <span>数组中的接口对象的顺序对应于由此对象表示的类的声明的<code>implements</code>子句中的接口名称的顺序。</span> <span>例如，给出声明：</span> </p>
<blockquote>
<span><code>class Shimmer implements FloorWax, DessertTopping { ... }</code></span>
</blockquote>
<span>假设的值<code>s</code>是实例<code>Shimmer</code> ;</span>
<span>表达式的值：</span>
<blockquote>
<span><code>s.getClass().getInterfaces()[0]</code></span>
</blockquote>
<span>是<code>类</code>对象，代表接口<code>FloorWax</code> ;</span>
<span>和的价值：</span>
<blockquote>
<span><code>s.getClass().getInterfaces()[1]</code></span>
</blockquote>
<span>是<code>类</code>对象，表示接口<code>DessertTopping</code> 。</span>
<p> <span>如果此对象表示接口，则该数组包含表示接口扩展的所有接口的对象。</span> <span>数组中接口对象的顺序对应于由该对象表示的接口的声明的<code>extends</code>子句中的接口名称的顺序。</span> </p>
<p> <span>如果此对象表示不实现接口的类或接口，则该方法返回长度为0的数组。</span> </p>
<p> <span>如果此对象表示原始类型或void，则该方法返回长度为0的数组。</span> </p>
<p> <span>如果此<code>类</code>对象表示数组类型，那么按照该顺序返回接口<code>Cloneable</code>和<code>java.io.Serializable</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个类实现的接口数组。 
           </dd>
</dl> </li>
</ul> <a name="getGenericInterfaces--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getGenericInterfaces</h4> <pre>public <a href="../../java/lang/reflect/Type.html" title="interface in java.lang.reflect">Type</a>[] getGenericInterfaces()</pre>
<div class="block">
<span>返回<code>Type</code>表示通过由该对象所表示的类或接口直接实现的接口秒。</span>
<p> <span>如果超级接口是参数化类型，返回的<code>Type</code>对象必须准确反映源代码中使用的实际类型参数。</span> <span>如果以前没有创建表示每个超级接口的参数化类型。</span> <span>有关参数化类型创建过程的语义，请参见<code>ParameterizedType</code>的<a href="../../java/lang/reflect/ParameterizedType.html" title="java.lang.reflect中的接口">声明</a> 。</span> </p>
<p> <span>如果此对象表示一个类，则返回值是包含表示该类实现的所有接口的对象的数组。</span> <span>数组中接口对象的顺序对应于该对象表示的类的声明的<code>implements</code>子句中接口名称的顺序。</span> <span>在数组类的情况下，按照该顺序返回接口<code>Cloneable</code>和<code>Serializable</code> 。</span> </p>
<p> <span>如果此对象表示一个接口，则该数组包含表示接口直接扩展的所有接口的对象。</span> <span>数组中接口对象的顺序对应于由此对象表示的接口的声明的<code>extends</code>子句中的接口名称的顺序。</span> </p>
<p> <span>如果此对象表示不实现接口的类或接口，则该方法返回长度为0的数组。</span> </p>
<p> <span>如果此对象表示原始类型或void，则该方法返回长度为0的数组。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个类实现的接口数组 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/reflect/GenericSignatureFormatError.html" title="class in java.lang.reflect">GenericSignatureFormatError</a></code> - 如果通用类签名不符合The Java™ Virtual Machine Specification中 
            <cite>指定</cite>的格式 
           </dd>
<dd>
<code><a href="../../java/lang/TypeNotPresentException.html" title="class in java.lang">TypeNotPresentException</a></code> - 如果任何一个通用超级接口引用不存在的类型声明 
           </dd>
<dd>
<code><a href="../../java/lang/reflect/MalformedParameterizedTypeException.html" title="class in java.lang.reflect">MalformedParameterizedTypeException</a></code> - 如果任何一个通用超级接口是指由于任何原因而无法实例化的参数化类型 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="getComponentType--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getComponentType</h4> <pre>public <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; getComponentType()</pre>
<div class="block">
<span>返回<code>类</code>数组的组件类型的Class。</span>
<span>如果此类不表示数组类，则此方法返回null。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>类</code>此类的组件类型，如果此类是数组 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/lang/reflect/Array.html" title="class java.lang.reflect"><code>Array</code></a></span>
</dd>
</dl> </li>
</ul> <a name="getModifiers--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getModifiers</h4> <pre>public int getModifiers()</pre>
<div class="block">
<span>返回此类或接口的Java语言修饰符，以整数编码。</span>
<span>修饰符由Java虚拟机的常数为<code>public</code> ， <code>protected</code> ， <code>private</code> ， <code>final</code> ， <code>static</code> ， <code>abstract</code>和<code>interface</code> ;</span>
<span>应使用<code>Modifier</code>类的方法进行解码。</span>
<p> <span>如果底层类是一个数组类，则其<code>public</code> ， <code>private</code>和<code>protected</code>改性剂是相同的组分的类型。</span> <span>如果这个<code>类</code>代表一个原始类型或空白，它的<code>public</code>修饰符始终是<code>true</code> ，其<code>protected</code>和<code>private</code>修饰符始终为<code>false</code> 。</span> <span>如果此对象表示数组类，则为原始类型或空格，则其<code>final</code>修饰符始终为<code>true</code> ，其接口修饰符始终为<code>false</code> 。</span> <span>其他修饰符的值不由本规范确定。</span> </p>
<p> <span>修改器编码在<em>Java虚拟机规范</em>表4.1中定义。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             该 
            <code>int</code>表示该类修饰符 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/lang/reflect/Modifier.html" title="class java.lang.reflect"><code>Modifier</code></a></span>
</dd>
</dl> </li>
</ul> <a name="getSigners--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getSigners</h4> <pre>public <a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] getSigners()</pre>
<div class="block">
            获得这个类的签名者。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>该类的签名者，如果没有签名者，则为null。</span>
<span>特别地，如果此对象表示基本类型或void，则此方法返回null。</span>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
</dl> </li>
</ul> <a name="getEnclosingMethod--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getEnclosingMethod</h4> <pre>public <a href="../../java/lang/reflect/Method.html" title="class in java.lang.reflect">方法</a> getEnclosingMethod()
                          throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>如果此<code>类</code>对象表示方法中的本地或匿名类，则返回表示<a href="../../java/lang/reflect/Method.html" title="class java.lang.reflect">基础</a>类的即时封闭方法的<code>方法</code>对象。</span>
<span>退货<code>null</code>否则。</span>
<span>特别地，此方法返回<code>null</code>当底层类是立即由类型声明，实例初始化或静态初始化包围的本地或匿名类。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>底层类的即时封闭方法，如果该类是本地或匿名类;</span>
<span>否则<code>null</code> 。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理员<i>s</i>存在，并且满足以下任何条件：</span>
<ul>
<li> <span>调用者的类加载器与封闭类的类加载器不同，并且<a href="../../java/lang/SecurityManager.html#checkPermission-java.security.Permission-"><code>s.checkPermission</code></a>方法的调用与<code>RuntimePermission("accessDeclaredMembers")</code>拒绝访问封闭类中的方法</span> </li>
<li> <span>调用者的类加载器与封装类的类加载器的祖先不相同，并且调用<a href="../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a>拒绝访问封装类的包</span> </li>
</ul>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="getEnclosingConstructor--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getEnclosingConstructor</h4> <pre>public <a href="../../java/lang/reflect/Constructor.html" title="class in java.lang.reflect">Constructor</a>&lt;?&gt; getEnclosingConstructor()
                                       throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>如果此<code>类</code>对象表示构造函数中的本地或匿名类，则返回一个<a href="../../java/lang/reflect/Constructor.html" title="class java.lang.reflect">表示</a>底层类的立即封闭构造函数的<a href="../../java/lang/reflect/Constructor.html" title="class java.lang.reflect"><code>Constructor</code></a>对象。</span>
<span>返回<code>null</code>其他。</span>
<span>特别地，此方法返回<code>null</code>当底层类是立即由类型声明，实例初始化或静态初始化包围的本地或匿名类。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>如果该类是本地或匿名类，那么基础类的立即包含构造函数;</span>
<span>否则<code>null</code> 。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理员<i>s</i>存在，并符合以下任何条件：</span>
<ul>
<li> <span>调用者的类加载器与封闭类的类加载器不同， <a href="../../java/lang/SecurityManager.html#checkPermission-java.security.Permission-"><code>s.checkPermission</code></a>方法的<code>RuntimePermission("accessDeclaredMembers")</code>拒绝访问封闭类中的构造函数</span> </li>
<li> <span>调用者的类加载器与封装类的类加载器的祖先不相同，并且调用<a href="../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a>拒绝访问封装类的包</span> </li>
</ul>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="getDeclaringClass--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getDeclaringClass</h4> <pre>public <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; getDeclaringClass()
                           throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>如果由此<code>类</code>对象表示的类或接口是另一个类的成员，则返回表示其声明的类的<code>类</code>对象。</span>
<span>如果此类或接口不是任何其他类的成员，则此方法返回null。</span>
<span>如果这个<code>类</code>对象表示一个数组类，一个原始类型或者void，那么这个方法返回null。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个类的声明类 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理员 
            <i>s</i>存在，并且调用者的类加载器与声明类的类加载器不相同或者祖先，并且调用 
            <a href="../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a>拒绝访问声明类的包 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
</dl> </li>
</ul> <a name="getEnclosingClass--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getEnclosingClass</h4> <pre>public <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; getEnclosingClass()
                           throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>返回底层类的即时封闭类。</span>
<span>如果底层类是顶级类，则此方法返回<code>null</code> 。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             底层类的立即封闭类 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果安全管理器 
            <i>，S</i>存在，并且调用者的类加载器是不一样或类加载器的封装类和调用的祖先 
            <a href="../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a>拒绝该包的封装类的访问 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="getSimpleName--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getSimpleName</h4> <pre>public <a href="../../java/lang/String.html" title="class in java.lang">String</a> getSimpleName()</pre>
<div class="block">
<span>返回源代码中给出的基础类的简单名称。</span>
<span>如果基础类是匿名的，则返回一个空字符串。</span>
<p> <span>数组的简单名称是附加了“[]”的组件类型的简单名称。</span> <span>特别是组件类型为匿名的数组的简单名称是“[]”。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             底层类的简单名称 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="getTypeName--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getTypeName</h4> <pre>public <a href="../../java/lang/String.html" title="class in java.lang">String</a> getTypeName()</pre>
<div class="block">
            为此类型的名称返回一个内容丰富的字符串。 
          </div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../java/lang/reflect/Type.html#getTypeName--">getTypeName</a></code>在界面 
            <code><a href="../../java/lang/reflect/Type.html" title="interface in java.lang.reflect">Type</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个用于此类型名称的信息字符串 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="getCanonicalName--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getCanonicalName</h4> <pre>public <a href="../../java/lang/String.html" title="class in java.lang">String</a> getCanonicalName()</pre>
<div class="block">
<span>返回由Java语言规范定义的基础类的规范名称。</span>
<span>如果基础类没有规范名称（即，如果它是本地或匿名类或其组件类型不具有规范名称的数组），则返回null。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             如果存在底层类的规范名称， 
            <code>null</code> null。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="isAnonymousClass--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isAnonymousClass</h4> <pre>public boolean isAnonymousClass()</pre>
<div class="block">
            返回 
           <code>true</code>当且仅当基础类是匿名类时。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>当且仅当此类是匿名类时。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="isLocalClass--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isLocalClass</h4> <pre>public boolean isLocalClass()</pre>
<div class="block">
            返回 
           <code>true</code>当且仅当基础类是本地类时。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>当且仅当此类是本地类时。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="isMemberClass--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isMemberClass</h4> <pre>public boolean isMemberClass()</pre>
<div class="block">
            返回 
           <code>true</code>当且仅当基础类是成员类时。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>当且仅当此类是成员类时。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="getClasses--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getClasses</h4> <pre>public <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;[] getClasses()</pre>
<div class="block">
<span>返回包含一个数组<code>类</code>表示所有的公共类和由此表示的类的成员接口的对象<code>类</code>对象。</span>
<span>这包括继承自类的公共类和接口成员以及该类声明的公共类和接口成员。</span>
<span>如果此<code>类</code>对象没有公共成员类或接口，则此方法返回一个长度为0的数组。</span>
<span>如果这个<code>类</code>对象表示一个原始类型，一个数组类或者void，该方法也返回一个长度为0的数组。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             代表这个类的公共成员的 
            <code>类</code>对象的数组 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果安全管理器 
            <i>，S</i>存在，并且调用者的类加载器是不一样或类加载器的当前类和调用的祖先 
            <a href="../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a>拒绝访问包这个类的。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
</dl> </li>
</ul> <a name="getFields--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getFields</h4> <pre>public <a href="../../java/lang/reflect/Field.html" title="class in java.lang.reflect">Field</a>[] getFields()
                  throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>返回包含一个数组<code>Field</code>对象反射由此表示的类或接口的所有可访问的公共字段<code>类</code>对象。</span>
<p> <span>如果此<code>类</code>对象表示没有无法访问的公共字段的类或接口，则此方法返回长度为0的数组。</span> </p>
<p> <span>如果这个<code>类</code>对象表示一个类，那么这个方法返回该类及其所有超类的公共字段。</span> </p>
<p> <span>如果此<code>类</code>对象表示一个接口，则该方法返回接口及其所有超级接口的字段。</span> </p>
<p> <span>如果这个<code>类</code>对象表示一个数组类型，一个基本类型或者void，那么这个方法返回一个长度为0的数组。</span> </p>
<p> <span>返回的数组中的元素不会被排序，并且不是以任何特定的顺序。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             表示公共字段的 
            <code>Field</code>对象的数组 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果安全管理器 
            <i>，S</i>存在，并且调用者的类加载器是不一样或类加载器的当前类和调用的祖先 
            <a href="../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a>拒绝访问包这个类的。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
<dt>
<span class="simpleTagLabel">See <cite> The Java™ Language Specification</cite>:</span>
</dt>
<dd>
             8.2类成员，8.3现场声明 
           </dd>
</dl> </li>
</ul> <a name="getMethods--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getMethods</h4> <pre>public <a href="../../java/lang/reflect/Method.html" title="class in java.lang.reflect">方法</a>[] getMethods()
                    throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>返回包含一个数组<code>方法</code>对象反射由此表示的类或接口的所有公共方法<code>类</code>对象，包括那些由类或接口和那些从超类和超接口继承的声明。</span>
<p> <span>如果此<code>类</code>对象表示具有多个具有相同名称和参数类型但具有不同返回类型的公共方法的类型，则返回的数组对于每个此类方法都有一个<code>方法</code>对象。</span> </p>
<p> <span>如果此<code>类</code>对象表示与类初始化方法的类型<code>&lt;clinit&gt;</code> ，则返回的阵列<em>不</em>具有相应的<code>方法</code>对象。</span> </p>
<p> <span>如果此<code>类</code>对象表示一个数组类型，则返回的阵列具有<code>方法</code>对于每个由阵列类型从继承的公共方法对象<code>Object</code> 。</span> <span>它不包含<code>方法</code>对象<code>clone()</code> 。</span> </p>
<p> <span>如果此<code>类</code>对象表示一个接口，那么返回的数组不包含任何隐含声明的方法，从<code>Object</code> 。</span> <span>因此，如果在此接口或其任何超级接口中没有显式声明方法，则返回的数组的长度为0.（注意，表示类的<code>类</code>对象始终具有从<code>Object</code>公共方法）。</span> </p>
<p> <span>如果此<code>类</code>对象表示原始类型或空值，则返回的数组的长度为0。</span> </p>
<p> <span>由此<code>类</code>对象表示的类或接口的超级接口中声明的静态方法不被视为类或接口的成员。</span> </p>
<p> <span>返回的数组中的元素不会被排序，并且不是以任何特定的顺序。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             代表这个类的公共方法的 
            <code>方法</code>对象的数组 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理员 
            <i>s</i> ，并且调用者的类加载器与当前类的类加载器不同或者祖先，并且调用
            <code>s.checkPackageAccess()</code>， 
            <a href="../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-">则</a>拒绝对该类的包的访问。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
<dt>
<span class="simpleTagLabel">See <cite> The Java™ Language Specification</cite>:</span>
</dt>
<dd>
             8.2类成员，8.4方法声明 
           </dd>
</dl> </li>
</ul> <a name="getConstructors--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getConstructors</h4> <pre>public <a href="../../java/lang/reflect/Constructor.html" title="class in java.lang.reflect">Constructor</a>&lt;?&gt;[] getConstructors()
                                 throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>返回一个包含Constructor对象的数组，反映由此<code>Constructor</code>对象表示的类的所有公共<code>类</code>函数。</span>
<span>如果类没有公共构造函数，或者类是数组类，或类反映原始类型或void时，返回长度为0的数组。</span>
<span>请注意，虽然此方法返回一个<code>Constructor&lt;T&gt;</code>对象（这是<code>Constructor&lt;T&gt;</code>构造函数数组）的数组，但此方法的返回类型为<code>Constructor&lt;?&gt;[]</code> ，而<em>不是</em> <code>Constructor&lt;T&gt;[]</code> 。</span>
<span>这种信息较少的返回类型是必要的，因为从该方法返回后，可以修改数组以容纳不同类的<code>Constructor</code>对象，这将违反Constructor&lt;T&gt;[]的类型<code>Constructor&lt;T&gt;[]</code> 。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             代表这个类的公共构造函数的 
            <code>Constructor</code>对象的数组 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果安全管理器 
            <i>，S</i>存在，并且调用者的类加载器是不一样或类加载器的当前类和调用的祖先 
            <a href="../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a>拒绝访问包这个类的。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
</dl> </li>
</ul> <a name="getField-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getField</h4> <pre>public <a href="../../java/lang/reflect/Field.html" title="class in java.lang.reflect">Field</a> getField(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name)
               throws <a href="../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a>,
                      <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>返回一个<code>Field</code>对象，它反映此表示的类或接口的指定公共成员字段<code>类</code>对象。</span>
<span><code>name</code>参数是一个<code>String</code> ，指定所需字段的简单名称。</span>
<p> <span>要反映的字段由以下算法确定。</span> <span>让C成为由该对象表示的类或接口：</span> </p>
<ol>
<li> <span>如果C声明一个具有指定名称的公共字段，那就是要反映的字段。</span> </li>
<li> <span>如果在上述步骤1中没有找到字段，则将该算法递归地应用于C的每个直接超级接口。直接超级接口按照它们被声明的顺序被搜索。</span> </li>
<li> <span>如果在上面的步骤1和2中没有找到字段，并且C具有超类S，则该算法在S上递归地调用。如果C没有超类，则抛出<code>NoSuchFieldException</code> 。</span> </li>
</ol>
<p> <span>如果此<code>类</code>对象表示数组类型，则此方法不会找到数组类型的<code>length</code>字段。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>name</code> - 字段名称 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>Field</code>对象由 
            <code>name</code>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a></code> - 如果找不到指定名称的字段。 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>name</code>是 
            <code>null</code>
</dd>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果安全管理器 
            <i>，S</i>存在，并且调用者的类加载器是不一样或类加载器的当前类和调用的祖先 
            <a href="../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a>拒绝访问包这个类的。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
<dt>
<span class="simpleTagLabel">See <cite> The Java™ Language Specification</cite>:</span>
</dt>
<dd>
             8.2类成员，8.3现场声明 
           </dd>
</dl> </li>
</ul> <a name="getMethod-java.lang.String-java.lang.Class...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getMethod</h4> <pre>public <a href="../../java/lang/reflect/Method.html" title="class in java.lang.reflect">方法</a> getMethod(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name,
                        <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;... parameterTypes)
                 throws <a href="../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                        <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>返回一个<code>方法</code>对象，它反映此表示的类或接口的指定公共成员方法<code>类</code>对象。</span>
<span><code>name</code>参数是一个<code>String</code>它指定了所需方法的简单名称。</span>
<span><code>parameterTypes</code>参数是以声明顺序标识方法的形式参数类型的<code>类</code>对象的数组。</span>
<span>如果<code>parameterTypes</code>是<code>null</code> ，它被视为一个空数组。</span>
<p> <span>如果<code>name</code>是“ <code>&lt;init&gt;</code> ”或“ <code>&lt;clinit&gt;</code> ”，则提出<code>NoSuchMethodException</code> 。</span> <span>否则，要反映的方法由以下算法确定。</span> <span>让C成为由该对象表示的类或接口：</span> </p>
<ol>
<li> <span>搜索C的<i>匹配方法</i> ，如下所述。</span> <span>如果找到匹配方法，就会反映出来。</span> </li>
<li> <span>如果步骤1没有找到匹配的方法，那么：</span>
<ol type="a">
<li> <span>如果C是<code>Object</code>以外的类，则该算法在C的超类上递归调用</span> </li>
<li> <span>如果C是<code>Object</code>类，或者如果C是一个接口，则搜索C（如果有的话）的超接口匹配方法。</span> <span>如果找到这样的方法，就会被反映出来。</span> </li>
</ol></li>
</ol>
<p> <span>在类或接口C中找到匹配的方法C：如果C声明一个具有指定名称和完全相同的形式参数类型的公共方法，那就是反映的方法。</span> <span>如果在C中找到不止一种这样的方法，并且这些方法之一具有比任何其他方法更具体的返回类型，则反映该方法;</span> <span>否则其中一种方法是任意选择的。</span> </p>
<p> <span>请注意，类中可能有多个匹配方法，因为Java语言禁止一个类声明具有相同签名但返回类型不同的多个方法，Java虚拟机不会。</span> <span>虚拟机中增加的灵活性可以用于实现各种语言特征。</span> <span>例如，协变回报可以用<a href="../../java/lang/reflect/Method.html#isBridge--">bridge methods实现</a> ;</span> <span>桥接方法和被覆盖的方法将具有相同的签名但不同的返回类型。</span> </p>
<p> <span>如果此<code>类</code>对象表示数组类型，则此方法找不到<code>clone()</code>方法。</span> </p>
<p> <span>由该<code>类</code>对象表示的类或接口的超级接口中声明的静态方法不被认为是类或接口的成员。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>name</code> - 方法的名称 
           </dd>
<dd>
<code>parameterTypes</code> - 参数列表 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>方法</code>对象匹配指定的 
            <code>name</code>和 
            <code>parameterTypes</code>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code> - 如果没有找到匹配的方法，或者名称是“&lt;init&gt;”还是“&lt;clinit&gt;”。 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>name</code>是 
            <code>null</code>
</dd>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果安全管理器 
            <i>，S</i>存在，并且调用者的类加载器是不一样或类加载器的当前类和调用的祖先 
            <a href="../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a>拒绝访问包这个类的。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
<dt>
<span class="simpleTagLabel">See <cite> The Java™ Language Specification</cite>:</span>
</dt>
<dd>
             8.2类成员，8.4方法声明 
           </dd>
</dl> </li>
</ul> <a name="getConstructor-java.lang.Class...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getConstructor</h4> <pre>public <a href="../../java/lang/reflect/Constructor.html" title="class in java.lang.reflect">Constructor</a>&lt;<a href="../../java/lang/Class.html" title="type parameter in Class">T</a>&gt; getConstructor(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;... parameterTypes)
                              throws <a href="../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                                     <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>返回一个<code>Constructor</code>对象，该对象反映<code>Constructor</code>对象表示的类的指定的公共<code>类</code>函数。</span>
<span><code>parameterTypes</code>参数是以声明顺序标识构造函数的形式参数类型的<code>类</code>对象的数组。</span>
<span>如果此<code>类</code>对象表示在非静态上下文中声明的内部类，则形式参数类型将显式包围实例作为第一个参数。</span>
<p> <span>反映的构造是这样表示的类的公共构造<code>类</code>对象，其形式参数类型匹配那些由指定的<code>parameterTypes</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>parameterTypes</code> - 参数数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             该 
            <code>Constructor</code>公共构造匹配指定的对象 
            <code>parameterTypes</code>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code> - 如果找不到匹配的方法。 
           </dd>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果安全管理器 
            <i>，S</i>存在，并且调用者的类加载器是不一样或类加载器的当前类和调用的祖先 
            <a href="../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a>拒绝访问包这个类的。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
</dl> </li>
</ul> <a name="getDeclaredClasses--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getDeclaredClasses</h4> <pre>public <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;[] getDeclaredClasses()
                              throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>返回的数组<code>类</code>对象反映声明此表示的类的成员的所有类和接口<code>类</code>对象。</span>
<span>这包括public，protected，default（package）访问以及该类声明的私有类和接口，但不包括继承的类和接口。</span>
<span>该方法返回一个长度为0的数组，如果该类不声明任何类或接口作为成员，或者这个<code>类</code>对象表示一个原始类型，一个数组类或者空。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>类</code>此类的所有声明成员的 
            <code>类</code>对象的数组 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果安全管理器<i>，S</i>存在任何下列条件得到满足：</span>
<ul>
<li> <span>调用者的类加载器是不一样的，因为这类和调用的类加载器<a href="../../java/lang/SecurityManager.html#checkPermission-java.security.Permission-"><code>s.checkPermission</code></a>法<code>RuntimePermission("accessDeclaredMembers")</code>这个类中拒绝该声明的类访问</span> </li>
<li> <span>调用者的类加载器与当前类的类加载器的祖先不同，并且调用<a href="../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a>拒绝访问此类的包</span> </li>
</ul>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
</dl> </li>
</ul> <a name="getDeclaredFields--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getDeclaredFields</h4> <pre>public <a href="../../java/lang/reflect/Field.html" title="class in java.lang.reflect">Field</a>[] getDeclaredFields()
                          throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>返回的数组<code>Field</code>对象反映此表示的类或接口声明的所有字段<code>类</code>对象。</span>
<span>这包括公共，受保护，默认（包）访问和私有字段，但不包括继承的字段。</span>
<p> <span>如果此<code>类</code>对象表示没有声明字段的类或接口，则此方法返回长度为0的数组。</span> </p>
<p> <span>如果此<code>类</code>对象表示数组类型，则为原始类型或void，则此方法返回长度为0的数组。</span> </p>
<p> <span>返回的数组中的元素不会被排序，并且不是以任何特定的顺序。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             表示此类的所有声明字段的 
            <code>Field</code>对象的数组 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理员<i>s</i>存在，并符合以下任何条件：</span>
<ul>
<li> <span>调用者的类加载器与此类的类加载器不同，并且调用<a href="../../java/lang/SecurityManager.html#checkPermission-java.security.Permission-"><code>s.checkPermission</code></a>方法与<code>RuntimePermission("accessDeclaredMembers")</code>拒绝访问此类中声明的字段</span> </li>
<li> <span>调用者的类加载器与当前类的类加载器的祖先不同，并且调用<a href="../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a>拒绝访问此类的包</span> </li>
</ul>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
<dt>
<span class="simpleTagLabel">See <cite> The Java™ Language Specification</cite>:</span>
</dt>
<dd>
             8.2类成员，8.3现场声明 
           </dd>
</dl> </li>
</ul> <a name="getDeclaredMethods--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getDeclaredMethods</h4> <pre>public <a href="../../java/lang/reflect/Method.html" title="class in java.lang.reflect">方法</a>[] getDeclaredMethods()
                            throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>返回包含一个数组<code>方法</code>对象反射的类或接口的所有声明的方法，通过此表示<code>类</code>对象，包括公共，保护，默认（包）访问和私有方法，但不包括继承的方法。</span>
<p> <span>如果此<code>类</code>对象表示具有多个具有相同名称和参数类型但具有不同返回类型的声明方法的类型，则返回的数组对于每个此类方法都有一个<code>方法</code>对象。</span> </p>
<p> <span>如果此<code>类</code>对象表示具有类初始化方法的类型<code>&lt;clinit&gt;</code> ，则返回的阵列<em>不</em>具有相应的<code>方法</code>对象。</span> </p>
<p> <span>如果此<code>类</code>对象表示没有声明方法的类或接口，则返回的数组的长度为0。</span> </p>
<p> <span>如果这个<code>类</code>对象表示一个数组类型，一个基本类型，或者是void，则返回的数组的长度为0。</span> </p>
<p> <span>返回的数组中的元素不会被排序，并且不是以任何特定的顺序。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>方法</code>此类的所有声明方法的 
            <code>方法</code>对象的数组 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果安全管理器<i>，S</i>存在任何下列条件得到满足：</span>
<ul>
<li> <span>调用者的类加载器与此类的类加载器不同，并且调用<a href="../../java/lang/SecurityManager.html#checkPermission-java.security.Permission-"><code>s.checkPermission</code></a>方法，使用<code>RuntimePermission("accessDeclaredMembers")</code>拒绝访问此类中声明的方法</span> </li>
<li> <span>调用者的类加载器不同于当前类的类加载器的祖先，并且调用<a href="../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a>拒绝访问此类的包</span> </li>
</ul>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
<dt>
<span class="simpleTagLabel">See <cite> The Java™ Language Specification</cite>:</span>
</dt>
<dd>
             8.2类成员，8.4方法声明 
           </dd>
</dl> </li>
</ul> <a name="getDeclaredConstructors--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getDeclaredConstructors</h4> <pre>public <a href="../../java/lang/reflect/Constructor.html" title="class in java.lang.reflect">Constructor</a>&lt;?&gt;[] getDeclaredConstructors()
                                         throws <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>返回反映<code>Constructor</code>对象表示的类声明的所有<code>Constructor</code>对象的数组<code>类</code> 。</span>
<span>这些是public，protected，default（package）访问和私有构造函数。</span>
<span>返回的数组中的元素不会排序，并且不是任何特定的顺序。</span>
<span>如果类有一个默认构造函数，它将包含在返回的数组中。</span>
<span>如果<code>类</code>对象表示接口，原始类型，数组类或空值，则此方法返回长度为0的数组。</span>
<p> <span>请参阅<em>Java语言规范</em> ，第8.2节。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             代表这个类的所有声明的构造函数的 
            <code>Constructor</code>对象的数组 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理员<i>s</i>存在，并符合以下任何条件：</span>
<ul>
<li> <span>调用者的类加载器与此类的类加载器不同，并且调用<a href="../../java/lang/SecurityManager.html#checkPermission-java.security.Permission-"><code>s.checkPermission</code></a>方法与<code>RuntimePermission("accessDeclaredMembers")</code>拒绝访问此类中声明的构造函数</span> </li>
<li> <span>调用者的类加载器与当前类的类加载器的祖先不同，并且调用<a href="../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a>拒绝访问此类的包</span> </li>
</ul>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
</dl> </li>
</ul> <a name="getDeclaredField-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getDeclaredField</h4> <pre>public <a href="../../java/lang/reflect/Field.html" title="class in java.lang.reflect">Field</a> getDeclaredField(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name)
                       throws <a href="../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a>,
                              <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>返回一个<code>Field</code>对象，它反映此表示的类或接口的指定已声明字段<code>类</code>对象。</span>
<span><code>name</code>参数是一个<code>String</code> ，它指定了所需字段的简单名称。</span>
<p> <span>如果此<code>类</code>对象表示数组类型，则此方法不会找到数组类型的<code>length</code>字段。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>name</code> - 字段的名称 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>Field</code>中指定字段的 
            <code>Field</code>对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a></code> - 如果找不到指定名称的字段。 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>name</code>是 
            <code>null</code>
</dd>
<dd>
<span><code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果安全管理器<i>，S</i>存在任何下列条件得到满足：</span>
<ul>
<li> <span>调用者的类加载器与此类的类加载器不同，并且调用<a href="../../java/lang/SecurityManager.html#checkPermission-java.security.Permission-"><code>s.checkPermission</code></a>方法与<code>RuntimePermission("accessDeclaredMembers")</code>拒绝访问已声明的字段</span> </li>
<li> <span>调用者的类加载器与当前类的类加载器的祖先不同，并且调用<a href="../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a>拒绝访问此类的包</span> </li>
</ul>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
<dt>
<span class="simpleTagLabel">See <cite> The Java™ Language Specification</cite>:</span>
</dt>
<dd>
             8.2类成员，8.3现场声明 
           </dd>
</dl> </li>
</ul> <a name="getDeclaredMethod-java.lang.String-java.lang.Class...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getDeclaredMethod</h4> <pre>public <a href="../../java/lang/reflect/Method.html" title="class in java.lang.reflect">方法</a> getDeclaredMethod(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name,
                                <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;... parameterTypes)
                         throws <a href="../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                                <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>返回一个<code>方法</code>对象，它反映此表示的类或接口的指定声明的方法<code>类</code>对象。</span>
<span><code>name</code>参数是一个<code>String</code> ，它指定了所需方法的简单名称， <code>parameterTypes</code>参数是以声明顺序标识方法的形式参数类型的<code>类</code>对象的数组。</span>
<span>如果在一个类中声明具有相同参数类型的多个方法，并且其中一个方法的返回类型比其他任何方法更具体，返回该方法;</span>
<span>否则其中一种方法是任意选择的。</span>
<span>如果名称为“&lt;init&gt;”或“&lt;clinit&gt;”，则提出<code>NoSuchMethodException</code> 。</span>
<p> <span>如果此<code>类</code>对象表示数组类型，则此方法找不到<code>clone()</code>方法。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>name</code> - 方法的名称 
           </dd>
<dd>
<code>parameterTypes</code> - 参数数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>方法</code>对象为此类的方法匹配指定的名称和参数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code> - 如果找不到匹配的方法。 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>name</code>是 
            <code>null</code>
</dd>
<dd>
<span><code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理员<i>s</i>存在，并符合以下任何条件：</span>
<ul>
<li> <span>调用者的类加载器与此类的类加载器不一样，并且调用<a href="../../java/lang/SecurityManager.html#checkPermission-java.security.Permission-"><code>s.checkPermission</code></a>方法与<code>RuntimePermission("accessDeclaredMembers")</code>拒绝访问已声明的方法</span> </li>
<li> <span>调用者的类加载器与当前类的类加载器的祖先不同，并且调用<a href="../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a>拒绝访问此类的包</span> </li>
</ul>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
<dt>
<span class="simpleTagLabel">See <cite> The Java™ Language Specification</cite>:</span>
</dt>
<dd>
             8.2类成员，8.4方法声明 
           </dd>
</dl> </li>
</ul> <a name="getDeclaredConstructor-java.lang.Class...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getDeclaredConstructor</h4> <pre>public <a href="../../java/lang/reflect/Constructor.html" title="class in java.lang.reflect">Constructor</a>&lt;<a href="../../java/lang/Class.html" title="type parameter in Class">T</a>&gt; getDeclaredConstructor(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;... parameterTypes)
                                      throws <a href="../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                                             <a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>返回一个<code>Constructor</code>对象，该对象反映<code>Constructor</code>对象表示的类或接口的指定<code>类</code>函数。</span>
<span><code>parameterTypes</code>参数是以声明顺序标识构造函数的形式参数类型的<code>类</code>对象的数组。</span>
<span>如果此<code>类</code>对象表示在非静态上下文中声明的内部类，则形式参数类型将显式包围实例作为第一个参数。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>parameterTypes</code> - 参数数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>Constructor</code>对象为具有指定参数列表的构造函数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code> - 如果找不到匹配的方法。 
           </dd>
<dd>
<span><code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果安全管理器<i>，S</i>存在任何下列条件得到满足：</span>
<ul>
<li> <span>调用者的类加载器与此类的类加载器不同，并且调用<a href="../../java/lang/SecurityManager.html#checkPermission-java.security.Permission-"><code>s.checkPermission</code></a>方法与<code>RuntimePermission("accessDeclaredMembers")</code>拒绝访问声明的构造函数</span> </li>
<li> <span>调用者的类加载器与当前类的类加载器的祖先不同，并且调用<a href="../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a>拒绝访问此类的包</span> </li>
</ul>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
</dl> </li>
</ul> <a name="getResourceAsStream-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getResourceAsStream</h4> <pre>public <a href="../../java/io/InputStream.html" title="class in java.io">InputStream</a> getResourceAsStream(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name)</pre>
<div class="block">
<span>查找具有给定名称的资源。</span>
<span>用于搜索与给定类相关联的资源的规则由该类的定义<a href="../../java/lang/ClassLoader.html" title="java.lang中的类">class loader</a>实现。</span>
<span>此方法委托给该对象的类加载器。</span>
<span>如果此对象由引导类加载器加载，则该方法委托为<a href="../../java/lang/ClassLoader.html#getSystemResourceAsStream-java.lang.String-"><code>ClassLoader.getSystemResourceAsStream(java.lang.String)</code></a> 。</span>
<p> <span>在委派之前，使用此算法从给定资源名称构建绝对资源名称：</span> </p>
<ul>
<li> <span>如果<code>name</code>以<code>'/'</code> （ <tt>'\u002f'</tt> ）开头，则资源的绝对名称是<code>name</code>之后的<code>'/'</code>的部分。</span> </li>
<li> <span>否则，绝对名称的格式如下：</span>
<blockquote>
<span><code>modified_package_name/name</code></span>
</blockquote><p> <span><code>modified_package_name</code>是<code>'/'</code>替换<code>'.'</code> （ <tt>'\u002e'</tt> ）的该对象的包名称。</span> </p></li>
</ul>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>name</code> - 所需资源的名称 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>A <a href="../../java/io/InputStream.html" title="java.io中的类"><code>InputStream</code></a>对象或<code>null</code>如果没有找到具有此名称的资源</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>name</code>是 
            <code>null</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
</dl> </li>
</ul> <a name="getResource-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getResource</h4> <pre>public <a href="../../java/net/URL.html" title="class in java.net">URL</a> getResource(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name)</pre>
<div class="block">
<span>查找具有给定名称的资源。</span>
<span>用于搜索与给定类相关联的资源的规则由该类的定义<a href="../../java/lang/ClassLoader.html" title="java.lang中的类">class loader</a>实现。</span>
<span>此方法委托给该对象的类加载器。</span>
<span>如果此对象由引导类加载器加载，则该方法将委托给<a href="../../java/lang/ClassLoader.html#getSystemResource-java.lang.String-"><code>ClassLoader.getSystemResource(java.lang.String)</code></a> 。</span>
<p> <span>在委派之前，使用此算法从给定资源名称构建绝对资源名称：</span> </p>
<ul>
<li> <span>如果<code>name</code>以<code>'/'</code> （ <tt>'\u002f'</tt> ）开头，那么资源的绝对名称是<code>name</code>之后的<code>'/'</code>的部分。</span> </li>
<li> <span>否则，绝对名称的格式如下：</span>
<blockquote>
<span><code>modified_package_name/name</code></span>
</blockquote><p> <span><code>modified_package_name</code>是<code>'/'</code>代替<code>'.'</code> （ <tt>'\u002e'</tt> ）的该对象的包名称。</span> </p></li>
</ul>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>name</code> - 所需资源的名称 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>A <a href="../../java/net/URL.html" title="java.net中的类"><code>URL</code></a>对象或<code>null</code>如果没有找到具有此名称的资源</span>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JDK1.1 
           </dd>
</dl> </li>
</ul> <a name="getProtectionDomain--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getProtectionDomain</h4> <pre>public <a href="../../java/security/ProtectionDomain.html" title="class in java.security">ProtectionDomain</a> getProtectionDomain()</pre>
<div class="block">
<span>返回<code>ProtectionDomain</code> 。</span>
<span>如果安装了一个安全管理员，此方法首先会使用<code>RuntimePermission("getProtectionDomain")</code>权限调用安全管理器的<code>checkPermission</code>方法，以确保获得<code>ProtectionDomain</code> 。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             该类的ProtectionDomain 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理器存在，并且其 
            <code>checkPermission</code>方法不允许获取ProtectionDomain。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.2 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/security/ProtectionDomain.html" title="java.security中的类"><code>ProtectionDomain</code></a> ， <a href="../../java/lang/SecurityManager.html#checkPermission-java.security.Permission-"><code>SecurityManager.checkPermission(java.security.Permission)</code></a> ， <a href="../../java/lang/RuntimePermission.html" title="java.lang中的类"><code>RuntimePermission</code></a></span>
</dd>
</dl> </li>
</ul> <a name="desiredAssertionStatus--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>desiredAssertionStatus</h4> <pre>public boolean desiredAssertionStatus()</pre>
<div class="block">
<span>如果要在调用此方法时初始化该类，则返回将分配给此类的断言状态。</span>
<span>如果此类已设置其断言状态，则将返回最近的设置;</span>
<span>否则，如果任何包默认断言状态属于此类，则返回最具体的相关包默认断言状态的最新设置;</span>
<span>否则，如果此类不是系统类（即它有一个类加载器），则返回其类加载器的默认断言状态;</span>
<span>否则返回系统类默认断言状态。</span>
<p> <span>几乎没有程序员需要这种方法;</span> <span>它为JRE本身的利益而提供。</span> <span>（它允许类在当时确定它是否被初始化是否应该启用断言。）请注意，该方法不能保证返回与（或将）与指定类相关联的实际断言状态，或将被）初始化。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定类的所需断言状态。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/ClassLoader.html#setClassAssertionStatus-java.lang.String-boolean-"><code>ClassLoader.setClassAssertionStatus(java.lang.String, boolean)</code></a> ， 
            <a href="../../java/lang/ClassLoader.html#setPackageAssertionStatus-java.lang.String-boolean-"><code>ClassLoader.setPackageAssertionStatus(java.lang.String, boolean)</code></a> ， 
            <a href="../../java/lang/ClassLoader.html#setDefaultAssertionStatus-boolean-"><code>ClassLoader.setDefaultAssertionStatus(boolean)</code></a>
</dd>
</dl> </li>
</ul> <a name="isEnum--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isEnum</h4> <pre>public boolean isEnum()</pre>
<div class="block">
            当且仅当该类在源代码中被声明为枚举时才返回true。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             当且仅当该类在源代码中被声明为枚举时才为真 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="getEnumConstants--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getEnumConstants</h4> <pre>public <a href="../../java/lang/Class.html" title="type parameter in Class">T</a>[] getEnumConstants()</pre>
<div class="block">
            返回此枚举类的元素，如果此Class对象不表示枚举类型，则返回null。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个数组，它包含按照它们声明的顺序由此Class对象表示的枚举类的值，如果此Class对象不表示枚举类型，则为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="cast-java.lang.Object-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>cast</h4> <pre>public <a href="../../java/lang/Class.html" title="type parameter in Class">T</a> cast(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> obj)</pre>
<div class="block">
            施放一个目的是通过本表示的类或接口 
           <code>类</code>对象。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>obj</code> - 要投射的对象 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             转换后的对象，如果obj为空则为null 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果对象不为空并且不能分配给类型T. 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="asSubclass-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>asSubclass</h4> <pre>public &lt;U&gt; <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;? extends U&gt; asSubclass(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;U&gt; clazz)</pre>
<div class="block">
<span><code>类</code>这个<code>类</code>对象来表示由指定的类对象表示的类的子类。</span>
<span>检查演员是否有效，如果不是，则抛出一个<code>ClassCastException</code> 。</span>
<span>如果此方法成功，它将始终返回此类对象的引用。</span>
<p> <span>当客户端需要“缩小” <code>类</code>对象的类型以将其传递给<code>类</code>其愿意接受的<code>类</code>对象的API时，此方法非常有用。</span> <span>转换将生成编译时警告，因为在运行时无法检查转换的正确性（因为通用类型通过擦除来实现）。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>U</code> - 将此类对象转换为的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>clazz</code> - 将此类对象转换为类的类 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个 
            <code>类</code>对象，转换为表示指定类对象的子类。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果这个 
            <code>类</code>对象不表示指定类的子类（这里“子类”包括该类本身）。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="getAnnotation-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getAnnotation</h4> <pre>public &lt;A extends <a href="../../java/lang/annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt; A getAnnotation(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;A&gt; annotationClass)</pre>
<div class="block">
<span class="descfrmTypeLabel">说明从界面： <code><a href="../../java/lang/reflect/AnnotatedElement.html#getAnnotation-java.lang.Class-">AnnotatedElement</a></code>复制</span>
</div>
<div class="block">
            返回该元素的，如果这样的注释 
           <em>，</em>否则返回null指定类型的注释。 
          </div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../java/lang/reflect/AnnotatedElement.html#getAnnotation-java.lang.Class-">getAnnotation</a></code>在界面 
            <code><a href="../../java/lang/reflect/AnnotatedElement.html" title="interface in java.lang.reflect">AnnotatedElement</a></code>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>A</code> - 要查询的注释的类型，如果存在则返回 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>annotationClass</code> - 对应于注释类型的Class对象 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             该元素的注释指定的注释类型，如果存在于此元素，否则为null 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果给定的注释类为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="isAnnotationPresent-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isAnnotationPresent</h4> <pre>public boolean isAnnotationPresent(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;? extends <a href="../../java/lang/annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt; annotationClass)</pre>
<div class="block">
<span>如果此元素上<em>存在</em>指定类型的注释，则返回true，否则返回false。</span>
<span>该方法主要用于方便访问标记注释。</span>
<p> <span>此方法返回的真值相当于： <code>getAnnotation(annotationClass) != null</code></span> </p>
<p> <span>默认方法的主体被指定为上述代码。</span> </p>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../java/lang/reflect/AnnotatedElement.html#isAnnotationPresent-java.lang.Class-">isAnnotationPresent</a></code>在界面 
            <code><a href="../../java/lang/reflect/AnnotatedElement.html" title="interface in java.lang.reflect">AnnotatedElement</a></code>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>annotationClass</code> - 对应于注释类型的Class对象 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             如果此元素上存在指定注释类型的注释，则为true，否则为false 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果给定的注释类为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="getAnnotationsByType-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getAnnotationsByType</h4> <pre>public &lt;A extends <a href="../../java/lang/annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt; A[] getAnnotationsByType(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;A&gt; annotationClass)</pre>
<div class="block">
<span class="descfrmTypeLabel">说明从界面： <code><a href="../../java/lang/reflect/AnnotatedElement.html#getAnnotationsByType-java.lang.Class-">AnnotatedElement</a></code>复制</span>
</div>
<div class="block">
<span>返回与此元素相关<em>联的注释</em> 。</span>
<span>如果没有与此元素相关联的<em>注释</em> ，则返回值为长度为0的数组。此方法与<a href="../../java/lang/reflect/AnnotatedElement.html#getAnnotation-java.lang.Class-"><code>AnnotatedElement.getAnnotation(Class)</code></a>之间的区别在于此方法检测其参数是否为可<em>重复注释类型</em> （JLS 9.6），如果是，则尝试通过“查看”容器注释来查找该类型的一个或多个注释。</span>
<span>该方法的调用者可以自由修改返回的数组;</span>
<span>它将对返回给其他调用者的数组没有影响。</span>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../java/lang/reflect/AnnotatedElement.html#getAnnotationsByType-java.lang.Class-">getAnnotationsByType</a></code>在界面 
            <code><a href="../../java/lang/reflect/AnnotatedElement.html" title="interface in java.lang.reflect">AnnotatedElement</a></code>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>A</code> - 要查询的注释类型，如果存在则返回 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>annotationClass</code> - 对应于注释类型的Class对象 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             如果与此元素相关联，则指定注释类型的所有元素注释，否则为长度为零的数组 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果给定的注释类为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="getAnnotations--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getAnnotations</h4> <pre>public <a href="../../java/lang/annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>[] getAnnotations()</pre>
<div class="block">
<span class="descfrmTypeLabel">说明从界面： <code><a href="../../java/lang/reflect/AnnotatedElement.html#getAnnotations--">AnnotatedElement</a></code>复制</span>
</div>
<div class="block">
<span>返回此元素上<em>存在的</em>注释。</span>
<span>如果没有<em>存在</em>于此元素上注解，返回值是长度为0这种方法的调用者可以随意修改返回的数组的数组;</span>
<span>它将对返回给其他调用者的数组没有影响。</span>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../java/lang/reflect/AnnotatedElement.html#getAnnotations--">getAnnotations</a></code>在界面 
            <code><a href="../../java/lang/reflect/AnnotatedElement.html" title="interface in java.lang.reflect">AnnotatedElement</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             此元素上出现的注释 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="getDeclaredAnnotation-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getDeclaredAnnotation</h4> <pre>public &lt;A extends <a href="../../java/lang/annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt; A getDeclaredAnnotation(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;A&gt; annotationClass)</pre>
<div class="block">
<span class="descfrmTypeLabel">说明从界面： <code><a href="../../java/lang/reflect/AnnotatedElement.html#getDeclaredAnnotation-java.lang.Class-">AnnotatedElement</a></code>复制</span>
</div>
<div class="block">
<span>如果这样的注释<em>直接存在</em> ，则返回指定类型的元素注释，否则返回null。</span>
<span>此方法忽略继承的注释。</span>
<span>（如果此元素上没有注释，则返回null）</span>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../java/lang/reflect/AnnotatedElement.html#getDeclaredAnnotation-java.lang.Class-">getDeclaredAnnotation</a></code>在界面 
            <code><a href="../../java/lang/reflect/AnnotatedElement.html" title="interface in java.lang.reflect">AnnotatedElement</a></code>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>A</code> - 查询的注释类型，如果直接出现则返回 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>annotationClass</code> - 对应于注释类型的Class对象 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             如果直接出现在该元素上，则指定注释类型的元素注释，否则为null 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果给定的注释类为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="getDeclaredAnnotationsByType-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getDeclaredAnnotationsByType</h4> <pre>public &lt;A extends <a href="../../java/lang/annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt; A[] getDeclaredAnnotationsByType(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;A&gt; annotationClass)</pre>
<div class="block">
<span class="descfrmTypeLabel">说明从界面： <code><a href="../../java/lang/reflect/AnnotatedElement.html#getDeclaredAnnotationsByType-java.lang.Class-">AnnotatedElement</a></code>复制</span>
</div>
<div class="block">
<span>如果此类注释<em>直接存在</em>或<em>间接存在，</em>则返回该元素的注释（指定类型）。</span>
<span>此方法忽略继承的注释。</span>
<span>如果在该元素上没有直接或间接存在的指定注释，则返回值是长度为0.的数组。此方法与<a href="../../java/lang/reflect/AnnotatedElement.html#getDeclaredAnnotation-java.lang.Class-"><code>AnnotatedElement.getDeclaredAnnotation(Class)</code></a>之间的<a href="../../java/lang/reflect/AnnotatedElement.html#getDeclaredAnnotation-java.lang.Class-">区别</a>在于该方法检测其参数是否是可<em>重复注释类型</em> （JLS 9.6），以及如果是，尝试通过“查看”容器注释（如果存在）来查找该类型的一个或多个注释。</span>
<span>该方法的调用者可以自由修改返回的数组;</span>
<span>它将对返回给其他调用者的数组没有影响。</span>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../java/lang/reflect/AnnotatedElement.html#getDeclaredAnnotationsByType-java.lang.Class-">getDeclaredAnnotationsByType</a></code>在界面 
            <code><a href="../../java/lang/reflect/AnnotatedElement.html" title="interface in java.lang.reflect">AnnotatedElement</a></code>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>A</code> - 直接或间接出现时查询和返回的注释类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>annotationClass</code> - 对应于注释类型的Class对象 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定注释类型的所有这些元素的注释，如果直接或间接地存在于该元素上，否则为长度为零的数组 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果给定的注释类为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="getDeclaredAnnotations--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getDeclaredAnnotations</h4> <pre>public <a href="../../java/lang/annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>[] getDeclaredAnnotations()</pre>
<div class="block">
<span class="descfrmTypeLabel">说明从界面： <code><a href="../../java/lang/reflect/AnnotatedElement.html#getDeclaredAnnotations--">AnnotatedElement</a></code>复制</span>
</div>
<div class="block">
<span>返回<em>直接存在</em>于此元素上的注释。</span>
<span>此方法忽略继承的注释。</span>
<span>如果此元素上没有<em>直接显示的</em>注释，则返回值为长度为0的数组。此方法的调用者可以自由修改返回的数组;</span>
<span>它将对返回给其他调用者的数组没有影响。</span>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../java/lang/reflect/AnnotatedElement.html#getDeclaredAnnotations--">getDeclaredAnnotations</a></code>在界面 
            <code><a href="../../java/lang/reflect/AnnotatedElement.html" title="interface in java.lang.reflect">AnnotatedElement</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             此元素上直接显示的注释 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="getAnnotatedSuperclass--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getAnnotatedSuperclass</h4> <pre>public <a href="../../java/lang/reflect/AnnotatedType.html" title="interface in java.lang.reflect">AnnotatedType</a> getAnnotatedSuperclass()</pre>
<div class="block">
<span>返回一个<code>AnnotatedType</code>对象，表示使用类型来指定由此<code>类</code>对象表示的实体的<code>类</code>类。</span>
<span>（ <em>使用</em> Foo类型指定“...扩展Foo”中的<em>超</em>类与Foo类型的<em>声明</em>不同）</span>
<p> <span>如果此<code>类</code>对象表示类型，其声明中并没有明确表示注解的父类，则返回值是<code>AnnotatedType</code>表示不带注释的元素对象。</span> </p>
<p> <span>如果这个<code>类</code>表示<code>Object</code>类，接口类型，数组类型，基元类型或void，则返回值为<code>null</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             表示超类的对象 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="getAnnotatedInterfaces--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>getAnnotatedInterfaces</h4> <pre>public <a href="../../java/lang/reflect/AnnotatedType.html" title="interface in java.lang.reflect">AnnotatedType</a>[] getAnnotatedInterfaces()</pre>
<div class="block">
<span>返回一个<code>AnnotatedType</code>对象的数组， <code>AnnotatedType</code>使用类型指定由此<code>AnnotatedType</code>对象表示的实体的超级<code>类</code> 。</span>
<span>（在“...实现Foo”中<em>使用</em> Foo类型指定一个超级接口与Foo类型的<em>声明</em>不同）</span>
<p> <span>如果这个<code>类</code>对象表示一个类，则返回值是一个数组，其中包含表示使用接口类型指定该类实现的接口的对象。</span> <span>数组中对象的顺序对应于此<code>类</code>对象声明的'implements'子句中使用的接口类型的顺序。</span> </p>
<p> <span>如果此<code>类</code>对象表示一个接口，则返回值是包含表示使用接口类型的对象的数组，用于指定接口直接扩展的接口。</span> <span>数组中对象的顺序对应于此<code>类</code>对象的声明的'extends'子句中使用的接口类型的顺序。</span> </p>
<p> <span>如果此<code>类</code>对象表示其声明未明确指示任何带注释的超级接口的类或接口，则返回值为长度为0的数组。</span> </p>
<p> <span>如果此<code>类</code>对象表示<code>Object</code>类，数组类型，原始类型或空值，则返回值为长度为0的数组。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             表示超级接口的数组 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>