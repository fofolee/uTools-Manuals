<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.lang.invoke 
   </div>
<h2 class="title" title="Class MethodHandles.Lookup">Class MethodHandles.Lookup</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.lang.invoke.MethodHandles.Lookup</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
         Enclosing class: 
       </dt>
<dd>
<span><a href="../../../java/lang/invoke/MethodHandles.html" title="class java.lang.invoke">MethodHandles</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public static final class <span class="typeNameLabel">MethodHandles.Lookup</span>
extends <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></pre>
<div class="block">
<span><em>查找对象</em>是创建方法句柄的工厂，当创建需要访问检查时。</span>
<span>方法句柄在调用时不执行访问检查，而是在创建时执行访问检查。</span>
<span>因此，当创建方法句柄时，必须强制执行方法句柄访问限制。</span>
<span>这些限制被强制执行的调用类被称为<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupClass">lookup class</a> 。</span>
<p> <span>需要创建方法句柄的查找类将调用<a href="../../../java/lang/invoke/MethodHandles.html#lookup--"><code>MethodHandles.lookup</code></a>为自己创建一个工厂。</span> <span>当创建<code>Lookup</code>工厂对象时，确定查找类的标识，并安全地存储在<code>Lookup</code>对象中。</span> <span>查找类（或其代理）可以使用<code>Lookup</code>对象上的工厂方法来创建访问检查成员的方法句柄。</span> <span>这包括允许查找类的所有方法，构造函数和字段，甚至是私有的。</span> </p>
<h1> <span><a name="lookups"></a>查找工厂方法</span> </h1>
<span><code>Lookup</code>对象上的工厂方法<code>Lookup</code>于方法，构造函数和字段的所有主要用例。</span>
<span>由工厂方法创建的每个方法句柄都是特定<em>字节码行为</em>的功能等同物。</span>
<span>（字节码行为在Java虚拟机规范的5.4.3.5节中描述。）这是这些工厂方法与生成的方法处理的行为之间的对应关系的总结。</span>
<span> <a name="equiv"></a>lookup expression member bytecode behavior   <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findGetter-java.lang.Class-java.lang.String-java.lang.Class-"><code>lookup.findGetter(C.class,"f",FT.class)</code></a> <code>FT f;</code> <code>(T) this.f;</code> <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findStaticGetter-java.lang.Class-java.lang.String-java.lang.Class-"><code>lookup.findStaticGetter(C.class,"f",FT.class)</code></a> <code>static</code><br/><code>FT f;</code> <code>(T) C.f;</code> <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findSetter-java.lang.Class-java.lang.String-java.lang.Class-"><code>lookup.findSetter(C.class,"f",FT.class)</code></a> <code>FT f;</code> <code>this.f = x;</code> <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findStaticSetter-java.lang.Class-java.lang.String-java.lang.Class-"><code>lookup.findStaticSetter(C.class,"f",FT.class)</code></a> <code>static</code><br/><code>FT f;</code> <code>C.f = arg;</code> <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findVirtual-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-"><code>lookup.findVirtual(C.class,"m",MT)</code></a> <code>T m(A*);</code> <code>(T) this.m(arg*);</code> <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findStatic-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-"><code>lookup.findStatic(C.class,"m",MT)</code></a> <code>static</code><br/><code>T m(A*);</code> <code>(T) C.m(arg*);</code> <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findSpecial-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-java.lang.Class-"><code>lookup.findSpecial(C.class,"m",MT,this.class)</code></a> <code>T m(A*);</code> <code>(T) super.m(arg*);</code> <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findConstructor-java.lang.Class-java.lang.invoke.MethodType-"><code>lookup.findConstructor(C.class,MT)</code></a> <code>C(A*);</code> <code>new C(arg*);</code> <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflectGetter-java.lang.reflect.Field-"><code>lookup.unreflectGetter(aField)</code></a> (<code>static</code>)?<br/><code>FT f;</code> <code>(FT) aField.get(thisOrNull);</code> <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflectSetter-java.lang.reflect.Field-"><code>lookup.unreflectSetter(aField)</code></a> (<code>static</code>)?<br/><code>FT f;</code> <code>aField.set(thisOrNull, arg);</code> <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflect-java.lang.reflect.Method-"><code>lookup.unreflect(aMethod)</code></a> (<code>static</code>)?<br/><code>T m(A*);</code> <code>(T) aMethod.invoke(thisOrNull, arg*);</code> <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflectConstructor-java.lang.reflect.Constructor-"><code>lookup.unreflectConstructor(aConstructor)</code></a> <code>C(A*);</code> <code>(C) aConstructor.newInstance(arg*);</code> <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflect-java.lang.reflect.Method-"><code>lookup.unreflect(aMethod)</code></a> (<code>static</code>)?<br/><code>T m(A*);</code> <code>(T) aMethod.invoke(thisOrNull, arg*);</code> </span>
<table border="1" cellpadding="5" summary="lookup method behaviors">
</table>
<span>这里，类型<code>C</code>是搜索成员的类或<code>refc</code> ，在查找方法中被记录为名为<code>refc</code> 。</span>
<span>方法类型<code>MT</code>由返回类型<code>T</code>和参数类型序列<code>A*</code> 。</span>
<span>构造函数还具有一系列参数类型<code>A*</code> ，并被视为返回新创建的类型为<code>C</code>对象。</span>
<span><code>MT</code>和字段类型<code>FT</code>都被记录为名为<code>type</code> 。</span>
<span>形式参数<code>this</code>代表C型的自<code>C</code> ;</span>
<span>如果它存在，它始终是方法句柄调用的主要参数。</span>
<span>（在某些<code>protected</code>成员的情况下， <code>this</code>可能被限制在查找类的类型中;见下文）。名称<code>arg</code>代表所有其他方法句柄参数。</span>
<span>在Core Reflection API的代码示例中，如果访问的方法或字段为静态，则名称<code>thisOrNull</code>表示空引用， <code>this</code> this。</span>
<span>名称<code>aMethod</code> ， <code>aField</code>和<code>aConstructor</code>代表对应于给定构件反射的对象。</span>
<p> <span>在给定成员具有可变权限（即，方法或构造方法）的情况下，返回的方法句柄也<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">将为variable arity</a> 。</span> <span>在所有其他情况下，返回的方法句柄将是固定的。</span> </p>
<p style="font-size:smaller;"> <span><em>讨论：</em>查找方法句柄和底层类成员和字节码行为之间的等价性可以通过以下几种方法分解：</span> </p>
<ul style="font-size:smaller;">
<li> <span>如果<code>C</code>不能从查找类的加载器中进行符号访问，即使没有等效的Java表达式或字节码常量，查找仍然可以成功。</span> </li>
<li> <span>同样，如果<code>T</code>或<code>MT</code>不能从查找类的加载器中进行符号访问，则查找仍然可以成功。</span> <span>例如，无论请求类型如何， <code>MethodHandle.invokeExact</code>和<code>MethodHandle.invoke</code>查找将始终成功。</span> </li>
<li> <span>如果安装了一个安全管理器，它可以禁止查找各种各样的理由（ <a href="MethodHandles.Lookup.html#secmgr">see below</a> ）。</span> <span>相比之下， <code>ldc</code>指令在<code>CONSTANT_MethodHandle</code>常量上不受安全管理员检查。</span> </li>
<li> <span>如果查找方法有一个<a href="MethodHandle.html#maxarity">very large arity</a> ，则由于方法句柄类型具有太多<a href="MethodHandle.html#maxarity">参数</a> ，方法句柄创建可能会失败。</span> </li>
</ul>
<h1> <span><a name="access"></a>访问检查</span> </h1>
<span>当创建方法句柄时，访问检查应用于<code>Lookup</code>的工厂方法。</span>
<span>这是与Core Reflection API的一个主要区别，因为<a href="../../../java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-"><code>java.lang.reflect.Method.invoke</code></a>在每次呼叫时对每个呼叫者执行访问检查。</span>
<p> <span>所有访问检查从<code>Lookup</code>对象开始，它将其记录的查找类与所有请求进行比较，以创建方法句柄。</span> <span>单个<code>Lookup</code>对象可用于创建任意数量的访问检查方法句柄，全部针对单个查找类进行检查。</span> </p>
<p> <span>一个<code>Lookup</code>对象可以与其他可信代码共享，如元对象协议。</span> <span>共享的<code>Lookup</code>对象委托在查找类的私有成员上创建方法句柄的功能。</span> <span>即使特权代码使用<code>Lookup</code>对象，访问检查也仅限于原始查找类的权限。</span> </p>
<p> <span>查找可能会失败，因为查找类不能访问包含的类，或者因为缺少所需的类成员，或者因为查找类不能访问所需的类成员，或者因为查找对象不够信任访问会员</span> <span>在任何这些情况下， <code>ReflectiveOperationException</code>将从尝试查找中抛出。</span> <span>确切的课程将是以下之一：</span> </p>
<ul>
<li> <span>NoSuchMethodException - 如果请求但不存在的方法</span> </li>
<li> <span>NoSuchFieldException - 如果一个字段被请求但不存在</span> </li>
<li> <span>IllegalAccessException - 如果成员存在，但访问检查失败</span> </li>
</ul>
<p> <span>通常，可以查找方法方法<code>M</code>的方法<code>M</code>的条件不比查找类可以编译，验证和解析到<code>M</code>的调用的条件更多的<code>M</code> 。</span> <span>如果JVM会引发诸如NoSuchMethodError之类的<code>NoSuchMethodError</code> ，方法句柄查找通常会引发相应的检查异常，例如<code>NoSuchMethodException</code> 。</span> <span>并调用从查询产生的方法处理的效果是<a href="MethodHandles.Lookup.html#equiv">exactly equivalent</a>对执行编制，验证和解决呼叫<code>M</code> 。</span> <span>字段和构造函数也是一样的。</span> </p>
<p style="font-size:smaller;"> <span><em>讨论：</em>访问检查仅适用于命名和反映的方法，构造函数和字段。</span> <span>其他方法句柄创建方法，如<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>MethodHandle.asType</code></a> ，不需要任何访问检查，并且独立于任何<code>Lookup</code>对象使用。</span> </p>
<p> <span>如果所需的成员是<code>protected</code> ，通常的JVM规则适用，包括要求查找类必须与所需成员在同一个包中，或必须继承该成员。</span> <span>（请参阅Java虚拟机规范，第4.9.2,5.4.3.5和6.4节）。另外，如果所需成员是不同包中的非静态字段或方法，则生成的方法句柄只能应用于查找类的对象或其子类之一。</span> <span>这一要求通过缩窄导致的类型强制<code>this</code>参数从<code>C</code> （将必然是查找类的超类）到查找类本身。</span> </p>
<p> <span>JVM对<code>invokespecial</code>指令提出了类似的要求，接收方参数必须与已解析的方法<em>和</em>当前类匹配。</span> <span>同样，通过将引导参数的类型缩小到生成的方法句柄来强制执行此要求。</span> <span>（请参阅Java虚拟机规范，第4.10.1.9节。）</span> </p>
<p> <span>JVM表示作为具有特殊名称的内部方法（ <code>"&lt;init&gt;"</code>和<code>"&lt;clinit&gt;"</code> ）的构造函数和静态初始化程序块。</span> <span>调用指令的内部语法允许它们引用这些内部方法，就像它们是正常方法一样，但是JVM字节码验证器拒绝它们。</span> <span>这种内部方法的查找将产生一个<code>NoSuchMethodException</code> 。</span> </p>
<p> <span>在某些情况下，Java编译器可以通过创建包装方法来访问同一顶层声明中另一个类的私有方法来获取嵌套类之间的访问。</span> <span>例如，一个嵌套类<code>C.D</code>可以其他相关的类如内访问私有成员<code>C</code> ， <code>C.D.E</code> ，或<code>C.B</code> ，但是Java编译器可能需要生成在这些相关的类包装方法。</span> <span>在这种情况下， <code>Lookup</code>的对象<code>C.E</code>将无法将这些私有成员。</span> <span>一种用于这一限制的方法是<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#in-java.lang.Class-"><code>Lookup.in</code></a>方法，它可以在变换的查找<code>C.E</code>成一个上的任何那些其他类的，没有特权的特殊仰角。</span> </p>
<p> <span>根据其设置的<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code></a> ，允许给定查找对象的访问可能受限于查找类通常可访问的成员的子集。</span> <span>例如， <a href="../../../java/lang/invoke/MethodHandles.html#publicLookup--"><code>publicLookup</code></a>方法生成一个查询对象，该对象仅允许访问公共类中的公共成员。</span> <span>调用者敏感方法<a href="../../../java/lang/invoke/MethodHandles.html#lookup--"><code>lookup</code></a>产生一个查找对象，具有相对于其调用者类的完整功能，以模拟所有支持的字节码行为。</span> <span>此外， <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#in-java.lang.Class-"><code>Lookup.in</code></a>方法可能产生一个查找对象，其访问模式比原始查找对象少。</span> </p>
<p style="font-size:smaller;"> <span><a name="privacc"></a> <em>私人访问的讨论：</em>我们说如果一个查找具有<em>私有访问权，</em>如果它的<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--">lookup modes</a>包括<em>访问</em> <code>private</code>成员的可能性。</span> <span>如其他相关方法中所述，只有具有私有访问权限的查询具有以下功能：</span> </p>
<ul style="font-size:smaller;">
<li> <span>访问查找类的私有字段，方法和构造函数</span> </li>
<li> <span>创建方法句柄，调用<a href="MethodHandles.Lookup.html#callsens">caller sensitive</a>方法，如<code>Class.forName</code></span> </li>
<li> <span>创建方法句柄<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findSpecial-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-java.lang.Class-"><code>emulate invokespecial</code></a>说明</span> </li>
<li> <span>避免<a href="MethodHandles.Lookup.html#secmgr">package access checks</a>查找类可访问的类</span> </li>
<li> <span>创建<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#in-java.lang.Class-"><code>delegated lookup objects</code></a> ，它们具有对同一个包成员内的其他类的私有访问</span> </li>
</ul>
<p style="font-size:smaller;"> <span>这些权限中的每一个都是这样一个事实的结果：具有私有访问的查找对象可以被安全地追溯到一个始发类，其中<a href="MethodHandles.Lookup.html#equiv">bytecode behaviors</a>和Java语言访问权限可以被方法句柄可靠地确定和模拟。</span> </p>
<h1> <span><a name="secmgr"></a>安全管理员交互</span> </h1>
<span>虽然字节码指令只能引用相关类加载器中的类，但是该API可以在任何类中搜索方法，只要对其<code>类</code>对象的引用即可。</span>
<span>Core Reflection API也可以使用这种跨装载程序引用，并且不可能使用诸如<code>invokestatic</code>或<code>getfield</code>字节码<code>getfield</code> 。</span>
<span>有一个<a href="../../../java/lang/SecurityManager.html" title="java.lang中的类">security manager API</a>允许应用程序检查这样的跨装载程序引用。</span>
<span>这些检查适用于<code>MethodHandles.Lookup</code> API和Core Reflection API（如<a href="../../../java/lang/Class.html" title="java.lang中的类"><code>类</code>所示</a> ）。</span>
<p> <span>如果存在安全管理员，则成员查询需要进行额外的检查。</span> <span>从一到三个电话是安全管理员。</span> <span>任何这些电话都可以通过投掷<a href="../../../java/lang/SecurityException.html" title="java.lang中的类"><code>SecurityException</code></a>拒绝访问。</span> <span>将<code>smgr</code>定义为安全管理器<code>lookc</code>作为当前查找对象的查找类， <code>refc</code>作为成员正在寻找的包含类，以及<code>defc</code>作为成员实际定义的类。</span> <span>值<code>lookc</code>被定义为<em>不存在</em> ，如果当前查找对象不具有<a href="MethodHandles.Lookup.html#privacc">private access</a> 。</span> <span>呼叫是按照以下规则进行的：</span> </p>
<ul>
<li> <span><b>步骤1：</b>如果<code>lookc</code>不存在，或者如果它的类加载器是不一样的或的类加载器的祖先<code>refc</code> ，则<a href="../../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>smgr.checkPackageAccess(refcPkg)</code></a>被调用，其中<code>refcPkg</code>是的包<code>refc</code> 。</span> </li>
<li> <span><b>步骤2：</b>如果检索的成员不是公开的，并且<code>lookc</code>不存在，则<a href="../../../java/lang/SecurityManager.html#checkPermission-java.security.Permission-">调用<code>smgr.checkPermission</code></a>与<code>RuntimePermission("accessDeclaredMembers")</code> 。</span> </li>
<li> <span><b>步骤3：</b>如果所检索的部件是不公开的，而如果<code>lookc</code>不存在，并且如果<code>defc</code>和<code>refc</code>不同，则<a href="../../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>smgr.checkPackageAccess(defcPkg)</code></a>被调用，其中<code>defcPkg</code>是的包<code>defc</code> 。</span> </li>
</ul>
<span>在通过其他访问检查之后执行安全检查。</span>
<span>因此，上述规则预先假定是一个公共成员，否则正在从具有访问该成员权限的查找类访问。</span>
<h1> <span><a name="callsens"></a>来电者敏感方法</span> </h1>
<span>少量的Java方法有一个特殊的属性叫做呼叫者敏感性。</span>
<span><em>来电者敏感的</em>方法可以根据其直接呼叫者的身份而有所不同。</span>
<p> <span>如果请求呼叫者敏感的方法的方法处理，对于一般的规则<a href="MethodHandles.Lookup.html#equiv">bytecode behaviors</a>申请，但他们考虑到查找类的一种特殊的方式。</span> <span>生成的方法句柄就像从查找类中包含的指令调用一样，以便调用者敏感的方法检测查找类。</span> <span>（相比之下，方法句柄的调用者被忽略。）因此，在调用者敏感方法的情况下，不同的查找类可能会产生不同行为的方法句柄。</span> </p>
<p> <span>在查找对象为<a href="../../../java/lang/invoke/MethodHandles.html#publicLookup--"><code>publicLookup()</code></a>或其他没有<a href="MethodHandles.Lookup.html#privacc">private access的</a>其他查找对象的情况下，查找类被忽略。</span> <span>在这种情况下，可以创建没有呼叫者-敏感的方法处理，访问是禁止的，并且查找失败并<code>IllegalAccessException</code> 。</span> </p>
<p style="font-size:smaller;"> <span><em>讨论：</em>例如，调用者敏感方法<a href="../../../java/lang/Class.html#forName-java.lang.String-"><code>Class.forName(x)</code></a>可以返回不同的类或抛出异常异常，这取决于调用它的类的类加载器。</span> <span><code>Class.forName</code>的公开查询将失败，因为没有合理的方式来确定其字节码行为。</span> </p>
<p style="font-size:smaller;"> <span>如果应用程序缓存方法句柄进行广泛共享，则应使用<code>publicLookup()</code>创建它们。</span> <span>如果有一个查找<code>Class.forName</code> ，它将失败，并且应用程序必须在这种情况下采取适当的措施。</span> <span>可能是在引用引导方法的调用期间的后续查找可以包含调用者的特定身份，从而使该方法可访问。</span> </p>
<p style="font-size:smaller;"> <span>功能<code>MethodHandles.lookup</code>是调用者敏感的，因此可以有一个用于查找的安全基础。</span> <span>JSR 292 API中几乎所有其他方法都依赖于查找对象来检查访问请求。</span> </p>
</div> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!-- --> </a> <h3>Field Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Field Summary table, listing fields, and an explanation">
<caption>
<span>Fields</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#PACKAGE">PACKAGE</a></span></code>
<div class="block">
              单位掩码表示 
             <code>package</code>访问（默认访问），这可能有助于结果 
             <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code></a> 。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#PRIVATE">PRIVATE</a></span></code>
<div class="block">
              单位掩码表示 
             <code>private</code>访问，这可能有助于结果 
             <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code></a> 。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#PROTECTED">PROTECTED</a></span></code>
<div class="block">
              单位掩码表示 
             <code>protected</code>访问，这可能有助于结果 
             <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code></a> 。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#PUBLIC">PUBLIC</a></span></code>
<div class="block">
              单位掩码表示 
             <code>public</code>访问，这可能有助于结果 
             <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code></a> 。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#bind-java.lang.Object-java.lang.String-java.lang.invoke.MethodType-">bind</a></span>(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> receiver, <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name, <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> type)</code>
<div class="block">
              为非静态方法生成早期绑定的方法句柄。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findConstructor-java.lang.Class-java.lang.invoke.MethodType-">findConstructor</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; refc, <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> type)</code>
<div class="block">
              使用指定类型的构造函数生成创建对象并初始化它的方法句柄。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findGetter-java.lang.Class-java.lang.String-java.lang.Class-">findGetter</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; refc, <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; type)</code>
<div class="block">
              产生方法句柄，给非静态字段的读访问权限。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findSetter-java.lang.Class-java.lang.String-java.lang.Class-">findSetter</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; refc, <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; type)</code>
<div class="block">
              产生一个给非静态字段写入访问权限的方法句柄。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findSpecial-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-java.lang.Class-">findSpecial</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; refc, <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name, <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> type, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; specialCaller)</code>
<div class="block">
              为虚拟方法生成早期绑定的方法句柄。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findStatic-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-">findStatic</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; refc, <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name, <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> type)</code>
<div class="block">
              为静态方法生成方法句柄。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findStaticGetter-java.lang.Class-java.lang.String-java.lang.Class-">findStaticGetter</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; refc, <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; type)</code>
<div class="block">
              产生一个给静态字段读取访问权限的方法句柄。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findStaticSetter-java.lang.Class-java.lang.String-java.lang.Class-">findStaticSetter</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; refc, <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; type)</code>
<div class="block">
              生成方法句柄，给静态字段写权限。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findVirtual-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-">findVirtual</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; refc, <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name, <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> type)</code>
<div class="block">
              为虚拟方法生成方法句柄。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#in-java.lang.Class-">in</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; requestedLookupClass)</code>
<div class="block">
              在指定的新查找类上创建一个查找。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code><a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupClass--">lookupClass</a></span>()</code>
<div class="block">
              告诉哪个类执行查找。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--">lookupModes</a></span>()</code>
<div class="block">
              告诉这个查找对象可以产生哪些访问保护类的成员。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandleInfo.html" title="interface in java.lang.invoke">MethodHandleInfo</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#revealDirect-java.lang.invoke.MethodHandle-">revealDirect</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target)</code>
<div class="block">
<a href="MethodHandleInfo.html#directmh">破解</a>由此查找对象或类似的对象创建的 
             <a href="MethodHandleInfo.html#directmh">direct method handle</a> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code><a href="../../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#toString--">toString</a></span>()</code>
<div class="block">
              显示要从中进行查找的类的名称。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflect-java.lang.reflect.Method-">unreflect</a></span>(<a href="../../../java/lang/reflect/Method.html" title="class in java.lang.reflect">方法</a> m)</code>
<div class="block">
              做一个 
             <a href="MethodHandleInfo.html#directmh">direct method handle</a>到 
             <i>m</i> ，如果查找类有权限。 
            </div> </td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflectConstructor-java.lang.reflect.Constructor-">unreflectConstructor</a></span>(<a href="../../../java/lang/reflect/Constructor.html" title="class in java.lang.reflect">Constructor</a>&lt;?&gt; c)</code>
<div class="block">
              为反射的构造函数生成方法句柄。 
            </div> </td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflectGetter-java.lang.reflect.Field-">unreflectGetter</a></span>(<a href="../../../java/lang/reflect/Field.html" title="class in java.lang.reflect">Field</a> f)</code>
<div class="block">
              产生方法句柄，给予反映字段的读访问权限。 
            </div> </td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflectSetter-java.lang.reflect.Field-">unreflectSetter</a></span>(<a href="../../../java/lang/reflect/Field.html" title="class in java.lang.reflect">Field</a> f)</code>
<div class="block">
              产生一个方法句柄，给一个反射的字段写权限。 
            </div> </td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflectSpecial-java.lang.reflect.Method-java.lang.Class-">unreflectSpecial</a></span>(<a href="../../../java/lang/reflect/Method.html" title="class in java.lang.reflect">方法</a> m, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; specialCaller)</code>
<div class="block">
              为反映的方法生成方法句柄。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!-- --> </a> <h3>字段详细信息</h3> <a name="PUBLIC">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>PUBLIC</h4> <pre>public static final int PUBLIC</pre>
<div class="block">
<span>单位掩码表示<code>public</code>访问，这可能有助于结果<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code></a> 。</span>
<span><code>0x01</code>的值恰好与<code>public</code> <a href="../../../java/lang/reflect/Modifier.html#PUBLIC">modifier bit</a>的值相同。</span>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../constant-values.html#java.lang.invoke.MethodHandles.Lookup.PUBLIC">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="PRIVATE">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>PRIVATE</h4> <pre>public static final int PRIVATE</pre>
<div class="block">
<span>单位掩码表示<code>private</code>访问，这可能有助于结果<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code></a> 。</span>
<span><code>0x02</code>的值恰好与<code>private</code> <a href="../../../java/lang/reflect/Modifier.html#PRIVATE">modifier bit</a>的值相同。</span>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../constant-values.html#java.lang.invoke.MethodHandles.Lookup.PRIVATE">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="PROTECTED">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>PROTECTED</h4> <pre>public static final int PROTECTED</pre>
<div class="block">
<span>单位掩码表示<code>protected</code>访问，这可能有助于结果<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code></a> 。</span>
<span>值<code>0x04</code>恰好与<code>protected</code> <a href="../../../java/lang/reflect/Modifier.html#PROTECTED">modifier bit</a>的值相同。</span>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../constant-values.html#java.lang.invoke.MethodHandles.Lookup.PROTECTED">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="PACKAGE">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>PACKAGE</h4> <pre>public static final int PACKAGE</pre>
<div class="block">
<span>单位掩码表示<code>package</code>访问（默认访问），这可能有助于结果<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code></a> 。</span>
<span>该值为<code>0x08</code> ，与任何特定的<a href="../../../java/lang/reflect/Modifier.html" title="class java.lang.reflect">modifier bit无关</a> 。</span>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../constant-values.html#java.lang.invoke.MethodHandles.Lookup.PACKAGE">Constant Field Values</a>
</dd>
</dl> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="lookupClass--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>lookupClass</h4> <pre>public <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; lookupClass()</pre>
<div class="block">
<span>告诉哪个类执行查找。</span>
<span>正是这种针对哪些检查执行可见性和访问权限的类。</span>
<p> <span>该类意味着访问许可的最大级别，但是权限可能另外受到位掩码<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code>的</a>限制，该位掩码控制是否可以访问非公共成员。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             查找类，代表此查找对象查找成员 
           </dd>
</dl> </li>
</ul> <a name="lookupModes--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>lookupModes</h4> <pre>public int lookupModes()</pre>
<div class="block">
<span>告诉这个查找对象可以产生哪些访问保护类的成员。</span>
<span>结果是比特的位掩码<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#PUBLIC">PUBLIC (0x01)</a> ， <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#PRIVATE">PRIVATE (0x02)</a> ， <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#PROTECTED">PROTECTED (0x04)</a>和<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#PACKAGE">PACKAGE (0x08)</a> 。</span>
<p> <span><a href="../../../java/lang/invoke/MethodHandles.html#lookup--">caller's class</a>上新创建的查找对象设置了所有可能的位，因为调用者类可以访问其所有成员。</span> <span>新的查找类别<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#in-java.lang.Class-">created from a previous lookup object</a>上的查找对象可能将某些模式位设置为零。</span> <span>这样做的目的是通过新的查找对象限制访问，以便它只能访问原始查找对象可以访问的名称，也可以访问新的查找类。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             查找模式，限制由该查找对象执行的访问的种类 
           </dd>
</dl> </li>
</ul> <a name="in-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>in</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a> in(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; requestedLookupClass)</pre>
<div class="block">
<span>在指定的新查找类上创建一个查找。</span>
<span>结果对象将报告指定的类作为自己的<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupClass"><code>lookupClass</code></a> 。</span>
<p> <span>然而，所得到的<code>Lookup</code>对象被保证没有比原来更多的访问能力。</span> <span>特别是，访问功能可能会丢失如下：</span> </p>
<ul>
<li> <span>如果新的查找类与旧的查找类不同，受保护的成员将不能通过继承访问。</span> <span>（受保护的成员可能因为包的共享而可以访问。）</span> </li>
<li> <span>如果新的查找类与旧的查找类不同，则保护和默认（包）成员将无法访问。</span> </li>
<li> <span>如果新的查找类与旧的查找类不在同一个包成员内，则私有成员将无法访问。</span> </li>
<li> <span>如果旧的查找类不能访问新的查找类，那么任何成员，甚至公共成员都不可访问。</span> <span>（在所有其他情况下，公共成员将继续可访问。）</span> </li>
</ul>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>requestedLookupClass</code> - 新查找对象所需的查找类 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             报告所需查找类的查找对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为空 
           </dd>
</dl> </li>
</ul> <a name="toString--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toString</h4> <pre>public <a href="../../../java/lang/String.html" title="class in java.lang">String</a> toString()</pre>
<div class="block">
<span>显示要从中进行查找的类的名称。</span>
<span>（名称是由<a href="../../../java/lang/Class.html#getName--"><code>Class.getName</code></a>报告的。）如果对该查找允许的访问有限制，则通过在类名称中添加一个后缀（由斜杠和关键字组成）来指示。</span>
<span>该关键字表示最强的访问权限，选择如下：</span>
<ul>
<li> <span>如果不允许访问，则后缀为“/ noaccess”。</span> </li>
<li> <span>如果只允许公共访问，则后缀为“/ public”。</span> </li>
<li> <span>如果只允许public和package访问，则后缀为“/ package”。</span> </li>
<li> <span>如果只允许public，package和private访问，则后缀为“/ private”。</span> </li>
</ul>
<span>如果上述情况都不适用，则允许完全访问（public，package，private和protected）。</span>
<span>在这种情况下，不添加后缀。</span>
<span>这只是对原始从<a href="../../../java/lang/invoke/MethodHandles.html#lookup--"><code>MethodHandles.lookup</code></a>获得的对象是真实的。</span>
<span>由<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#in-java.lang.Class-"><code>Lookup.in</code></a>创建的<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#in-java.lang.Class-">对象</a>总是具有限制访问权限，并将显示一个后缀。</span>
<p> <span>（看起来很奇怪，受保护的访问应该比私有访问更强大，独立于包访问，受保护的访问是首先丢失的，因为它需要调用者和被调用方之间的直接子类关系。</span> </p>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../../java/lang/Object.html#toString--">toString</a></code>在 
            <code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             对象的字符串表示形式。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#in-java.lang.Class-"><code>in(java.lang.Class&lt;?&gt;)</code></a>
</dd>
</dl> </li>
</ul> <a name="findStatic-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>findStatic</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> findStatic(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; refc,
                               <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name,
                               <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> type)
                        throws <a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                               <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre>
<div class="block">
<span>为静态方法生成方法句柄。</span>
<span>方法句柄的类型将是该方法的类型。</span>
<span>（由于静态方法不接收接收器，所以在方法句柄类型中没有插入附加的接收参数，正如<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findVirtual-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-"><code>findVirtual</code></a>或<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findSpecial-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-java.lang.Class-"><code>findSpecial</code>所示</a> ）。查找对象的方法及其所有参数类型必须可访问。</span>
<p> <span>返回的方法句柄将有<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity，</a>当且仅当该方法的变量arity修饰符位（ <code>0x0080</code> ）被设置。</span> </p>
<p> <span>如果调用返回的方法句柄，方法的类将被初始化，如果尚未被初始化。</span> </p>
<p> <span><b>例：</b></span> </p>
<blockquote>
<span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
  "asList", methodType(List.class, Object[].class));
assertEquals("[x, y]", MH_asList.invoke("x", "y").toString());
 </code></pre></span>
</blockquote>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>refc</code> - 访问该方法的类 
           </dd>
<dd>
<code>name</code> - 方法的名称 
           </dd>
<dd>
<code>type</code> - 方法的类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             所需的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code> - 如果方法不存在 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败，或者方法不是 
            <code>static</code> ，或者方法的可变 
            <code>asVarargsCollector</code>修饰符位被设置并且 
            <code>asVarargsCollector</code>失败 
           </dd>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果一个安全管理员存在，它是 
            <a href="MethodHandles.Lookup.html#secmgr">refuses access</a>
</dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为空 
           </dd>
</dl> </li>
</ul> <a name="findVirtual-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>findVirtual</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> findVirtual(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; refc,
                                <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name,
                                <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> type)
                         throws <a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                                <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre>
<div class="block">
<span>为虚拟方法生成方法句柄。</span>
<span>方法句柄的类型将是该方法的类型，接收器类型（通常为<code>refc</code> ）为前缀。</span>
<span>查询对象必须可访问该方法及其所有参数类型。</span>
<p> <span>当被调用时，句柄会将第一个参数视为接收者，并在接收者的类型上进行调度，以确定要输入的方法实现。</span> <span>（调度动作与<code>invokevirtual</code>或<code>invokeinterface</code>指令执行的动作相同）</span> </p>
<p> <span>如果查找类具有访问该成员的完整权限，则第一个参数将为<code>refc</code> 。</span> <span>否则该成员必须是<code>protected</code> ，并且第一个参数将被限制在查找类的类型中。</span> </p>
<p> <span>返回的方法句柄将有<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity，</a>当且仅当该方法的变量arity修饰符位（ <code>0x0080</code> ）被设置。</span> </p>
<p> <span>因为一般<a href="MethodHandles.Lookup.html#equiv">equivalence</a>之间<code>invokevirtual</code>指令和方法所生产手柄<code>findVirtual</code> ，如果类是<code>MethodHandle</code>和名称的字符串是<code>invokeExact</code>或<code>invoke</code> ，所得到的方法手柄等效于一个由产生<a href="../../../java/lang/invoke/MethodHandles.html#exactInvoker-java.lang.invoke.MethodType-"><code>MethodHandles.exactInvoker</code></a>或<a href="../../../java/lang/invoke/MethodHandles.html#invoker-java.lang.invoke.MethodType-"><code>MethodHandles.invoker</code></a>具有相同<code>type</code>参数。</span> <span><b>例：</b></span> </p>
<blockquote>
<span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle MH_concat = publicLookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
MethodHandle MH_hashCode = publicLookup().findVirtual(Object.class,
  "hashCode", methodType(int.class));
MethodHandle MH_hashCode_String = publicLookup().findVirtual(String.class,
  "hashCode", methodType(int.class));
assertEquals("xy", (String) MH_concat.invokeExact("x", "y"));
assertEquals("xy".hashCode(), (int) MH_hashCode.invokeExact((Object)"xy"));
assertEquals("xy".hashCode(), (int) MH_hashCode_String.invokeExact("xy"));
// interface method:
MethodHandle MH_subSequence = publicLookup().findVirtual(CharSequence.class,
  "subSequence", methodType(CharSequence.class, int.class, int.class));
assertEquals("def", MH_subSequence.invoke("abcdefghi", 3, 6).toString());
// constructor "internal method" must be accessed differently:
MethodType MT_newString = methodType(void.class); //()V for new String()
try { assertEquals("impossible", lookup()
        .findVirtual(String.class, "&lt;init&gt;", MT_newString));
 } catch (NoSuchMethodException ex) { } // OK
MethodHandle MH_newString = publicLookup()
  .findConstructor(String.class, MT_newString);
assertEquals("", (String) MH_newString.invokeExact());
 </code></pre></span>
</blockquote>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>refc</code> - 访问该方法的类或接口 
           </dd>
<dd>
<code>name</code> - 方法的名称 
           </dd>
<dd>
<code>type</code> - 方法的类型，省略了接收方参数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             所需的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code> - 如果方法不存在 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败，或者如果方法为 
            <code>static</code>或者方法的可变 
            <code>asVarargsCollector</code>修饰符位被设置并且 
            <code>asVarargsCollector</code>失败 
           </dd>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果一个安全管理员存在，它 
            <a href="MethodHandles.Lookup.html#secmgr">refuses access</a>
</dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为空 
           </dd>
</dl> </li>
</ul> <a name="findConstructor-java.lang.Class-java.lang.invoke.MethodType-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>findConstructor</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> findConstructor(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; refc,
                                    <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> type)
                             throws <a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                                    <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre>
<div class="block">
<span>使用指定类型的构造函数生成创建对象并初始化它的方法句柄。</span>
<span>方法句柄的参数类型将是构造函数的参数类型，而返回类型将是对构造函数类的引用。</span>
<span>查询对象必须可以访问构造函数及其所有参数类型。</span>
<p> <span>请求的类型必须有一个返回类型<code>void</code> 。</span> <span>（这与JVM处理构造函数类型描述符一致。）</span> </p>
<p> <span>当且仅当构造函数的变量arity修饰符位（ <code>0x0080</code> ）被设置时，返回的方法句柄将具有<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a> 。</span> </p>
<p> <span>如果调用返回的方法句柄，那么构造函数的类将被初始化，如果还没有被初始化。</span> </p>
<p> <span><b>例：</b></span> </p>
<blockquote>
<span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle MH_newArrayList = publicLookup().findConstructor(
  ArrayList.class, methodType(void.class, Collection.class));
Collection orig = Arrays.asList("x", "y");
Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
assert(orig != copy);
assertEquals(orig, copy);
// a variable-arity constructor:
MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
  ProcessBuilder.class, methodType(void.class, String[].class));
ProcessBuilder pb = (ProcessBuilder)
  MH_newProcessBuilder.invoke("x", "y", "z");
assertEquals("[x, y, z]", pb.command().toString());
 </code></pre></span>
</blockquote>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>refc</code> - 访问该方法的类或接口 
           </dd>
<dd>
<code>type</code> - 方法的类型，省略了接收者参数，以及一个void返回类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             所需的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code> - 如果构造函数不存在 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败或者方法的变量arity修饰符位被设置并且 
            <code>asVarargsCollector</code>失败 
           </dd>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果一个安全管理器存在，它 
            <a href="MethodHandles.Lookup.html#secmgr">refuses access</a>
</dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为空 
           </dd>
</dl> </li>
</ul> <a name="findSpecial-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>findSpecial</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> findSpecial(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; refc,
                                <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name,
                                <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> type,
                                <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; specialCaller)
                         throws <a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                                <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre>
<div class="block">
<span>为虚拟方法生成早期绑定的方法句柄。</span>
<span>它会绕过检查重写在接收机，方法<a href="MethodHandles.Lookup.html#equiv">as if called</a>从<code>invokespecial</code>从明确内指令指定<code>specialCaller</code> 。</span>
<span>方法句柄的类型将是该方法的类型，前面加上适当受限的接收器类型。</span>
<span>（接收器类型将为<code>specialCaller</code>或子类型。）查找对象必须可访问该方法及其所有参数类型。</span>
<p> <span>在方法解析之前，如果显式指定的调用者类与查找类不相同，或者如果此查找对象没有<a href="MethodHandles.Lookup.html#privacc">private access</a>权限，则访问失败。</span> </p>
<p> <span>返回的方法句柄将具有<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity，</a>如果且仅当方法的变量arity修饰符位（ <code>0x0080</code> ）被设置。</span> </p>
<p style="font-size:smaller;"> <span><em>（注意：即使<code>invokespecial</code>指令在特殊情况下可以引用，也可以使用名为<code>"&lt;init&gt;"</code> JVM内部方法，使用<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findConstructor-java.lang.Class-java.lang.invoke.MethodType-"><code>findConstructor</code></a>可以安全访问实例初始化方法。）</em></span> </p>
<p> <span><b>例：</b></span> </p>
<blockquote>
<span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
static class Listie extends ArrayList {
  public String toString() { return "[wee Listie]"; }
  static Lookup lookup() { return MethodHandles.lookup(); }
}
...
// no access to constructor via invokeSpecial:
MethodHandle MH_newListie = Listie.lookup()
  .findConstructor(Listie.class, methodType(void.class));
Listie l = (Listie) MH_newListie.invokeExact();
try { assertEquals("impossible", Listie.lookup().findSpecial(
        Listie.class, "&lt;init&gt;", methodType(void.class), Listie.class));
 } catch (NoSuchMethodException ex) { } // OK
// access to super and self methods via invokeSpecial:
MethodHandle MH_super = Listie.lookup().findSpecial(
  ArrayList.class, "toString" , methodType(String.class), Listie.class);
MethodHandle MH_this = Listie.lookup().findSpecial(
  Listie.class, "toString" , methodType(String.class), Listie.class);
MethodHandle MH_duper = Listie.lookup().findSpecial(
  Object.class, "toString" , methodType(String.class), Listie.class);
assertEquals("[]", (String) MH_super.invokeExact(l));
assertEquals(""+l, (String) MH_this.invokeExact(l));
assertEquals("[]", (String) MH_duper.invokeExact(l)); // ArrayList method
try { assertEquals("inaccessible", Listie.lookup().findSpecial(
        String.class, "toString", methodType(String.class), Listie.class));
 } catch (IllegalAccessException ex) { } // OK
Listie subl = new Listie() { public String toString() { return "[subclass]"; } };
assertEquals(""+l, (String) MH_this.invokeExact(subl)); // Listie method
 </code></pre></span>
</blockquote>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>refc</code> - 访问该方法的类或接口 
           </dd>
<dd>
<code>name</code> - 方法的名称（不能为“&lt;init&gt;”） 
           </dd>
<dd>
<code>type</code> - 方法的类型，省略了接收方参数 
           </dd>
<dd>
<code>specialCaller</code> - 提出的呼叫类执行 
            <code>invokespecial</code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             所需的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code> - 如果方法不存在 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败，或者方法的变量 
            <code>asVarargsCollector</code>修饰符位置位，并且 
            <code>asVarargsCollector</code>失败 
           </dd>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果一个安全管理员存在，它 
            <a href="MethodHandles.Lookup.html#secmgr">refuses access</a>
</dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为空 
           </dd>
</dl> </li>
</ul> <a name="findGetter-java.lang.Class-java.lang.String-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>findGetter</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> findGetter(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; refc,
                               <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name,
                               <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; type)
                        throws <a href="../../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a>,
                               <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre>
<div class="block">
<span>产生方法句柄，给非静态字段的读访问权限。</span>
<span>方法句柄的类型将具有字段值类型的返回类型。</span>
<span>方法句柄的单个参数将是包含该字段的实例。</span>
<span>代表查找类立即执行访问检查。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>refc</code> - 访问该方法的类或接口 
           </dd>
<dd>
<code>name</code> - 该字段的名称 
           </dd>
<dd>
<code>type</code> - 字段的类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个可以从字段加载值的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a></code> - 如果该字段不存在 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败，或者该字段是 
            <code>static</code>
</dd>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果一个安全管理员存在，它 
            <a href="MethodHandles.Lookup.html#secmgr">refuses access</a>
</dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为空 
           </dd>
</dl> </li>
</ul> <a name="findSetter-java.lang.Class-java.lang.String-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>findSetter</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> findSetter(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; refc,
                               <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name,
                               <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; type)
                        throws <a href="../../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a>,
                               <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre>
<div class="block">
<span>产生一个给非静态字段写入访问权限的方法句柄。</span>
<span>方法句柄的类型将具有void返回类型。</span>
<span>方法句柄将使用两个参数，包含该字段的实例和要存储的值。</span>
<span>第二个参数将是字段的值类型。</span>
<span>代表查找类立即执行访问检查。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>refc</code> - 访问该方法的类或接口 
           </dd>
<dd>
<code>name</code> - 该字段的名称 
           </dd>
<dd>
<code>type</code> - 字段的类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个可以将值存储到字段中的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a></code> - 如果该字段不存在 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败，或者该字段是 
            <code>static</code>
</dd>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果一个安全管理员存在，它 
            <a href="MethodHandles.Lookup.html#secmgr">refuses access</a>
</dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为空 
           </dd>
</dl> </li>
</ul> <a name="findStaticGetter-java.lang.Class-java.lang.String-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>findStaticGetter</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> findStaticGetter(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; refc,
                                     <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name,
                                     <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; type)
                              throws <a href="../../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a>,
                                     <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre>
<div class="block">
<span>产生一个给静态字段读取访问权限的方法句柄。</span>
<span>方法句柄的类型将具有字段值类型的返回类型。</span>
<span>方法句柄将不会引用任何参数。</span>
<span>代表查找类立即执行访问检查。</span>
<p> <span>如果调用了返回的方法句柄，则该字段的类将被初始化，如果尚未初始化。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>refc</code> - 访问该方法的类或接口 
           </dd>
<dd>
<code>name</code> - 该字段的名称 
           </dd>
<dd>
<code>type</code> - 字段的类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个可以从字段加载值的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a></code> - 如果该字段不存在 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败，或者该字段不是 
            <code>static</code>
</dd>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果一个安全管理员存在，它 
            <a href="MethodHandles.Lookup.html#secmgr">refuses access</a>
</dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为空 
           </dd>
</dl> </li>
</ul> <a name="findStaticSetter-java.lang.Class-java.lang.String-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>findStaticSetter</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> findStaticSetter(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; refc,
                                     <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name,
                                     <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; type)
                              throws <a href="../../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a>,
                                     <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre>
<div class="block">
<span>生成方法句柄，给静态字段写权限。</span>
<span>方法句柄的类型将具有void返回类型。</span>
<span>方法句柄将使用单个参数，字段的值类型，要存储的值。</span>
<span>代表查找类立即执行访问检查。</span>
<p> <span>如果调用了返回的方法句柄，则该字段的类将被初始化，如果尚未初始化。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>refc</code> - 访问该方法的类或接口 
           </dd>
<dd>
<code>name</code> - 该字段的名称 
           </dd>
<dd>
<code>type</code> - 字段的类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个可以将值存储到字段中的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a></code> - 如果该字段不存在 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败，或者该字段不是 
            <code>static</code>
</dd>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果一个安全管理员存在，它 
            <a href="MethodHandles.Lookup.html#secmgr">refuses access</a>
</dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为空 
           </dd>
</dl> </li>
</ul> <a name="bind-java.lang.Object-java.lang.String-java.lang.invoke.MethodType-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>bind</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> bind(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> receiver,
                         <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name,
                         <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> type)
                  throws <a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                         <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre>
<div class="block">
<span>为非静态方法生成早期绑定的方法句柄。</span>
<span>接收者必须有一个超类型<code>defc</code> ，其中给定名称和类型的方法可以被查找类访问。</span>
<span>查询对象必须可访问该方法及其所有参数类型。</span>
<span>方法句柄的类型将是该方法的类型，而不插入附加的接收器参数。</span>
<span>给定的接收器将被绑定到方法句柄中，以便每次调用方法句柄将在给定的接收器上调用请求的方法。</span>
<p> <span>当且仅当该方法的变量arity修饰符位（ <code>0x0080</code> ）被设置<em>且</em>尾数组参数不是唯一的参数时，返回的方法句柄将具有<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a> 。</span> <span>（如果尾数组参数是唯一的参数，给定的接收器值将被绑定到它。）</span> </p>
<p> <span>这相当于以下代码：</span> </p>
<blockquote>
<span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle mh0 = lookup().findVirtual(defc, name, type);
MethodHandle mh1 = mh0.bindTo(receiver);
MethodType mt1 = mh1.type();
if (mh0.isVarargsCollector())
  mh1 = mh1.asVarargsCollector(mt1.parameterType(mt1.parameterCount()-1));
return mh1;
 </code></pre></span>
</blockquote>
<span>其中<code>defc</code>是<code>receiver.getClass()</code>或该类的超类型，其中所请求的方法可以被查找类访问。</span>
<span>（请注意， <code>bindTo</code>不能保留变量。）</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>receiver</code> - 访问该方法的对象 
           </dd>
<dd>
<code>name</code> - 方法的名称 
           </dd>
<dd>
<code>type</code> - 方法的类型，省略了接收方参数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             所需的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code> - 如果方法不存在 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败或者方法的变量arity修饰符位被设置，并且 
            <code>asVarargsCollector</code>失败 
           </dd>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果一个安全管理员存在，它 
            <a href="MethodHandles.Lookup.html#secmgr">refuses access</a>
</dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为空 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/invoke/MethodHandle.html#bindTo-java.lang.Object-"><code>MethodHandle.bindTo(java.lang.Object)</code></a> ， 
            <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findVirtual-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-"><code>findVirtual(java.lang.Class&lt;?&gt;, java.lang.String, java.lang.invoke.MethodType)</code></a>
</dd>
</dl> </li>
</ul> <a name="unreflect-java.lang.reflect.Method-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unreflect</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> unreflect(<a href="../../../java/lang/reflect/Method.html" title="class in java.lang.reflect">方法</a> m)
                       throws <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre>
<div class="block">
<span>做一个<a href="MethodHandleInfo.html#directmh">direct method handle</a>到<i>m</i> ，如果查找类有权限。</span>
<span>如果<i>m</i>是非静态的，则接收者参数被视为初始参数。</span>
<span>如果<i>m</i>是虚拟的，则在每次呼叫时都应该重写。</span>
<span>与Core Reflection API不同，异常<em>不</em>包装。</span>
<span>方法句柄的类型将是方法的类型，接收器类型为前缀（但仅当它是非静态的）时。</span>
<span>如果未设置方法的<code>accessible</code>标志，则代表查找类立即执行访问检查。</span>
<span>如果<i>m</i>不是公开的，不要与不信任方共享所产生的句柄。</span>
<p> <span>当且仅当方法的变量arity修饰符位（ <code>0x0080</code> ）被设置时，返回的方法句柄将具有<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a> 。</span> </p>
<p> <span>如果<i>m</i>是静态的，并且如果返回的方法句柄被调用，那么方法的类将被初始化，如果它还没有被初始化。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>m</code> - 反映的方法 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可以调用反射方法的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败或者方法的变量arity修饰符位被设置并且 
            <code>asVarargsCollector</code>失败 
           </dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为空 
           </dd>
</dl> </li>
</ul> <a name="unreflectSpecial-java.lang.reflect.Method-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unreflectSpecial</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> unreflectSpecial(<a href="../../../java/lang/reflect/Method.html" title="class in java.lang.reflect">方法</a> m,
                                     <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; specialCaller)
                              throws <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre>
<div class="block">
<span>为反映的方法生成方法句柄。</span>
<span>它会绕过检查重写在接收机，方法<a href="MethodHandles.Lookup.html#equiv">as if called</a>从<code>invokespecial</code>从明确内指令指定<code>specialCaller</code> 。</span>
<span>方法句柄的类型将是该方法的类型，前面加上适当受限的接收器类型。</span>
<span>（接收器类型将为<code>specialCaller</code>或子类型。）如果未设置方法的<code>accessible</code>标志，则代表查找类立即执行访问检查，就像<code>invokespecial</code>指令被链接一样。</span>
<p> <span>在方法解析之前，如果显式指定的调用者类与lookup类不相同，或者该查找对象没有<a href="MethodHandles.Lookup.html#privacc">private access</a>权限，则访问失败。</span> </p>
<p> <span>当且仅当方法的变量修饰符位（ <code>0x0080</code> ）被设置时，返回的方法句柄将具有<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>m</code> - 反映的方法 
           </dd>
<dd>
<code>specialCaller</code> - 这个类名字叫做方法 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可以调用反射方法的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败或者方法的变量arity修饰符位被设置，并且 
            <code>asVarargsCollector</code>失败 
           </dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为空 
           </dd>
</dl> </li>
</ul> <a name="unreflectConstructor-java.lang.reflect.Constructor-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unreflectConstructor</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> unreflectConstructor(<a href="../../../java/lang/reflect/Constructor.html" title="class in java.lang.reflect">Constructor</a>&lt;?&gt; c)
                                  throws <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre>
<div class="block">
<span>为反射的构造函数生成方法句柄。</span>
<span>方法句柄的类型将是构造函数的类型，返回类型更改为声明类。</span>
<span>方法句柄将执行<code>newInstance</code>操作，在传递给方法句柄的参数上创建构造函数类的新实例。</span>
<p> <span>如果未设置构造函数的<code>accessible</code>标志，则代表查找类立即执行访问检查。</span> </p>
<p> <span>当且仅当构造函数的变量arity修饰符位（ <code>0x0080</code> ）被设置时，返回的方法句柄将具有<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a> 。</span> </p>
<p> <span>如果调用返回的方法句柄，那么构造函数的类将被初始化，如果还没有被初始化。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>c</code> - 反映的构造函数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可以调用反射的构造函数的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败或者方法的变量arity修饰符位被设置，并且 
            <code>asVarargsCollector</code>失败 
           </dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为空 
           </dd>
</dl> </li>
</ul> <a name="unreflectGetter-java.lang.reflect.Field-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unreflectGetter</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> unreflectGetter(<a href="../../../java/lang/reflect/Field.html" title="class in java.lang.reflect">Field</a> f)
                             throws <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre>
<div class="block">
<span>产生方法句柄，给予反映字段的读访问权限。</span>
<span>方法句柄的类型将具有字段值类型的返回类型。</span>
<span>如果该字段是静态的，方法句柄将不会引用任何参数。</span>
<span>否则，其单个参数将是包含该字段的实例。</span>
<span>如果字段的<code>accessible</code>标志未设置，则代表查找类立即执行访问检查。</span>
<p> <span>如果该字段是静态的，并且如果返回的方法句柄被调用，则该字段的类将被初始化，如果它还没有被初始化。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>f</code> - 反射场 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个方法句柄，可以从反射的字段加载值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败 
           </dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为null 
           </dd>
</dl> </li>
</ul> <a name="unreflectSetter-java.lang.reflect.Field-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unreflectSetter</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> unreflectSetter(<a href="../../../java/lang/reflect/Field.html" title="class in java.lang.reflect">Field</a> f)
                             throws <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre>
<div class="block">
<span>产生一个方法句柄，给一个反射的字段写权限。</span>
<span>方法句柄的类型将具有void返回类型。</span>
<span>如果该字段是静态的，那么方法句柄将使用一个参数，即字段的值类型，要存储的值。</span>
<span>否则，两个参数将是包含该字段的实例和要存储的值。</span>
<span>如果字段的<code>accessible</code>标志未设置，则代表查找类立即执行访问检查。</span>
<p> <span>如果该字段是静态的，并且如果返回的方法句柄被调用，则该字段的类将被初始化，如果它还没有被初始化。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>f</code> - 反射场 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一种可以将值存储到反射场中的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败 
           </dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为空 
           </dd>
</dl> </li>
</ul> <a name="revealDirect-java.lang.invoke.MethodHandle-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>revealDirect</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandleInfo.html" title="interface in java.lang.invoke">MethodHandleInfo</a> revealDirect(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target)</pre>
<div class="block">
<span><a href="MethodHandleInfo.html#directmh">破解</a>由此查找对象或类似的对象创建的<a href="MethodHandleInfo.html#directmh">direct method handle</a> 。</span>
<span>执行安全和访问检查以确保该查找对象能够再现目标方法句柄。</span>
<span>这意味着如果目标是一个直接的方法句柄但是由一个不相关的查找对象创建，则破解可能会失败。</span>
<span>如果方法句柄为<a href="MethodHandles.Lookup.html#callsens">caller sensitive</a> ，并且由不同类的查找对象创建，则可能会发生这种情况。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>target</code> - 一种直接的方法手柄来破解符号参考组件 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个符号引用，可用于从此查找对象重建此方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果一个安全管理器存在，它 
            <a href="MethodHandles.Lookup.html#secmgr">refuses access</a>
</dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果目标不是直接方法句柄或访问检查失败 
           </dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果目标是 
            <code>null</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../../java/lang/invoke/MethodHandleInfo.html" title="java.lang.invoke中的接口"><code>MethodHandleInfo</code></a></span>
</dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>