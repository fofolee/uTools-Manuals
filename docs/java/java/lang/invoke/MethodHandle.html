<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.lang.invoke 
   </div>
<h2 class="title" title="Class MethodHandle">Class MethodHandle</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.lang.invoke.MethodHandle</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre>public abstract class <span class="typeNameLabel">MethodHandle</span>
extends <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></pre>
<div class="block">
<span>方法句柄是一个类型化的，直接可执行的对底层方法，构造函数，字段或类似低级操作的引用，具有参数或返回值的可选转换。</span>
<span>这些转换是相当普遍的，并且包括这样的模式为<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-">conversion</a> ， <a href="../../../java/lang/invoke/MethodHandle.html#bindTo-java.lang.Object-">insertion</a> ， <a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-">deletion</a>和<a href="../../../java/lang/invoke/MethodHandles.html#filterArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle...-">substitution</a> 。</span>
<h1> <span>方法句柄内容</span> </h1>
<span>根据其参数和返回类型，方法句柄是动态和强类型的。</span>
<span>它们不被其基础方法的名称或定义类区分。</span>
<span>必须使用与方法句柄自己的<a href="../../../java/lang/invoke/MethodHandle.html#type">type descriptor</a>匹配的符号类型描述符来调用方法句柄。</span>
<p> <span>每个方法句柄通过<a href="../../../java/lang/invoke/MethodHandle.html#type"><code>type</code></a>访问器报告其类型描述<a href="../../../java/lang/invoke/MethodHandle.html#type">符</a> 。</span> <span>该类型描述符是一个<a href="../../../java/lang/invoke/MethodType.html" title="class java.lang.invoke"><code>MethodType</code></a>对象，其结构是一系列类，其中一个是方法的返回类型（如果没有<code>void.class</code> ）。</span> </p>
<p> <span>方法句柄的类型控制它接受的调用类型，以及适用于它的转换种类。</span> </p>
<p> <span>方法句柄包含一对称为<a href="../../../java/lang/invoke/MethodHandle.html#invokeExact-java.lang.Object...-"><code>invokeExact</code></a>和<a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>的特殊调用方法。</span> <span>这两个调用方法都可以直接访问方法句柄的底层方法，构造函数，字段或其他操作，通过参数和返回值的转换进行修改。</span> <span>两个调用者接受与方法句柄自己的类型完全匹配的调用。</span> <span>普通的，不精确的调用者也接受一系列其他呼叫类型。</span> </p>
<p> <span>方法句柄是不可变的，没有可见状态。</span> <span>当然，它们可以绑定到显示状态的底层方法或数据。</span> <span>对于Java内存模型，任何方法句柄的行为就好像它的所有（内部）字段都是最终变量。</span> <span>这意味着对应用程序可见的任何方法句柄将始终完全形成。</span> <span>即使在数据竞赛中通过共享变量发布方法句柄也是如此。</span> </p>
<p> <span>方法句柄不能被用户子类化。</span> <span>实现方式可以（或可以不）创建的内部子类<code>MethodHandle</code> ，其可以经由可见<a href="../../../java/lang/Object.html#getClass--"><code>Object.getClass</code></a>操作。</span> <span>程序员不应该从其特定的类中得出关于方法句柄的结论，因为方法句柄类层次结构（如果有的话）可能会随时或跨不同供应商的实现而改变。</span> </p>
<h1> <span>方法句柄编译</span> </h1>
<span>命名为<code>invokeExact</code>或<code>invoke</code> Java方法调用表达式可以从Java源代码调用方法句柄。</span>
<span>从源代码的角度来看，这些方法可以接受任何参数，并将其结果转换为任何返回类型。</span>
<span>正式地，这是通过给出调用者方法<code>Object</code>返回类型和变量arity <code>Object</code>参数来实现的，但是它们具有称为<em>签名多态性</em>的附加质量，其将该调用自由直接连接到JVM执行堆栈。</span>
<p> <span>像虚拟方法一样，源级调用<code>invokeExact</code>和<code>invoke</code>编译为<code>invokevirtual</code>指令。</span> <span>更奇怪的是，编译器必须记录实际的参数类型，并且可能不会对参数执行方法调用转换。</span> <span>相反，它必须根据自己的未转换类型将它们推送到堆栈上。</span> <span>方法handle对象本身被推送到栈前的参数。</span> <span>然后，编译器使用描述参数和返回类型的符号类型描述符来调用方法句柄。</span> </p>
<p> <span>要发出完整的符号类型描述符，编译器还必须确定返回类型。</span> <span>这是基于对方法调用表达式的转换（如果有的话），否则<code>Object</code>如果调用是一个表达式，否则<code>void</code>如果调用是一个语句。</span> <span>演员可能是原始类型（但不是<code>void</code> ）。</span> </p>
<p> <span>作为一个角色，一个未被广播的<code>null</code>参数被赋予一个符号类型描述<code>java.lang.Void</code> 。</span> <span>与Void类型的<code>Void</code>是无害的，因为没有引用类型<code>Void</code>除了空引用。</span> </p>
<h1> <span>方法句柄调用</span> </h1>
<span>一个第一次<code>invokevirtual</code>指令被执行它所链接，由指令解析象征性的名称，并确定该方法调用是静态的法律。</span>
<span>呼叫<code>invokeExact</code>和<code>invoke</code>是真的。</span>
<span>在这种情况下，检查由编译器发出的符号类型描述符，以查找正确的语法，并且解析其包含的名称。</span>
<span>因此，只要符号类型描述符在语法上形成良好并且类型存在，则调用方法句柄的<code>invokevirtual</code>指令将始终链接。</span>
<p> <span>当链接后执行<code>invokevirtual</code>时，接收方法句柄的类型首先由JVM检查，以确保它符合符号类型描述符。</span> <span>如果类型匹配失败，则意味着调用者调用的方法不会在被调用的单个方法句柄上显示。</span> </p>
<p> <span>在<code>invokeExact</code>的情况下， <code>invokeExact</code>的类型描述符（解析符号类型名称后）必须与接收方法句柄的方法类型完全匹配。</span> <span>在简单的，不精确的<code>invoke</code>的情况下，解析的类型描述符必须是接收者的<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code></a>方法的有效参数。</span> <span>因此，纯<code>invoke</code>比更宽容的<code>invokeExact</code> 。</span> </p>
<p> <span>类型匹配后，直接调用<code>invokeExact</code>并立即调用方法句柄的底层方法（或其他行为，视情况而定）。</span> </p>
<p> <span>平淡的呼叫<code>invoke</code>的工作方式相同的电话<code>invokeExact</code> ，如果调用者指定符号类型说明符的方法处理自己的类型完全匹配。</span> <span>如果有类型不匹配， <code>invoke</code>尝试调整接收方法句柄的类型，好像通过调用<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code></a> ，以获得一个完全可调用的方法句柄<code>M2</code> 。</span> <span>这允许在调用者和被调用者之间进行更强大的方法类型协商。</span> </p>
<p> <span>（ <em>注意：</em>调整后的方法句柄<code>M2</code>不是直接可见的，因此实现不需要实现。）</span> </p>
<h1> <span>调用检查</span> </h1>
<span>在典型的程序中，方法句柄类型匹配通常会成功。</span>
<span>但是，如果地址不匹配时，JVM将抛出一个<a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class java.lang.invoke"><code>WrongMethodTypeException</code></a> ，直接（在的情况下<code>invokeExact</code> ）或间接仿佛被呼叫失败到<code>asType</code> （在的情况下<code>invoke</code> ）。</span>
<p> <span>因此，在静态类型程序中可能显示为链接错误的方法类型不匹配可以在使用方法句柄的程序中显示为动态<code>WrongMethodTypeException</code> 。</span> </p>
<p> <span>因为方法类型包含“live” <code>类</code>对象，所以方法类型匹配同时考虑了类名和类加载器。</span> <span>因此，即使一个方法处理<code>M</code>在一个类加载器创建<code>L1</code>和使用另一<code>L2</code> ，方法句柄调用是类型安全的，因为调用者的符号类型描述符，如解决<code>L2</code> ，与最初的被叫方法的符号类型匹配描述符，解析于<code>L1</code> 。</span> <span>决议<code>L1</code>时发生<code>M</code>被创建，其类型分配，而在分辨率<code>L2</code>当发生<code>invokevirtual</code>指令链接。</span> </p>
<p> <span>除了检查类型描述符之外，方法句柄调用其底层方法的能力是不受限制的。</span> <span>如果方法句柄是通过访问该方法的类在非公共方法上形成的，那么生成的句柄可以由任何接收到它的引用的调用者在任何地方使用。</span> </p>
<p> <span>与Core Reflection API不同，每次调用反射方法时都会检查访问权限，因此执行方法句柄访问检查<a href="MethodHandles.Lookup.html#access">when the method handle is created</a> 。</span> <span>在<code>ldc</code> （见下文）的情况下，访问检查作为链接恒定方法句柄下的常量池条目的一部分执行。</span> </p>
<p> <span>因此，非公共方法的处理方式或非公共类的方法一般应保密。</span> <span>它们不应该传递给不受信任的代码，除非它们来自不受信任的代码的使用将是无害的。</span> </p>
<h1> <span>方法句柄创建</span> </h1>
<span>Java代码可以创建一个方法句柄，直接访问该代码可访问的任何方法，构造函数或字段。</span>
<span>这通过一个反映性能基于API的API完成，名为<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class java.lang.invoke"><code>MethodHandles.Lookup</code></a>例如，可以从<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findStatic-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-"><code>Lookup.findStatic</code></a>获取静态方法句柄。</span>
<span>还有Core Reflection API对象的转换方法，如<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflect-java.lang.reflect.Method-"><code>Lookup.unreflect</code></a> 。</span>
<p> <span>像类和字符串一样，对应于可访问字段，方法和构造函数的方法句柄也可以直接在类文件的常量池中表示为要由<code>ldc</code>字节码加载的常量。</span> <span>一种新型的常量存储库项，的<code>CONSTANT_MethodHandle</code> ，直接指到相关联的<code>CONSTANT_Methodref</code> ， <code>CONSTANT_InterfaceMethodref</code> ，或<code>CONSTANT_Fieldref</code>常量存储库项。</span> <span>（有关方法句柄常量的详细信息，请参阅Java虚拟机规范的第4.4.8和5.4.3.5节。）</span> </p>
<p> <span>来自具有变量arity修饰符位（ <code>0x0080</code> ）的方法或构造函数的查找或常量加载产生的方法句柄具有相应的变量arity，就像在<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-"><code>asVarargsCollector</code></a>的帮助下定义<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">一样</a> 。</span> </p>
<p> <span>方法引用可以指静态方法或非静态方法。</span> <span>在非静态情况下，方法句柄类型包括一个显式的接收器参数，在任何其他参数之前。</span> <span>在方法句柄的类型中，初始的接收者参数根据初始请求方法的类来键入。</span> <span>（例如，如果通过<code>ldc</code>获得非静态方法句柄，则接收器的类型是在常量池条目中命名的类。）</span> </p>
<p> <span>方法句柄常量受到相同的链接时访问检查其对应的字节码指令，如果字节码行为会抛出此错误，则<code>ldc</code>指令将抛出相应的链接错误。</span> </p>
<p> <span>作为其推论，对受保护成员的访问仅限于访问类或其子类之一的接收者，而访问类又必须是受保护成员的定义类的子类（或包兄弟）。</span> <span>如果方法引用是指当前包以外的类的受保护的非静态方法或字段，则接收方参数将被缩小为访问类的类型。</span> </p>
<p> <span>当调用一个虚拟方法的方法句柄时，方法总是在接收器中查找（也就是第一个参数）。</span> </p>
<p> <span>也可以创建特定虚拟方法实现的非虚拟方法句柄。</span> <span>这些不执行基于接收器类型的虚拟查找。</span> <span>这种方法句柄可以模拟<code>invokespecial</code>指令对同一方法的影响。</span> </p>
<h1> <span>用法示例</span> </h1>
<span>以下是一些使用示例：</span>
<blockquote>
<span><pre><code>
Object x, y; String s; int i;
MethodType mt; MethodHandle mh;
MethodHandles.Lookup lookup = MethodHandles.lookup();
// mt is (char,char)String
mt = MethodType.methodType(String.class, char.class, char.class);
mh = lookup.findVirtual(String.class, "replace", mt);
s = (String) mh.invokeExact("daddy",'d','n');
// invokeExact(Ljava/lang/String;CC)Ljava/lang/String;
assertEquals(s, "nanny");
// weakly typed invocation (using MHs.invoke)
s = (String) mh.invokeWithArguments("sappy", 'p', 'v');
assertEquals(s, "savvy");
// mt is (Object[])List
mt = MethodType.methodType(java.util.List.class, Object[].class);
mh = lookup.findStatic(java.util.Arrays.class, "asList", mt);
assert(mh.isVarargsCollector());
x = mh.invoke("one", "two");
// invoke(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;
assertEquals(x, java.util.Arrays.asList("one","two"));
// mt is (Object,Object,Object)Object
mt = MethodType.genericMethodType(3);
mh = mh.asType(mt);
x = mh.invokeExact((Object)1, (Object)2, (Object)3);
// invokeExact(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
assertEquals(x, java.util.Arrays.asList(1,2,3));
// mt is ()int
mt = MethodType.methodType(int.class);
mh = lookup.findVirtual(java.util.List.class, "size", mt);
i = (int) mh.invokeExact(java.util.Arrays.asList(1,2,3));
// invokeExact(Ljava/util/List;)I
assert(i == 3);
mt = MethodType.methodType(void.class, String.class);
mh = lookup.findVirtual(java.io.PrintStream.class, "println", mt);
mh.invokeExact(System.out, "Hello, world.");
// invokeExact(Ljava/io/PrintStream;Ljava/lang/String;)V
 </code></pre></span>
</blockquote>
<span>上述对<code>invokeExact</code>或plain <code>invoke</code>的以上调用都将<code>invokeExact</code> <code>invoke</code>下列注释中指示的符号类型描述符的单个invoke虚拟指令。</span>
<span>在这些示例中，辅助方法<code>assertEquals</code>被假定为一个方法，它调用<a href="../../../java/util/Objects.html#equals-java.lang.Object-java.lang.Object-"><code>Objects.equals</code></a>参数，并声明结果为真。</span>
<h1> <span>例外</span> </h1>
<span>方法<code>invokeExact</code>和<code>invoke</code>被声明为抛出<a href="../../../java/lang/Throwable.html" title="java.lang中的类"><code>Throwable</code></a> ，也就是说，方法句柄可以抛出什么没有静态限制。</span>
<span>由于JVM不区分被检查和未检查的异常（当然，除了它们的类之外），因此将检查的异常归因于方法句柄调用对字节码形状没有特别的影响。</span>
<span>但是在Java源代码中，执行方法处理调用的方法必须明确地抛出<code>Throwable</code> ，否则必须在本地捕获所有的throwable，重新抛出在上下文中合法的那些，并且包装非法的那些。</span>
<h1> <span><a name="sigpoly"></a>签名多态性</span> </h1>
<span><code>invokeExact</code>和平原<code>invoke</code>的不寻常的编译和连接行为被术语<em>签名多态性引用</em> 。</span>
<span>如Java语言规范中定义的，签名多态方法是可以与广泛的呼叫签名和返回类型中的任何一种进行操作的方法。</span>
<p> <span>在源代码中，对签名多态方法的调用将编译，而不管请求的符号类型描述符如何。</span> <span>像往常一样，Java编译器使用给定的符号类型描述符针对命名方法发出<code>invokevirtual</code>指令。</span> <span>不寻常的部分是符号类型描述符是从实际的参数和返回类型派生而不是方法声明。</span> </p>
<p> <span>当JVM处理包含签名多态调用的字节码时，它将成功链接任何此类调用，而不管其符号类型描述符如何。</span> <span>（为了保持类型安全性，JVM将通过适当的动态类型检查来保护此类呼叫，如其他地方所述）。</span> </p>
<p> <span>字节码生成器（包括编译器后端）需要为这些方法发出未转换的符号类型描述符。</span> <span>确定符号链接的工具需要接受这些未转换的描述符，而不报告链接错误。</span> </p>
<h1> <span>方法手柄和Core Reflection API之间的互操作</span> </h1>
<span>在<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class java.lang.invoke"><code>Lookup</code></a> API中使用工厂方法，由Core Reflection API对象表示的任何类成员都可以转换为行为上等效的方法句柄。</span>
<span>例如，反射<a href="../../../java/lang/reflect/Method.html" title="class java.lang.reflect"><code>方法</code></a>可以被转换为使用方法手柄<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflect-java.lang.reflect.Method-"><code>Lookup.unreflect</code></a> 。</span>
<span>所得到的方法句柄通常提供对基础类成员的更直接和有效的访问。</span>
<p> <span>作为一种特殊情况，当Core Reflection API用于查看此类中的签名多态方法<code>invokeExact</code>或plain <code>invoke</code>时，它们显示为普通的非多态方法。</span> <span>由<a href="../../../java/lang/Class.html#getDeclaredMethod-java.lang.String-java.lang.Class...-"><code>Class.getDeclaredMethod</code></a>查看， <a href="../../../java/lang/Class.html#getDeclaredMethod-java.lang.String-java.lang.Class...-">它们</a>的反射性外观不受其在该API中的特殊状态的影响。</span> <span>例如， <a href="../../../java/lang/reflect/Method.html#getModifiers--"><code>Method.getModifiers</code></a>将正好报告任何类似声明方法所需的修改位，包括在这种情况下为<code>native</code>和<code>varargs</code>位。</span> </p>
<p> <span>与任何反映的方法一样，这些方法（反映时）可以通过<a href="../../../java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-"><code>java.lang.reflect.Method.invoke</code></a>调用。</span> <span>但是，这种反射调用不会导致方法句柄调用。</span> <span>这样一个调用，如果通过必需的参数（一个单一的，类型为<code>Object[]</code> ），将忽略该参数，并将抛出一个<code>UnsupportedOperationException</code> 。</span> </p>
<p> <span>由于<code>invokevirtual</code>指令可以在任何符号类型描述符下本地调用方法句柄，所以这种反射视图与通过字节码的这些方法的正常呈现相冲突。</span> <span>因此，这两个本机方法，当由反射性观察<code>Class.getDeclaredMethod</code> ，可被视为仅占位符。</span> </p>
<p> <span>为了获得特定类型描述符的调用者方法，请使用<a href="../../../java/lang/invoke/MethodHandles.html#exactInvoker-java.lang.invoke.MethodType-"><code>MethodHandles.exactInvoker</code></a>或<a href="../../../java/lang/invoke/MethodHandles.html#invoker-java.lang.invoke.MethodType-"><code>MethodHandles.invoker</code></a> 。</span> <span><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findVirtual-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-"><code>Lookup.findVirtual</code></a> API还能够返回一个方法句柄来调用<code>invokeExact</code>或者简单的<code>invoke</code> ，用于任何指定的类型描述符。</span> </p>
<h1> <span>方法句柄和Java泛型之间的互操作</span> </h1>
<span>可以使用Java通用类型声明的方法，构造函数或字段获取方法句柄。</span>
<span>与Core Reflection API一样，方法句柄的类型将由源级类型的擦除构成。</span>
<span>调用方法句柄时，其参数或返回值转换类型的类型可能是通用类型或类型实例。</span>
<span>如果发生这种情况，当它构建的符号类型说明符编译器将取代这些类型由它们的擦除<code>invokevirtual</code>指令。</span>
<p> <span>方法句柄在Java参数化（通用）类型方面并不表示其类似函数的类型，因为类函数类型和参数化Java类型之间存在三个不匹配。</span> </p>
<ul>
<li> <span>方法类型的范围在所有可能arities，从没有参数到<a href="MethodHandle.html#maxarity">maximum number</a>允许争论。</span> <span>泛型不是可变的，所以不能代表这一点。</span> </li>
<li> <span>方法类型可以指定原始类型的参数，哪些Java通用类型不能覆盖。</span> </li>
<li> <span>方法手柄（组合器）的高阶函数通常在广泛的函数类型（包括多个特征的函数类型）中是通用的。</span> <span>使用Java类型参数来表示这种通用性是不可能的。</span> </li>
</ul>
<h1> <span><a name="maxarity"></a>等级限制</span> </h1>
<span>JVM对任何类型的所有方法和构造函数都施加255个堆栈参数的绝对限制。</span>
<span>在某些情况下，这个限制可能会更具限制性：</span>
<ul>
<li> <span>A <code>long</code>或<code>double</code>参数计数（作为极限限制）作为两个参数插槽。</span> </li>
<li> <span>非静态方法为调用该方法的对象消耗额外的参数。</span> </li>
<li> <span>构造函数为正在构造的对象消耗额外的参数。</span> </li>
<li> <span>由于方法句柄<code>invoke</code>方法（或其他签名多态方法）是非虚拟的，除了任何非虚拟接收器对象之外，它还为方法句柄本身消耗额外的参数。</span> </li>
</ul>
<span>这些限制意味着无法创建某些方法句柄，仅因为堆栈参数的JVM限制。</span>
<span>例如，如果静态JVM方法完全接受255个参数，则无法为其创建方法句柄。</span>
<span>尝试使用不可能的方法类型创建方法句柄导致<a href="../../../java/lang/IllegalArgumentException.html" title="java.lang中的类"><code>IllegalArgumentException</code></a> 。</span>
<span>特别地，方法句柄的类型不能具有最大255的精确度。</span>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../../java/lang/invoke/MethodType.html" title="class java.lang.invoke"><code>MethodType</code></a> ， <a href="../../../java/lang/invoke/MethodHandles.html" title="class java.lang.invoke"><code>MethodHandles</code></a></span>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#asCollector-java.lang.Class-int-">asCollector</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; arrayType, int arrayLength)</code>
<div class="block">
              使 
             <em>数组收集</em>方法句柄接受给定数量的尾随位置参数并将其收集到数组参数中。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#asFixedArity--">asFixedArity</a></span>()</code>
<div class="block">
              创建一个 
             <em>固定的arity</em>方法句柄，否则相当于当前的方法句柄。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#asSpreader-java.lang.Class-int-">asSpreader</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; arrayType, int arrayLength)</code>
<div class="block">
              创建一个 
             <em>数组扩展</em>方法句柄，它接受一个尾随的数组参数，并将其元素作为位置参数传播。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-">asType</a></span>(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> newType)</code>
<div class="block">
              生成一个适配器方法句柄，该句柄将当前方法句柄的类型适配为新类型。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">asVarargsCollector</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; arrayType)</code>
<div class="block">
              创建一个 
             <em>可变的arity</em>适配器，它可以接受任意数量的尾随位置参数并将其收集到数组参数中。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#bindTo-java.lang.Object-">bindTo</a></span>(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> x)</code>
<div class="block">
              将值 
             <code>x</code>绑定到方法句柄的第一个参数，而不调用它。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-">invoke</a></span>(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>... args)</code>
<div class="block">
              调用方法句柄，允许任何调用者类型描述符，以及可选地对参数和返回值执行转换。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#invokeExact-java.lang.Object...-">invokeExact</a></span>(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>... args)</code>
<div class="block">
              调用方法句柄，允许任何调用者类型描述符，但需要确切的类型匹配。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#invokeWithArguments-java.util.List-">invokeWithArguments</a></span>(<a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; arguments)</code>
<div class="block">
              执行可变元数调用，传递参数给定的阵列中的方法处理，就好像通过不精确 
             <a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>从呼叫位点，其仅提到类型 
             <code>Object</code> ，且其元数是参数阵列的长度。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#invokeWithArguments-java.lang.Object...-">invokeWithArguments</a></span>(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>... arguments)</code>
<div class="block">
              执行可变元数调用，传递的参数在给定列表的方法处理，就好像通过不精确 
             <a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>从呼叫位点，其仅提到类型 
             <code>Object</code> ，且其元数是参数列表的长度。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#isVarargsCollector--">isVarargsCollector</a></span>()</code>
<div class="block">
              确定此方法句柄是否支持 
             <a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a>调用。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code><a href="../../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#toString--">toString</a></span>()</code>
<div class="block">
              返回方法句柄的字符串表示 
             <code>"MethodHandle"</code> ，从字符串"MethodHandle"开始，以方法句柄类型的字符串 
             <code>"MethodHandle"</code>结束。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#type--">type</a></span>()</code>
<div class="block">
              报告此方法句柄的类型。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="type--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>type</h4> <pre>public <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> type()</pre>
<div class="block">
<span>报告此方法句柄的类型。</span>
<span>通过<code>invokeExact</code>每次调用此方法句柄必须与此类型完全匹配。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             方法句柄类型 
           </dd>
</dl> </li>
</ul> <a name="invokeExact-java.lang.Object...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>invokeExact</h4> <pre>public final <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> invokeExact(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>... args)
                         throws <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a></pre>
<div class="block">
<span>调用方法句柄，允许任何调用者类型描述符，但需要确切的类型匹配。</span>
<span>invokeExact的呼叫站点上的符号类型描述<code>invokeExact</code>必须与此方法句柄<a href="../../../java/lang/invoke/MethodHandle.html#type"><code>type</code></a>完全匹配。</span>
<span>参数或返回值不允许转换。</span>
<p> <span>当通过Core Reflection API观察此方法时，它将显示为单个本机方法，获取对象数组并返回一个对象。</span> <span>如果通过<a href="../../../java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-"><code>java.lang.reflect.Method.invoke</code></a>直接通过JNI或通过<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflect-java.lang.reflect.Method-"><code>Lookup.unreflect</code>间接</a>调用此本机方法，它将抛出一个<code>UnsupportedOperationException</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>args</code> - 使用varargs静态表示的签名 - 多态参数列表 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             签名多态结果，使用 
            <code>Object</code>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果目标的类型与调用者的符号类型描述符不相同 
           </dd>
<dd>
<code><a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a></code> - 底层方法抛出的东西通过方法句柄调用传播不变 
           </dd>
</dl> </li>
</ul> <a name="invoke-java.lang.Object...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>invoke</h4> <pre>public final <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> invoke(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>... args)
                    throws <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a></pre>
<div class="block">
<span>调用方法句柄，允许任何调用者类型描述符，以及可选地对参数和返回值执行转换。</span>
<p> <span>如果调用点的符号类型说明符完全匹配这种方法处理的<a href="../../../java/lang/invoke/MethodHandle.html#type"><code>type</code></a> ，进行呼叫仿佛<a href="../../../java/lang/invoke/MethodHandle.html#invokeExact-java.lang.Object...-"><code>invokeExact</code></a> 。</span> </p>
<p> <span>否则，通过调用<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code></a>调整此方法句柄至所需类型，调用方法句柄首先进行调整，然后通过<a href="../../../java/lang/invoke/MethodHandle.html#invokeExact-java.lang.Object...-"><code>invokeExact</code></a>调整方法句柄进行调用。</span> </p>
<p> <span>不能保证<code>asType</code>电话实际上是做的。</span> <span>如果JVM可以预测进行调用的结果，则可以直接对调用者的参数进行调整，并根据自己的确切类型调用目标方法句柄。</span> </p>
<p> <span>invoke呼叫站点上解析的类型描述<code>invoke</code>必须是接收方<code>asType</code>方法的有效参数。</span> <span>特别是，调用者必须指定相同的参数作为元数被叫方的类型，如果被叫方是不是<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity collector</a> 。</span> </p>
<p> <span>当通过Core Reflection API观察此方法时，它将显示为单个本机方法，获取对象数组并返回一个对象。</span> <span>如果通过<a href="../../../java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-"><code>java.lang.reflect.Method.invoke</code></a>直接调用本机方法，通过JNI或通过<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflect-java.lang.reflect.Method-"><code>Lookup.unreflect</code>间接</a>调用该方法，则会抛出<code>UnsupportedOperationException</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>args</code> - 使用varargs静态表示的签名 - 多态参数列表 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             签名多态结果，使用 
            <code>Object</code>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果目标的类型无法调整到调用者的符号类型描述符 
           </dd>
<dd>
<code><a href="../../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果目标的类型可以调整到调用者，但参考转换失败 
           </dd>
<dd>
<code><a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a></code> - 底层方法抛出的东西通过方法句柄调用传播不变 
           </dd>
</dl> </li>
</ul> <a name="invokeWithArguments-java.lang.Object...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>invokeWithArguments</h4> <pre>public <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> invokeWithArguments(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>... arguments)
                           throws <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a></pre>
<div class="block">
<span>执行可变元数调用，传递的参数在给定列表的方法处理，就好像通过不精确<a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>从呼叫位点，其仅提到类型<code>Object</code> ，且其元数是参数列表的长度。</span>
<p> <span>具体来说，执行如下，通过以下步骤进行，尽管如果JVM可以预测它们的效果，则不保证调用这些方法。</span> </p>
<ul>
<li> <span>确定参数数组的长度为<code>N</code> 。</span> <span>对于null引用， <code>N=0</code> 。</span> </li>
<li> <span>确定一般类型<code>TN</code>的<code>N</code>参数，如<code>TN=MethodType.genericMethodType(N)</code> 。</span> </li>
<li> <span>将原始目标方法手柄<code>MH0</code>为所需类型，如<code>MH1 = MH0.asType(TN)</code> 。</span> </li>
<li> <span>将数组扩展为<code>N</code>单独的参数<code>A0, ...</code> 。</span> </li>
<li> <span>调用解压缩参数的类型调整方法句柄：MH1.invokeExact（A0，...）。</span> </li>
<li> <span>以返回值作为<code>Object</code>参考。</span> </li>
</ul>
<p> <span>由于<code>asType</code>步骤的操作，必要时将应用以下参数转换：</span> </p>
<ul>
<li> <span>参考铸造</span> </li>
<li> <span>拆箱</span> </li>
<li> <span>拓宽原始转换</span> </li>
</ul>
<p> <span>如果调用返回的结果是原始的，则调用返回的结果为boxed，如果返回类型为void，则强制为null。</span> </p>
<p> <span>此呼叫等同于以下代码：</span> </p>
<blockquote>
<span><pre><code>
 MethodHandle invoker = MethodHandles.spreadInvoker(this.type(), 0);
 Object result = invoker.invokeExact(this, arguments);
 </code></pre></span>
</blockquote>
<p> <span>与签名多态方法<code>invokeExact</code>和<code>invoke</code> ， <code>invokeWithArguments</code>可以通过Core Reflection API和JNI正常访问。</span> <span>因此，它可以用作本机或反射代码和方法句柄之间的桥梁。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>arguments</code> - 传递给目标的参数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             目标返回的结果 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果参数无法通过引用转换转换 
           </dd>
<dd>
<code><a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果目标的类型不能被调整为采用给定数量的 
            <code>Object</code>参数 
           </dd>
<dd>
<code><a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a></code> - 目标方法调用抛出的任何东西 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/invoke/MethodHandles.html#spreadInvoker-java.lang.invoke.MethodType-int-"><code>MethodHandles.spreadInvoker(java.lang.invoke.MethodType, int)</code></a>
</dd>
</dl> </li>
</ul> <a name="invokeWithArguments-java.util.List-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>invokeWithArguments</h4> <pre>public <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> invokeWithArguments(<a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; arguments)
                           throws <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a></pre>
<div class="block">
<span>执行可变元数调用，传递参数给定的阵列中的方法处理，就好像通过不精确<a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>从呼叫位点，其仅提到类型<code>Object</code> ，且其元数是参数阵列的长度。</span>
<p> <span>此方法也等效于以下代码：</span> </p>
<blockquote>
<span><pre><code>
   invokeWithArguments(arguments.toArray()
 </code></pre></span>
</blockquote>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>arguments</code> - 传递给目标的参数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             目标返回的结果 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>arguments</code>是空引用 
           </dd>
<dd>
<code><a href="../../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果参数无法通过引用转换转换 
           </dd>
<dd>
<code><a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果目标的类型不能被调整为采用给定数量的 
            <code>Object</code>参数 
           </dd>
<dd>
<code><a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a></code> - 目标方法调用抛出的东西 
           </dd>
</dl> </li>
</ul> <a name="asType-java.lang.invoke.MethodType-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>asType</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> asType(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> newType)</pre>
<div class="block">
<span>生成一个适配器方法句柄，该句柄将当前方法句柄的类型适配为新类型。</span>
<span>生成的方法句柄保证报告一个等于所需新类型的类型。</span>
<p> <span>如果原始类型和新类型相同，则返回<code>this</code> 。</span> </p>
<p> <span>新方法句柄被调用时，将执行以下步骤：</span> </p>
<ul>
<li> <span>转换传入参数列表以匹配原始方法句柄的参数列表。</span> </li>
<li> <span>在转换的参数列表中调用原始方法句柄。</span> </li>
<li> <span>将原始方法句柄返回的任何结果转换为新方法句柄的返回类型。</span> </li>
</ul>
<p> <span>这种方法提供了<a href="../../../java/lang/invoke/MethodHandle.html#invokeExact-java.lang.Object...-"><code>invokeExact</code></a>与普通，不精确的<a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>之间的关键行为<a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-">差异</a> 。</span> <span>当调用者的类型描述符确切地调用被调用者时，两种方法执行相同的步骤，但是当类型不同时，普通<a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>也调用<code>asType</code> （或一些内部等效的），以匹配调用方和被叫方的类型。</span> </p>
<p> <span>如果当前的方法是一个变量arity方法，那么handle参数列表转换可能涉及将数个参数转换和收集到数组中，如<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">described elsewhere</a> 。</span> <span>在所有其他情况下，所有的转换被应用<em>成对</em>的，这意味着每个参数或返回值被转换为只有一个参数或返回值（或没有返回值）。</span> <span>应用的转换通过查看旧方法和新方法句柄类型的相应组件类型进行定义。</span> </p>
<p> <span>令<em>T0</em>和<em>T1</em>是相应的新旧参数类型，或旧的和新的返回类型。</span> <span>具体而言，对于一些有效的索引<code>i</code> ，让<em>T0</em> <code>=newType.parameterType(i)</code>和<em>T1</em> <code>=this.type().parameterType(i)</code> 。</span> <span>否则，以另一种方式返回值，让<em>T0</em> <code>=this.type().returnType()</code>和<em>T1</em> <code>=newType.returnType()</code> 。</span> <span>如果类型相同，则新方法句柄将不会更改相应的参数或返回值（如果有）。</span> <span>否则，如果可能，将应用以下转换之一：</span> </p>
<ul>
<li> <span>如果<em>T0</em>和<em>T1</em>是引用，则应用到<em>T1</em>的转换。</span> <span>（这些类型不需要以任何特定的方式相关联，这是因为null的动态值可以转换为任何引用类型。）</span> </li>
<li> <span>如果<em>T0</em>和<em>T1</em>是原语，则应用Java方法调用转换（JLS 5.3）（如果存在）。</span> <span>（具体来说， <em>T0</em>必须通过扩展的原语转换转换为<em>T1</em> ）</span> </li>
<li> <span>如果<em>T0</em>是原语， <em>T1</em>是引用，则如果存在Java转换（JLS 5.5），则应用它。</span> <span>（具体来说，该值从<em>T0</em>到其包装类包装，然后根据需要加宽到<em>T1</em> ）。</span> </li>
<li> <span>如果<em>T0</em>是引用， <em>T1</em>是原语，则在运行时将应用拆箱转换，可能之后是对基本值进行Java方法调用转换（JLS 5.3）。</span> <span>（这些是原始的扩展转换。） <em>T0</em>必须是包装类或超类型。</span> <span>（在<em>T0</em>是Object的情况下，这些是<code>java.lang.reflect.Method.invoke</code>允许的<a href="../../../java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-">转换</a> 。）拆箱转换必须具有成功的可能性，这意味着如果<em>T0</em>本身不是封装类，则必须至少存在一个包装类<em>TW</em>是<em>T0</em>的子类型，其未装箱原始值可以扩大到<em>T1</em> 。</span> </li>
<li> <span>如果返回类型<em>T1</em>被标记为void，则返回的值将被丢弃</span> </li>
<li> <span>如果返回类型<em>T0</em>为空， <em>T1</em>为引用，则引入空值。</span> </li>
<li> <span>如果返回类型<em>T0</em>为空， <em>T1</em>为原语，则引入零值。</span> </li>
</ul>
<span>（ <em>注意：</em> <em>T0</em>和<em>T1</em>都可以被视为静态类型，因为它们都不具体对应于任何实际参数或返回值的<em>动态类型</em> 。）</span>
<p> <span>如果无法进行任何一个所需的成对转换，则无法进行方法句柄转换。</span> </p>
<p> <span>在运行时，应用于引用参数或返回值的转换可能需要额外的运行时检查，这可能会失败。</span> <span>拆箱操作可能会失败，因为原始引用为null，导致<a href="../../../java/lang/NullPointerException.html" title="java.lang中的类"><code>NullPointerException</code></a> 。</span> <span>解包操作或参考铸造也可能失败上错误类型的一个对象的引用，引起<a href="../../../java/lang/ClassCastException.html" title="java.lang中的类"><code>ClassCastException</code></a> 。</span> <span>尽管拆箱操作可能会接受几种包装，但如果没有可用的话， <code>ClassCastException</code>将被抛出。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>newType</code> - 新方法句柄的预期类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个方法句柄，在执行任何必要的参数 
            <code>this</code>后委托给this，并安排任何必要的返回值转换 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>newType</code>是空引用 
           </dd>
<dd>
<code><a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果不能进行转换 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/invoke/MethodHandles.html#explicitCastArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-"><code>MethodHandles.explicitCastArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType)</code></a>
</dd>
</dl> </li>
</ul> <a name="asSpreader-java.lang.Class-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>asSpreader</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> asSpreader(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; arrayType,
                               int arrayLength)</pre>
<div class="block">
<span>创建一个<em>数组扩展</em>方法句柄，它接受一个尾随的数组参数，并将其元素作为位置参数传播。</span>
<span>新的方法句柄适应当前方法句柄的<i>目标</i> 。</span>
<span>适配器的类型将与目标的类型相同，但目标类型的最终<code>arrayLength</code>参数由arrayType类型的单个数组参数<code>arrayType</code> 。</span>
<p> <span>如果数组元素类型与原始目标上的任何相应参数类型不同，则原始目标适合直接取数组元素，就像通过调用<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code>一样</a> 。</span> </p>
<p> <span>调用时，适配器将数组元素的尾随数组参数替换为每个对象的自身参数。</span> <span>（参数的顺序被保留。）它们通过转换和/或取消装箱成对转换为目标的尾随参数的类型。</span> <span>最后调用目标。</span> <span>目标最终返回的内容不会被适配器返回。</span> </p>
<p> <span>在调用目标之前，适配器会验证数组是否包含足够的元素，以便为目标方法句柄提供正确的参数计数。</span> <span>（当需要零个元素时，数组也可能为空。）</span> </p>
<p> <span>如果调用适配器时，提供的数组参数没有正确数量的元素，则适配器将抛出<a href="../../../java/lang/IllegalArgumentException.html" title="java.lang中的类"><code>IllegalArgumentException</code></a>而不是调用目标。</span> </p>
<p> <span>以下是阵列扩展方法句柄的一些简单示例：</span> </p>
<blockquote>
<span><pre><code>
MethodHandle equals = publicLookup()
  .findVirtual(String.class, "equals", methodType(boolean.class, Object.class));
assert( (boolean) equals.invokeExact("me", (Object)"me"));
assert(!(boolean) equals.invokeExact("me", (Object)"thee"));
// spread both arguments from a 2-array:
MethodHandle eq2 = equals.asSpreader(Object[].class, 2);
assert( (boolean) eq2.invokeExact(new Object[]{ "me", "me" }));
assert(!(boolean) eq2.invokeExact(new Object[]{ "me", "thee" }));
// try to spread from anything but a 2-array:
for (int n = 0; n &lt;= 10; n++) {
  Object[] badArityArgs = (n == 2 ? null : new Object[n]);
  try { assert((boolean) eq2.invokeExact(badArityArgs) &amp;&amp; false); }
  catch (IllegalArgumentException ex) { } // OK
}
// spread both arguments from a String array:
MethodHandle eq2s = equals.asSpreader(String[].class, 2);
assert( (boolean) eq2s.invokeExact(new String[]{ "me", "me" }));
assert(!(boolean) eq2s.invokeExact(new String[]{ "me", "thee" }));
// spread second arguments from a 1-array:
MethodHandle eq1 = equals.asSpreader(Object[].class, 1);
assert( (boolean) eq1.invokeExact("me", new Object[]{ "me" }));
assert(!(boolean) eq1.invokeExact("me", new Object[]{ "thee" }));
// spread no arguments from a 0-array or null:
MethodHandle eq0 = equals.asSpreader(Object[].class, 0);
assert( (boolean) eq0.invokeExact("me", (Object)"me", new Object[0]));
assert(!(boolean) eq0.invokeExact("me", (Object)"thee", (Object[])null));
// asSpreader and asCollector are approximate inverses:
for (int n = 0; n &lt;= 2; n++) {
    for (Class&lt;?&gt; a : new Class&lt;?&gt;[]{Object[].class, String[].class, CharSequence[].class}) {
        MethodHandle equals2 = equals.asSpreader(a, n).asCollector(a, n);
        assert( (boolean) equals2.invokeWithArguments("me", "me"));
        assert(!(boolean) equals2.invokeWithArguments("me", "thee"));
    }
}
MethodHandle caToString = publicLookup()
  .findStatic(Arrays.class, "toString", methodType(String.class, char[].class));
assertEquals("[A, B, C]", (String) caToString.invokeExact("ABC".toCharArray()));
MethodHandle caString3 = caToString.asCollector(char[].class, 3);
assertEquals("[A, B, C]", (String) caString3.invokeExact('A', 'B', 'C'));
MethodHandle caToString2 = caString3.asSpreader(char[].class, 2);
assertEquals("[A, B, C]", (String) caToString2.invokeExact('A', "BC".toCharArray()));
 </code></pre></span>
</blockquote>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>arrayType</code> - 通常是 
            <code>Object[]</code> ，从中提取扩展参数的数组参数的类型 
           </dd>
<dd>
<code>arrayLength</code> - 从传入数组参数传播的参数数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个新的方法句柄，在调用原始方法句柄之前扩展其最后的数组参数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>arrayType</code>是空引用 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>arrayType</code>不是数组类型，或者如果目标不具有至少 
            <code>arrayLength</code>参数类型，或者如果 
            <code>arrayLength</code>为负数，或者如果生成的方法句柄的类型将具有 
            <a href="MethodHandle.html#maxarity">too many parameters</a>
</dd>
<dd>
<code><a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果隐含的 
            <code>asType</code>调用失败 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/invoke/MethodHandle.html#asCollector-java.lang.Class-int-"><code>asCollector(java.lang.Class&lt;?&gt;, int)</code></a>
</dd>
</dl> </li>
</ul> <a name="asCollector-java.lang.Class-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>asCollector</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> asCollector(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; arrayType,
                                int arrayLength)</pre>
<div class="block">
<span>使<em>数组收集</em>方法句柄接受给定数量的尾随位置参数并将其收集到数组参数中。</span>
<span>新的方法句柄适应当前方法句柄的<i>目标</i> 。</span>
<span>类型的适配器的将是相同的作为目标的类型，不同的是（通常的类型的单个尾随参数<code>arrayType</code> ）被替换为<code>arrayLength</code>参数，其类型为的元素类型<code>arrayType</code> 。</span>
<p> <span>如果数组类型与原始目标的最终参数类型不同，则原始目标适合直接采用数组类型，就像通过调用<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code>一样</a> 。</span> </p>
<p> <span>当被调用时，该适配器替换其尾随<code>arrayLength</code>由类型的单个新数组参数<code>arrayType</code> ，其元素包括（按顺序）被替换的参数。</span> <span>最后调用目标。</span> <span>目标最终返回的内容不会被适配器返回。</span> </p>
<p> <span>（当<code>arrayLength</code>为零时，数组也可能是共享常量。）</span> </p>
<p> <span>（ <em>注意：</em> <code>arrayType</code>通常与原始目标的最后一个参数类型相同，它是与<code>asSpreader</code>对称的明确参数，也允许目标使用简单的<code>Object</code>作为其最后一个参数类型。）</span> </p>
<p> <span>为了创建不限于特定数量的收集参数的收集适配器，请<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">改用<code>asVarargsCollector</code></a> 。</span> </p>
<p> <span>以下是数组收集方法句柄的一些示例：</span> </p>
<blockquote>
<span><pre><code>
MethodHandle deepToString = publicLookup()
  .findStatic(Arrays.class, "deepToString", methodType(String.class, Object[].class));
assertEquals("[won]",   (String) deepToString.invokeExact(new Object[]{"won"}));
MethodHandle ts1 = deepToString.asCollector(Object[].class, 1);
assertEquals(methodType(String.class, Object.class), ts1.type());
//assertEquals("[won]", (String) ts1.invokeExact(         new Object[]{"won"})); //FAIL
assertEquals("[[won]]", (String) ts1.invokeExact((Object) new Object[]{"won"}));
// arrayType can be a subtype of Object[]
MethodHandle ts2 = deepToString.asCollector(String[].class, 2);
assertEquals(methodType(String.class, String.class, String.class), ts2.type());
assertEquals("[two, too]", (String) ts2.invokeExact("two", "too"));
MethodHandle ts0 = deepToString.asCollector(Object[].class, 0);
assertEquals("[]", (String) ts0.invokeExact());
// collectors can be nested, Lisp-style
MethodHandle ts22 = deepToString.asCollector(Object[].class, 3).asCollector(String[].class, 2);
assertEquals("[A, B, [C, D]]", ((String) ts22.invokeExact((Object)'A', (Object)"B", "C", "D")));
// arrayType can be any primitive array type
MethodHandle bytesToString = publicLookup()
  .findStatic(Arrays.class, "toString", methodType(String.class, byte[].class))
  .asCollector(byte[].class, 3);
assertEquals("[1, 2, 3]", (String) bytesToString.invokeExact((byte)1, (byte)2, (byte)3));
MethodHandle longsToString = publicLookup()
  .findStatic(Arrays.class, "toString", methodType(String.class, long[].class))
  .asCollector(long[].class, 1);
assertEquals("[123]", (String) longsToString.invokeExact((long)123));
 </code></pre></span>
</blockquote>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>arrayType</code> - 通常是 
            <code>Object[]</code> ，将收集参数的数组参数的类型 
           </dd>
<dd>
<code>arrayLength</code> - 要收集到新数组参数中的参数数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个新的方法句柄，在调用原始方法句柄之前，将一些尾随参数收集到数组中 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>arrayType</code>是空引用 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>arrayType</code>不是数组类型，或 
            <code>arrayType</code>不能分配给该方法句柄的尾随参数类型，或 
            <code>arrayLength</code>不是合法的数组大小，或者所得到的方法句柄的类型将具有 
            <a href="MethodHandle.html#maxarity">too many parameters</a>
</dd>
<dd>
<code><a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果隐含的 
            <code>asType</code>调用失败 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/invoke/MethodHandle.html#asSpreader-java.lang.Class-int-"><code>asSpreader(java.lang.Class&lt;?&gt;, int)</code></a> ， 
            <a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-"><code>asVarargsCollector(java.lang.Class&lt;?&gt;)</code></a>
</dd>
</dl> </li>
</ul> <a name="asVarargsCollector-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>asVarargsCollector</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> asVarargsCollector(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; arrayType)</pre>
<div class="block">
<span>创建一个<em>可变的arity</em>适配器，它可以接受任意数量的尾随位置参数并将其收集到数组参数中。</span>
<p> <span>适配器的类型和行为将与目标的类型和行为相同，只是某些<code>invoke</code>和<code>asType</code>请求可能导致尾随的位置参数被收集到目标的尾随参数中。</span> <span>此外，适配器的最后一个参数类型将为<code>arrayType</code> ，即使目标具有不同的最后一个参数类型。</span> </p>
<p> <span>这种转化可以返回<code>this</code>如果该方法手柄是可变的元数的已和它的尾部参数类型是相同的<code>arrayType</code> 。</span> </p>
<p> <span>当使用<a href="../../../java/lang/invoke/MethodHandle.html#invokeExact-java.lang.Object...-"><code>invokeExact</code></a>调用时，适配器调用目标而不改变参数。</span> <span>（ <em>注意：</em>此行为与fixed arity collector <a href="../../../java/lang/invoke/MethodHandle.html#asCollector-java.lang.Class-int-">不同</a> ，因为它接受一个不确定长度的整个数组，而不是固定数量的参数。）</span> </p>
<p> <span>当使用普通，不精确的<a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>调用时，如果调用者类型与适配器相同，则适配器将使用<code>invokeExact</code>调用目标。</span> <span>（这是类型匹配时<code>invoke</code>的正常行为。）</span> </p>
<p> <span>否则，如果调用者和适配器相同，并且调用者的尾随参数类型是与适配器的尾随参数类型相同或可分配的引用类型，则参数和返回值将成对转换，如同<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code></a>在固定的方法手柄上。</span> </p>
<p> <span>否则，电平不一致，或适配器的尾随参数类型不能从相应的呼叫者类型分配。</span> <span>在这种情况下，适配器会从原始的尾随参数位置<code>arrayType</code>替换arrayType类型的新数组，其元素包括（按顺序）替换的参数。</span> </p>
<p> <span>调用者类型必须提供足够的参数和正确类型，以满足目标对尾随数组参数之前位置参数的要求。</span> <span>因此，呼叫者必须至少提供<code>N-1</code>参数，其中<code>N</code>是目标的<code>N</code> 。</span> <span>此外，必须存在从传入参数到目标参数的转换。</span> <span>与平原<code>invoke</code>其他用途<code>invoke</code> ，如果这些基本要求不能满足，可能会抛出一个<code>WrongMethodTypeException</code> 。</span> </p>
<p> <span>在所有情况下，最终返回的目标将由适配器保持不变。</span> </p>
<p> <span>在最后的情况下，正好像目标方法句柄暂时适应一个<a href="../../../java/lang/invoke/MethodHandle.html#asCollector-java.lang.Class-int-">fixed arity collector</a> ，以调用者类型所需要的。</span> <span>（与<code>asCollector</code> ，如果数组长度为零，则可以使用共享常量而不是新数组，如果对<code>asCollector</code>的隐含调用将抛出<code>IllegalArgumentException</code>或<code>WrongMethodTypeException</code> ，则对变量arity适配器的调用必须抛出<code>WrongMethodTypeException</code> ）</span> </p>
<p> <span><a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code></a>的行为也是专门针对可变局域适配器，维持不变量，简单，不精确<code>invoke</code>总是相当于一个<code>asType</code>调用调整目标类型，其次是<code>invokeExact</code> 。</span> <span>因此，当且仅当适配器和请求的类型在正态分布或尾随参数类型不同时，可变地区适配器才能响应<code>asType</code>请求。</span> <span>所得到的固定收集器的类型通过成对转换进一步调整（如果需要）到所请求的类型，好像通过asType的<code>asType</code> 。</span> </p>
<p> <span>当通过执行<code>CONSTANT_MethodHandle</code>常数的<code>ldc</code>指令获得方法句柄，并且目标方法被标记为可变方法（具有修饰符位<code>0x0080</code> ）时，方法句柄将接受多个特征，就好像方法句柄常数是通过调用<code>asVarargsCollector</code> 。</span> </p>
<p> <span>为了创建收集预定数量参数并且其类型反映该预定数量的收集适配器，代之以使用<a href="../../../java/lang/invoke/MethodHandle.html#asCollector-java.lang.Class-int-"><code>asCollector</code></a> 。</span> </p>
<p> <span>没有方法句柄转换可以产生具有可变原型的新方法句柄，除非它们被记录为这样做。</span> <span>因此，除了<code>asVarargsCollector</code> ，在所有方法<code>MethodHandle</code>和<code>MethodHandles</code>将在那里他们被指定为返回他们的原操作返回的方法手柄固定元数，除了在情况下（例如， <code>asType</code>的方法处理自己的类型）。</span> </p>
<p> <span>对方法句柄调用<code>asVarargsCollector</code>已经是可变的，将产生一个具有相同类型和行为的方法句柄。</span> <span>它可能（或可能不）返回原始变量arity方法句柄。</span> </p>
<p> <span>这是一个例子，一个列表制作变量arity方法句柄：</span> </p>
<blockquote>
<span><pre><code>
MethodHandle deepToString = publicLookup()
  .findStatic(Arrays.class, "deepToString", methodType(String.class, Object[].class));
MethodHandle ts1 = deepToString.asVarargsCollector(Object[].class);
assertEquals("[won]",   (String) ts1.invokeExact(    new Object[]{"won"}));
assertEquals("[won]",   (String) ts1.invoke(         new Object[]{"won"}));
assertEquals("[won]",   (String) ts1.invoke(                      "won" ));
assertEquals("[[won]]", (String) ts1.invoke((Object) new Object[]{"won"}));
// findStatic of Arrays.asList(...) produces a variable arity method handle:
MethodHandle asList = publicLookup()
  .findStatic(Arrays.class, "asList", methodType(List.class, Object[].class));
assertEquals(methodType(List.class, Object[].class), asList.type());
assert(asList.isVarargsCollector());
assertEquals("[]", asList.invoke().toString());
assertEquals("[1]", asList.invoke(1).toString());
assertEquals("[two, too]", asList.invoke("two", "too").toString());
String[] argv = { "three", "thee", "tee" };
assertEquals("[three, thee, tee]", asList.invoke(argv).toString());
assertEquals("[three, thee, tee]", asList.invoke((Object[])argv).toString());
List ls = (List) asList.invoke((Object)argv);
assertEquals(1, ls.size());
assertEquals("[three, thee, tee]", Arrays.toString((Object[])ls.get(0)));
 </code></pre></span>
</blockquote>
<p style="font-size:smaller;"> <span><em>讨论：</em>这些规则被设计为可变方法的Java规则的动态类型变体。</span> <span>在这两种情况下，调用变量arity方法或方法句柄都可以传递零个或多个位置参数，否则可以传递任何长度的预先收集的数组。</span> <span>用户应该意识到最终参数的特殊角色，以及类型匹配对最终参数的影响，该参数决定了单个尾随参数是否被解释为数组的整个数组或单个元素。集。</span> <span>请注意，尾随参数的动态类型对此决定没有影响，只是调用站点的符号类型描述符和方法句柄的类型描述符之间的比较。）</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>arrayType</code> - 通常是 
            <code>Object[]</code> ，将收集参数的数组参数的类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个新的方法句柄，可以在调用原始方法句柄之前收集任意数量的尾随参数到数组中 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>arrayType</code>是空引用 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>arrayType</code>不是数组类型或 
            <code>arrayType</code>不能分配给该方法句柄的尾随参数类型 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/invoke/MethodHandle.html#asCollector-java.lang.Class-int-"><code>asCollector(java.lang.Class&lt;?&gt;, int)</code></a> ， 
            <a href="../../../java/lang/invoke/MethodHandle.html#isVarargsCollector--"><code>isVarargsCollector()</code></a> ， 
            <a href="../../../java/lang/invoke/MethodHandle.html#asFixedArity--"><code>asFixedArity()</code></a>
</dd>
</dl> </li>
</ul> <a name="isVarargsCollector--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isVarargsCollector</h4> <pre>public boolean isVarargsCollector()</pre>
<div class="block">
<span>确定此方法句柄是否支持<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a>调用。</span>
<span>这种方法处理来自以下来源：</span>
<ul>
<li> <span>致电<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">asVarargsCollector</a></span> </li>
<li> <span>调用一个<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class java.lang.invoke">lookup method</a> ，它解析为一个可变的arity Java方法或构造函数</span> </li>
<li> <span>一个<code>ldc</code> ldc <code>CONSTANT_MethodHandle</code> ，它解析为一个可变的arity Java方法或构造函数</span> </li>
</ul>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             如果这个方法句柄接受多个简单的，不精确的 
            <code>invoke</code>调用， 
            <code>invoke</code>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-"><code>asVarargsCollector(java.lang.Class&lt;?&gt;)</code></a> ， 
            <a href="../../../java/lang/invoke/MethodHandle.html#asFixedArity--"><code>asFixedArity()</code></a>
</dd>
</dl> </li>
</ul> <a name="asFixedArity--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>asFixedArity</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> asFixedArity()</pre>
<div class="block">
<span>创建一个<em>固定的arity</em>方法句柄，否则相当于当前的方法句柄。</span>
<p> <span>如果当前方法句柄不是<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a> ，则返回当前方法句柄。</span> <span>即使当前方法句柄不能是<code>asVarargsCollector</code>的有效输入， <code>asVarargsCollector</code> 。</span> </p>
<p> <span>否则，所得到的固定方法句柄具有与当前方法句柄相同的类型和行为，但<a href="../../../java/lang/invoke/MethodHandle.html#isVarargsCollector--"><code>isVarargsCollector</code></a>将为false。</span> <span>固定方法句柄可能（或可能不）是<code>asVarargsCollector</code>的先前参数。</span> </p>
<p> <span>这是一个例子，一个列表制作变量arity方法句柄：</span> </p>
<blockquote>
<span><pre><code>
MethodHandle asListVar = publicLookup()
  .findStatic(Arrays.class, "asList", methodType(List.class, Object[].class))
  .asVarargsCollector(Object[].class);
MethodHandle asListFix = asListVar.asFixedArity();
assertEquals("[1]", asListVar.invoke(1).toString());
Exception caught = null;
try { asListFix.invoke((Object)1); }
catch (Exception ex) { caught = ex; }
assert(caught instanceof ClassCastException);
assertEquals("[two, too]", asListVar.invoke("two", "too").toString());
try { asListFix.invoke("two", "too"); }
catch (Exception ex) { caught = ex; }
assert(caught instanceof WrongMethodTypeException);
Object[] argv = { "three", "thee", "tee" };
assertEquals("[three, thee, tee]", asListVar.invoke(argv).toString());
assertEquals("[three, thee, tee]", asListFix.invoke(argv).toString());
assertEquals(1, ((List) asListVar.invoke((Object)argv)).size());
assertEquals("[three, thee, tee]", asListFix.invoke((Object)argv).toString());
 </code></pre></span>
</blockquote>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个只接受固定数量参数的新方法句柄 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-"><code>asVarargsCollector(java.lang.Class&lt;?&gt;)</code></a> ， 
            <a href="../../../java/lang/invoke/MethodHandle.html#isVarargsCollector--"><code>isVarargsCollector()</code></a>
</dd>
</dl> </li>
</ul> <a name="bindTo-java.lang.Object-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>bindTo</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> bindTo(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> x)</pre>
<div class="block">
<span>将值<code>x</code>绑定到方法句柄的第一个参数，而不调用它。</span>
<span>新的方法句柄通过将其绑定到给定的参数来适配当前方法句柄作为其<i>目标</i> 。</span>
<span>绑定句柄的类型将与目标的类型相同，不同之处在于单个引用参考参数将被省略。</span>
<p> <span>当被调用时，绑定的句柄将给定的值<code>x</code>作为新的引导参数插入目标。</span> <span>其他论点也不变。</span> <span>目标最终返回的结果由绑定句柄返回。</span> </p>
<p> <span>参考号<code>x</code>必须可转换为目标的第一个参数类型。</span> </p>
<p> <span>（ <em>注意：</em>由于方法句柄是不可变的，所以目标方法句柄保留其原始类型和行为。）</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>x</code> - 绑定到目标的第一个参数的值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个新的方法句柄，在调用原始方法句柄之前，将给定值添加到传入参数列表 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果目标不具有引用类型的引导参数类型 
           </dd>
<dd>
<code><a href="../../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果 
            <code>x</code>无法转换为目标的引导参数类型 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/invoke/MethodHandles.html#insertArguments-java.lang.invoke.MethodHandle-int-java.lang.Object...-"><code>MethodHandles.insertArguments(java.lang.invoke.MethodHandle, int, java.lang.Object...)</code></a>
</dd>
</dl> </li>
</ul> <a name="toString--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>toString</h4> <pre>public <a href="../../../java/lang/String.html" title="class in java.lang">String</a> toString()</pre>
<div class="block">
<span>返回方法句柄的字符串表示<code>"MethodHandle"</code> ，以字符串"MethodHandle"开始，以方法句柄类型的字符串表示<code>"MethodHandle"</code>结束。</span>
<span>换句话说，这个方法返回一个等于下列值的字符串：</span>
<blockquote>
<span><pre><code>
 "MethodHandle" + type().toString()
 </code></pre></span>
</blockquote>
<p> <span>（ <em>注意：</em>此API的未来版本可能会向字符串表示形式添加更多信息，因此，本语法不应由应用程序解析。）</span> </p>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../../java/lang/Object.html#toString--">toString</a></code>在类别 
            <code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             a string representation of the method handle 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>