<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.lang.invoke 
   </div>
<h2 class="title" title="Class MethodHandles">Class MethodHandles</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.lang.invoke.MethodHandles</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre>public class <span class="typeNameLabel">MethodHandles</span>
extends <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></pre>
<div class="block">
<span>该类仅由静态方法组成，或者返回方法句柄。</span>
<span>它们分为几类：</span>
<ul>
<li> <span>有助于创建方法和字段的方法句柄的查找方法。</span> </li>
<li> <span>组合方法，将预先存在的方法句柄组合或转换为新的方法。</span> </li>
<li> <span>其他工厂方法来创建方法句柄来模拟其他常见的JVM操作或控制流模式。</span> </li>
</ul>
<p></p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.7 
       </dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!-- --> </a> <h3>Nested Class Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption>
<span>Nested Classes</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Class and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></span></code>
<div class="block">
<em>查找对象</em>是创建方法句柄的工厂，当创建需要访问检查时。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t1"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#arrayElementGetter-java.lang.Class-">arrayElementGetter</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; arrayClass)</code>
<div class="block">
              产生方法句柄，提供对数组元素的读取访问。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#arrayElementSetter-java.lang.Class-">arrayElementSetter</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; arrayClass)</code>
<div class="block">
              生成方法句柄，为数组的元素提供写访问权限。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#catchException-java.lang.invoke.MethodHandle-java.lang.Class-java.lang.invoke.MethodHandle-">catchException</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;? extends <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a>&gt; exType, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> handler)</code>
<div class="block">
              通过在异常处理程序中运行它来创建适应目标方法句柄的方法句柄。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#collectArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle-">collectArguments</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target, int pos, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> filter)</code>
<div class="block">
              通过使用过滤器（另一种方法句柄）预处理其参数的子序列来适应目标方法句柄。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#constant-java.lang.Class-java.lang.Object-">constant</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; type, <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> value)</code>
<div class="block">
              生成请求的返回类型的方法句柄，每次调用时返回给定的常量值。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.lang.Class...-">dropArguments</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target, int pos, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;... valueTypes)</code>
<div class="block">
              生成方法句柄，在调用其他 
             <i>指定的</i>方法句柄之前，将抛弃一些虚拟参数。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-">dropArguments</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target, int pos, <a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&gt; valueTypes)</code>
<div class="block">
              生成方法句柄，在调用其他 
             <i>指定的</i>方法句柄之前，将抛弃一些虚拟参数。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#exactInvoker-java.lang.invoke.MethodType-">exactInvoker</a></span>(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> type)</code>
<div class="block">
              生成一个特殊的 
             <em>调用方法句柄</em> ，可以用来调用给定类型的任何方法句柄，就像 
             <a href="../../../java/lang/invoke/MethodHandle.html#invokeExact-java.lang.Object...-"><code>invokeExact</code>一样</a> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#explicitCastArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-">explicitCastArguments</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target, <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> newType)</code>
<div class="block">
              生成方法句柄，通过成对参数和返回类型转换将给定方法句柄的类型适配为新类型。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#filterArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle...-">filterArguments</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target, int pos, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>... filters)</code>
<div class="block">
              通过预处理其一个或多个参数来适应目标方法句柄，每个参数具有自己的一元过滤器函数，然后使用每个预处理的参数替换为相应过滤器函数的结果来调用目标。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#filterReturnValue-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">filterReturnValue</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> filter)</code>
<div class="block">
              通过使用过滤器（另一种方法句柄）对其返回值（如果有的话）进行后处理来适应目标方法句柄。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#foldArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">foldArguments</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> combiner)</code>
<div class="block">
              通过预处理一些参数来适应目标方法句柄，然后调用具有预处理结果的目标，插入到原始的参数序列中。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">guardWithTest</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> test, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> fallback)</code>
<div class="block">
              使用方法句柄来调整目标方法句柄，通过用测试保护它，一个布尔值方法句柄。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#identity-java.lang.Class-">identity</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; type)</code>
<div class="block">
              生成方法句柄，在调用时返回其唯一参数。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#insertArguments-java.lang.invoke.MethodHandle-int-java.lang.Object...-">insertArguments</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target, int pos, <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>... values)</code>
<div class="block">
              在方法句柄的调用之前提供一个具有一个或多个 
             <em>绑定参数</em>的目标方法句柄。 
            </div> </td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#invoker-java.lang.invoke.MethodType-">invoker</a></span>(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> type)</code>
<div class="block">
              生成一个特殊的 
             <em>调用方法句柄</em> ，可以用来调用与给定类型兼容的任何方法句柄，就像 
             <a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code>一样</a> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#lookup--">lookup</a></span>()</code>
<div class="block">
<span>返回<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class java.lang.invoke"><code>lookup object</code></a>全功能模拟来电的所有受支持字节码的行为。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#permuteArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-int...-">permuteArguments</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target, <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> newType, int... reorder)</code>
<div class="block">
              生成方法句柄，通过重新排序参数，将方法句柄调整到新类型的调用顺序。 
            </div> </td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#publicLookup--">publicLookup</a></span>()</code>
<div class="block">
<span>返回<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class java.lang.invoke"><code>lookup object</code></a>这是可信的最低限度。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>static &lt;T extends <a href="../../../java/lang/reflect/Member.html" title="interface in java.lang.reflect">Member</a>&gt;<br/>T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#reflectAs-java.lang.Class-java.lang.invoke.MethodHandle-">reflectAs</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;T&gt; expected, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target)</code>
<div class="block">
              执行的一个未经检查的“裂纹” 
             <a href="MethodHandleInfo.html#directmh">direct method handle</a> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#spreadInvoker-java.lang.invoke.MethodType-int-">spreadInvoker</a></span>(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> type, int leadingArgCount)</code>
<div class="block">
              产生一个方法句柄，它将调用给定的 
             <code>type</code>任何方法句柄，给定数量的尾随参数被一个 
             <code>Object[]</code>数组替换。 
            </div> </td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#throwException-java.lang.Class-java.lang.Class-">throwException</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; returnType, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;? extends <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a>&gt; exType)</code>
<div class="block">
              产生一个方法句柄，它会抛出给定的 
             <code>exType</code> 。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#toString--">toString</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="lookup--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>lookup</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a> lookup()</pre>
<div class="block">
<span>返回<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class java.lang.invoke"><code>lookup object</code></a>全功能模拟来电的所有受支持字节码的行为。</span>
<span>这些功能包括<a href="MethodHandles.Lookup.html#privacc">呼叫者的private access</a> 。</span>
<span>查找对象上的工厂方法可以为调用者通过字节码（包括受保护和私有字段和方法）访问的任何成员创建<a href="MethodHandleInfo.html#directmh">direct method handles</a> 。</span>
<span>该查找对象是可以被委托给可信代理的<em>能力</em> 。</span>
<span>不要将其存储在不受信任的代码可以访问的位置。</span>
<p> <span>这种方法是调用者敏感的，这意味着它可能会向不同的呼叫者返回不同的值。</span> </p>
<p> <span>对于任何给定的呼叫者类别<code>C</code> ，此调用返回的查找对象具有与JVM提供的任何查找对象相同的<a href="package-summary.html#indyinsn">能力，</a>以便在同一个呼叫者类别<code>C</code>中执行的<a href="package-summary.html#indyinsn">invokedynamic instruction</a>的引导方法。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个用于此方法的调用者的查找对象，具有私有访问权限 
           </dd>
</dl> </li>
</ul> <a name="publicLookup--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>publicLookup</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a> publicLookup()</pre>
<div class="block">
<span>返回<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class java.lang.invoke"><code>lookup object</code></a>这是可信的最低限度。</span>
<span>它只能用于创建可公开访问的字段和方法的方法句柄。</span>
<p> <span>作为纯粹的习惯问题，在<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupClass">lookup class</a>此查询的对象将是<a href="../../../java/lang/Object.html" title="java.lang中的类"><code>Object</code></a> 。</span> </p>
<p style="font-size:smaller;"> <span><em>讨论：</em>该查找类可以被改变为任何其他类<code>C</code>使用形式的表达<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#in-java.lang.Class-"><code>publicLookup().in(C.class)</code></a> 。</span> <span>由于所有类都具有公共名称的平等访问权限，所以这种更改将不会赋予新的访问权限。</span> <span>公共查找对象总是受到<a href="MethodHandles.Lookup.html#secmgr">security manager checks的约束</a> 。</span> <span>此外，它不能访问<a href="MethodHandles.Lookup.html#callsens">caller sensitive methods</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个可信赖的查找对象 
           </dd>
</dl> </li>
</ul> <a name="reflectAs-java.lang.Class-java.lang.invoke.MethodHandle-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>reflectAs</h4> <pre>public static &lt;T extends <a href="../../../java/lang/reflect/Member.html" title="interface in java.lang.reflect">Member</a>&gt; T reflectAs(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;T&gt; expected,
                                             <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target)</pre>
<div class="block">
<span>执行的一个未经检查的“裂纹” <a href="MethodHandleInfo.html#directmh">direct method handle</a> 。</span>
<span>结果就好像用户已经获得了足够能够破解目标方法句柄的查找对象，称为<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#revealDirect-java.lang.invoke.MethodHandle-">目标</a>上的<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#revealDirect-java.lang.invoke.MethodHandle-"><code>Lookup.revealDirect</code></a>以获取其符号引用，然后调用<a href="../../../java/lang/invoke/MethodHandleInfo.html#reflectAs-java.lang.Class-java.lang.invoke.MethodHandles.Lookup-"><code>MethodHandleInfo.reflectAs</code></a>来解析对成员的符号引用。</span>
<p> <span>如果有一个安全管理员，它的<code>checkPermission</code>方法被调用一个<code>ReflectPermission("suppressAccessChecks")</code>权限。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<span><code>T</code> - 所需类型的结果， <a href="../../../java/lang/reflect/Member.html" title="java.lang.reflect中的接口"><code>Member</code></a>或子类型</span>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>target</code> - 一个直接的方法手柄来破解符号参考组件 
           </dd>
<dd>
<code>expected</code> - 表示所需结果类型 
            <code>T</code>的类对象 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             对方法，构造函数或字段对象的引用 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果呼叫者没有权限呼叫 
            <code>setAccessible</code>
</dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数是 
            <code>null</code>
</dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果目标不是一个直接的方法句柄 
           </dd>
<dd>
<code><a href="../../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果该成员不是预期类型 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="arrayElementGetter-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>arrayElementGetter</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> arrayElementGetter(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; arrayClass)
                                       throws <a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></pre>
<div class="block">
<span>产生方法句柄，提供对数组元素的读取访问。</span>
<span>方法句柄的类型将具有数组的元素类型的返回类型。</span>
<span>它的第一个参数是数组类型，第二个参数将是<code>int</code> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>arrayClass</code> - 数组类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个方法句柄，可以从给定的数组类型加载值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为空 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果arrayClass不是数组类型 
           </dd>
</dl> </li>
</ul> <a name="arrayElementSetter-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>arrayElementSetter</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> arrayElementSetter(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; arrayClass)
                                       throws <a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></pre>
<div class="block">
<span>生成方法句柄，为数组的元素提供写访问权限。</span>
<span>方法句柄的类型将具有void返回类型。</span>
<span>它的最后一个参数将是数组的元素类型。</span>
<span>第一个和第二个参数将是数组类型和int。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>arrayClass</code> - 数组的类 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个可以将值存储到数组类型中的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为空 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果arrayClass不是数组类型 
           </dd>
</dl> </li>
</ul> <a name="spreadInvoker-java.lang.invoke.MethodType-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>spreadInvoker</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> spreadInvoker(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> type,
                                         int leadingArgCount)</pre>
<div class="block">
<span>产生一个方法句柄，它将调用给定的<code>type</code>任何方法句柄，给定数量的尾随参数被一个<code>Object[]</code>数组替换。</span>
<span>生成的调用者将是一个方法句柄，其中包含以下参数：</span>
<ul>
<li> <span>一个单一的<code>MethodHandle</code>目标</span> </li>
<li> <span>零个或多个领先价值（按<code>leadingArgCount</code>计算）</span> </li>
<li> <span>一个包含尾随参数的<code>Object[]</code>数组</span> </li>
</ul>
<p> <span>调用者将调用其目标，就像拨打<a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>一样， <a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-">标</a>有<code>type</code> 。</span> <span>也就是说，如果目标是给定的<code>type</code> ，它的行为就像<code>invokeExact</code> ;</span> <span>否则它的行为就好像<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code></a>用于将目标转换为所需的<code>type</code> 。</span> </p>
<p> <span>返回的调用者的类型不会是给定的<code>type</code> ，而是除了第一个<code>leadingArgCount</code>之外的所有<code>leadingArgCount</code>替换为<code>Object[]</code>类型的单个数组，这将是最终的参数。</span> </p>
<p> <span>在调用其目标之前，调用者将传播最终的数组，根据需要应用引用转换，并解开并扩展原始参数。</span> <span>如果调用调用者时，提供的数组参数没有正确数量的元素，调用者将抛出一个<a href="../../../java/lang/IllegalArgumentException.html" title="java.lang中的类"><code>IllegalArgumentException</code></a>而不是调用目标。</span> </p>
<p> <span>此方法等同于以下代码（尽管可能更有效）：</span> </p>
<blockquote>
<span><pre><code>
MethodHandle invoker = MethodHandles.invoker(type);
int spreadArgCount = type.parameterCount() - leadingArgCount;
invoker = invoker.asSpreader(Object[].class, spreadArgCount);
return invoker;
 </code></pre></span>
</blockquote>
<span>此方法不会引发反思或安全异常。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>type</code> - 所需的目标类型 
           </dd>
<dd>
<code>leadingArgCount</code> - 固定参数的数量，不变地传递给目标 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             适用于调用给定类型的任何方法句柄的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>type</code>为空 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>leadingArgCount</code>不在0到 
            <code>type.parameterCount()</code>之间，或者如果结果方法句柄的类型将具有 
            <a href="MethodHandle.html#maxarity">too many parameters</a>
</dd>
</dl> </li>
</ul> <a name="exactInvoker-java.lang.invoke.MethodType-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>exactInvoker</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> exactInvoker(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> type)</pre>
<div class="block">
<span>产生一个特殊的<em>调用方法句柄</em> ，可以用来调用给定类型的任何方法句柄，就像<a href="../../../java/lang/invoke/MethodHandle.html#invokeExact-java.lang.Object...-"><code>invokeExact</code>一样</a> 。</span>
<span>将得到的调用器将有一个类型，其正好等于所期望的类型，不同之处在于它将接受类型的附加参数领先<code>MethodHandle</code> 。</span>
<p> <span>此方法相当于以下代码（尽管可能更有效）： <code>publicLookup().findVirtual(MethodHandle.class, "invokeExact", type)</code></span> </p>
<p style="font-size:smaller;"> <span><em>讨论：</em>当使用未知类型的变量方法句柄时，Invoker方法句柄可能很有用。</span> <span>例如，为了模拟一个<code>invokeExact</code>呼叫给一个变量的方法处理<code>M</code> ，提取其类型<code>T</code> ，查找该调用方法<code>X</code>为<code>T</code> ，并调用调用方法，如<code>X.invoke(T, A...)</code> 。</span> <span>（调用<code>X.invokeExact</code> ，因为<code>T</code>类型是未知的）。如果需要扩展，收集或其他参数转换，则可以将它们应用于调用者<code>X</code>一次， <code>X</code>用于许多<code>M</code>方法句柄值，只要它们与X的类型<code>X</code> 。</span> </p>
<p style="font-size:smaller;"> <span><em>（注意：Invokeer方法不能通过Core Reflection API获得，尝试在声明的<code>invokeExact</code>或<code>invoke</code>方法上调用<a href="../../../java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-">java.lang.reflect.Method.invoke</a>将提升<a href="../../../java/lang/UnsupportedOperationException.html" title="java.lang中的类"><code>UnsupportedOperationException</code></a> ））</em></span> </p>
<p> <span>此方法不会引发反思或安全异常。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>type</code> - 所需的目标类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             适用于调用给定类型的任何方法句柄的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果结果方法句柄的类型将具有 
            <a href="MethodHandle.html#maxarity">too many parameters</a>
</dd>
</dl> </li>
</ul> <a name="invoker-java.lang.invoke.MethodType-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>invoker</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> invoker(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> type)</pre>
<div class="block">
<span>生成一个特殊的<em>调用方法句柄</em> ，可以用来调用与给定类型兼容的任何方法句柄，就像<a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code>一样</a> 。</span>
<span>将得到的调用器将有一个类型，其正好等于所期望的类型，不同之处在于它将接受类型的附加参数领先<code>MethodHandle</code> 。</span>
<p> <span>在调用其目标之前，如果目标与预期类型不同，则调用者将根据需要应用引用转换，并使用box，unbox或者扩展原始值，如<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code>所示</a> 。</span> <span>类似地，返回值将根据需要进行转换。</span> <span>如果目标是<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity method handle</a> ，则将进行所需的转换，再次如<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code>那样</a> 。</span> </p>
<p> <span>此方法等同于以下代码（尽管可能更有效）： <code>publicLookup().findVirtual(MethodHandle.class, "invoke", type)</code></span> </p>
<p style="font-size:smaller;"> <span><em>讨论：</em>一个<a href="../../../java/lang/invoke/MethodType.html#genericMethodType-int-boolean-">general method type</a>是一个仅提到<code>Object</code>参数和返回值。</span> <span>这种类型的调用者能够调用与一般类型相同的任何方法句柄。</span> </p>
<p style="font-size:smaller;"> <span><em>（注意：Invokeer方法不能通过Core Reflection API使用。尝试在声明的<code>invokeExact</code>或<code>invoke</code>方法上调用<a href="../../../java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-">java.lang.reflect.Method.invoke</a>将提升<a href="../../../java/lang/UnsupportedOperationException.html" title="java.lang中的类"><code>UnsupportedOperationException</code></a> ）</em></span> </p>
<p> <span>此方法不会引发反思或安全异常。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>type</code> - 所需的目标类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             适用于调用可转换为给定类型的任何方法句柄的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果结果方法句柄的类型将具有 
            <a href="MethodHandle.html#maxarity">too many parameters</a>
</dd>
</dl> </li>
</ul> <a name="explicitCastArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>explicitCastArguments</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> explicitCastArguments(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target,
                                                 <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> newType)</pre>
<div class="block">
<span>生成方法句柄，通过成对参数和返回类型转换将给定方法句柄的类型适配为新类型。</span>
<span>原始类型和新类型必须具有相同数量的参数。</span>
<span>生成的方法句柄保证报告一个等于所需新类型的类型。</span>
<p> <span>如果原始类型和新类型相等，则返回目标。</span> </p>
<p> <span>对于<code>MethodHandle.asType</code>，允许使用相同的<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-">转换</a> ，如果转换失败，还会应用一些额外的转换。</span> <span>给定类型<em>T0</em> ， <em>T1</em> ，如果可能，应用以下转换之一，之前或代替asType完成的任何<code>asType</code> ：</span> </p>
<ul>
<li> <span>如果<em>T0</em>和<em>T1</em>是引用，并且<em>T1</em>是接口类型，则类型<em>T0</em>的值作为<em>T1</em>传递而不进行转换。</span> <span>（这种接口的处理遵循字节码验证器的使用。）</span> </li>
<li> <span>如果<em>T0</em>是布尔值， <em>T1</em>是另一个原语，则布尔值转换为字节值，1为真，0为false。</span> <span>（此处理遵循字节码验证器的使用。）</span> </li>
<li> <span>如果<em>T1</em>是布尔值， <em>T0</em>是另一个原语，则通过Java转换（JLS 5.5）将<em>T0</em>转换为字节，并测试结果的低位，如<code>(x &amp; 1) != 0</code> 。</span> </li>
<li> <span>如果<em>T0</em>和<em>T1</em>是除布尔值之外的基元，则应用Java转换（JLS 5.5）。</span> <span>（具体来说， <em>T0</em>将通过加宽和/或变窄而转换为<em>T1</em> ）</span> </li>
<li> <span>如果<em>T0</em>是引用， <em>T1</em>是原语，则在运行时将应用拆箱转换，可能之后是对原始值进行Java转换（JLS 5.5），之后可以通过测试低阶转换为字节到布尔位。</span> </li>
<li> <span>如果<em>T0</em>是引用， <em>T1</em>是一个原语，并且如果引用在运行时为空，则引入零值。</span> </li>
</ul>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>target</code> - 在参数之后调用的方法句柄被重新输入 
           </dd>
<dd>
<code>newType</code> - 新方法句柄的预期类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             在执行任何必要的参数转换后委托给目标的方法句柄，并排列任何必要的返回值转换 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为空 
           </dd>
<dd>
<code><a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果不能进行转换 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>MethodHandle.asType(java.lang.invoke.MethodType)</code></a>
</dd>
</dl> </li>
</ul> <a name="permuteArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-int...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>permuteArguments</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> permuteArguments(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target,
                                            <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a> newType,
                                            int... reorder)</pre>
<div class="block">
<span>生成方法句柄，通过重新排序参数，将方法句柄调整到新类型的调用顺序。</span>
<span>生成的方法句柄保证报告一个等于所需新类型的类型。</span>
<p> <span>给定的数组控制重新排序。</span> <span>拨打<code>#I</code>输入参数（值为<code>newType.parameterCount()</code> ，并拨出<code>#O</code>输出参数数值（值<code>target.type().parameterCount()</code> ），然后重排序数组的长度必须为<code>#O</code> ，每个元素必须为非负数小于<code>#I</code>对于每<code>N</code>小于<code>#O</code> ，所述<code>N</code>个传出参数将被从所拍摄的<code>I</code>个传入的参数，其中<code>I</code>是<code>reorder[N]</code> 。</span> </p>
<p> <span>不应用参数或返回值转换。</span> <span>由<code>newType</code>确定的每个传入参数的类型必须与目标方法句柄中对应的传出参数或参数的类型相同。</span> <span><code>newType</code>的返回类型必须与原始目标的返回类型相同。</span> </p>
<p> <span>重排序数组不需要指定实际的排列。</span> <span>如果其索引在数组中出现多次，则传入参数将被重复，如果引用参数的索引未出现在数组中，则引入参数将被删除。</span> <span>如<a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-"><code>dropArguments</code></a>的情况，在排序数组中未提及的传入参数可以是任何类型，仅由<code>newType</code> 。</span> </p>
<blockquote>
<span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodType intfn1 = methodType(int.class, int.class);
MethodType intfn2 = methodType(int.class, int.class, int.class);
MethodHandle sub = ... (int x, int y) -&gt; (x-y) ...;
assert(sub.type().equals(intfn2));
MethodHandle sub1 = permuteArguments(sub, intfn2, 0, 1);
MethodHandle rsub = permuteArguments(sub, intfn2, 1, 0);
assert((int)rsub.invokeExact(1, 100) == 99);
MethodHandle add = ... (int x, int y) -&gt; (x+y) ...;
assert(add.type().equals(intfn2));
MethodHandle twice = permuteArguments(add, intfn1, 0, 0);
assert(twice.type().equals(intfn1));
assert((int)twice.invokeExact(21) == 42);
 </code></pre></span>
</blockquote>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>target</code> - 在参数之后调用的方法句柄被重新排序 
           </dd>
<dd>
<code>newType</code> - 新方法句柄的预期类型 
           </dd>
<dd>
<code>reorder</code> - 控制重新排序的索引数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个方法句柄，它在它删除未使用的参数并移动和/或复制其他参数之后委托给目标 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为空 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果索引数组长度不等于目标的arity，或者如果索引数组元素不是newType的 
            <code>newType</code>的有效索引，或者如果 
            <code>target.type()</code>和 
            <code>newType</code>中的两个对应的参数类型不相同， 
           </dd>
</dl> </li>
</ul> <a name="constant-java.lang.Class-java.lang.Object-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>constant</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> constant(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; type,
                                    <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> value)</pre>
<div class="block">
<span>生成请求的返回类型的方法句柄，每次调用时返回给定的常量值。</span>
<p> <span>在返回方法句柄之前，将传入值转换为请求的类型。</span> <span>如果请求的类型是原始的，则尝试扩大原始转换，否则尝试参考转换。</span> </p>
<p> <span>返回的方法句柄相当于<code>identity(type).bindTo(value)</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>type</code> - 所需方法句柄的返回类型 
           </dd>
<dd>
<code>value</code> - 要返回的值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             给定返回类型的方法句柄，并且没有参数，它始终返回给定的值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>type</code>参数为空 
           </dd>
<dd>
<code><a href="../../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果该值无法转换为所需的返回类型 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果给定的类型是 
            <code>void.class</code>
</dd>
</dl> </li>
</ul> <a name="identity-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>identity</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> identity(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; type)</pre>
<div class="block">
            生成方法句柄，在调用时返回其唯一参数。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>type</code> - 唯一参数的类型和所需方法句柄的返回值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             接受并返回给定类型的一元方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为空 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果给定类型是 
            <code>void.class</code>
</dd>
</dl> </li>
</ul> <a name="insertArguments-java.lang.invoke.MethodHandle-int-java.lang.Object...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>insertArguments</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> insertArguments(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target,
                                           int pos,
                                           <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>... values)</pre>
<div class="block">
<span>在方法句柄的调用之前提供一个具有一个或多个<em>绑定参数</em>的目标方法句柄。</span>
<span>对应于绑定参数的目标的形式参数称为<em>绑定参数</em> 。</span>
<span>返回一个新的方法句柄，可以省去绑定的参数。</span>
<span>当它被调用时，它会接收任何非绑定参数的参数，将保存的参数绑定到其对应的参数，并调用原始目标。</span>
<p> <span>新方法句柄的类型将从原始目标类型中删除绑定参数的类型，因为新方法句柄将不再需要这些参数由其调用者提供。</span> </p>
<p> <span>每个给定的参数对象必须匹配相应的绑定参数类型。</span> <span>如果绑定的参数类型是一个原语，则参数对象必须是包装器，并且将被取消装箱以产生原始值。</span> </p>
<p> <span><code>pos</code>参数选择要绑定的参数。</span> <span>它可以在零和<i>NL</i>之间（包括），其中<i>N</i>是目标方法句柄的粗细， <i>L</i>是值数组的长度。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>target</code> - 插入参数后调用的方法句柄 
           </dd>
<dd>
<code>pos</code> - 在哪里插入参数（第一个为零） 
           </dd>
<dd>
<code>values</code> - 插入的一系列参数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             在调用原始方法句柄之前插入附加参数的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果目标或 
            <code>values</code>数组为空 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/invoke/MethodHandle.html#bindTo-java.lang.Object-"><code>MethodHandle.bindTo(java.lang.Object)</code></a>
</dd>
</dl> </li>
</ul> <a name="dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>dropArguments</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> dropArguments(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target,
                                         int pos,
                                         <a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&gt; valueTypes)</pre>
<div class="block">
<span>生成方法句柄，在调用其他<i>指定的</i>方法句柄之前，将抛弃一些虚拟参数。</span>
<span>新方法句柄的类型将与目标类型相同，但在某些给定位置，它也包括虚拟参数类型。</span>
<p> <span><code>pos</code>参数可以介于零和<i>N</i>之间，其中<i>N</i>是目标的<code>pos</code> 。</span> <span>如果<code>pos</code>为零，则虚拟参数将在目标的实参之前;</span> <span>如果<code>pos</code>是<i>N，</i>他们会后来。</span> </p>
<p> <span><b>例：</b></span> </p>
<blockquote>
<span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
assertEquals("xy", (String) cat.invokeExact("x", "y"));
MethodType bigType = cat.type().insertParameterTypes(0, int.class, String.class);
MethodHandle d0 = dropArguments(cat, 0, bigType.parameterList().subList(0,2));
assertEquals(bigType, d0.type());
assertEquals("yz", (String) d0.invokeExact(123, "x", "y", "z"));
 </code></pre></span>
</blockquote>
<p> <span>此方法也等效于以下代码：</span> </p>
<blockquote>
<span><pre>
 <a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.lang.Class...-"><code>dropArguments</code></a><code> (target, pos, valueTypes.toArray(new Class[0]))</code>
 </pre></span>
</blockquote>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>target</code> - 删除参数后调用的方法句柄 
           </dd>
<dd>
<code>valueTypes</code> - 要删除的参数的类型 
           </dd>
<dd>
<code>pos</code> - 第一个参数的位置（最左边为零） 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个方法句柄，在调用原始方法句柄之前删除给定类型的参数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果目标为空，或者如果 
            <code>valueTypes</code>列表或其任何元素为空 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果任何元素 
            <code>valueTypes</code>是 
            <code>void.class</code> ，或者如果 
            <code>pos</code>比目标的元数负或更大，或者如果新的方法处理的类型将有太多的参数 
           </dd>
</dl> </li>
</ul> <a name="dropArguments-java.lang.invoke.MethodHandle-int-java.lang.Class...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>dropArguments</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> dropArguments(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target,
                                         int pos,
                                         <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;... valueTypes)</pre>
<div class="block">
<span>生成方法句柄，在调用其他<i>指定的</i>方法句柄之前，将抛弃一些虚拟参数。</span>
<span>新方法句柄的类型将与目标类型相同，但在某些给定位置，它也包括虚拟参数类型。</span>
<p> <span><code>pos</code>参数的范围可以在零和<i>N</i>之间，其中<i>N</i>是目标的<code>pos</code> 。</span> <span>如果<code>pos</code>为零，则虚拟参数将在目标的实参之前;</span> <span>如果<code>pos</code>是<i>N，</i>他们会后来。</span> </p>
<p> <span><b>例：</b></span> </p>
<blockquote>
<span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
assertEquals("xy", (String) cat.invokeExact("x", "y"));
MethodHandle d0 = dropArguments(cat, 0, String.class);
assertEquals("yz", (String) d0.invokeExact("x", "y", "z"));
MethodHandle d1 = dropArguments(cat, 1, String.class);
assertEquals("xz", (String) d1.invokeExact("x", "y", "z"));
MethodHandle d2 = dropArguments(cat, 2, String.class);
assertEquals("xy", (String) d2.invokeExact("x", "y", "z"));
MethodHandle d12 = dropArguments(cat, 1, int.class, boolean.class);
assertEquals("xz", (String) d12.invokeExact("x", 12, true, "z"));
 </code></pre></span>
</blockquote>
<p> <span>此方法也等效于以下代码：</span> </p>
<blockquote>
<span><pre>
 <a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-"><code>dropArguments</code></a><code> (target, pos, Arrays.asList(valueTypes))</code>
 </pre></span>
</blockquote>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>target</code> - 删除参数后调用的方法句柄 
           </dd>
<dd>
<code>valueTypes</code> - 要删除的参数的类型 
           </dd>
<dd>
<code>pos</code> - 第一个参数的位置下降（零为最左边） 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个方法句柄，在调用原始方法句柄之前删除给定类型的参数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果目标为null，或者如果 
            <code>valueTypes</code>数组或其任何元素为空 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果任何元素 
            <code>valueTypes</code>是 
            <code>void.class</code> ，或者如果 
            <code>pos</code>比目标的元数负或更大，或者如果新的方法处理的类型将有 
            <a href="MethodHandle.html#maxarity">too many parameters</a>
</dd>
</dl> </li>
</ul> <a name="filterArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>filterArguments</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> filterArguments(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target,
                                           int pos,
                                           <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>... filters)</pre>
<div class="block">
<span>通过预处理其一个或多个参数来适应目标方法句柄，每个参数具有自己的一元过滤器函数，然后使用每个预处理的参数替换为相应过滤器函数的结果来调用目标。</span>
<p> <span>预处理由<code>filters</code>数组的元素中指定的一个或多个方法手柄<code>filters</code> 。</span> <span>过滤器阵列的第一个元素对应于目标的<code>pos</code>参数，依次类推。</span> </p>
<p> <span>数组中的空参数被视为身份函数，相应的参数保持不变。</span> <span>（如果数组中没有非空元素，则返回原始目标。）每个过滤器都应用于适配器的相应参数。</span> </p>
<p> <span>如果过滤器<code>F</code>适用于目标的<code>N</code> th参数，那么<code>F</code>必须是一个方法句柄， <code>F</code>需要一个参数。</span> <span><code>F</code>的唯一参数的类型将替换生成的适应方法句柄中的对象的相应参数类型。</span> <span><code>F</code>的返回类型必须与目标的相应参数类型相同。</span> </p>
<p> <span>如果有<code>filters</code> （null或not）的元素不对应于目标中的参数位置，则是一个错误。</span> </p>
<p> <span><b>例：</b></span> </p>
<blockquote>
<span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
MethodHandle upcase = lookup().findVirtual(String.class,
  "toUpperCase", methodType(String.class));
assertEquals("xy", (String) cat.invokeExact("x", "y"));
MethodHandle f0 = filterArguments(cat, 0, upcase);
assertEquals("Xy", (String) f0.invokeExact("x", "y")); // Xy
MethodHandle f1 = filterArguments(cat, 1, upcase);
assertEquals("xY", (String) f1.invokeExact("x", "y")); // xY
MethodHandle f2 = filterArguments(cat, 0, upcase, upcase);
assertEquals("XY", (String) f2.invokeExact("x", "y")); // XY
 </code></pre></span>
</blockquote>
<p> <span>以下是生成的适配器的伪代码：</span> </p>
<blockquote>
<span><pre><code>
 V target(P... p, A[i]... a[i], B... b);
 A[i] filter[i](V[i]);
 T adapter(P... p, V[i]... v[i], B... b) {
   return target(p..., f[i](v[i])..., b...);
 }
 </code></pre></span>
</blockquote>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>target</code> - 过滤参数后调用的方法句柄 
           </dd>
<dd>
<code>pos</code> - 要过滤的第一个参数的位置 
           </dd>
<dd>
<code>filters</code> - 
            <code>filters</code>调用过滤参数的方法句柄 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             方法句柄包含指定的参数过滤逻辑 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果目标为null或 
            <code>filters</code>数组为空 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code>的非空元素与 
            <code>filters</code>对应的对象参数类型不匹配，或者如果 
            <code>pos+filters.length</code>大于 
            <code>target.type().parameterCount()</code> ，或者如果生成的方法句柄的类型将具有 
            <a href="MethodHandle.html#maxarity">too many parameters</a>
</dd>
</dl> </li>
</ul> <a name="collectArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>collectArguments</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> collectArguments(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target,
                                            int pos,
                                            <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> filter)</pre>
<div class="block">
<span>通过使用过滤器（另一种方法句柄）预处理其参数的子序列来适应目标方法句柄。</span>
<span>预处理参数被过滤器函数的结果（如果有）替换。</span>
<span>然后在修改的（通常缩短的）参数列表上调用目标。</span>
<p> <span>如果过滤器返回一个值，则目标必须接受该值作为其位置<code>pos</code>的参数，在未传递给过滤器的任何参数之前和/或之后。</span> <span>如果过滤器返回void，则目标必须接受所有不传递给过滤器的参数。</span> <span>没有参数被重新排序，并且从过滤器返回的结果替换原来传递给适配器的参数的整个子序列（按顺序）。</span> </p>
<p> <span>过滤器的参数类型（如果有）替换了零或一个参数类型的目标，在位置<code>pos</code> ，在结果调整的方法句柄。</span> <span>过滤器的返回类型（如果有）必须与目标位置<code>pos</code>的参数类型<code>pos</code> ，该目标参数由过滤器的返回值提供。</span> </p>
<p> <span>在所有情况下， <code>pos</code>必须大于或等于零，并且<code>pos</code>也必须小于或等于目标的精度。</span> </p>
<p> <span><b>例：</b></span> </p>
<blockquote>
<span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle deepToString = publicLookup()
  .findStatic(Arrays.class, "deepToString", methodType(String.class, Object[].class));

MethodHandle ts1 = deepToString.asCollector(String[].class, 1);
assertEquals("[strange]", (String) ts1.invokeExact("strange"));

MethodHandle ts2 = deepToString.asCollector(String[].class, 2);
assertEquals("[up, down]", (String) ts2.invokeExact("up", "down"));

MethodHandle ts3 = deepToString.asCollector(String[].class, 3);
MethodHandle ts3_ts2 = collectArguments(ts3, 1, ts2);
assertEquals("[top, [up, down], strange]",
             (String) ts3_ts2.invokeExact("top", "up", "down", "strange"));

MethodHandle ts3_ts2_ts1 = collectArguments(ts3_ts2, 3, ts1);
assertEquals("[top, [up, down], [strange]]",
             (String) ts3_ts2_ts1.invokeExact("top", "up", "down", "strange"));

MethodHandle ts3_ts2_ts3 = collectArguments(ts3_ts2, 1, ts3);
assertEquals("[top, [[up, down, strange], charm], bottom]",
             (String) ts3_ts2_ts3.invokeExact("top", "up", "down", "strange", "charm", "bottom"));
 </code></pre></span>
</blockquote>
<p> <span>以下是生成的适配器的伪代码：</span> </p>
<blockquote>
<span><pre><code>
 T target(A...,V,C...);
 V filter(B...);
 T adapter(A... a,B... b,C... c) {
   V v = filter(b...);
   return target(a...,v,c...);
 }
 // and if the filter has no arguments:
 T target2(A...,V,C...);
 V filter2();
 T adapter2(A... a,C... c) {
   V v = filter2();
   return target2(a...,v,c...);
 }
 // and if the filter has a void return:
 T target3(A...,C...);
 void filter3(B...);
 void adapter3(A... a,B... b,C... c) {
   filter3(b...);
   return target3(a...,c...);
 }
 </code></pre></span>
</blockquote>
<p> <span>收集适配器<code>collectArguments(mh, 0, coll)</code>等效于首先“折叠”受影响的参数，然后将它们分离出来，如下所示：</span> </p>
<blockquote>
<span><pre><code>
 mh = MethodHandles.dropArguments(mh, 1, coll.type().parameterList()); //step 2
 mh = MethodHandles.foldArguments(mh, coll); //step 1
 </code></pre></span>
</blockquote>
<span>如果目标方法句柄除了过滤器<code>coll</code>的结果（如果有的话）以外没有<code>coll</code> ，那么<code>collectArguments(mh, 0, coll)</code>相当于<code>filterReturnValue(coll, mh)</code> 。</span>
<span>如果滤波器方法句柄<code>coll</code>消耗一个参数并产生无效结果，那么<code>collectArguments(mh, N, coll)</code>相当于<code>filterArguments(mh, N, coll)</code> 。</span>
<span>其他等价是可能的，但需要参数置换。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>target</code> - 过滤子参数后的方法句柄 
           </dd>
<dd>
<code>pos</code> - 传递给过滤器的第一个适配器参数的位置和/或接收过滤器结果的目标参数 
           </dd>
<dd>
<code>filter</code> - 方法句柄来调用参数的子序列 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             方法句柄，其包含指定的参数子序列过滤逻辑 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为空 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果的返回类型 
            <code>filter</code>为非空隙和不一样的 
            <code>pos</code>目标的参数，或者如果 
            <code>pos</code>不为0之间以及在目标的元数，包括端值，或者如果产生的方法手柄的类型将具有 
            <a href="MethodHandle.html#maxarity">too many parameters</a>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/invoke/MethodHandles.html#foldArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>foldArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)</code></a> ， 
            <a href="../../../java/lang/invoke/MethodHandles.html#filterArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle...-"><code>filterArguments(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle...)</code></a> ， 
            <a href="../../../java/lang/invoke/MethodHandles.html#filterReturnValue-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>filterReturnValue(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)</code></a>
</dd>
</dl> </li>
</ul> <a name="filterReturnValue-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>filterReturnValue</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> filterReturnValue(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target,
                                             <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> filter)</pre>
<div class="block">
<span>通过使用过滤器（另一种方法句柄）对其返回值（如果有的话）进行后处理来适应目标方法句柄。</span>
<span>从适配器返回过滤器的结果。</span>
<p> <span>如果目标返回值，则过滤器必须接受该值作为其唯一参数。</span> <span>如果目标返回void，则过滤器不能接受参数。</span> </p>
<p> <span>过滤器的返回类型替换生成的适应方法句柄中的目标的返回类型。</span> <span>过滤器的参数类型（如果有）必须与目标的返回类型相同。</span> </p>
<p> <span><b>例：</b></span> </p>
<blockquote>
<span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
MethodHandle length = lookup().findVirtual(String.class,
  "length", methodType(int.class));
System.out.println((String) cat.invokeExact("x", "y")); // xy
MethodHandle f0 = filterReturnValue(cat, length);
System.out.println((int) f0.invokeExact("x", "y")); // 2
 </code></pre></span>
</blockquote>
<p> <span>以下是生成的适配器的伪代码：</span> </p>
<blockquote>
<span><pre><code>
 V target(A...);
 T filter(V);
 T adapter(A... a) {
   V v = target(a...);
   return filter(v);
 }
 // and if the target has a void return:
 void target2(A...);
 T filter2();
 T adapter2(A... a) {
   target2(a...);
   return filter2();
 }
 // and if the filter has a void return:
 V target3(A...);
 void filter3(V);
 void adapter3(A... a) {
   V v = target3(a...);
   filter3(v);
 }
 </code></pre></span>
</blockquote>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>target</code> - 在过滤返回值之前调用的方法句柄 
           </dd>
<dd>
<code>filter</code> - 方法句柄来调用返回值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             方法句柄，其包含指定的返回值过滤逻辑 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为空 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果参数列表 
            <code>filter</code>不匹配目标的返回类型如上所述 
           </dd>
</dl> </li>
</ul> <a name="foldArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>foldArguments</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> foldArguments(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target,
                                         <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> combiner)</pre>
<div class="block">
<span>通过预处理一些参数来适应目标方法句柄，然后调用具有预处理结果的目标，插入到原始的参数序列中。</span>
<p> <span>预处理由<code>combiner</code> ，第二个方法句柄。</span> <span>传递给适配器的参数中，第一个<code>N</code>参数被复制到组合器，然后被调用。</span> <span>（这里， <code>N</code>被定义为组合器的参数计数。）此后，控制传递给目标，任何来自组合器的结果在原始<code>N</code>传入参数之前插入。</span> </p>
<p> <span>如果组合器返回一个值，则目标的第一个参数类型必须与组合器的返回类型相同，并且下一个<code>N</code>参数类型必须与组合器的参数完全匹配。</span> </p>
<p> <span>如果组合<code>N</code>有空值返回，则不会插入任何结果，并且目标的第一个<code>N</code>参数类型必须与组合器的参数完全匹配。</span> </p>
<p> <span>生成的适配器与目标的类型相同，不同之处在于，如果第一个参数类型与组合器的结果相对应，那么它将被删除。</span> </p>
<p> <span>（请注意， <a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-"><code>dropArguments</code></a>可用于删除组合器或目标不希望接收的任何参数。如果某些传入参数仅用于组合器，请考虑使用<a href="../../../java/lang/invoke/MethodHandle.html#asCollector-java.lang.Class-int-"><code>asCollector</code></a> ，因为这些参数不需要生活在堆栈上进入目标。）</span> </p>
<p> <span><b>例：</b></span> </p>
<blockquote>
<span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,
  "println", methodType(void.class, String.class))
    .bindTo(System.out);
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
assertEquals("boojum", (String) cat.invokeExact("boo", "jum"));
MethodHandle catTrace = foldArguments(cat, trace);
// also prints "boo":
assertEquals("boojum", (String) catTrace.invokeExact("boo", "jum"));
 </code></pre></span>
</blockquote>
<p> <span>以下是生成的适配器的伪代码：</span> </p>
<blockquote>
<span><pre><code>
 // there are N arguments in A...
 T target(V, A[N]..., B...);
 V combiner(A...);
 T adapter(A... a, B... b) {
   V v = combiner(a...);
   return target(v, a..., b...);
 }
 // and if the combiner has a void return:
 T target2(A[N]..., B...);
 void combiner2(A...);
 T adapter2(A... a, B... b) {
   combiner2(a...);
   return target2(a..., b...);
 }
 </code></pre></span>
</blockquote>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>target</code> - 组合参数后调用的方法句柄 
           </dd>
<dd>
<code>combiner</code> - 
            <code>combiner</code>调用传入参数的方法句柄 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             包含指定参数折叠逻辑的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为空 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>combiner</code>的返回类型是无效的并且与目标的第一个参数类型不相同，或者如果目标的初始 
            <code>N</code>参数类型（跳过与 
            <code>combiner</code>的返回类型匹配的 
            <code>combiner</code> ）不等同于参数类型为 
            <code>combiner</code>
</dd>
</dl> </li>
</ul> <a name="guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>guardWithTest</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> guardWithTest(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> test,
                                         <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target,
                                         <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> fallback)</pre>
<div class="block">
<span>使用方法句柄来调整目标方法句柄，通过用测试保护它，一个布尔值方法句柄。</span>
<span>如果防守失败，则会调用后备句柄。</span>
<span>所有三个方法句柄必须具有相同的对应参数和返回类型，除了测试的返回类型必须为布尔值，并且允许测试具有比其他两个方法句柄少的参数。</span>
<p> <span>以下是生成的适配器的伪代码：</span> </p>
<blockquote>
<span><pre><code>
 boolean test(A...);
 T target(A...,B...);
 T fallback(A...,B...);
 T adapter(A... a,B... b) {
   if (test(a...))
     return target(a..., b...);
   else
     return fallback(a..., b...);
 }
 </code></pre></span>
</blockquote>
<span>请注意，测试参数（ <code>a...</code>中的a...）无法通过执行测试进行修改，因此根据需要，从调用者不变地传递到目标或后备。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>test</code> - 用于测试的方法句柄，必须返回布尔值 
           </dd>
<dd>
<code>target</code> - 如果测试通过，则调用方法句柄 
           </dd>
<dd>
<code>fallback</code> - 如果测试失败，调用方法句柄 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             方法句柄包含指定的if / then / else逻辑 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为空 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>test</code>不返回布尔值，或者如果所有三种方法类型都不匹配（ 
            <code>test</code>的返回类型更改为匹配目标）。 
           </dd>
</dl> </li>
</ul> <a name="catchException-java.lang.invoke.MethodHandle-java.lang.Class-java.lang.invoke.MethodHandle-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>catchException</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> catchException(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target,
                                          <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;? extends <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a>&gt; exType,
                                          <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> handler)</pre>
<div class="block">
<span>通过在异常处理程序中运行它来创建适应目标方法句柄的方法句柄。</span>
<span>如果目标返回正常，则适配器返回该值。</span>
<span>如果抛出与指定类型匹配的异常，则会在异常时调用回退句柄，再加上原始参数。</span>
<p> <span>目标和处理程序必须具有相同的对应参数和返回类型，但处理程序可能会省略尾随参数（与<code>guardWithTest</code>中的<a href="../../../java/lang/invoke/MethodHandles.html#guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">谓词相似</a> ）。</span> <span>此外，处理程序必须具有额外的前导参数<code>exType</code>或超类型。</span> </p>
<p> <span>以下是生成的适配器的伪代码：</span> </p>
<blockquote>
<span><pre><code>
 T target(A..., B...);
 T handler(ExType, A...);
 T adapter(A... a, B... b) {
   try {
     return target(a..., b...);
   } catch (ExType ex) {
     return handler(ex, a...);
   }
 }
 </code></pre></span>
</blockquote>
<span>请注意，保存的参数（ <code>a...</code>中的a...）无法通过执行目标进行修改，如果调用处理程序，则从调用程序到处理程序的引用也不会被修改。</span>
<p> <span>目标和处理程序必须返回相同的类型，即使处理程序总是抛出。</span> <span>（这可能发生，例如，因为处理程序正在模拟一个<code>finally</code>子句）。</span> <span>要创建这样的抛出处理程序，使用<a href="../../../java/lang/invoke/MethodHandles.html#throwException-java.lang.Class-java.lang.Class-"><code>throwException</code></a>编写处理程序创建逻辑，以创建正确返回类型的方法句柄。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>target</code> - 调用方法句柄 
           </dd>
<dd>
<code>exType</code> - 处理程序将捕获的异常类型 
           </dd>
<dd>
<code>handler</code> - 如果抛出匹配的异常，则调用方法句柄 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             包含指定的try / catch逻辑的方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为空 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>handler</code>不接受给定的异常类型，或者方法句柄类型在其返回类型及其相应参数中不匹配 
           </dd>
</dl> </li>
</ul> <a name="throwException-java.lang.Class-java.lang.Class-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>throwException</h4> <pre>public static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> throwException(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; returnType,
                                          <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;? extends <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a>&gt; exType)</pre>
<div class="block">
<span>产生一个方法句柄，它会抛出给定的<code>exType</code> 。</span>
<span>方法句柄将接受<code>exType</code>的单个参数，并立即将其作为例外。</span>
<span>方法类型将名义上指定返回值为<code>returnType</code> 。</span>
<span>返回类型可能是任何方便的：方法句柄的行为无关紧要，因为它将永远不会正常返回。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>returnType</code> - 所需方法句柄的返回类型 
           </dd>
<dd>
<code>exType</code> - 所需方法句柄的参数类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             方法句柄可以抛出给定的异常 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为空 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>