<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.lang 
   </div>
<h2 class="title" title="Class Thread">Class Thread</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.lang.Thread</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
         All Implemented Interfaces: 
       </dt>
<dd>
<span><a href="../../java/lang/Runnable.html" title="java.lang中的接口">Runnable</a></span>
</dd>
</dl>
<dl>
<dt>
        已知直接子类：
       </dt>
<dd>
<span><a href="../../java/util/concurrent/ForkJoinWorkerThread.html" title="java.util.concurrent中的类">ForkJoinWorkerThread</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public class <span class="typeNameLabel">Thread</span>
extends <a href="../../java/lang/Object.html" title="class in java.lang">Object</a>
implements <a href="../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a></pre>
<div class="block">
<span><i>线程</i>是程序中执行的线程。</span>
<span>Java虚拟机允许应用程序同时执行多个执行线程。</span>
<p> <span>每个线程都有优先权。</span> <span>具有较高优先级的线程优先于优先级较低的线程执行。</span> <span>每个线程可能也可能不会被标记为守护程序。</span> <span>当在某个线程中运行的代码创建一个新的<code>Thread</code>对象时，新线程的优先级最初设置为等于创建线程的优先级，并且当且仅当创建线程是守护进程时才是守护线程。</span> </p>
<p> <span>当Java虚拟机启动时，通常有一个非守护进程线程（通常调用某些指定类的名为<code>main</code>的方法）。</span> <span>Java虚拟机将继续执行线程，直到发生以下任一情况：</span> </p>
<ul>
<li> <span>已经调用了<code>Runtime</code>类的<code>exit</code>方法，并且安全管理器已经允许进行退出操作。</span> </li>
<li> <span>所有不是守护进程线程的线程都已经死亡，无论是从调用返回到<code>run</code>方法还是抛出超出<code>run</code>方法的<code>run</code> 。</span> </li>
</ul>
<p> <span>创建一个新的执行线程有两种方法。</span> <span>一个是将一个类声明为<code>Thread</code>的子类。</span> <span>这个子类应该重写<code>run</code>类的方法<code>Thread</code> 。</span> <span>然后可以分配并启动子类的实例。</span> <span>例如，计算大于规定值的素数的线程可以写成如下：</span> </p>
<hr/>
<blockquote>
<span><pre>
     class PrimeThread extends Thread {
         long minPrime;
         PrimeThread(long minPrime) {
             this.minPrime = minPrime;
         }

         public void run() {
             // compute primes larger than minPrime
              . . .
         }
     }
 </pre></span>
</blockquote>
<hr/>
<p> <span>然后，以下代码将创建一个线程并启动它运行：</span> </p>
<blockquote>
<span><pre>
     PrimeThread p = new PrimeThread(143);
     p.start();
 </pre></span>
</blockquote>
<p> <span>另一种方法来创建一个线程是声明实现类<code>Runnable</code>接口。</span> <span>那个类然后实现了<code>run</code>方法。</span> <span>然后可以分配类的实例，在创建<code>Thread</code>时作为参数传递，并启动。</span> <span>这种其他风格的同一个例子如下所示：</span> </p>
<hr/>
<blockquote>
<span><pre>
     class PrimeRun implements Runnable {
         long minPrime;
         PrimeRun(long minPrime) {
             this.minPrime = minPrime;
         }

         public void run() {
             // compute primes larger than minPrime
              . . .
         }
     }
 </pre></span>
</blockquote>
<hr/>
<p> <span>然后，以下代码将创建一个线程并启动它运行：</span> </p>
<blockquote>
<span><pre>
     PrimeRun p = new PrimeRun(143);
     new Thread(p).start();
 </pre></span>
</blockquote>
<p> <span>每个线程都有一个用于识别目的的名称。</span> <span>多个线程可能具有相同的名称。</span> <span>如果在创建线程时未指定名称，则会为其生成一个新名称。</span> </p>
<p> <span>除非另有说明，否则将<code>null</code>参数传递给<code>null</code>中的构造函数或方法将导致抛出<a href="../../java/lang/NullPointerException.html" title="java.lang中的类"><code>NullPointerException</code></a> 。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         JDK1.0 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/lang/Runnable.html" title="java.lang中的接口"><code>Runnable</code></a> ， <a href="../../java/lang/Runtime.html#exit-int-"><code>Runtime.exit(int)</code></a> ， <a href="../../java/lang/Thread.html#run--"><code>run()</code></a> ， <a href="../../java/lang/Thread.html#stop--"><code>stop()</code></a></span>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!-- --> </a> <h3>Nested Class Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption>
<span>Nested Classes</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Class and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.State.html" title="enum in java.lang">Thread.State</a></span></code>
<div class="block">
              线程状态。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static interface </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.UncaughtExceptionHandler.html" title="interface in java.lang">Thread.UncaughtExceptionHandler</a></span></code>
<div class="block">
              当Thread由于未捕获的异常而突然终止时，处理程序的 
             <tt>接口</tt>被调用。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!-- --> </a> <h3>Field Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Field Summary table, listing fields, and an explanation">
<caption>
<span>Fields</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#MAX_PRIORITY">MAX_PRIORITY</a></span></code>
<div class="block">
              线程可以拥有的最大优先级。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#MIN_PRIORITY">MIN_PRIORITY</a></span></code>
<div class="block">
              线程可以拥有的最小优先级。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#NORM_PRIORITY">NORM_PRIORITY</a></span></code>
<div class="block">
              分配给线程的默认优先级。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!-- --> </a> <h3>构造方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Constructor Summary table, listing constructors, and an explanation">
<caption>
<span>构造方法</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#Thread--">Thread</a></span>()</code>
<div class="block">
              分配一个新的 
             <code>Thread</code>对象。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#Thread-java.lang.Runnable-">Thread</a></span>(<a href="../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> target)</code>
<div class="block">
              分配一个新的 
             <code>Thread</code>对象。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#Thread-java.lang.Runnable-java.lang.String-">Thread</a></span>(<a href="../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> target, <a href="../../java/lang/String.html" title="class in java.lang">String</a> name)</code>
<div class="block">
              分配一个新的 
             <code>Thread</code>对象。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#Thread-java.lang.String-">Thread</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name)</code>
<div class="block">
              分配一个新的 
             <code>Thread</code>对象。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#Thread-java.lang.ThreadGroup-java.lang.Runnable-">Thread</a></span>(<a href="../../java/lang/ThreadGroup.html" title="class in java.lang">ThreadGroup</a> group, <a href="../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> target)</code>
<div class="block">
              分配一个新的 
             <code>Thread</code>对象。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-">Thread</a></span>(<a href="../../java/lang/ThreadGroup.html" title="class in java.lang">ThreadGroup</a> group, <a href="../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> target, <a href="../../java/lang/String.html" title="class in java.lang">String</a> name)</code>
<div class="block">
              分配一个新的 
             <code>Thread</code>对象，使其具有 
             <code>target</code>作为其运行对象，具有指定的 
             <code>name</code>作为其名称，属于 
             <code>group</code>引用的线程组。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-long-">Thread</a></span>(<a href="../../java/lang/ThreadGroup.html" title="class in java.lang">ThreadGroup</a> group, <a href="../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> target, <a href="../../java/lang/String.html" title="class in java.lang">String</a> name, long stackSize)</code>
<div class="block">
              分配一个新的 
             <code>Thread</code>对象，以便它具有 
             <code>target</code>作为其运行对象，将指定的 
             <code>name</code>正如其名，以及属于该线程组由称作 
             <code>group</code> ，并具有指定的 
             <i>堆栈大小</i> 。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#Thread-java.lang.ThreadGroup-java.lang.String-">Thread</a></span>(<a href="../../java/lang/ThreadGroup.html" title="class in java.lang">ThreadGroup</a> group, <a href="../../java/lang/String.html" title="class in java.lang">String</a> name)</code>
<div class="block">
              分配一个新的 
             <code>Thread</code>对象。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t1"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t6"><span><a href="javascript:show(32);">弃用的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#activeCount--">activeCount</a></span>()</code>
<div class="block">
<span>返回当前线程的<a href="../../java/lang/ThreadGroup.html" title="java.lang中的类">thread group</a>及其子组中活动线程数的估计。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#checkAccess--">checkAccess</a></span>()</code>
<div class="block">
              确定当前正在运行的线程是否有权限修改此线程。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>protected <a href="../../java/lang/Object.html" title="class in java.lang">Object</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#clone--">clone</a></span>()</code>
<div class="block">
              将CloneNotSupportedException作为线程抛出无法有意义地克隆。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#countStackFrames--">countStackFrames</a></span>()</code>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<div class="block">
<span><span class="deprecationComment">此呼叫的定义取决于<a href="../../java/lang/Thread.html#suspend--"><code>suspend()</code></a> ，它已被弃用。</span></span>
<span><span class="deprecationComment">此外，此呼叫的结果从未明确。</span></span>
</div>
</div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>static <a href="../../java/lang/Thread.html" title="class in java.lang">Thread</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#currentThread--">currentThread</a></span>()</code>
<div class="block">
              返回对当前正在执行的线程对象的引用。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#destroy--">destroy</a></span>()</code>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<div class="block">
<span><span class="deprecationComment">这种方法最初是为了销毁这个线程而没有任何清理。</span></span>
<span><span class="deprecationComment">它所持有的任何监视器都将保持锁定。</span></span>
<span><span class="deprecationComment">但是，该方法从未实现。</span></span>
<span><span class="deprecationComment">如果要实施，那么它将是<a href="../../java/lang/Thread.html#suspend--"><code>suspend()</code></a>的方式是<a href="../../java/lang/Thread.html#suspend--">僵死的</a> 。</span></span>
<span><span class="deprecationComment">如果目标线程在销毁时保护关键系统资源的锁，则无法再次访问该资源。</span></span>
<span><span class="deprecationComment">如果另一个线程曾尝试锁定此资源，将导致死锁。</span></span>
<span><span class="deprecationComment">这种僵局通常表现为“冻结”过程。</span></span>
<span><span class="deprecationComment">有关详细信息，请参阅<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a> 。</span></span>
</div>
</div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#dumpStack--">dumpStack</a></span>()</code>
<div class="block">
              将当前线程的堆栈跟踪打印到标准错误流。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#enumerate-java.lang.Thread:A-">enumerate</a></span>(<a href="../../java/lang/Thread.html" title="class in java.lang">Thread</a>[] tarray)</code>
<div class="block">
              将当前线程的线程组及其子组中的每个活动线程复制到指定的数组中。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>static <a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;<a href="../../java/lang/Thread.html" title="class in java.lang">Thread</a>,<a href="../../java/lang/StackTraceElement.html" title="class in java.lang">StackTraceElement</a>[]&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#getAllStackTraces--">getAllStackTraces</a></span>()</code>
<div class="block">
              返回所有活动线程的堆栈跟踪图。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code><a href="../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#getContextClassLoader--">getContextClassLoader</a></span>()</code>
<div class="block">
              返回此Thread的上下文ClassLoader。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>static <a href="../../java/lang/Thread.UncaughtExceptionHandler.html" title="interface in java.lang">Thread.UncaughtExceptionHandler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#getDefaultUncaughtExceptionHandler--">getDefaultUncaughtExceptionHandler</a></span>()</code>
<div class="block">
              返回当线程由于未捕获异常突然终止而调用的默认处理程序。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#getId--">getId</a></span>()</code>
<div class="block">
              返回此线程的标识符。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code><a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#getName--">getName</a></span>()</code>
<div class="block">
              返回此线程的名称。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#getPriority--">getPriority</a></span>()</code>
<div class="block">
              返回此线程的优先级。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code><a href="../../java/lang/StackTraceElement.html" title="class in java.lang">StackTraceElement</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#getStackTrace--">getStackTrace</a></span>()</code>
<div class="block">
              返回表示此线程的堆栈转储的堆栈跟踪元素数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code><a href="../../java/lang/Thread.State.html" title="enum in java.lang">Thread.State</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#getState--">getState</a></span>()</code>
<div class="block">
              返回此线程的状态。 
            </div> </td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code><a href="../../java/lang/ThreadGroup.html" title="class in java.lang">ThreadGroup</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#getThreadGroup--">getThreadGroup</a></span>()</code>
<div class="block">
              返回此线程所属的线程组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code><a href="../../java/lang/Thread.UncaughtExceptionHandler.html" title="interface in java.lang">Thread.UncaughtExceptionHandler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#getUncaughtExceptionHandler--">getUncaughtExceptionHandler</a></span>()</code>
<div class="block">
              返回由于未捕获的异常，此线程突然终止时调用的处理程序。 
            </div> </td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#holdsLock-java.lang.Object-">holdsLock</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> obj)</code>
<div class="block">
              返回 
             <tt>true</tt>当且仅当当前线程在指定的对象上保持监视器锁。 
            </div> </td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#interrupt--">interrupt</a></span>()</code>
<div class="block">
              中断这个线程。 
            </div> </td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#interrupted--">interrupted</a></span>()</code>
<div class="block">
              测试当前线程是否中断。 
            </div> </td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#isAlive--">isAlive</a></span>()</code>
<div class="block">
              测试这个线程是否活着。 
            </div> </td>
</tr>
<tr class="altColor" id="i22">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#isDaemon--">isDaemon</a></span>()</code>
<div class="block">
              测试这个线程是否是守护线程。 
            </div> </td>
</tr>
<tr class="rowColor" id="i23">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#isInterrupted--">isInterrupted</a></span>()</code>
<div class="block">
              测试这个线程是否被中断。 
            </div> </td>
</tr>
<tr class="altColor" id="i24">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#join--">join</a></span>()</code>
<div class="block">
              等待这个线程死亡。 
            </div> </td>
</tr>
<tr class="rowColor" id="i25">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#join-long-">join</a></span>(long millis)</code>
<div class="block">
              等待这个线程死亡最多 
             <code>millis</code>毫秒。 
            </div> </td>
</tr>
<tr class="altColor" id="i26">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#join-long-int-">join</a></span>(long millis, int nanos)</code>
<div class="block">
              等待最多 
             <code>millis</code>毫秒加上 
             <code>nanos</code>纳秒这个线程死亡。 
            </div> </td>
</tr>
<tr class="rowColor" id="i27">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#resume--">resume</a></span>()</code>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<div class="block">
<span><span class="deprecationComment">该方法仅用于与<a href="../../java/lang/Thread.html#suspend--"><code>suspend()</code></a>一起使用，因为它是死锁倾向的，因此已被弃用。</span></span>
<span><span class="deprecationComment">有关详细信息，请参阅<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a> 。</span></span>
</div>
</div> </td>
</tr>
<tr class="altColor" id="i28">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#run--">run</a></span>()</code>
<div class="block">
<span>如果这个线程使用单独的<code>Runnable</code>运行对象构造，则调用该<code>Runnable</code>对象的<code>run</code>方法;</span>
<span>否则，此方法不执行任何操作并返回。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i29">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#setContextClassLoader-java.lang.ClassLoader-">setContextClassLoader</a></span>(<a href="../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> cl)</code>
<div class="block">
              设置此线程的上下文ClassLoader。 
            </div> </td>
</tr>
<tr class="altColor" id="i30">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#setDaemon-boolean-">setDaemon</a></span>(boolean on)</code>
<div class="block">
              将此线程标记为 
             <a href="../../java/lang/Thread.html#isDaemon--">daemon</a>线程或用户线程。 
            </div> </td>
</tr>
<tr class="rowColor" id="i31">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#setDefaultUncaughtExceptionHandler-java.lang.Thread.UncaughtExceptionHandler-">setDefaultUncaughtExceptionHandler</a></span>(<a href="../../java/lang/Thread.UncaughtExceptionHandler.html" title="interface in java.lang">Thread.UncaughtExceptionHandler</a> eh)</code>
<div class="block">
              设置当线程由于未捕获的异常突然终止而调用的默认处理程序，并且没有为该线程定义其他处理程序。 
            </div> </td>
</tr>
<tr class="altColor" id="i32">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#setName-java.lang.String-">setName</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name)</code>
<div class="block">
              将此线程的名称更改为等于参数 
             <code>name</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i33">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#setPriority-int-">setPriority</a></span>(int newPriority)</code>
<div class="block">
              更改此线程的优先级。 
            </div> </td>
</tr>
<tr class="altColor" id="i34">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#setUncaughtExceptionHandler-java.lang.Thread.UncaughtExceptionHandler-">setUncaughtExceptionHandler</a></span>(<a href="../../java/lang/Thread.UncaughtExceptionHandler.html" title="interface in java.lang">Thread.UncaughtExceptionHandler</a> eh)</code>
<div class="block">
              设置当该线程由于未捕获的异常而突然终止时调用的处理程序。 
            </div> </td>
</tr>
<tr class="rowColor" id="i35">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#sleep-long-">sleep</a></span>(long millis)</code>
<div class="block">
              使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。 
            </div> </td>
</tr>
<tr class="altColor" id="i36">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#sleep-long-int-">sleep</a></span>(long millis, int nanos)</code>
<div class="block">
              导致正在执行的线程以指定的毫秒数加上指定的纳秒数来暂停（临时停止执行），这取决于系统定时器和调度器的精度和准确性。 
            </div> </td>
</tr>
<tr class="rowColor" id="i37">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#start--">start</a></span>()</code>
<div class="block">
<span>导致此线程开始执行;</span>
<span>Java虚拟机调用此线程的<code>run</code>方法。</span>
</div> </td>
</tr>
<tr class="altColor" id="i38">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#stop--">stop</a></span>()</code>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<div class="block">
<span><span class="deprecationComment">这种方法本质上是不安全的。</span></span>
<span><span class="deprecationComment">使用Thread.stop停止线程可以解锁所有已锁定的监视器（由于未<code>ThreadDeath</code> ThreadDeath异常在堆栈中<code>ThreadDeath</code>的自然结果）。</span></span>
<span><span class="deprecationComment">如果先前受这些监视器保护的任何对象处于不一致的状态，则损坏的对象将变得对其他线程可见，可能导致任意行为。</span></span>
<span><span class="deprecationComment"><code>stop</code>许多用途应该被替换为只是修改一些变量以指示目标线程应该停止运行的代码。</span></span>
<span><span class="deprecationComment">目标线程应该定期检查此变量，如果变量表示要停止运行，则以有序方式从其运行方法返回。</span></span>
<span><span class="deprecationComment">如果目标线程长时间等待（例如，在<code>interrupt</code>变量上），则应该使用<code>interrupt</code>方法来中断等待。</span></span>
<span><span class="deprecationComment">有关详细信息，请参阅<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a> 。</span></span>
</div>
</div> </td>
</tr>
<tr class="rowColor" id="i39">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#stop-java.lang.Throwable-">stop</a></span>(<a href="../../java/lang/Throwable.html" title="class in java.lang">Throwable</a> obj)</code>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<div class="block">
<span><span class="deprecationComment">该方法最初设计为强制线程停止并抛出一个给定的<code>Throwable</code>作为例外。</span></span>
<span><span class="deprecationComment">它本质上是不安全的（有关详细信息，请参阅<a href="../../java/lang/Thread.html#stop--"><code>stop()</code></a> ），此外还可用于生成目标线程未准备处理的异常。</span></span>
<span><span class="deprecationComment">有关详细信息，请参阅<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a> 。</span></span>
</div>
</div> </td>
</tr>
<tr class="altColor" id="i40">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#suspend--">suspend</a></span>()</code>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<div class="block">
<span><span class="deprecationComment">这种方法已被弃用，因为它本身就是死锁的。</span></span>
<span><span class="deprecationComment">如果目标线程在挂起时保护关键系统资源的监视器上的锁定，则在目标线程恢复之前，线程不能访问该资源。</span></span>
<span><span class="deprecationComment">如果要恢复目标线程的线程在调用<code>resume</code>之前尝试锁定此监视器， <code>resume</code>导致死锁。</span></span>
<span><span class="deprecationComment">这种僵局通常表现为“冻结”过程。</span></span>
<span><span class="deprecationComment">有关详细信息，请参阅<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a> 。</span></span>
</div>
</div> </td>
</tr>
<tr class="rowColor" id="i41">
<td class="colFirst"><code><a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#toString--">toString</a></span>()</code>
<div class="block">
              返回此线程的字符串表示，包括线程的名称，优先级和线程组。 
            </div> </td>
</tr>
<tr class="altColor" id="i42">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/lang/Thread.html#yield--">yield</a></span>()</code>
<div class="block">
              对调度程序的一个暗示，即当前线程愿意产生当前使用的处理器。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../java/lang/Object.html#notify--">notify</a>, <a href="../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../java/lang/Object.html#wait--">wait</a>, <a href="../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!-- --> </a> <h3>字段详细信息</h3> <a name="MIN_PRIORITY">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>MIN_PRIORITY</h4> <pre>public static final int MIN_PRIORITY</pre>
<div class="block">
            线程可以拥有的最小优先级。 
          </div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.lang.Thread.MIN_PRIORITY">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="NORM_PRIORITY">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>NORM_PRIORITY</h4> <pre>public static final int NORM_PRIORITY</pre>
<div class="block">
            分配给线程的默认优先级。 
          </div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.lang.Thread.NORM_PRIORITY">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="MAX_PRIORITY">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>MAX_PRIORITY</h4> <pre>public static final int MAX_PRIORITY</pre>
<div class="block">
            线程可以拥有的最大优先级。 
          </div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.lang.Thread.MAX_PRIORITY">Constant Field Values</a>
</dd>
</dl> </li>
</ul> </li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!-- --> </a> <h3>构造方法详细信息</h3> <a name="Thread--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>Thread</h4> <pre>public Thread()</pre>
<div class="block">
<span>分配一个新的<code>Thread</code>对象。</span>
<span>此构造具有相同的效果<a href="../../java/lang/Thread.html#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-">Thread</a> <code>(null, null, gname)</code> ，其中<code>gname</code>是新生成的名字。</span>
<span>自动生成的名称格式为<code>"Thread-"+</code> <i>n</i> ，其中<i>n</i>为整数。</span>
</div> </li>
</ul> <a name="Thread-java.lang.Runnable-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>Thread</h4> <pre>public Thread(<a href="../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> target)</pre>
<div class="block">
<span>分配一个新的<code>Thread</code>对象。</span>
<span>该构造函数具有与<a href="../../java/lang/Thread.html#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-">Thread</a> <code>(null, target, gname)</code>相同的效果，其中<code>gname</code>是新生成的名称。</span>
<span>自动生成的名称格式为<code>"Thread-"+</code> <i>n</i> ，其中<i>n</i>为整数。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>target</code> - 启动此线程时调用其<code>run</code>方法的对象。</span>
<span>如果<code>null</code> ，这个类<code>run</code>方法什么都不做。</span>
</dd>
</dl> </li>
</ul> <a name="Thread-java.lang.ThreadGroup-java.lang.Runnable-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>Thread</h4> <pre>public Thread(<a href="../../java/lang/ThreadGroup.html" title="class in java.lang">ThreadGroup</a> group,
              <a href="../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> target)</pre>
<div class="block">
<span>分配一个新的<code>Thread</code>对象。</span>
<span>此构造具有相同的效果<a href="../../java/lang/Thread.html#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-">Thread</a> <code>(group, target, gname)</code> ，其中<code>gname</code>是新生成的名字。</span>
<span>自动生成的名称格式为<code>"Thread-"+</code> <i>n</i> ，其中<i>n</i>为整数。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>group</code> - 线程组。</span>
<span>如果是<code>null</code>并且有一个安全管理员，那么该组由<a href="../../java/lang/SecurityManager.html#getThreadGroup--">SecurityManager.getThreadGroup()决定</a> 。</span>
<span>如果没有安全管理员或<code>SecurityManager.getThreadGroup()</code>返回<code>null</code> ，该组将设置为当前线程的线程组。</span>
</dd>
<dd>
<span><code>target</code> - 启动此线程时调用其<code>run</code>方法的对象。</span>
<span>如果<code>null</code> ，这个线程的run方法被调用。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果当前线程不能在指定的线程组中创建线程 
           </dd>
</dl> </li>
</ul> <a name="Thread-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>Thread</h4> <pre>public Thread(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name)</pre>
<div class="block">
<span>分配一个新的<code>Thread</code>对象。</span>
<span>此构造具有相同的效果<a href="../../java/lang/Thread.html#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-">Thread</a> <code>(null, null, name)</code> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>name</code> - 新线程的名称 
           </dd>
</dl> </li>
</ul> <a name="Thread-java.lang.ThreadGroup-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>Thread</h4> <pre>public Thread(<a href="../../java/lang/ThreadGroup.html" title="class in java.lang">ThreadGroup</a> group,
              <a href="../../java/lang/String.html" title="class in java.lang">String</a> name)</pre>
<div class="block">
<span>分配一个新的<code>Thread</code>对象。</span>
<span>此构造具有相同的效果<a href="../../java/lang/Thread.html#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-">Thread</a> <code>(group, null, name)</code> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>group</code> - 线程组。</span>
<span>如果是<code>null</code>并且有一个安全管理器，则该组由<a href="../../java/lang/SecurityManager.html#getThreadGroup--">SecurityManager.getThreadGroup()决定</a> 。</span>
<span>如果没有安全管理员或<code>SecurityManager.getThreadGroup()</code>返回<code>null</code> ，则该组将设置为当前线程的线程组。</span>
</dd>
<dd>
<code>name</code> - 新线程的名称 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果当前线程无法在指定的线程组中创建线程 
           </dd>
</dl> </li>
</ul> <a name="Thread-java.lang.Runnable-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>Thread</h4> <pre>public Thread(<a href="../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> target,
              <a href="../../java/lang/String.html" title="class in java.lang">String</a> name)</pre>
<div class="block">
<span>分配一个新的<code>Thread</code>对象。</span>
<span>此构造具有相同的效果<a href="../../java/lang/Thread.html#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-">Thread</a> <code>(null, target, name)</code> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>target</code> - 启动此线程时调用其<code>run</code>方法的对象。</span>
<span>如果<code>null</code> ，则调用此线程的run方法。</span>
</dd>
<dd>
<code>name</code> - 新线程的名称 
           </dd>
</dl> </li>
</ul> <a name="Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>Thread</h4> <pre>public Thread(<a href="../../java/lang/ThreadGroup.html" title="class in java.lang">ThreadGroup</a> group,
              <a href="../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> target,
              <a href="../../java/lang/String.html" title="class in java.lang">String</a> name)</pre>
<div class="block">
<span>分配一个新的<code>Thread</code>对象，使其具有<code>target</code>作为其运行对象，具有指定的<code>name</code>作为其名称，属于<code>group</code>引用的线程组。</span>
<p> <span>如果有安全管理器，则使用ThreadGroup作为参数调用其<a href="../../java/lang/SecurityManager.html#checkAccess-java.lang.ThreadGroup-"><code>checkAccess</code></a>方法。</span> </p>
<p> <span>此外，它的<code>checkPermission</code>方法由<code>RuntimePermission("enableContextClassLoaderOverride")</code>权限调用，直接或间接地由覆盖<code>getContextClassLoader</code>或<code>setContextClassLoader</code>方法的子类的<code>getContextClassLoader</code> <code>setContextClassLoader</code>调用。</span> </p>
<p> <span>新创建的线程的优先级设置为等于创建线程的优先级，即当前正在运行的线程。</span> <span>可以使用方法<a href="../../java/lang/Thread.html#setPriority-int-">setPriority</a>将优先级改变为新值。</span> </p>
<p> <span>当且仅当创建它的线程当前被标记为守护线程时，新创建的线程才被初始化为守护线程。</span> <span>方法<a href="../../java/lang/Thread.html#setDaemon-boolean-">setDaemon</a>可以用于改变线程是否是守护进程。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>group</code> - 线程组。</span>
<span>如果是<code>null</code>并且有一个安全管理器，则该组由<a href="../../java/lang/SecurityManager.html#getThreadGroup--">SecurityManager.getThreadGroup()决定</a> 。</span>
<span>如果没有安全管理员或<code>SecurityManager.getThreadGroup()</code>返回<code>null</code> ，该组将设置为当前线程的线程组。</span>
</dd>
<dd>
<span><code>target</code> - 启动此线程时调用其<code>run</code>方法的对象。</span>
<span>如果<code>null</code> ，则调用此线程的run方法。</span>
</dd>
<dd>
<code>name</code> - 新线程的名称 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果当前线程不能在指定的线程组中创建线程，或者不能覆盖上下文类加载器方法。 
           </dd>
</dl> </li>
</ul> <a name="Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-long-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>Thread</h4> <pre>public Thread(<a href="../../java/lang/ThreadGroup.html" title="class in java.lang">ThreadGroup</a> group,
              <a href="../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> target,
              <a href="../../java/lang/String.html" title="class in java.lang">String</a> name,
              long stackSize)</pre>
<div class="block">
<span>分配一个新的<code>Thread</code>对象，以便它具有<code>target</code>作为其运行对象，将指定的<code>name</code>正如其名，以及属于该线程组由称作<code>group</code> ，并具有指定的<i>堆栈大小</i> 。</span>
<p> <span>这个构造<a href="../../java/lang/Thread.html#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-">函数</a>与<code>Thread(ThreadGroup,Runnable,String)</code>相同，除了它允许指定线程栈大小的事实之外。</span> <span>堆栈大小是虚拟机为该线程的堆栈分配的大致的地址空间字节数。</span> <span><b><code>stackSize</code>参数的影响（如果有的话）与平台有关。</b></span> </p>
<p> <span>在某些平台上，指定了一个较高的值<code>stackSize</code>参数可以允许抛出一个前一个线程来实现更大的递归深度<a href="../../java/lang/StackOverflowError.html" title="java.lang中的类"><code>StackOverflowError</code></a> 。</span> <span>类似地，指定较低的值可能允许更多数量的线程同时存在，而不会抛出<a href="../../java/lang/OutOfMemoryError.html" title="java.lang中的类"><code>OutOfMemoryError</code></a> （或其他内部错误）。</span> <span>所述<tt>stackSize</tt>参数的值和最大递归深度和并发水平之间的关系的细节是依赖于平台的。</span> <span><b>在某些平台上，该值<code>stackSize</code>参数可能没有任何效果。</b></span> </p>
<p> <span>虚拟机可以自由地对待<code>stackSize</code>参数作为建议。</span> <span>如果平台的指定值不合理地低，虚拟机可能会改为使用一些平台特定的最小值;</span> <span>如果指定的值不合理地高，虚拟机可能会使用一些平台特定的最大值。</span> <span>同样，虚拟机可以自由地按照合适的方式向上或向下舍入指定的值（或完全忽略它）。</span> </p>
<p> <span>对于指定的值为零<code>stackSize</code>参数将使这种构造的行为酷似<code>Thread(ThreadGroup, Runnable, String)</code>构造。</span> </p>
<p> <span><i>由于此构造函数的行为依赖于平台依赖性质，因此在使用时应特别小心。</i></span> <span><i>执行给定计算所需的线程栈大小可能会因JRE实现而异。</i></span> <span><i>鉴于这种变化，可能需要仔细调整堆栈大小参数，并且可能需要对要运行应用程序的每个JRE实现重复调整。</i></span> </p>
<p> <span>实现注意事项：鼓励Java平台实现者的记录其实施的行为<code>stackSize</code>参数。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>group</code> - 线程组。</span>
<span>如果<code>null</code>并且有一个安全管理器，该组由<a href="../../java/lang/SecurityManager.html#getThreadGroup--">SecurityManager.getThreadGroup()确定</a> 。</span>
<span>如果没有安全管理员或<code>SecurityManager.getThreadGroup()</code>返回<code>null</code> ，该组将设置为当前线程的线程组。</span>
</dd>
<dd>
<span><code>target</code> - 启动此线程时调用其<code>run</code>方法的对象。</span>
<span>如果<code>null</code> ，这个线程的run方法被调用。</span>
</dd>
<dd>
<code>name</code> - 新线程的名称 
           </dd>
<dd>
<code>stackSize</code> - 新线程所需的堆栈大小，或为零表示此参数将被忽略。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果当前线程无法在指定线程组中创建线程 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
</dl> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="currentThread--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>currentThread</h4> <pre>public static <a href="../../java/lang/Thread.html" title="class in java.lang">Thread</a> currentThread()</pre>
<div class="block">
            返回对当前正在执行的线程对象的引用。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             当前正在执行的线程。 
           </dd>
</dl> </li>
</ul> <a name="yield--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>yield</h4> <pre>public static void yield()</pre>
<div class="block">
<span>对调度程序的一个暗示，即当前线程愿意产生当前使用的处理器。</span>
<span>调度程序可以自由地忽略这个提示。</span>
<p> <span>产量是一种启发式尝试，以改善否则会过度利用CPU的线程之间的相对进度。</span> <span>其使用应与详细的分析和基准相结合，以确保其具有预期的效果。</span> </p>
<p> <span>很少使用这种方法。</span> <span>它可能对调试或测试有用，可能有助于根据种族条件重现错误。</span> <span>在设计并发控制结构（例如<a href="../../java/util/concurrent/locks/package-summary.html"><code>java.util.concurrent.locks</code></a>包中的<a href="../../java/util/concurrent/locks/package-summary.html">并行</a>控制结构）时也可能有用。</span> </p>
</div> </li>
</ul> <a name="sleep-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sleep</h4> <pre>public static void sleep(long millis)
                  throws <a href="../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></pre>
<div class="block">
<span>使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。</span>
<span>线程不会丢失任何显示器的所有权。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>millis</code> - 以毫秒为单位的睡眠时间长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>millis</code>值为负数 
           </dd>
<dd>
<span><code><a href="../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></code> - 如果任何线程中断当前线程。</span>
<span>当抛出此异常时，当前线程的<i>中断状态</i>将被清除。</span>
</dd>
</dl> </li>
</ul> <a name="sleep-long-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sleep</h4> <pre>public static void sleep(long millis,
                         int nanos)
                  throws <a href="../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></pre>
<div class="block">
<span>导致正在执行的线程以指定的毫秒数加上指定的纳秒数来暂停（临时停止执行），这取决于系统定时器和调度器的精度和准确性。</span>
<span>线程不会丢失任何显示器的所有权。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>millis</code> - 以毫秒为单位的睡眠时间长度 
           </dd>
<dd>
<code>nanos</code> - 
            <code>0-999999</code>额外的纳秒睡眠 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果值 
            <code>millis</code>是否定的，或的值 
            <code>nanos</code>不在范围 
            <code>0-999999</code>
</dd>
<dd>
<span><code><a href="../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></code> - 如果任何线程中断当前线程。</span>
<span>当抛出此异常时，当前线程的<i>中断状态</i>将被清除。</span>
</dd>
</dl> </li>
</ul> <a name="clone--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>clone</h4> <pre>protected <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> clone()
                throws <a href="../../java/lang/CloneNotSupportedException.html" title="class in java.lang">CloneNotSupportedException</a></pre>
<div class="block">
<span>将CloneNotSupportedException作为线程抛出无法有意义地克隆。</span>
<span>构造一个新的线程。</span>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../java/lang/Object.html#clone--">clone</a></code>在类别 
            <code><a href="../../java/lang/Object.html" title="class in java.lang">Object</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个实例的一个克隆。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/CloneNotSupportedException.html" title="class in java.lang">CloneNotSupportedException</a></code> - 永远 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/lang/Cloneable.html" title="java.lang中的接口"><code>Cloneable</code></a></span>
</dd>
</dl> </li>
</ul> <a name="start--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>start</h4> <pre>public void start()</pre>
<div class="block">
<span>导致此线程开始执行;</span>
<span>Java虚拟机调用此线程的<code>run</code>方法。</span>
<p> <span>结果是两个线程同时运行：当前线程（从调用返回到<code>start</code>方法）和另一个线程（执行其<code>run</code>方法）。</span> </p>
<p> <span>不止一次启动线程是不合法的。</span> <span>特别地，一旦线程完成执行就可能不会重新启动。</span> </p>
</div>
<dl>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalThreadStateException.html" title="class in java.lang">IllegalThreadStateException</a></code> - 如果线程已经启动。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Thread.html#run--"><code>run()</code></a> ， 
            <a href="../../java/lang/Thread.html#stop--"><code>stop()</code></a>
</dd>
</dl> </li>
</ul> <a name="run--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>run</h4> <pre>public void run()</pre>
<div class="block">
<span>如果这个线程是使用单独的<code>Runnable</code>运行对象构造的，则<code>Runnable</code>对象的<code>run</code>方法;</span>
<span>否则，此方法不执行任何操作并返回。</span>
<p> <span>Thread的<code>Thread</code>应该覆盖此方法。</span> </p>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../java/lang/Runnable.html#run--">run</a></code>在界面 
            <code><a href="../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a></code>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Thread.html#start--"><code>start()</code></a> ， 
            <a href="../../java/lang/Thread.html#stop--"><code>stop()</code></a> ， 
            <a href="../../java/lang/Thread.html#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-"><code>Thread(ThreadGroup, Runnable, String)</code></a>
</dd>
</dl> </li>
</ul> <a name="stop--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>stop</h4> <pre><a href="../../java/lang/Deprecated.html" title="annotation in java.lang">@Deprecated</a>
public final void stop()</pre>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<span><span class="deprecationComment">这种方法本质上是不安全的。</span></span>
<span><span class="deprecationComment">使用Thread.stop停止线程可以解锁所有已锁定的监视器（由于未<code>ThreadDeath</code> ThreadDeath异常在堆栈中<code>ThreadDeath</code>的自然结果）。</span></span>
<span><span class="deprecationComment">如果先前受这些监视器保护的任何对象处于不一致的状态，则损坏的对象将变得对其他线程可见，可能导致任意行为。</span></span>
<span><span class="deprecationComment"><code>stop</code>许多用途应该被代替，只需修改一些变量来指示目标线程应该停止运行。</span></span>
<span><span class="deprecationComment">目标线程应该定期检查此变量，如果变量表示要停止运行，则以有序方式从其运行方法返回。</span></span>
<span><span class="deprecationComment">如果目标线程长时间等待（例如，在<code>interrupt</code>变量上），则应该使用<code>interrupt</code>方法来中断等待。</span></span>
<span><span class="deprecationComment">有关详细信息，请参阅<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a> 。</span></span>
</div>
<div class="block">
<span>强制线程停止执行。</span>
<p> <span>如果安装了一个安全管理器，它的<code>checkAccess</code>方法<code>this</code>作为参数。</span> <span>这可能导致<code>SecurityException</code>被提升（在当前线程中）。</span> </p>
<p> <span>如果此线程与当前线程不同（即当前线程正试图停止除本身线程之外的线程），则另外还调用安全管理器的<code>checkPermission</code>方法（具有<code>RuntimePermission("stopThread")</code>参数）。</span> <span>再次，这可能会导致抛出<code>SecurityException</code> （在当前线程中）。</span> </p>
<p> <span>由该线程表示的线程被强制停止，它正在异常进行，并抛出一个新创建的<code>ThreadDeath</code>对象作为例外。</span> </p>
<p> <span>允许停止尚未启动的线程。</span> <span>如果线程最终启动，它将立即终止。</span> </p>
<p> <span>一个应用程序通常不应该尝试捕获<code>ThreadDeath</code> ，除非它必须做一些非凡的清理操作（请注意，抛出<code>ThreadDeath</code>导致<code>finally</code>语句<code>try</code>语句在线程正式死亡之前执行）。</span> <span>如果一个<code>catch</code>子句捕获一个<code>ThreadDeath</code>对象，重要的是重新抛出该对象，使线程实际上死亡。</span> </p>
<p> <span>该反应否则捕获的异常不打印出消息，或者如果未捕获的异常是一个实例，否则通知应用程序的顶级错误处理程序<code>ThreadDeath</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果当前线程不能修改此线程。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/lang/Thread.html#interrupt--"><code>interrupt()</code></a> ， <a href="../../java/lang/Thread.html#checkAccess--"><code>checkAccess()</code></a> ， <a href="../../java/lang/Thread.html#run--"><code>run()</code></a> ， <a href="../../java/lang/Thread.html#start--"><code>start()</code></a> ， <a href="../../java/lang/ThreadDeath.html" title="java.lang中的类"><code>ThreadDeath</code></a> ， <a href="../../java/lang/ThreadGroup.html#uncaughtException-java.lang.Thread-java.lang.Throwable-"><code>ThreadGroup.uncaughtException(Thread,Throwable)</code></a> ， <a href="../../java/lang/SecurityManager.html#checkAccess-java.lang.Thread-"><code>SecurityManager.checkAccess(Thread)</code></a> ， <a href="../../java/lang/SecurityManager.html#checkPermission-java.security.Permission-"><code>SecurityManager.checkPermission(java.security.Permission)</code></a></span>
</dd>
</dl> </li>
</ul> <a name="stop-java.lang.Throwable-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>stop</h4> <pre><a href="../../java/lang/Deprecated.html" title="annotation in java.lang">@Deprecated</a>
public final void stop(<a href="../../java/lang/Throwable.html" title="class in java.lang">Throwable</a> obj)</pre>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<span><span class="deprecationComment">该方法最初设计为强制线程停止并抛出一个给定的<code>Throwable</code>作为例外。</span></span>
<span><span class="deprecationComment">它本质上是不安全的（详见<a href="../../java/lang/Thread.html#stop--"><code>stop()</code></a> ），此外还可用于生成目标线程未准备处理的异常。</span></span>
<span><span class="deprecationComment">有关详细信息，请参阅<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a> 。</span></span>
</div>
<div class="block">
<code>UnsupportedOperationException</code> 。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>obj</code> - 忽略 
           </dd>
</dl> </li>
</ul> <a name="interrupt--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>interrupt</h4> <pre>public void interrupt()</pre>
<div class="block">
<span>中断这个线程。</span>
<p> <span>除非当前线程中断自身，这是始终允许的，所以调用此线程的<a href="../../java/lang/Thread.html#checkAccess--"><code>checkAccess</code></a>方法，这可能会导致抛出<a href="../../java/lang/SecurityException.html" title="java.lang中的类"><code>SecurityException</code></a> 。</span> </p>
<p> <span>如果该线程阻塞的调用<a href="../../java/lang/Object.html#wait--"><code>wait()</code></a> ， <a href="../../java/lang/Object.html#wait-long-"><code>wait(long)</code></a> ，或<a href="../../java/lang/Object.html#wait-long-int-"><code>wait(long, int)</code></a>的方法<a href="../../java/lang/Object.html" title="java.lang中的类"><code>Object</code></a>类，或者在<a href="../../java/lang/Thread.html#join--"><code>join()</code></a> ， <a href="../../java/lang/Thread.html#join-long-"><code>join(long)</code></a> ， <a href="../../java/lang/Thread.html#join-long-int-"><code>join(long, int)</code></a> ， <a href="../../java/lang/Thread.html#sleep-long-"><code>sleep(long)</code></a> ，或<a href="../../java/lang/Thread.html#sleep-long-int-"><code>sleep(long, int)</code></a> ，这个类的方法，那么它的中断状态将被清除，并且将收到一个<a href="../../java/lang/InterruptedException.html" title="java.lang中的类"><code>InterruptedException</code></a> 。</span> </p>
<p> <span>如果该线程在可阻止在I / O操作<a href="../../java/nio/channels/InterruptibleChannel.html" title="java.nio.channels中的接口"><code>InterruptibleChannel</code></a>则信道将被关闭，该线程的中断状态将被设置，并且螺纹将收到一个<a href="../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels中的类"><code>ClosedByInterruptException</code></a> 。</span> </p>
<p> <span>如果该线程在<a href="../../java/nio/channels/Selector.html" title="java.nio.channels中的类"><code>Selector</code></a>中被阻塞，则线程的中断状态将被设置，并且它将从选择操作立即返回，可能具有非零值，就像调用了选择器的<a href="../../java/nio/channels/Selector.html#wakeup--"><code>wakeup</code></a>方法一样。</span> </p>
<p> <span>如果以前的条件都不成立，则该线程的中断状态将被设置。</span> </p>
<p> <span>中断不存在的线程不需要任何效果。</span> </p>
</div>
<dl>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果当前线程不能修改此线程 
           </dd>
</dl> </li>
</ul> <a name="interrupted--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>interrupted</h4> <pre>public static boolean interrupted()</pre>
<div class="block">
<span>测试当前线程是否中断。</span>
<span>该方法可以清除线程的<i>中断状态</i> 。</span>
<span>换句话说，如果这个方法被连续调用两次，那么第二个调用将返回false（除非当前线程再次中断，在第一个调用已经清除其中断状态之后，在第二个调用之前已经检查过）。</span>
<p> <span>忽略线程中断，因为线程在中断时不存在将被该方法返回false所反映。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span><code>true</code>如果当前线程已被中断;</span>
<span><code>false</code>否则。</span>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Thread.html#isInterrupted--"><code>isInterrupted()</code></a>
</dd>
</dl> </li>
</ul> <a name="isInterrupted--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isInterrupted</h4> <pre>public boolean isInterrupted()</pre>
<div class="block">
<span>测试这个线程是否被中断。</span>
<span>线程的<i>中断状态</i>不受此方法的影响。</span>
<p> <span>忽略线程中断，因为线程在中断时不存在将被该方法返回false所反映。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span><code>true</code>如果这个线程已被中断;</span>
<span><code>false</code>否则。</span>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Thread.html#interrupted--"><code>interrupted()</code></a>
</dd>
</dl> </li>
</ul> <a name="destroy--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>destroy</h4> <pre><a href="../../java/lang/Deprecated.html" title="annotation in java.lang">@Deprecated</a>
public void destroy()</pre>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<span><span class="deprecationComment">这种方法最初是为了销毁这个线程而没有任何清理。</span></span>
<span><span class="deprecationComment">它所持有的任何监视器都将保持锁定。</span></span>
<span><span class="deprecationComment">但是，该方法从未实现。</span></span>
<span><span class="deprecationComment">如果要实施，那么<code>suspend()</code>的方式会是<a href="../../java/lang/Thread.html#suspend--">僵死的</a> 。</span></span>
<span><span class="deprecationComment">如果目标线程在销毁时保护关键系统资源的锁，则无法再次访问该资源。</span></span>
<span><span class="deprecationComment">如果另一个线程曾尝试锁定此资源，将导致死锁。</span></span>
<span><span class="deprecationComment">这种僵局通常表现为“冻结”过程。</span></span>
<span><span class="deprecationComment">有关更多信息，请参阅<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a> 。</span></span>
</div>
<div class="block">
<span><a href="../../java/lang/NoSuchMethodError.html" title="java.lang中的类">投掷<code>NoSuchMethodError</code></a> 。</span>
</div>
<dl>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NoSuchMethodError.html" title="class in java.lang">NoSuchMethodError</a></code> - 永远 
           </dd>
</dl> </li>
</ul> <a name="isAlive--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isAlive</h4> <pre>public final boolean isAlive()</pre>
<div class="block">
<span>测试这个线程是否活着。</span>
<span>如果一个线程已经启动并且尚未死亡，那么线程是活着的。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span><code>true</code>如果这个线程还活着;</span>
<span><code>false</code>否则。</span>
</dd>
</dl> </li>
</ul> <a name="suspend--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>suspend</h4> <pre><a href="../../java/lang/Deprecated.html" title="annotation in java.lang">@Deprecated</a>
public final void suspend()</pre>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<span><span class="deprecationComment">这种方法已被弃用，因为它本身就是死锁的。</span></span>
<span><span class="deprecationComment">如果目标线程在挂起时保护关键系统资源的监视器上的锁定，则在目标线程恢复之前，线程不能访问该资源。</span></span>
<span><span class="deprecationComment">如果要恢复目标线程的线程在调用<code>resume</code>之前尝试锁定此监视器， <code>resume</code>导致死锁。</span></span>
<span><span class="deprecationComment">这种僵局通常表现为“冻结”过程。</span></span>
<span><span class="deprecationComment">有关详细信息，请参阅<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a> 。</span></span>
</div>
<div class="block">
<span>暂停这个线程。</span>
<p> <span>首先，这个线程的<code>checkAccess</code>方法被调用，没有参数。</span> <span>这可能会导致<code>SecurityException</code> （在当前线程中）。</span> </p>
<p> <span>如果线程活着，它将被暂停，并且不会进一步进行，除非和直到恢复。</span> </p>
</div>
<dl>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果当前线程不能修改此线程。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Thread.html#checkAccess--"><code>checkAccess()</code></a>
</dd>
</dl> </li>
</ul> <a name="resume--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>resume</h4> <pre><a href="../../java/lang/Deprecated.html" title="annotation in java.lang">@Deprecated</a>
public final void resume()</pre>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<span><span class="deprecationComment">此方法仅适用于<a href="../../java/lang/Thread.html#suspend--"><code>suspend()</code></a> ，由于它是死锁倾向，因此已被弃用。</span></span>
<span><span class="deprecationComment">有关更多信息，请参阅<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a> 。</span></span>
</div>
<div class="block">
<span>恢复挂起的线程。</span>
<p> <span>首先，这个线程的<code>checkAccess</code>方法被调用，没有参数。</span> <span>这可能会导致<code>SecurityException</code> （在当前线程中）。</span> </p>
<p> <span>如果线程存活但被暂停，则它被恢复并被允许在其执行中取得进展。</span> </p>
</div>
<dl>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果当前线程不能修改此线程。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Thread.html#checkAccess--"><code>checkAccess()</code></a> ， 
            <a href="../../java/lang/Thread.html#suspend--"><code>suspend()</code></a>
</dd>
</dl> </li>
</ul> <a name="setPriority-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setPriority</h4> <pre>public final void setPriority(int newPriority)</pre>
<div class="block">
<span>更改此线程的优先级。</span>
<p> <span>首先调用这个线程的<code>checkAccess</code>方法，没有参数。</span> <span>这可能会导致投掷<code>SecurityException</code> 。</span> </p>
<p> <span>否则，该线程的优先级设置为指定的小<code>newPriority</code>和最大允许的线程的线程组的优先级。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>newPriority</code> - 设置此线程的优先级 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果优先级不在 
            <code>MIN_PRIORITY</code>到 
            <code>MAX_PRIORITY</code> 。 
           </dd>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果当前线程不能修改此线程。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Thread.html#getPriority--"><code>getPriority()</code></a> ， 
            <a href="../../java/lang/Thread.html#checkAccess--"><code>checkAccess()</code></a> ， 
            <a href="../../java/lang/Thread.html#getThreadGroup--"><code>getThreadGroup()</code></a> ， 
            <a href="../../java/lang/Thread.html#MAX_PRIORITY"><code>MAX_PRIORITY</code></a> ， 
            <a href="../../java/lang/Thread.html#MIN_PRIORITY"><code>MIN_PRIORITY</code></a> ， 
            <a href="../../java/lang/ThreadGroup.html#getMaxPriority--"><code>ThreadGroup.getMaxPriority()</code></a>
</dd>
</dl> </li>
</ul> <a name="getPriority--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getPriority</h4> <pre>public final int getPriority()</pre>
<div class="block">
            返回此线程的优先级。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个线程的优先级。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Thread.html#setPriority-int-"><code>setPriority(int)</code></a>
</dd>
</dl> </li>
</ul> <a name="setName-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setName</h4> <pre>public final void setName(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name)</pre>
<div class="block">
<span>将此线程的名称更改为等于参数<code>name</code> 。</span>
<p> <span>首先调用这个线程的<code>checkAccess</code>方法，没有参数。</span> <span>这可能会导致投掷<code>SecurityException</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>name</code> - 这个线程的新名称。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果当前线程不能修改此线程。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Thread.html#getName--"><code>getName()</code></a> ， 
            <a href="../../java/lang/Thread.html#checkAccess--"><code>checkAccess()</code></a>
</dd>
</dl> </li>
</ul> <a name="getName--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getName</h4> <pre>public final <a href="../../java/lang/String.html" title="class in java.lang">String</a> getName()</pre>
<div class="block">
            返回此线程的名称。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个线程的名字。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Thread.html#setName-java.lang.String-"><code>setName(String)</code></a>
</dd>
</dl> </li>
</ul> <a name="getThreadGroup--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getThreadGroup</h4> <pre>public final <a href="../../java/lang/ThreadGroup.html" title="class in java.lang">ThreadGroup</a> getThreadGroup()</pre>
<div class="block">
<span>返回此线程所属的线程组。</span>
<span>如果线程已经死机（停止），此方法返回null。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个线程的线程组。 
           </dd>
</dl> </li>
</ul> <a name="activeCount--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>activeCount</h4> <pre>public static int activeCount()</pre>
<div class="block">
<span>返回当前线程的<a href="../../java/lang/ThreadGroup.html" title="java.lang中的类">thread group</a>及其子组中活动线程数的估计。</span>
<span>递归地遍历当前线程的线程组中的所有子组。</span>
<p> <span>返回的值只是一个估计，因为线程数可能会在此方法遍历内部数据结构时动态更改，并且可能受某些系统线程的存在的影响。</span> <span>此方法主要用于调试和监视。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             对当前线程的线程组和任何其他线程组中当前线程的线程组作为祖先的活动线程数的估计 
           </dd>
</dl> </li>
</ul> <a name="enumerate-java.lang.Thread:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>enumerate</h4> <pre>public static int enumerate(<a href="../../java/lang/Thread.html" title="class in java.lang">Thread</a>[] tarray)</pre>
<div class="block">
<span>将当前线程的线程组及其子组中的每个活动线程复制到指定的数组中。</span>
<span>该方法简单地调用当前线程的线程组的<a href="../../java/lang/ThreadGroup.html#enumerate-java.lang.Thread:A-"><code>ThreadGroup.enumerate(Thread[])</code></a>方法。</span>
<p> <span>应用程序可能会使用<a href="../../java/lang/Thread.html#activeCount--">activeCount</a>方法来估计数组的大小，但是<i>如果数组太短而不能容纳所有线程，则会忽略额外的线程。</i></span> <span>如果在当前线程组及其子组中获取每个活动线程至关重要，则调用者应验证返回的int值是否严格小于<code>tarray</code>的长度。</span> </p>
<p> <span>由于本方法中固有的竞争条件，建议该方法仅用于调试和监控。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>tarray</code> - 放置线程列表的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             放入数组的线程数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果 
            <a href="../../java/lang/ThreadGroup.html#checkAccess--"><code>ThreadGroup.checkAccess()</code></a>确定当前线程无法访问其线程组 
           </dd>
</dl> </li>
</ul> <a name="countStackFrames--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>countStackFrames</h4> <pre><a href="../../java/lang/Deprecated.html" title="annotation in java.lang">@Deprecated</a>
public int countStackFrames()</pre>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<span><span class="deprecationComment">此调用的定义取决于<a href="../../java/lang/Thread.html#suspend--"><code>suspend()</code></a> ，它被废弃了。</span></span>
<span><span class="deprecationComment">此外，此呼叫的结果从未明确。</span></span>
</div>
<div class="block">
<span>计算此线程中的堆栈帧数。</span>
<span>线程必须暂停。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             此线程中的堆栈帧数。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalThreadStateException.html" title="class in java.lang">IllegalThreadStateException</a></code> - 如果此线程未挂起。 
           </dd>
</dl> </li>
</ul> <a name="join-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>join</h4> <pre>public final void join(long millis)
                throws <a href="../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></pre>
<div class="block">
<span>等待这个线程死亡的时间最多为<code>millis</code>毫秒。</span>
<span><code>0</code>的超时意味着永远等待。</span>
<p> <span>此实现使用<code>this.wait</code>调用的循环，条件为<code>this.isAlive</code> 。</span> <span>当线程终止时，调用<code>this.notifyAll</code>方法。</span> <span>建议应用程序不使用<code>wait</code> ， <code>notify</code> ，或<code>notifyAll</code>上<code>Thread</code>实例。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>millis</code> - 以毫秒为单位等待的时间 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>millis</code>值为负 
           </dd>
<dd>
<span><code><a href="../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></code> - 如果任何线程中断当前线程。</span>
<span>当抛出此异常时，当前线程的<i>中断状态</i>将被清除。</span>
</dd>
</dl> </li>
</ul> <a name="join-long-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>join</h4> <pre>public final void join(long millis,
                       int nanos)
                throws <a href="../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></pre>
<div class="block">
<span>等待最多<code>millis</code>毫秒加上这个线程死亡的<code>nanos</code>纳秒。</span>
<p> <span>此实现使用<code>this.wait</code>调用的循环，条件为<code>this.isAlive</code> 。</span> <span>当线程终止时，调用<code>this.notifyAll</code>方法。</span> <span>建议应用程序不使用<code>wait</code> ， <code>notify</code> ，或<code>notifyAll</code>上<code>Thread</code>实例。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>millis</code> - 等待毫秒的时间 
           </dd>
<dd>
<code>nanos</code> - 
            <code>0-999999</code>等待的额外纳秒 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果值 
            <code>millis</code>是否定的，或的值 
            <code>nanos</code>不在范围 
            <code>0-999999</code>
</dd>
<dd>
<span><code><a href="../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></code> - 如果任何线程已中断当前线程。</span>
<span>当抛出此异常时，当前线程的<i>中断状态</i>将被清除。</span>
</dd>
</dl> </li>
</ul> <a name="join--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>join</h4> <pre>public final void join()
                throws <a href="../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></pre>
<div class="block">
<span>等待这个线程死亡。</span>
<p> <span>调用此方法的行为方式与调用完全相同</span> </p>
<blockquote>
<span><a href="../../java/lang/Thread.html#join-long-">join</a> <code>(0)</code></span>
</blockquote>
</div>
<dl>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></code> - 如果任何线程中断当前线程。</span>
<span>当抛出此异常时，当前线程的<i>中断状态</i>将被清除。</span>
</dd>
</dl> </li>
</ul> <a name="dumpStack--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>dumpStack</h4> <pre>public static void dumpStack()</pre>
<div class="block">
<span>将当前线程的堆栈跟踪打印到标准错误流。</span>
<span>此方法仅用于调试。</span>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Throwable.html#printStackTrace--"><code>Throwable.printStackTrace()</code></a>
</dd>
</dl> </li>
</ul> <a name="setDaemon-boolean-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setDaemon</h4> <pre>public final void setDaemon(boolean on)</pre>
<div class="block">
<span>将此线程标记为<a href="../../java/lang/Thread.html#isDaemon--">daemon</a>线程或用户线程。</span>
<span>当运行的唯一线程都是守护进程线程时，Java虚拟机将退出。</span>
<p> <span>线程启动前必须调用此方法。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>on</code> - 如果 
            <code>true</code> ，将此线程标记为守护线程 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalThreadStateException.html" title="class in java.lang">IllegalThreadStateException</a></code> - 如果这个线程是 
            <a href="../../java/lang/Thread.html#isAlive--">alive</a>
</dd>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果 
            <a href="../../java/lang/Thread.html#checkAccess--"><code>checkAccess()</code></a>确定当前线程不能修改此线程 
           </dd>
</dl> </li>
</ul> <a name="isDaemon--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isDaemon</h4> <pre>public final boolean isDaemon()</pre>
<div class="block">
            测试这个线程是否是守护线程。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span><code>true</code>如果这个线程是一个守护线程;</span>
<span><code>false</code>否则。</span>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Thread.html#setDaemon-boolean-"><code>setDaemon(boolean)</code></a>
</dd>
</dl> </li>
</ul> <a name="checkAccess--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>checkAccess</h4> <pre>public final void checkAccess()</pre>
<div class="block">
<span>确定当前正在运行的线程是否有权限修改此线程。</span>
<p> <span>如果有一个安全管理器，它的<code>checkAccess</code>方法被调用这个线程作为它的参数。</span> <span>这可能会导致投掷<code>SecurityException</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果当前线程不允许访问此线程。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/SecurityManager.html#checkAccess-java.lang.Thread-"><code>SecurityManager.checkAccess(Thread)</code></a>
</dd>
</dl> </li>
</ul> <a name="toString--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toString</h4> <pre>public <a href="../../java/lang/String.html" title="class in java.lang">String</a> toString()</pre>
<div class="block">
            返回此线程的字符串表示，包括线程的名称，优先级和线程组。 
          </div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../java/lang/Object.html#toString--">toString</a></code>在 
            <code><a href="../../java/lang/Object.html" title="class in java.lang">Object</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个线程的字符串表示形式。 
           </dd>
</dl> </li>
</ul> <a name="getContextClassLoader--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getContextClassLoader</h4> <pre>public <a href="../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> getContextClassLoader()</pre>
<div class="block">
<span>返回此Thread的上下文ClassLoader。</span>
<span>上下文ClassLoader由线程的创建者提供，以便在加载类和资源时在此线程中运行的代码使用。</span>
<span>如果不是<a href="../../java/lang/Thread.html#setContextClassLoader-java.lang.ClassLoader-">set</a> ，默认是父线程的ClassLoader上下文。</span>
<span>原始线程的上下文ClassLoader通常设置为用于加载应用程序的类加载器。</span>
<p> <span>如果安全管理器存在，并且调用者的类加载器不是<code>null</code> ，并且与上下文类加载器的祖先不一样或者祖先，则该方法调用安全管理器的<a href="../../java/lang/SecurityManager.html#checkPermission-java.security.Permission-"><code>checkPermission</code></a>方法，具有<a href="../../java/lang/RuntimePermission.html" title="java.lang中的类"><code>RuntimePermission</code></a> <code>("getClassLoader")</code>权限，以验证是否检索上下文类加载器是允许的。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             该线程的上下文ClassLoader，或 
            <code>null</code>指示系统类加载器（或者失败的是引导类加载器） 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果当前线程无法获取上下文ClassLoader 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.2 
           </dd>
</dl> </li>
</ul> <a name="setContextClassLoader-java.lang.ClassLoader-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setContextClassLoader</h4> <pre>public void setContextClassLoader(<a href="../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> cl)</pre>
<div class="block">
<span>设置此线程的上下文ClassLoader。</span>
<span>当创建线程时，可以设置上下文ClassLoader，并允许线程的创建者通过<code>getContextClassLoader</code>提供相应的类加载器，以便在加载类和资源时在线程中运行代码。</span>
<p> <span>如果存在安全管理员，则其<a href="../../java/lang/SecurityManager.html#checkPermission-java.security.Permission-"><code>checkPermission</code></a>方法将被调用<a href="../../java/lang/RuntimePermission.html" title="java.lang中的类"><code>RuntimePermission</code></a> <code>("setContextClassLoader")</code>权限，以查看是否允许设置上下文ClassLoader。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>cl</code> - 此线程的上下文ClassLoader，或指示系统类加载器的空值（或者，失败的是引导类加载器） 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果当前线程不能设置上下文ClassLoader 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.2 
           </dd>
</dl> </li>
</ul> <a name="holdsLock-java.lang.Object-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>holdsLock</h4> <pre>public static boolean holdsLock(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> obj)</pre>
<div class="block">
<span>返回<tt>true</tt>当且仅当当前线程在指定的对象上保持监视器锁。</span>
<p> <span>该方法旨在允许程序断言当前线程已经保存指定的锁：</span> </p>
<pre>  <span>assert Thread.holdsLock(obj);</span> </pre>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>obj</code> - 测试锁拥有权的对象 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<tt>true</tt>如果当前线程保持指定对象上的监视器锁定。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果obj是 
            <tt>null</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
</dl> </li>
</ul> <a name="getStackTrace--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getStackTrace</h4> <pre>public <a href="../../java/lang/StackTraceElement.html" title="class in java.lang">StackTraceElement</a>[] getStackTrace()</pre>
<div class="block">
<span>返回表示此线程的堆栈转储的堆栈跟踪元素数组。</span>
<span>该方法将返回一个零长度的数组，如果该线程尚未启动，已启动但尚未被计划运行，或已终止。</span>
<span>如果返回的数组非零长度，则数组的第一个元素表示堆栈的顶部，这是序列中最近的方法调用。</span>
<span>数组的最后一个元素表示堆栈的底部，这是序列中最近最少的方法调用。</span>
<p> <span>如果有一个安全管理器，并且这个线程不是当前的线程，那么安全管理器的<tt>checkPermission</tt>方法被调用一个<tt>RuntimePermission("getStackTrace")</tt>权限来查看是否可以获取堆栈跟踪。</span> </p>
<p> <span>在某些情况下，某些虚拟机可能从堆栈跟踪中省略一个或多个堆栈帧。</span> <span>在极端情况下，允许没有关于该线程的堆栈跟踪信息的虚拟机从该方法返回零长度数组。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <tt>StackTraceElement</tt>的数组，每个代表一个堆栈帧。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理器存在，并且其 
            <tt>checkPermission</tt>方法不允许获取线程的堆栈跟踪。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/lang/SecurityManager.html#checkPermission-java.security.Permission-"><code>SecurityManager.checkPermission(java.security.Permission)</code></a> ， <a href="../../java/lang/RuntimePermission.html" title="java.lang中的类"><code>RuntimePermission</code></a> ， <a href="../../java/lang/Throwable.html#getStackTrace--"><code>Throwable.getStackTrace()</code></a></span>
</dd>
</dl> </li>
</ul> <a name="getAllStackTraces--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getAllStackTraces</h4> <pre>public static <a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;<a href="../../java/lang/Thread.html" title="class in java.lang">Thread</a>,<a href="../../java/lang/StackTraceElement.html" title="class in java.lang">StackTraceElement</a>[]&gt; getAllStackTraces()</pre>
<div class="block">
<span>返回所有活动线程的堆栈跟踪图。</span>
<span>地图键是线程，每个地图值是<tt>StackTraceElement</tt>数组，表示对应的<tt>Thread</tt>的堆栈转储。</span>
<span>返回的堆栈跟踪格式为<a href="../../java/lang/Thread.html#getStackTrace--"><code>getStackTrace</code></a>方法指定的格式。</span>
<p> <span>线程可能正在执行，而此方法被调用。</span> <span>每个线程的堆栈跟踪仅表示快照，并且可以在不同时间获取每个堆栈跟踪。</span> <span>如果虚拟机没有关于线程的堆栈跟踪信息，则将在地图值中返回零长度的数组。</span> </p>
<p> <span>如果有一个安全管理员，那么安全管理员的<tt>checkPermission</tt>方法被调用一个<tt>RuntimePermission("getStackTrace")</tt>权限以及<tt>RuntimePermission("modifyThreadGroup")</tt>权限来查看是否可以获取所有线程的堆栈跟踪。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <tt>Map</tt>从 
            <tt>Thread</tt>到一个 
            <tt>StackTraceElement</tt>的数组， 
            <tt>代表</tt>相应线程的堆栈跟踪。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理器存在，并且其 
            <tt>checkPermission</tt>方法不允许获取线程的堆栈跟踪。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/lang/Thread.html#getStackTrace--"><code>getStackTrace()</code></a> ， <a href="../../java/lang/SecurityManager.html#checkPermission-java.security.Permission-"><code>SecurityManager.checkPermission(java.security.Permission)</code></a> ， <a href="../../java/lang/RuntimePermission.html" title="java.lang中的类"><code>RuntimePermission</code></a> ， <a href="../../java/lang/Throwable.html#getStackTrace--"><code>Throwable.getStackTrace()</code></a></span>
</dd>
</dl> </li>
</ul> <a name="getId--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getId</h4> <pre>public long getId()</pre>
<div class="block">
<span>返回此线程的标识符。</span>
<span>线程ID是创建此线程时生成的正数<tt>long</tt>号。</span>
<span>线程ID是唯一的，并且在其生命周期内保持不变。</span>
<span>当线程被终止时，该线程ID可以被重用。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个线程的ID。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="getState--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getState</h4> <pre>public <a href="../../java/lang/Thread.State.html" title="enum in java.lang">Thread.State</a> getState()</pre>
<div class="block">
<span>返回此线程的状态。</span>
<span>该方法设计用于监视系统状态，不用于同步控制。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个线程的状态。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="setDefaultUncaughtExceptionHandler-java.lang.Thread.UncaughtExceptionHandler-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setDefaultUncaughtExceptionHandler</h4> <pre>public static void setDefaultUncaughtExceptionHandler(<a href="../../java/lang/Thread.UncaughtExceptionHandler.html" title="interface in java.lang">Thread.UncaughtExceptionHandler</a> eh)</pre>
<div class="block">
<span>设置当线程由于未捕获的异常突然终止而调用的默认处理程序，并且没有为该线程定义其他处理程序。</span>
<p> <span>未捕获的异常处理首先由线程控制，然后由线程的<a href="../../java/lang/ThreadGroup.html" title="java.lang中的类"><code>ThreadGroup</code></a>对象控制，最后由默认的未捕获异常处理程序控制。</span> <span>如果线程没有明确的未捕获异常处理程序集，并且线程的线程组（包括父线程组）没有专门化其<tt>uncaughtException</tt>方法，那么默认处理程序的<tt>uncaughtException</tt>方法将被调用。</span> </p>
<p> <span>通过设置默认未捕获的异常处理程序，应用程序可以更改未被捕获的异常处理方式（例如，记录到特定设备或文件），这些线程将已经接受了系统提供的任何“默认”行为。</span> </p>
<p> <span>请注意，默认未捕获的异常处理程序通常不会延迟到线程的<tt>ThreadGroup</tt>对象，因为这可能会导致无限递归。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>eh</code> - 用作默认未捕获异常处理程序的对象。</span>
<span>如果<tt>null</tt>那么没有默认处理程序。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理器存在，并且否认 
            <tt><a href="../../java/lang/RuntimePermission.html" title="class in java.lang"><code>RuntimePermission</code></a> ("setDefaultUncaughtExceptionHandler")</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Thread.html#setUncaughtExceptionHandler-java.lang.Thread.UncaughtExceptionHandler-"><code>setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)</code></a> ， 
            <a href="../../java/lang/Thread.html#getUncaughtExceptionHandler--"><code>getUncaughtExceptionHandler()</code></a> ， 
            <a href="../../java/lang/ThreadGroup.html#uncaughtException-java.lang.Thread-java.lang.Throwable-"><code>ThreadGroup.uncaughtException(java.lang.Thread, java.lang.Throwable)</code></a>
</dd>
</dl> </li>
</ul> <a name="getDefaultUncaughtExceptionHandler--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getDefaultUncaughtExceptionHandler</h4> <pre>public static <a href="../../java/lang/Thread.UncaughtExceptionHandler.html" title="interface in java.lang">Thread.UncaughtExceptionHandler</a> getDefaultUncaughtExceptionHandler()</pre>
<div class="block">
<span>返回当线程由于未捕获异常突然终止而调用的默认处理程序。</span>
<span>如果返回值为<tt>null</tt> ，则没有默认值。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             所有线程的默认未捕获的异常处理程序 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Thread.html#setDefaultUncaughtExceptionHandler-java.lang.Thread.UncaughtExceptionHandler-"><code>setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)</code></a>
</dd>
</dl> </li>
</ul> <a name="getUncaughtExceptionHandler--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getUncaughtExceptionHandler</h4> <pre>public <a href="../../java/lang/Thread.UncaughtExceptionHandler.html" title="interface in java.lang">Thread.UncaughtExceptionHandler</a> getUncaughtExceptionHandler()</pre>
<div class="block">
<span>返回由于未捕获的异常，此线程突然终止时调用的处理程序。</span>
<span>如果此线程没有明确设置未捕获的异常处理程序，则返回此线程的<tt>ThreadGroup</tt>对象，除非此线程已终止，否则返回<tt>null</tt> 。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             该线程的未捕获的异常处理程序 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="setUncaughtExceptionHandler-java.lang.Thread.UncaughtExceptionHandler-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>setUncaughtExceptionHandler</h4> <pre>public void setUncaughtExceptionHandler(<a href="../../java/lang/Thread.UncaughtExceptionHandler.html" title="interface in java.lang">Thread.UncaughtExceptionHandler</a> eh)</pre>
<div class="block">
<span>设置当该线程由于未捕获的异常而突然终止时调用的处理程序。</span>
<p> <span>线程可以完全控制如何通过明确设置其未捕获的异常处理来响应未捕获的异常。</span> <span>如果没有设置这样的处理程序，那么线程的<tt>ThreadGroup</tt>对象将作为其处理程序。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>eh</code> - 用作此线程未捕获的异常处理程序的对象。</span>
<span>如果<tt>null</tt>那么这个线程没有明确的处理程序。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果当前线程不允许修改此线程。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Thread.html#setDefaultUncaughtExceptionHandler-java.lang.Thread.UncaughtExceptionHandler-"><code>setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)</code></a> ， 
            <a href="../../java/lang/ThreadGroup.html#uncaughtException-java.lang.Thread-java.lang.Throwable-"><code>ThreadGroup.uncaughtException(java.lang.Thread, java.lang.Throwable)</code></a>
</dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>