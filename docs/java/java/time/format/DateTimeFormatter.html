<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.time.format 
   </div>
<h2 class="title" title="Class DateTimeFormatter">Class DateTimeFormatter</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.time.format.DateTimeFormatter</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre>public final class <span class="typeNameLabel">DateTimeFormatter</span>
extends <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></pre>
<div class="block">
<span>格式化器用于打印和解析日期时间对象。</span>
<p> <span>该类提供打印和解析的主要应用程序入口点，并提供DateTimeFormatter的常见<code>DateTimeFormatter</code> ：</span> </p>
<ul>
<li> <span>使用预定义的常量，如<a href="../../../java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE"><code>ISO_LOCAL_DATE</code></a></span> </li>
<li> <span>使用模式字母，如<code>uuuu-MMM-dd</code></span> </li>
<li> <span>使用本地化样式，如<code>long</code>或<code>medium</code></span> </li>
</ul>
<p> <span>更复杂的格式化程序由<a href="../../../java/time/format/DateTimeFormatterBuilder.html" title="java.time.format中的类"><code>DateTimeFormatterBuilder</code></a>提供。</span> </p>
<p> <span>主要的日期时间类提供两种方法 - 一种用于格式化， <code>format(DateTimeFormatter formatter)</code> ， <code>format(DateTimeFormatter formatter)</code>一种用于解析， <code>parse(CharSequence text, DateTimeFormatter formatter)</code> 。</span> </p>
<p> <span>例如：</span> </p>
<blockquote>
<span><pre>
  String text = date.toString(formatter);
  LocalDate date = LocalDate.parse(text, formatter);
 </pre></span>
</blockquote>
<p> <span>除格式之外，可以使用所需的区域设置，年表，ZoneId和DecimalStyle创建格式化程序。</span> </p>
<p> <span><a href="../../../java/time/format/DateTimeFormatter.html#withLocale-java.util.Locale-"><code>withLocale</code></a>方法返回一个覆盖区域设置的新格式化程序。</span> <span>区域设置影响格式化和解析的一些方面。</span> <span>例如， <a href="../../../java/time/format/DateTimeFormatter.html#ofLocalizedDate-java.time.format.FormatStyle-"><code>ofLocalizedDate</code></a>提供了使用特定于语言环境的日期格式的格式化程序。</span> </p>
<p> <span><a href="../../../java/time/format/DateTimeFormatter.html#withChronology-java.time.chrono.Chronology-"><code>withChronology</code></a>方法返回一个覆盖年表的新格式化程序。</span> <span>如果被覆盖，则在格式化之前将日期时间值转换为年表。</span> <span>在解析期间，返回日期时间值之前将其转换为年表。</span> </p>
<p> <span><a href="../../../java/time/format/DateTimeFormatter.html#withZone-java.time.ZoneId-"><code>withZone</code></a>方法返回一个覆盖该区域的新格式化程序。</span> <span>如果被覆盖，日期时间值将在格式化之前转换为带有请求的ZoneId的ZonedDateTime。</span> <span>在解析期间，在返回值之前应用ZoneId。</span> </p>
<p> <span><a href="../../../java/time/format/DateTimeFormatter.html#withDecimalStyle-java.time.format.DecimalStyle-"><code>withDecimalStyle</code></a>方法返回一个新的格式化程序，覆盖<a href="../../../java/time/format/DecimalStyle.html" title="java.time.format中的类"><code>DecimalStyle</code></a> 。</span> <span>DecimalStyle符号用于格式化和解析。</span> </p>
<p> <span>某些应用程序可能需要使用较旧的<a href="../../../java/text/Format.html" title="java.text中的类"><code>java.text.Format</code></a>类进行格式化。</span> <span><a href="../../../java/time/format/DateTimeFormatter.html#toFormat--"><code>toFormat()</code></a>方法返回java.text.Format的<code>java.text.Format</code> 。</span> </p>
<h3 id="predefined"> <span>预定格式化器</span> </h3>
<span>  Formatter Description Example     <a href="../../../java/time/format/DateTimeFormatter.html#ofLocalizedDate-java.time.format.FormatStyle-"><code>ofLocalizedDate(dateStyle)</code></a>   Formatter with date style from the locale   '2011-12-03'    <a href="../../../java/time/format/DateTimeFormatter.html#ofLocalizedTime-java.time.format.FormatStyle-"><code>ofLocalizedTime(timeStyle)</code></a>   Formatter with time style from the locale   '10:15:30'    <a href="../../../java/time/format/DateTimeFormatter.html#ofLocalizedDateTime-java.time.format.FormatStyle-"><code>ofLocalizedDateTime(dateTimeStyle)</code></a>   Formatter with a style for date and time from the locale  '3 Jun 2008 11:05:30'    <a href="../../../java/time/format/DateTimeFormatter.html#ofLocalizedDateTime-java.time.format.FormatStyle-"><code>ofLocalizedDateTime(dateStyle,timeStyle)</code></a>   Formatter with date and time styles from the locale   '3 Jun 2008 11:05'    <a href="../../../java/time/format/DateTimeFormatter.html#BASIC_ISO_DATE"><code>BASIC_ISO_DATE</code></a> Basic ISO date  '20111203'    <a href="../../../java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE"><code>ISO_LOCAL_DATE</code></a>  ISO Local Date  '2011-12-03'    <a href="../../../java/time/format/DateTimeFormatter.html#ISO_OFFSET_DATE"><code>ISO_OFFSET_DATE</code></a>  ISO Date with offset  '2011-12-03+01:00'    <a href="../../../java/time/format/DateTimeFormatter.html#ISO_DATE"><code>ISO_DATE</code></a>  ISO Date with or without offset   '2011-12-03+01:00'; '2011-12-03'    <a href="../../../java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME"><code>ISO_LOCAL_TIME</code></a>  Time without offset  '10:15:30'    <a href="../../../java/time/format/DateTimeFormatter.html#ISO_OFFSET_TIME"><code>ISO_OFFSET_TIME</code></a>  Time with offset  '10:15:30+01:00'    <a href="../../../java/time/format/DateTimeFormatter.html#ISO_TIME"><code>ISO_TIME</code></a>  Time with or without offset  '10:15:30+01:00'; '10:15:30'    <a href="../../../java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME"><code>ISO_LOCAL_DATE_TIME</code></a>  ISO Local Date and Time  '2011-12-03T10:15:30'    <a href="../../../java/time/format/DateTimeFormatter.html#ISO_OFFSET_DATE_TIME"><code>ISO_OFFSET_DATE_TIME</code></a>  Date Time with Offset  2011-12-03T10:15:30+01:00'    <a href="../../../java/time/format/DateTimeFormatter.html#ISO_ZONED_DATE_TIME"><code>ISO_ZONED_DATE_TIME</code></a>  Zoned Date Time  '2011-12-03T10:15:30+01:00[Europe/Paris]'    <a href="../../../java/time/format/DateTimeFormatter.html#ISO_DATE_TIME"><code>ISO_DATE_TIME</code></a>  Date and time with ZoneId  '2011-12-03T10:15:30+01:00[Europe/Paris]'    <a href="../../../java/time/format/DateTimeFormatter.html#ISO_ORDINAL_DATE"><code>ISO_ORDINAL_DATE</code></a>  Year and day of year  '2012-337'    <a href="../../../java/time/format/DateTimeFormatter.html#ISO_WEEK_DATE"><code>ISO_WEEK_DATE</code></a>  Year and Week  2012-W48-6'    <a href="../../../java/time/format/DateTimeFormatter.html#ISO_INSTANT"><code>ISO_INSTANT</code></a>  Date and Time of an Instant  '2011-12-03T10:15:30Z'     <a href="../../../java/time/format/DateTimeFormatter.html#RFC_1123_DATE_TIME"><code>RFC_1123_DATE_TIME</code></a>  RFC 1123 / RFC 822  'Tue, 3 Jun 2008 11:05:30 GMT'  </span>
<table border="0" cellpadding="2" cellspacing="3" summary="Predefined Formatters">
</table>
<h3 id="patterns"> <span>格式和解析模式</span> </h3>
<span>模式基于简单的字母和符号序列。</span>
<span>使用模式创建一个格式化器使用<a href="../../../java/time/format/DateTimeFormatter.html#ofPattern-java.lang.String-"><code>ofPattern(String)</code></a>和<a href="../../../java/time/format/DateTimeFormatter.html#ofPattern-java.lang.String-java.util.Locale-"><code>ofPattern(String, Locale)</code></a>方法。</span>
<span>例如， <code>"d MMM uuuu"</code>将格式为2011-12-03，为“2011年12月3日”。</span>
<span>从模式创建的格式化程序可以根据需要多次使用，它是不可变的并且是线程安全的。</span>
<p> <span>例如：</span> </p>
<blockquote>
<span><pre>
  DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy MM dd");
  String text = date.toString(formatter);
  LocalDate date = LocalDate.parse(text, formatter);
 </pre></span>
</blockquote>
<p> <span>所有字母“A”至“Z”和“a”至“z”保留为图案字母。</span> <span>定义了以下图案字母：</span> </p>
<pre>  <span>Symbol  Meaning                     Presentation      Examples
  ------  -------                     ------------      -------
   G       era                         text              AD; Anno Domini; A
   u       year                        year              2004; 04
   y       year-of-era                 year              2004; 04
   D       day-of-year                 number            189
   M/L     month-of-year               number/text       7; 07; Jul; July; J
   d       day-of-month                number            10

   Q/q     quarter-of-year             number/text       3; 03; Q3; 3rd quarter
   Y       week-based-year             year              1996; 96
   w       week-of-week-based-year     number            27
   W       week-of-month               number            4
   E       day-of-week                 text              Tue; Tuesday; T
   e/c     localized day-of-week       number/text       2; 02; Tue; Tuesday; T
   F       week-of-month               number            3

   a       am-pm-of-day                text              PM
   h       clock-hour-of-am-pm (1-12)  number            12
   K       hour-of-am-pm (0-11)        number            0
   k       clock-hour-of-am-pm (1-24)  number            0

   H       hour-of-day (0-23)          number            0
   m       minute-of-hour              number            30
   s       second-of-minute            number            55
   S       fraction-of-second          fraction          978
   A       milli-of-day                number            1234
   n       nano-of-second              number            987654321
   N       nano-of-day                 number            1234000000

   V       time-zone ID                zone-id           America/Los_Angeles; Z; -08:30
   z       time-zone name              zone-name         Pacific Standard Time; PST
   O       localized zone-offset       offset-O          GMT+8; GMT+08:00; UTC-08:00;
   X       zone-offset 'Z' for zero    offset-X          Z; -08; -0830; -08:30; -083015; -08:30:15;
   x       zone-offset                 offset-x          +0000; -08; -0830; -08:30; -083015; -08:30:15;
   Z       zone-offset                 offset-Z          +0000; -0800; -08:00;

   p       pad next                    pad modifier      1

   '       escape for text             delimiter
   ''      single quote                literal           '
   [       optional section start
   ]       optional section end
   #       reserved for future use
   {       reserved for future use
   }       reserved for future use</span> </pre>
<p> <span>模式字母的数量决定了格式。</span> </p>
<p> <span><b>文本</b> ：文字样式是根据所使用的图案字母数确定的。</span> <span>少于4个图案字母将使用<a href="../../../java/time/format/TextStyle.html#SHORT"><code>short form</code></a> 。</span> <span>完全4个图案字母将使用<a href="../../../java/time/format/TextStyle.html#FULL"><code>full form</code></a> 。</span> <span>完全5个图案字母将使用<a href="../../../java/time/format/TextStyle.html#NARROW"><code>narrow form</code></a> 。</span> <span>图案字母'L'，'c'和'q'指定文本样式的独立形式。</span> </p>
<p> <span><b>编号</b> ：如果字母数为1，则使用最小位数输出该值，而不填充。</span> <span>否则，使用数字计数作为输出字段的宽度，根据需要使用零填充值。</span> <span>以下模式字母对字母数的约束。</span> <span>只能指定'c'和'F'的一个字母。</span> <span>可以指定多达两个'd'，'H'，'h'，'K'，'k'，'m'和's'的字母。</span> <span>最多可以指定三个字母'D'。</span> </p>
<p> <span><b>数字/文本</b> ：如果模式字母的数量为3或更大，请使用上述文本规则。</span> <span>否则使用上面的数字规则。</span> </p>
<p> <span><b>分数</b> ：输出二分之一纳秒的场。</span> <span>纳秒值有九位数，因此模式字母的计数从1到9.如果小于9，那么纳秒值将被截断，只有最高有效位被输出。</span> <span>在严格模式下解析时，解析数字的数量必须与模式字母的数量相匹配。</span> <span>当在宽松模式下解析时，解析数字的数目必须至少为模式字母数，最多9位数。</span> </p>
<p> <span><b>年份</b> ：字母数确定使用最小字段宽度低于哪个填充。</span> <span>如果字母数为2，则使用一个<a href="../../../java/time/format/DateTimeFormatterBuilder.html#appendValueReduced-java.time.temporal.TemporalField-int-int-int-"><code>reduced</code></a>两位数的形式。</span> <span>对于打印，这将输出最右边的两位数字。</span> <span>对于解析，这将使用基数值2000解析，导致一年在2000到2099之间的范围内。</span> <span>如果字母数小于四（但不是两个），则符号只能按照<a href="../../../java/time/format/SignStyle.html#NORMAL"><code>SignStyle.NORMAL</code></a>输出为负数。</span> <span>否则，符号为输出如果超过垫宽度，按照<a href="../../../java/time/format/SignStyle.html#EXCEEDS_PAD"><code>SignStyle.EXCEEDS_PAD</code></a> 。</span> </p>
<p> <span><b>ZoneId</b> ：输出时区ID，如“Europe / Paris”。</span> <span>如果字母数为2，则输出时区ID。</span> <span>任何其他字母数字抛出<code>IllegalArgumentException</code> 。</span> </p>
<p> <span><b>区域名称</b> ：输出时区ID的显示名称。</span> <span>如果字母数为1，2或3，则输出短名称。</span> <span>如果字母数为4，则输出全名。</span> <span>五个或更多的字母抛出<code>IllegalArgumentException</code> 。</span> </p>
<p> <span><b>偏移X和x</b> ：这将根据模式字母的数量格式化偏移量。</span> <span>一个字母只输出小时，例如“+01”，除非分钟不为零，在这种情况下也输出分钟，例如“+0130”。</span> <span>两个字母输出小时和分钟，没有冒号，例如'+0130'。</span> <span>三个字母输出小时和分钟，冒号如“+01：30”。</span> <span>四个字母输出小时和分钟，可选第二个，没有冒号，例如'+013015'。</span> <span>五个字母输出小时和分钟，可选第二个，冒号如“+01：30：15”。</span> <span>六个或更多的字母抛出<code>IllegalArgumentException</code> 。</span> <span>当要输出的偏移量为零时，模式字母“X”（大写）将输出“Z”，而模式字母“x”（小写）将输出“+00”，“+0000”或“+00 ：00'。</span> </p>
<p> <span><b>偏移量O</b> ：根据模式字母的数量格式化局部偏移量。</span> <span>一个字母输出局部偏移的<a href="../../../java/time/format/TextStyle.html#SHORT">short</a>形式，这是局部偏移文本，如“GMT”，小时无前导零，可选的2位数分钟和秒，如果非零，冒号，例如'GMT + 8 '。</span> <span>四个字母输出<a href="../../../java/time/format/TextStyle.html#FULL">full</a>表格，这是一个本地化的偏移文本，例如“GMT”，具有2位小时和分钟字段，可选第二个字段（如果非零），冒号（例如'GMT + 08：00）。</span> <span>任何其他字母数字抛出<code>IllegalArgumentException</code> 。</span> </p>
<p> <span><b>偏移Z</b> ：根据模式字母的数量格式化偏移量。</span> <span>一个，两个或三个字母输出小时和分钟，没有冒号，例如'+0130'。</span> <span>当偏移为零时，输出将为“+0000”。</span> <span>四个字母输出<a href="../../../java/time/format/TextStyle.html#FULL">full</a>形式的局部偏移量，相当于Offset-O的四个字母。</span> <span>如果偏移为零，输出将为相应的局部偏移文本。</span> <span>五个字母输出小时，分钟，可选第二个（如果非零），冒号。</span> <span>如果偏移为零，则输出“Z”。</span> <span>六个或更多的字母抛出<code>IllegalArgumentException</code> 。</span> </p>
<p> <span><b>可选部分</b> ：可选部分标记与调用<a href="../../../java/time/format/DateTimeFormatterBuilder.html#optionalStart--"><code>DateTimeFormatterBuilder.optionalStart()</code></a>和<a href="../../../java/time/format/DateTimeFormatterBuilder.html#optionalEnd--"><code>DateTimeFormatterBuilder.optionalEnd()</code>完全相同</a> 。</span> </p>
<p> <span><b>垫修饰符</b> ：修改紧随其后的模式以填充空格。</span> <span>垫宽度由图案字母的数量决定。</span> <span>这与拨打<a href="../../../java/time/format/DateTimeFormatterBuilder.html#padNext-int-"><code>DateTimeFormatterBuilder.padNext(int)</code></a>相同。</span> </p>
<p> <span>例如，'ppH'输出在左边填充空格的宽度为2的小时。</span> </p>
<p> <span>任何无法识别的字母都是错误。</span> <span>除'['，']'，'{'，'}'，'＃'和单引号之外的任何非字母字符都将直接输出。</span> <span>尽管如此，建议对要直接输出的所有字符使用单引号，以确保将来的更改不会破坏您的应用程序。</span> </p>
<h3 id="resolving"> <span>解决</span> </h3>
<span>解析实现为两阶段操作。</span>
<span>首先，使用格式化程序定义的布局解析文本，产生一个<code>Map</code>的字段，一个<code>ZoneId</code>和一个<code>Chronology</code> 。</span>
<span>第二，通过验证，组合和简化各种领域，使解析的数据<em>得到解决</em> 。</span>
<p> <span>这个类提供了五种解析方法。</span> <span>其中四个执行解析和解析阶段。</span> <span>第五种方法， <a href="../../../java/time/format/DateTimeFormatter.html#parseUnresolved-java.lang.CharSequence-java.text.ParsePosition-"><code>parseUnresolved(CharSequence, ParsePosition)</code></a> ，仅执行第一阶段，留下结果未解决。</span> <span>因此，它本质上是一个低级别的操作。</span> </p>
<p> <span>解析阶段由这个类设置的两个参数控制。</span> </p>
<p> <span><a href="../../../java/time/format/ResolverStyle.html" title="枚举在java.time.format中"><code>ResolverStyle</code></a>是一种枚举，提供三种不同的方法，严格，智能和宽松。</span> <span>智能选项是默认值。</span> <span>可以使用<a href="../../../java/time/format/DateTimeFormatter.html#withResolverStyle-java.time.format.ResolverStyle-"><code>withResolverStyle(ResolverStyle)</code></a>设置。</span> </p>
<p> <span><a href="../../../java/time/format/DateTimeFormatter.html#withResolverFields-java.time.temporal.TemporalField...-"><code>withResolverFields(TemporalField...)</code></a>参数允许在解析开始之前对要解析的字段进行过滤。</span> <span>例如，如果格式化程序已经解析了一年，一个月，一个月的日子和一天，那么有两种方法可以解决一个日期：（年+月+月 - 日）和（年+一年）。</span> <span>解析器字段允许选择两种方法之一。</span> <span>如果没有设置解析器字段，则两种方法都必须产生相同的日期。</span> </p>
<p> <span>解决单独的字段以形成完整的日期和时间是一个复杂的过程，其行为分布在多个类中。</span> <span>它遵循这些步骤：</span> </p>
<ol>
<li> <span>年表是确定的。</span> <span>结果的年表是被解析的年表，或者如果没有按时间顺序被解析，那么这个时间顺序是在这个类上设置的，或者如果是空的，那么是<code>IsoChronology</code> 。</span> </li>
<li> <span><code>ChronoField</code>日期字段已解决。</span> <span>这是使用<a href="../../../java/time/chrono/Chronology.html#resolveDate-java.util.Map-java.time.format.ResolverStyle-"><code>Chronology.resolveDate(Map, ResolverStyle)</code></a>实现的。</span> <span>有关现场解析的文件位于执行<code>Chronology</code> 。</span> </li>
<li> <span><code>ChronoField</code>时间字段已解决。</span> <span>这在<code>ChronoField</code>中<a href="../../../java/time/temporal/ChronoField.html" title="枚举在java.time.temporal">有所记载</a> ，对于所有的年表都是一样的。</span> </li>
<li> <span>任何不是<code>ChronoField</code>字段都被处理。</span> <span>这是使用<a href="../../../java/time/temporal/TemporalField.html#resolve-java.util.Map-java.time.temporal.TemporalAccessor-java.time.format.ResolverStyle-"><code>TemporalField.resolve(Map, TemporalAccessor, ResolverStyle)</code></a>实现的。</span> <span>关于现场解决的文件位于执行<code>TemporalField</code> 。</span> </li>
<li> <span><code>ChronoField</code>日期和时间字段被重新解析。</span> <span>这允许第四步中的字段生成<code>ChronoField</code>值，并将它们处理为日期和时间。</span> </li>
<li> <span>如果有至少一个小时<code>LocalTime</code>则形成一个LocalTime。</span> <span>这涉及提供分秒，秒和秒的分数的默认值。</span> </li>
<li> <span>任何剩余的未解决的字段与已解决的任何日期和/或时间进行交叉检查。</span> <span>因此，较早的阶段将解决（年+月+月的日）到一个日期，这个阶段将检查星期几是有效的日期。</span> </li>
<li> <span>如果<a href="../../../java/time/format/DateTimeFormatter.html#parsedExcessDays--">excess number of days</a>被解析，那么如果有<a href="../../../java/time/format/DateTimeFormatter.html#parsedExcessDays--">可用</a>的日期，则将其添加到日期。</span> </li>
</ol>
</div>
<dl>
<dt>
<span class="simpleTagLabel">实现要求：</span>
</dt>
<dd>
         这个类是不可变的和线程安全的。 
       </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.8 
       </dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!-- --> </a> <h3>Field Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Field Summary table, listing fields, and an explanation">
<caption>
<span>Fields</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#BASIC_ISO_DATE">BASIC_ISO_DATE</a></span></code>
<div class="block">
              格式化或解析没有偏移量的日期的ISO日期格式化程序，例如“20111203”。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#ISO_DATE">ISO_DATE</a></span></code>
<div class="block">
              ISO日期格式化程序格式化或解析具有偏移量的日期（如可用），如“2011-12-03”或“2011-12-03 + 01：00”。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#ISO_DATE_TIME">ISO_DATE_TIME</a></span></code>
<div class="block">
              类似ISO的日期格式化程序，用于格式化或解析具有偏移量和区域（如果有的话）的日期时间，如“2011-12-03T10：15：30”，“2011-12-03T10：15：30 + 01” ：00'或'2011-12-03T10：15：30 + 01：00 [欧洲/巴黎]'。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#ISO_INSTANT">ISO_INSTANT</a></span></code>
<div class="block">
              ISO即时格式化程序，用于格式化或解析UTC中的即时消息，例如“2011-12-03T10：15：30Z”。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE">ISO_LOCAL_DATE</a></span></code>
<div class="block">
              ISO日期格式化程序格式化或解析没有偏移量的日期，如“2011-12-03”。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME">ISO_LOCAL_DATE_TIME</a></span></code>
<div class="block">
              ISO日期格式化程序格式化或解析没有偏移量的日期时间，例如“2011-12-03T10：15：30”。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME">ISO_LOCAL_TIME</a></span></code>
<div class="block">
              ISO时间格式化程序格式化或解析一个没有偏移量的时间，例如“10：15”或“10：15：30”。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#ISO_OFFSET_DATE">ISO_OFFSET_DATE</a></span></code>
<div class="block">
              ISO日期格式化程序格式化或解析具有偏移量的日期，例如“2011-12-03 + 01：00”。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#ISO_OFFSET_DATE_TIME">ISO_OFFSET_DATE_TIME</a></span></code>
<div class="block">
              ISO日期格式化程序格式化或解析具有偏移量的日期时间，例如“2011-12-03T10：15：30 + 01：00”。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#ISO_OFFSET_TIME">ISO_OFFSET_TIME</a></span></code>
<div class="block">
              格式化或解析时间偏移的ISO时间格式化程序，如“10：15 + 01：00”或“10：15：30 + 01：00”。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#ISO_ORDINAL_DATE">ISO_ORDINAL_DATE</a></span></code>
<div class="block">
              ISO日期格式化程序格式化或解析没有偏移量的序数日期，例如“2012-337”。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#ISO_TIME">ISO_TIME</a></span></code>
<div class="block">
              格式化或解析时间的ISO时间格式化程序，如果可用的偏移量，如“10：15”，“10：15：30”或“10：15：30 + 01：00”。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#ISO_WEEK_DATE">ISO_WEEK_DATE</a></span></code>
<div class="block">
              ISO日期格式化程序，用于格式化或解析不带偏移量的基于周的日期，例如“2012-W48-6”。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#ISO_ZONED_DATE_TIME">ISO_ZONED_DATE_TIME</a></span></code>
<div class="block">
              类似ISO的日期格式化程序，用于格式化或解析具有偏移和区域的日期时间，例如“2011-12-03T10：15：30 + 01：00 [Europe / Paris]”。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#RFC_1123_DATE_TIME">RFC_1123_DATE_TIME</a></span></code>
<div class="block">
              RFC-1123日期格式化程序，如“星期二，2008年6月3日11:05:30 GMT”。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t1"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code><a href="../../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#format-java.time.temporal.TemporalAccessor-">format</a></span>(<a href="../../../java/time/temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a> temporal)</code>
<div class="block">
              使用此格式化程序格式化日期时间对象。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#formatTo-java.time.temporal.TemporalAccessor-java.lang.Appendable-">formatTo</a></span>(<a href="../../../java/time/temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a> temporal, <a href="../../../java/lang/Appendable.html" title="interface in java.lang">Appendable</a> appendable)</code>
<div class="block">
              格式化一个日期时间对象到 
             <code>Appendable</code>使用这个格式化程序。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code><a href="../../../java/time/chrono/Chronology.html" title="interface in java.time.chrono">Chronology</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#getChronology--">getChronology</a></span>()</code>
<div class="block">
              获得在格式化期间使用的压倒一记的年表。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code><a href="../../../java/time/format/DecimalStyle.html" title="class in java.time.format">DecimalStyle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#getDecimalStyle--">getDecimalStyle</a></span>()</code>
<div class="block">
              获取在格式化期间使用的DecimalStyle。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code><a href="../../../java/util/Locale.html" title="class in java.util">Locale</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#getLocale--">getLocale</a></span>()</code>
<div class="block">
              获取格式化期间要使用的区域设置。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code><a href="../../../java/util/Set.html" title="interface in java.util">Set</a>&lt;<a href="../../../java/time/temporal/TemporalField.html" title="interface in java.time.temporal">TemporalField</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#getResolverFields--">getResolverFields</a></span>()</code>
<div class="block">
              获取在解析期间使用的解析器字段。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code><a href="../../../java/time/format/ResolverStyle.html" title="enum in java.time.format">ResolverStyle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#getResolverStyle--">getResolverStyle</a></span>()</code>
<div class="block">
              获取在解析过程中使用的解析器样式。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code><a href="../../../java/time/ZoneId.html" title="class in java.time">ZoneId</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#getZone--">getZone</a></span>()</code>
<div class="block">
              获取在格式化期间使用的覆盖区域。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#ofLocalizedDate-java.time.format.FormatStyle-">ofLocalizedDate</a></span>(<a href="../../../java/time/format/FormatStyle.html" title="enum in java.time.format">FormatStyle</a> dateStyle)</code>
<div class="block">
              返回ISO年表的区域设置特定日期格式。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#ofLocalizedDateTime-java.time.format.FormatStyle-">ofLocalizedDateTime</a></span>(<a href="../../../java/time/format/FormatStyle.html" title="enum in java.time.format">FormatStyle</a> dateTimeStyle)</code>
<div class="block">
              返回ISO时代的区域设置特定的日期时间格式化程序。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#ofLocalizedDateTime-java.time.format.FormatStyle-java.time.format.FormatStyle-">ofLocalizedDateTime</a></span>(<a href="../../../java/time/format/FormatStyle.html" title="enum in java.time.format">FormatStyle</a> dateStyle, <a href="../../../java/time/format/FormatStyle.html" title="enum in java.time.format">FormatStyle</a> timeStyle)</code>
<div class="block">
              返回ISO时代的特定日期和时间格式。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#ofLocalizedTime-java.time.format.FormatStyle-">ofLocalizedTime</a></span>(<a href="../../../java/time/format/FormatStyle.html" title="enum in java.time.format">FormatStyle</a> timeStyle)</code>
<div class="block">
              返回ISO时代的区域设置特定时间格式。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#ofPattern-java.lang.String-">ofPattern</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> pattern)</code>
<div class="block">
              使用指定的模式创建格式化程序。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#ofPattern-java.lang.String-java.util.Locale-">ofPattern</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> pattern, <a href="../../../java/util/Locale.html" title="class in java.util">Locale</a> locale)</code>
<div class="block">
              使用指定的模式和区域设置创建格式化程序。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code><a href="../../../java/time/temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#parse-java.lang.CharSequence-">parse</a></span>(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a> text)</code>
<div class="block">
              完全解析产生时间对象的文本。 
            </div> </td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code><a href="../../../java/time/temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#parse-java.lang.CharSequence-java.text.ParsePosition-">parse</a></span>(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a> text, <a href="../../../java/text/ParsePosition.html" title="class in java.text">ParsePosition</a> position)</code>
<div class="block">
              使用此格式化器解析文本，提供对文本位置的控制。 
            </div> </td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code>&lt;T&gt; T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#parse-java.lang.CharSequence-java.time.temporal.TemporalQuery-">parse</a></span>(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a> text, <a href="../../../java/time/temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;T&gt; query)</code>
<div class="block">
              完全解析产生指定类型对象的文本。 
            </div> </td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code><a href="../../../java/time/temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#parseBest-java.lang.CharSequence-java.time.temporal.TemporalQuery...-">parseBest</a></span>(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a> text, <a href="../../../java/time/temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;?&gt;... queries)</code>
<div class="block">
              完全解析产生指定类型之一的对象的文本。 
            </div> </td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>static <a href="../../../java/time/temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;<a href="../../../java/time/Period.html" title="class in java.time">Period</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#parsedExcessDays--">parsedExcessDays</a></span>()</code>
<div class="block">
              一个查询，可以访问已解析的多余天数。 
            </div> </td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>static <a href="../../../java/time/temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;<a href="../../../java/lang/Boolean.html" title="class in java.lang">Boolean</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#parsedLeapSecond--">parsedLeapSecond</a></span>()</code>
<div class="block">
              提供访问是否解析了跨越秒的查询。 
            </div> </td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code><a href="../../../java/time/temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#parseUnresolved-java.lang.CharSequence-java.text.ParsePosition-">parseUnresolved</a></span>(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a> text, <a href="../../../java/text/ParsePosition.html" title="class in java.text">ParsePosition</a> position)</code>
<div class="block">
              使用此格式化程序解析文本，而无需解析结果，用于高级用例。 
            </div> </td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code><a href="../../../java/text/Format.html" title="class in java.text">Format</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#toFormat--">toFormat</a></span>()</code>
<div class="block">
              将此格式化程序作为 
             <code>java.text.Format</code>实例返回。 
            </div> </td>
</tr>
<tr class="altColor" id="i22">
<td class="colFirst"><code><a href="../../../java/text/Format.html" title="class in java.text">Format</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#toFormat-java.time.temporal.TemporalQuery-">toFormat</a></span>(<a href="../../../java/time/temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;?&gt; parseQuery)</code>
<div class="block">
              将此格式化器返回为 
             <code>java.text.Format</code>实例，将使用指定的查询进行解析。 
            </div> </td>
</tr>
<tr class="rowColor" id="i23">
<td class="colFirst"><code><a href="../../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#toString--">toString</a></span>()</code>
<div class="block">
              返回底层格式化程序的描述。 
            </div> </td>
</tr>
<tr class="altColor" id="i24">
<td class="colFirst"><code><a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#withChronology-java.time.chrono.Chronology-">withChronology</a></span>(<a href="../../../java/time/chrono/Chronology.html" title="interface in java.time.chrono">Chronology</a> chrono)</code>
<div class="block">
              使用新的覆盖年表返回此格式化程序的副本。 
            </div> </td>
</tr>
<tr class="rowColor" id="i25">
<td class="colFirst"><code><a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#withDecimalStyle-java.time.format.DecimalStyle-">withDecimalStyle</a></span>(<a href="../../../java/time/format/DecimalStyle.html" title="class in java.time.format">DecimalStyle</a> decimalStyle)</code>
<div class="block">
              使用新的DecimalStyle返回此格式化程序的副本。 
            </div> </td>
</tr>
<tr class="altColor" id="i26">
<td class="colFirst"><code><a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#withLocale-java.util.Locale-">withLocale</a></span>(<a href="../../../java/util/Locale.html" title="class in java.util">Locale</a> locale)</code>
<div class="block">
              使用新的语言环境返回此格式化程序的副本。 
            </div> </td>
</tr>
<tr class="rowColor" id="i27">
<td class="colFirst"><code><a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#withResolverFields-java.util.Set-">withResolverFields</a></span>(<a href="../../../java/util/Set.html" title="interface in java.util">Set</a>&lt;<a href="../../../java/time/temporal/TemporalField.html" title="interface in java.time.temporal">TemporalField</a>&gt; resolverFields)</code>
<div class="block">
              使用一组新的解析器字段返回此格式化程序的副本。 
            </div> </td>
</tr>
<tr class="altColor" id="i28">
<td class="colFirst"><code><a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#withResolverFields-java.time.temporal.TemporalField...-">withResolverFields</a></span>(<a href="../../../java/time/temporal/TemporalField.html" title="interface in java.time.temporal">TemporalField</a>... resolverFields)</code>
<div class="block">
              使用一组新的解析器字段返回此格式化程序的副本。 
            </div> </td>
</tr>
<tr class="rowColor" id="i29">
<td class="colFirst"><code><a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#withResolverStyle-java.time.format.ResolverStyle-">withResolverStyle</a></span>(<a href="../../../java/time/format/ResolverStyle.html" title="enum in java.time.format">ResolverStyle</a> resolverStyle)</code>
<div class="block">
              使用新的解析器样式返回此格式化程序的副本。 
            </div> </td>
</tr>
<tr class="altColor" id="i30">
<td class="colFirst"><code><a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/time/format/DateTimeFormatter.html#withZone-java.time.ZoneId-">withZone</a></span>(<a href="../../../java/time/ZoneId.html" title="class in java.time">ZoneId</a> zone)</code>
<div class="block">
              使用新的覆盖区域返回此格式化程序的副本。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!-- --> </a> <h3>字段详细信息</h3> <a name="ISO_LOCAL_DATE">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ISO_LOCAL_DATE</h4> <pre>public static final <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_LOCAL_DATE</pre>
<div class="block">
<span>ISO日期格式化程序格式化或解析没有偏移量的日期，如“2011-12-03”。</span>
<p> <span>这将返回一个不可变形的格式化程序，能够格式化和解析ISO-8601扩展的本地日期格式。</span> <span>格式包括：</span> </p>
<ul>
<li> <span><a href="../../../java/time/temporal/ChronoField.html#YEAR"><code>year</code>的</a>四位数字以上。</span> <span>在0000到9999之间的年份将被预填零，以确保四位数。</span> <span>超出该范围的年份将有一个前缀的正或负符号。</span> </li>
<li> <span>一个破折号</span> </li>
<li> <span>两位数字为<a href="../../../java/time/temporal/ChronoField.html#MONTH_OF_YEAR"><code>month-of-year</code></a> 。</span> <span>这被预填充为零以确保两位数字。</span> </li>
<li> <span>一个破折号</span> </li>
<li> <span>两位数字为<a href="../../../java/time/temporal/ChronoField.html#DAY_OF_MONTH"><code>day-of-month</code></a> 。</span> <span>这被预填充为零以确保两位数字。</span> </li>
</ul>
<p> <span>返回的格式化程序具有ISO设置的时间顺序，以确保其他日历系统中的日期正确转换。</span> <span>它没有覆盖区域，并使用<a href="../../../java/time/format/ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器风格。</span> </p>
</div> </li>
</ul> <a name="ISO_OFFSET_DATE">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ISO_OFFSET_DATE</h4> <pre>public static final <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_OFFSET_DATE</pre>
<div class="block">
<span>ISO日期格式化程序格式化或解析具有偏移量的日期，例如“2011-12-03 + 01：00”。</span>
<p> <span>这将返回一个能够格式化和解析ISO-8601扩展偏移日期格式的不可变格式器。</span> <span>格式包括：</span> </p>
<ul>
<li> <span><a href="../../../java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE"><code>ISO_LOCAL_DATE</code></a></span> </li>
<li> <span><a href="../../../java/time/ZoneOffset.html#getId--"><code>offset ID</code></a> 。</span> <span>如果偏移量有秒，那么即使这不是ISO-8601标准的一部分，它们将被处理。</span> <span>解析不区分大小写。</span> </li>
</ul>
<p> <span>返回的格式化程序具有ISO设置的时间顺序，以确保其他日历系统中的日期正确转换。</span> <span>它没有覆盖区域，并使用<a href="../../../java/time/format/ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器风格。</span> </p>
</div> </li>
</ul> <a name="ISO_DATE">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ISO_DATE</h4> <pre>public static final <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_DATE</pre>
<div class="block">
<span>ISO日期格式化程序格式化或解析具有偏移量的日期（如可用），如“2011-12-03”或“2011-12-03 + 01：00”。</span>
<p> <span>这将返回一个不可变形的格式化程序，能够格式化和解析ISO-8601扩展日期格式。</span> <span>格式包括：</span> </p>
<ul>
<li> <span><a href="../../../java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE"><code>ISO_LOCAL_DATE</code></a></span> </li>
<li> <span>如果偏移不可用，则格式完成。</span> </li>
<li> <span><a href="../../../java/time/ZoneOffset.html#getId--"><code>offset ID</code></a> 。</span> <span>如果偏移量有秒，那么即使这不是ISO-8601标准的一部分，它们将被处理。</span> <span>解析不区分大小写。</span> </li>
</ul>
<p> <span>由于此格式化程序具有可选元素，因此可能需要使用<a href="../../../java/time/format/DateTimeFormatter.html#parseBest-java.lang.CharSequence-java.time.temporal.TemporalQuery...-"><code>parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery&lt;?&gt;...)</code></a>进行解析。</span> </p>
<p> <span>返回的格式化程序具有ISO设置的时间顺序，以确保其他日历系统中的日期正确转换。</span> <span>它没有覆盖区域，并使用<a href="../../../java/time/format/ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p>
</div> </li>
</ul> <a name="ISO_LOCAL_TIME">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ISO_LOCAL_TIME</h4> <pre>public static final <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_LOCAL_TIME</pre>
<div class="block">
<span>ISO时间格式化程序格式化或解析一个没有偏移量的时间，例如“10：15”或“10：15：30”。</span>
<p> <span>这将返回一个不可变形的格式化程序，能够格式化和解析ISO-8601扩展的本地时间格式。</span> <span>格式包括：</span> </p>
<ul>
<li> <span>两位数字为<a href="../../../java/time/temporal/ChronoField.html#HOUR_OF_DAY"><code>hour-of-day</code></a> 。</span> <span>这被预填充为零以确保两位数字。</span> </li>
<li> <span>一个冒号</span> </li>
<li> <span>两位数字为<a href="../../../java/time/temporal/ChronoField.html#MINUTE_OF_HOUR"><code>minute-of-hour</code></a> 。</span> <span>这被预填充为零以确保两位数字。</span> </li>
<li> <span>如果第二分钟不可用，则格式完成。</span> </li>
<li> <span>一个冒号</span> </li>
<li> <span>两位数字为<a href="../../../java/time/temporal/ChronoField.html#SECOND_OF_MINUTE"><code>second-of-minute</code></a> 。</span> <span>这被预填充为零以确保两位数字。</span> </li>
<li> <span>如果纳秒是零或不可用，则格式完成。</span> </li>
<li> <span>小数点</span> </li>
<li> <span>一到九位数字为<a href="../../../java/time/temporal/ChronoField.html#NANO_OF_SECOND"><code>nano-of-second</code></a> 。</span> <span>根据需要输出多个数字。</span> </li>
</ul>
<p> <span>返回的格式化程序没有覆盖年表或区域。</span> <span>它使用<a href="../../../java/time/format/ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器风格。</span> </p>
</div> </li>
</ul> <a name="ISO_OFFSET_TIME">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ISO_OFFSET_TIME</h4> <pre>public static final <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_OFFSET_TIME</pre>
<div class="block">
<span>格式化或解析时间偏移的ISO时间格式化程序，如“10：15 + 01：00”或“10：15：30 + 01：00”。</span>
<p> <span>这将返回能够格式化和解析ISO-8601扩展偏移时间格式的不可变格式器。</span> <span>格式包括：</span> </p>
<ul>
<li> <span><a href="../../../java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME"><code>ISO_LOCAL_TIME</code></a></span> </li>
<li> <span><a href="../../../java/time/ZoneOffset.html#getId--"><code>offset ID</code></a> 。</span> <span>如果偏移量有秒，那么即使这不是ISO-8601标准的一部分，它们将被处理。</span> <span>解析不区分大小写。</span> </li>
</ul>
<p> <span>返回的格式化程序没有覆盖年表或区域。</span> <span>它使用<a href="../../../java/time/format/ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p>
</div> </li>
</ul> <a name="ISO_TIME">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ISO_TIME</h4> <pre>public static final <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_TIME</pre>
<div class="block">
<span>格式化或解析时间的ISO时间格式化程序，如果可用的偏移量，如“10：15”，“10：15：30”或“10：15：30 + 01：00”。</span>
<p> <span>这将返回能够格式化和解析ISO-8601扩展偏移时间格式的不可变格式器。</span> <span>格式包括：</span> </p>
<ul>
<li> <span><a href="../../../java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME"><code>ISO_LOCAL_TIME</code></a></span> </li>
<li> <span>如果偏移不可用，则格式完成。</span> </li>
<li> <span><a href="../../../java/time/ZoneOffset.html#getId--"><code>offset ID</code></a> 。</span> <span>如果偏移量有秒，那么即使这不是ISO-8601标准的一部分，它们将被处理。</span> <span>解析不区分大小写。</span> </li>
</ul>
<p> <span>由于此格式化程序具有可选元素，因此可能需要使用<a href="../../../java/time/format/DateTimeFormatter.html#parseBest-java.lang.CharSequence-java.time.temporal.TemporalQuery...-"><code>parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery&lt;?&gt;...)</code></a>进行解析。</span> </p>
<p> <span>返回的格式化程序没有覆盖年表或区域。</span> <span>它使用<a href="../../../java/time/format/ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器风格。</span> </p>
</div> </li>
</ul> <a name="ISO_LOCAL_DATE_TIME">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ISO_LOCAL_DATE_TIME</h4> <pre>public static final <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_LOCAL_DATE_TIME</pre>
<div class="block">
<span>ISO日期格式化程序格式化或解析没有偏移量的日期时间，例如“2011-12-03T10：15：30”。</span>
<p> <span>这将返回一个不可变形的格式化器，能够格式化和解析ISO-8601扩展偏移日期时间格式。</span> <span>格式包括：</span> </p>
<ul>
<li> <span><a href="../../../java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE"><code>ISO_LOCAL_DATE</code></a></span> </li>
<li> <span>字母“T”。</span> <span>解析不区分大小写。</span> </li>
<li> <span><a href="../../../java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME"><code>ISO_LOCAL_TIME</code></a></span> </li>
</ul>
<p> <span>返回的格式化程序具有ISO设置的时间顺序，以确保其他日历系统中的日期正确转换。</span> <span>它没有覆盖区域，并使用<a href="../../../java/time/format/ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p>
</div> </li>
</ul> <a name="ISO_OFFSET_DATE_TIME">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ISO_OFFSET_DATE_TIME</h4> <pre>public static final <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_OFFSET_DATE_TIME</pre>
<div class="block">
<span>ISO日期格式化程序格式化或解析具有偏移量的日期时间，例如“2011-12-03T10：15：30 + 01：00”。</span>
<p> <span>这将返回一个不可变形的格式化器，能够格式化和解析ISO-8601扩展偏移日期时间格式。</span> <span>格式包括：</span> </p>
<ul>
<li> <span><a href="../../../java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME"><code>ISO_LOCAL_DATE_TIME</code></a></span> </li>
<li> <span><a href="../../../java/time/ZoneOffset.html#getId--"><code>offset ID</code></a> 。</span> <span>如果偏移量有秒，那么即使这不是ISO-8601标准的一部分，它们将被处理。</span> <span>解析不区分大小写。</span> </li>
</ul>
<p> <span>返回的格式化程序具有ISO设置的时间顺序，以确保其他日历系统中的日期正确转换。</span> <span>它没有覆盖区域，并使用<a href="../../../java/time/format/ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p>
</div> </li>
</ul> <a name="ISO_ZONED_DATE_TIME">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ISO_ZONED_DATE_TIME</h4> <pre>public static final <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_ZONED_DATE_TIME</pre>
<div class="block">
<span>类似ISO的日期格式化程序，用于格式化或解析具有偏移和区域的日期时间，例如“2011-12-03T10：15：30 + 01：00 [Europe / Paris]”。</span>
<p> <span>这将返回一个不可变的格式化程序，能够格式化和解析扩展ISO-8601扩展偏移日期时间格式的格式来添加时区。</span> <span>方括号中的部分不属于ISO-8601标准。</span> <span>格式包括：</span> </p>
<ul>
<li> <span><a href="../../../java/time/format/DateTimeFormatter.html#ISO_OFFSET_DATE_TIME"><code>ISO_OFFSET_DATE_TIME</code></a></span> </li>
<li> <span>如果区域ID不可用或是<code>ZoneOffset</code>则格式已完成。</span> </li>
<li> <span>一个开放的方括号'['。</span> </li>
<li> <span><a href="../../../java/time/ZoneId.html#getId--"><code>zone ID</code></a> 。</span> <span>这不是ISO-8601标准的一部分。</span> <span>解析区分大小写。</span> </li>
<li> <span>一个近方括号']'。</span> </li>
</ul>
<p> <span>返回的格式化程序具有ISO设置的时间顺序，以确保其他日历系统中的日期正确转换。</span> <span>它没有覆盖区域，并使用<a href="../../../java/time/format/ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p>
</div> </li>
</ul> <a name="ISO_DATE_TIME">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ISO_DATE_TIME</h4> <pre>public static final <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_DATE_TIME</pre>
<div class="block">
<span>类似ISO的日期格式化程序，用于格式化或解析具有偏移量和区域（如果有的话）的日期时间，如“2011-12-03T10：15：30”，“2011-12-03T10：15：30 + 01” ：00'或'2011-12-03T10：15：30 + 01：00 [欧洲/巴黎]'。</span>
<p> <span>这将返回一个不可变形的格式化程序，能够格式化和解析ISO-8601扩展本地或偏移日期时间格式，以及指定时区的扩展非ISO格式。</span> <span>格式包括：</span> </p>
<ul>
<li> <span><a href="../../../java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME"><code>ISO_LOCAL_DATE_TIME</code></a></span> </li>
<li> <span>如果偏移量不可用于格式化或解析，则格式完成。</span> </li>
<li> <span><a href="../../../java/time/ZoneOffset.html#getId--"><code>offset ID</code></a> 。</span> <span>如果偏移量有秒，那么即使这不是ISO-8601标准的一部分，它们将被处理。</span> </li>
<li> <span>如果区域ID不可用或是<code>ZoneOffset</code>则格式已完成。</span> </li>
<li> <span>一个开放的方括号'['。</span> </li>
<li> <span><a href="../../../java/time/ZoneId.html#getId--"><code>zone ID</code></a> 。</span> <span>这不是ISO-8601标准的一部分。</span> <span>解析区分大小写。</span> </li>
<li> <span>一个近方括号']'。</span> </li>
</ul>
<p> <span>由于该格式化程序具有可选元素，因此可能需要使用<a href="../../../java/time/format/DateTimeFormatter.html#parseBest-java.lang.CharSequence-java.time.temporal.TemporalQuery...-"><code>parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery&lt;?&gt;...)</code></a>进行解析。</span> </p>
<p> <span>返回的格式化程序具有ISO设置的时间顺序，以确保其他日历系统中的日期正确转换。</span> <span>它没有覆盖区域，并使用<a href="../../../java/time/format/ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器风格。</span> </p>
</div> </li>
</ul> <a name="ISO_ORDINAL_DATE">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ISO_ORDINAL_DATE</h4> <pre>public static final <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_ORDINAL_DATE</pre>
<div class="block">
<span>ISO日期格式化程序格式化或解析没有偏移量的序数日期，例如“2012-337”。</span>
<p> <span>这将返回一个不可变形格式化器，能够格式化和解析ISO-8601扩展序数日期格式。</span> <span>格式包括：</span> </p>
<ul>
<li> <span><a href="../../../java/time/temporal/ChronoField.html#YEAR"><code>year</code>的</a>四位数字以上。</span> <span>在0000到9999之间的年份将被预填零，以确保四位数。</span> <span>超出该范围的年份将有一个前缀的正或负符号。</span> </li>
<li> <span>一个破折号</span> </li>
<li> <span>三位数字为<a href="../../../java/time/temporal/ChronoField.html#DAY_OF_YEAR"><code>day-of-year</code></a> 。</span> <span>这被预填充为零以确保三位数字。</span> </li>
<li> <span>如果偏移量不可用于格式化或解析，则格式完成。</span> </li>
<li> <span><a href="../../../java/time/ZoneOffset.html#getId--"><code>offset ID</code></a> 。</span> <span>如果偏移量有秒，那么即使这不是ISO-8601标准的一部分，它们将被处理。</span> <span>解析不区分大小写。</span> </li>
</ul>
<p> <span>由于此格式化程序具有可选元素，因此可能需要使用<a href="../../../java/time/format/DateTimeFormatter.html#parseBest-java.lang.CharSequence-java.time.temporal.TemporalQuery...-"><code>parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery&lt;?&gt;...)</code></a>进行解析。</span> </p>
<p> <span>返回的格式化程序具有ISO设置的时间顺序，以确保其他日历系统中的日期正确转换。</span> <span>它没有覆盖区域，并使用<a href="../../../java/time/format/ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p>
</div> </li>
</ul> <a name="ISO_WEEK_DATE">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ISO_WEEK_DATE</h4> <pre>public static final <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_WEEK_DATE</pre>
<div class="block">
<span>ISO日期格式化程序，用于格式化或解析不带偏移量的基于周的日期，例如“2012-W48-6”。</span>
<p> <span>这将返回一个不可变的格式化程序，能够格式化和解析ISO-8601延伸的基于周的日期格式。</span> <span>格式包括：</span> </p>
<ul>
<li> <span><a href="../../../java/time/temporal/IsoFields.html#WEEK_BASED_YEAR"><code>week-based-year</code>的</a>四位数字或更多。</span> <span>在0000到9999之间的年份将被预填零，以确保四位数。</span> <span>超出该范围的年份将有一个前缀的正或负符号。</span> </li>
<li> <span>一个破折号</span> </li>
<li> <span>字母“W”。</span> <span>解析不区分大小写。</span> </li>
<li> <span>两位数字为<a href="../../../java/time/temporal/IsoFields.html#WEEK_OF_WEEK_BASED_YEAR"><code>week-of-week-based-year</code></a> 。</span> <span>这被预填充为零以确保三位数字。</span> </li>
<li> <span>一个破折号</span> </li>
<li> <span>一位数字为<a href="../../../java/time/temporal/ChronoField.html#DAY_OF_WEEK"><code>day-of-week</code></a> 。</span> <span>价值从星期一（1）到星期日（7）。</span> </li>
<li> <span>如果偏移量不可用于格式化或解析，则格式完成。</span> </li>
<li> <span><a href="../../../java/time/ZoneOffset.html#getId--"><code>offset ID</code></a> 。</span> <span>如果偏移量有秒，那么即使这不是ISO-8601标准的一部分，它们将被处理。</span> <span>解析不区分大小写。</span> </li>
</ul>
<p> <span>由于此格式化程序具有可选元素，因此可能需要使用<a href="../../../java/time/format/DateTimeFormatter.html#parseBest-java.lang.CharSequence-java.time.temporal.TemporalQuery...-"><code>parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery&lt;?&gt;...)</code></a>进行解析。</span> </p>
<p> <span>返回的格式化程序具有ISO设置的时间顺序，以确保其他日历系统中的日期正确转换。</span> <span>它没有覆盖区域，并使用<a href="../../../java/time/format/ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p>
</div> </li>
</ul> <a name="ISO_INSTANT">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ISO_INSTANT</h4> <pre>public static final <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_INSTANT</pre>
<div class="block">
<span>ISO即时格式化程序，用于格式化或解析UTC中的即时消息，例如“2011-12-03T10：15：30Z”。</span>
<p> <span>这将返回能够格式化和解析ISO-8601即时格式的不可变格式化程序。</span> <span>格式化时，总是输出第二分钟。</span> <span>根据需要，毫秒级输出零，三，六或九位数字。</span> <span>解析时，至少需要秒字段的时间。</span> <span>解析从0到9的小数秒。</span> <span>不使用本地化的十进制格式。</span> </p>
<p> <span>这是一个特殊情况格式化程序，旨在允许人类可读形式的一个<a href="../../../java/time/Instant.html" title="java.time中的类"><code>Instant</code></a> 。</span> <span><code>Instant</code>课程旨在仅代表一个时间点，内部存储从1970-01-01Z固定时期的纳秒值。</span> <span>因此， <code>Instant</code>不能格式化为日期或时间，而不提供某种形式的时区。</span> <span>格式化程序允许<code>Instant</code>格式化，通过使用ZoneOffset.UTC提供适当的<code>ZoneOffset.UTC</code> 。</span> </p>
<p> <span>格式包括：</span> </p>
<ul>
<li> <span><a href="../../../java/time/format/DateTimeFormatter.html#ISO_OFFSET_DATE_TIME"><code>ISO_OFFSET_DATE_TIME</code></a>其中即时转换为<a href="../../../java/time/temporal/ChronoField.html#INSTANT_SECONDS"><code>ChronoField.INSTANT_SECONDS</code></a>和<a href="../../../java/time/temporal/ChronoField.html#NANO_OF_SECOND"><code>ChronoField.NANO_OF_SECOND</code></a>使用<code>UTC</code>抵消。</span> <span>解析不区分大小写。</span> </li>
</ul>
<p> <span>返回的格式化程序没有覆盖年表或区域。</span> <span>它使用<a href="../../../java/time/format/ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器风格。</span> </p>
</div> </li>
</ul> <a name="BASIC_ISO_DATE">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>BASIC_ISO_DATE</h4> <pre>public static final <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> BASIC_ISO_DATE</pre>
<div class="block">
<span>格式化或解析没有偏移量的日期的ISO日期格式化程序，例如“20111203”。</span>
<p> <span>这将返回一个不可变形的格式化程序，能够格式化和解析ISO-8601基本本地日期格式。</span> <span>格式包括：</span> </p>
<ul>
<li> <span><a href="../../../java/time/temporal/ChronoField.html#YEAR"><code>year</code>的</a>四位数字。</span> <span>只支持在0000到9999的范围内。</span> </li>
<li> <span>两位数字为<a href="../../../java/time/temporal/ChronoField.html#MONTH_OF_YEAR"><code>month-of-year</code></a> 。</span> <span>这被预填充为零以确保两位数字。</span> </li>
<li> <span>两位数字为<a href="../../../java/time/temporal/ChronoField.html#DAY_OF_MONTH"><code>day-of-month</code></a> 。</span> <span>这被预填充为零以确保两位数字。</span> </li>
<li> <span>如果偏移量不可用于格式化或解析，则格式完成。</span> </li>
<li> <span><a href="../../../java/time/ZoneOffset.html#getId--"><code>offset ID</code></a>没有冒号。</span> <span>如果偏移量有秒，那么即使这不是ISO-8601标准的一部分，它们将被处理。</span> <span>解析不区分大小写。</span> </li>
</ul>
<p> <span>由于此格式化程序具有可选元素，因此可能需要使用<a href="../../../java/time/format/DateTimeFormatter.html#parseBest-java.lang.CharSequence-java.time.temporal.TemporalQuery...-"><code>parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery&lt;?&gt;...)</code></a>进行解析。</span> </p>
<p> <span>返回的格式化程序具有ISO设置的时间顺序，以确保其他日历系统中的日期正确转换。</span> <span>它没有覆盖区域，并使用<a href="../../../java/time/format/ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p>
</div> </li>
</ul> <a name="RFC_1123_DATE_TIME">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>RFC_1123_DATE_TIME</h4> <pre>public static final <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> RFC_1123_DATE_TIME</pre>
<div class="block">
<span>RFC-1123日期格式化程序，如“星期二，2008年6月3日11:05:30 GMT”。</span>
<p> <span>这返回一个不可变的格式化器，能够格式化和解析大部分的RFC-1123格式。</span> <span>RFC-1123更新RFC-822将年份从两位数更改为四位。</span> <span>该实施需要四位数的年份。</span> <span>这种实施也不会处理北美或军区的名称，只有'GMT'和偏移量。</span> </p>
<p> <span>格式包括：</span> </p>
<ul>
<li> <span>如果星期几不可用于格式化或解析，然后跳到月份。</span> </li>
<li> <span>三个字母<a href="../../../java/time/temporal/ChronoField.html#DAY_OF_WEEK"><code>day-of-week</code></a>用英文。</span> </li>
<li> <span>一个逗号</span> </li>
<li> <span>一个空间</span> </li>
<li> <span><a href="../../../java/time/temporal/ChronoField.html#DAY_OF_MONTH"><code>day-of-month</code>的</a>一位或两位数字。</span> </li>
<li> <span>一个空间</span> </li>
<li> <span>三个字母<a href="../../../java/time/temporal/ChronoField.html#MONTH_OF_YEAR"><code>month-of-year</code></a>英文。</span> </li>
<li> <span>一个空间</span> </li>
<li> <span><a href="../../../java/time/temporal/ChronoField.html#YEAR"><code>year</code>的</a>四位数字。</span> <span>只支持在0000到9999的范围内。</span> </li>
<li> <span>一个空间</span> </li>
<li> <span>两位数字为<a href="../../../java/time/temporal/ChronoField.html#HOUR_OF_DAY"><code>hour-of-day</code></a> 。</span> <span>这被预填充为零以确保两位数字。</span> </li>
<li> <span>一个冒号</span> </li>
<li> <span>两位数字为<a href="../../../java/time/temporal/ChronoField.html#MINUTE_OF_HOUR"><code>minute-of-hour</code></a> 。</span> <span>这被预填充为零以确保两位数字。</span> </li>
<li> <span>如果第二分钟不可用，则跳转到下一个空格。</span> </li>
<li> <span>一个冒号</span> </li>
<li> <span>两位数字为<a href="../../../java/time/temporal/ChronoField.html#SECOND_OF_MINUTE"><code>second-of-minute</code></a> 。</span> <span>这被预填充为零以确保两位数字。</span> </li>
<li> <span>一个空间</span> </li>
<li> <span><a href="../../../java/time/ZoneOffset.html#getId--"><code>offset ID</code></a>没有冒号或秒。</span> <span>零偏移使用“GMT”。</span> <span>北美地区名称和军区名称不予处理。</span> </li>
</ul>
<p> <span>解析不区分大小写。</span> </p>
<p> <span>返回的格式化程序具有ISO设置的时间顺序，以确保其他日历系统中的日期正确转换。</span> <span>它没有覆盖区域，并使用<a href="../../../java/time/format/ResolverStyle.html#SMART"><code>SMART</code></a>解析器样式。</span> </p>
</div> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="ofPattern-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ofPattern</h4> <pre>public static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ofPattern(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> pattern)</pre>
<div class="block">
<span>使用指定的模式创建格式化程序。</span>
<p> <span>此方法将根据类文档中所述的简单<a href="#patterns">pattern of letters and symbols</a>创建一个格式化程序。</span> <span>例如， <code>d MMM uuuu</code>将格式为2011-12-03，为“2011年12月3日”。</span> </p>
<p> <span>格式化程序将使用<a href="../../../java/util/Locale.html#getDefault-java.util.Locale.Category-"><code>default FORMAT locale</code></a> 。</span> <span>这可以使用返回的格式化<a href="../../../java/time/format/DateTimeFormatter.html#withLocale-java.util.Locale-">器</a>上的<code>withLocale(Locale)</code>进行更改或者使用此方法的<a href="../../../java/time/format/DateTimeFormatter.html#ofPattern-java.lang.String-java.util.Locale-"><code>ofPattern(String, Locale)</code></a>变体。</span> </p>
<p> <span>返回的格式化程序没有覆盖年表或区域。</span> <span>它使用<a href="../../../java/time/format/ResolverStyle.html#SMART"><code>SMART</code></a>解析器风格。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>pattern</code> - 要使用的模式，不为空 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             格式化程序基于模式，不为空 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果模式无效 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/time/format/DateTimeFormatterBuilder.html#appendPattern-java.lang.String-"><code>DateTimeFormatterBuilder.appendPattern(String)</code></a>
</dd>
</dl> </li>
</ul> <a name="ofPattern-java.lang.String-java.util.Locale-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ofPattern</h4> <pre>public static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ofPattern(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> pattern,
                                          <a href="../../../java/util/Locale.html" title="class in java.util">Locale</a> locale)</pre>
<div class="block">
<span>使用指定的模式和区域设置创建格式化程序。</span>
<p> <span>该方法将根据类文档中所述的简单<a href="#patterns">pattern of letters and symbols</a>创建一个格式化程序。</span> <span>例如， <code>d MMM uuuu</code>将格式为2011-12-03为“2011年12月3日”。</span> </p>
<p> <span>格式化程序将使用指定的区域设置。</span> <span>这可以使用返回的格式化<a href="../../../java/time/format/DateTimeFormatter.html#withLocale-java.util.Locale-">程序</a>上的<code>withLocale(Locale)</code>进行更改</span> </p>
<p> <span>返回的格式化程序没有覆盖年表或区域。</span> <span>它使用<a href="../../../java/time/format/ResolverStyle.html#SMART"><code>SMART</code></a>解析器风格。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>pattern</code> - 要使用的模式，不为空 
           </dd>
<dd>
<code>locale</code> - 要使用的语言环境，不为空 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             格式化程序基于模式，不为空 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果模式无效 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/time/format/DateTimeFormatterBuilder.html#appendPattern-java.lang.String-"><code>DateTimeFormatterBuilder.appendPattern(String)</code></a>
</dd>
</dl> </li>
</ul> <a name="ofLocalizedDate-java.time.format.FormatStyle-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ofLocalizedDate</h4> <pre>public static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ofLocalizedDate(<a href="../../../java/time/format/FormatStyle.html" title="enum in java.time.format">FormatStyle</a> dateStyle)</pre>
<div class="block">
<span>返回ISO年表的区域设置特定日期格式。</span>
<p> <span>这将返回格式化程序，以格式化或解析日期。</span> <span>所使用的确切格式模式因地区而异。</span> </p>
<p> <span>区域设置是从格式化程序确定的。</span> <span>通过此方法直接返回的格式化程序将使用<a href="../../../java/util/Locale.html#getDefault-java.util.Locale.Category-"><code>default FORMAT locale</code></a> 。</span> <span>可以使用<a href="../../../java/time/format/DateTimeFormatter.html#withLocale-java.util.Locale-"><code>withLocale(Locale)</code></a>对该方法的结果进行控制。</span> </p>
<p> <span>请注意，本地化模式被懒惰地查找。</span> <span>这个<code>DateTimeFormatter</code>拥有所需的风格和语言环境，查找需要的图案。</span> </p>
<p> <span>返回的格式化程序具有ISO设置的时间顺序，以确保其他日历系统中的日期正确转换。</span> <span>它没有覆盖区域，并使用<a href="../../../java/time/format/ResolverStyle.html#SMART"><code>SMART</code></a>解析器样式。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>dateStyle</code> - 获取格式化器样式，不为null 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             日期格式化程序，不为null 
           </dd>
</dl> </li>
</ul> <a name="ofLocalizedTime-java.time.format.FormatStyle-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ofLocalizedTime</h4> <pre>public static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ofLocalizedTime(<a href="../../../java/time/format/FormatStyle.html" title="enum in java.time.format">FormatStyle</a> timeStyle)</pre>
<div class="block">
<span>返回ISO时代的区域设置特定时间格式。</span>
<p> <span>这将返回一个格式化程序，用于格式化或解析一个时间。</span> <span>所使用的确切格式模式因地区而异。</span> </p>
<p> <span>区域设置是从格式化程序确定的。</span> <span>通过此方法直接返回的格式化程序将使用<a href="../../../java/util/Locale.html#getDefault-java.util.Locale.Category-"><code>default FORMAT locale</code></a> 。</span> <span>可以使用<a href="../../../java/time/format/DateTimeFormatter.html#withLocale-java.util.Locale-"><code>withLocale(Locale)</code></a>对该方法的结果进行控制。</span> </p>
<p> <span>请注意，本地化模式被懒惰地查找。</span> <span>这个<code>DateTimeFormatter</code>拥有所需的风格和语言环境，查找需要的模式。</span> </p>
<p> <span>返回的格式化程序具有ISO设置的时间顺序，以确保其他日历系统中的日期正确转换。</span> <span>它没有覆盖区域，并使用<a href="../../../java/time/format/ResolverStyle.html#SMART"><code>SMART</code></a>解析器样式。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>timeStyle</code> - 获取格式化程序样式，不为null 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             时间格式化，不为空 
           </dd>
</dl> </li>
</ul> <a name="ofLocalizedDateTime-java.time.format.FormatStyle-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ofLocalizedDateTime</h4> <pre>public static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ofLocalizedDateTime(<a href="../../../java/time/format/FormatStyle.html" title="enum in java.time.format">FormatStyle</a> dateTimeStyle)</pre>
<div class="block">
<span>返回ISO时代的区域设置特定的日期时间格式化程序。</span>
<p> <span>这将返回格式化程序，以格式化或解析日期时间。</span> <span>所使用的确切格式模式因地区而异。</span> </p>
<p> <span>区域设置是从格式化程序确定的。</span> <span>通过此方法直接返回的格式化程序将使用<a href="../../../java/util/Locale.html#getDefault-java.util.Locale.Category-"><code>default FORMAT locale</code></a> 。</span> <span>该方法的结果可以使用<a href="../../../java/time/format/DateTimeFormatter.html#withLocale-java.util.Locale-"><code>withLocale(Locale)</code>控制</a>该区域设置。</span> </p>
<p> <span>请注意，本地化模式被懒惰地查找。</span> <span>这个<code>DateTimeFormatter</code>拥有所需的风格和语言环境，查找需要的模式。</span> </p>
<p> <span>返回的格式化程序具有ISO设置的时间顺序，以确保其他日历系统中的日期正确转换。</span> <span>它没有覆盖区域，并使用<a href="../../../java/time/format/ResolverStyle.html#SMART"><code>SMART</code></a>解析器样式。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>dateTimeStyle</code> - 获取的格式化器样式，不为null 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             日期时间格式化程序，不为空 
           </dd>
</dl> </li>
</ul> <a name="ofLocalizedDateTime-java.time.format.FormatStyle-java.time.format.FormatStyle-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ofLocalizedDateTime</h4> <pre>public static <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ofLocalizedDateTime(<a href="../../../java/time/format/FormatStyle.html" title="enum in java.time.format">FormatStyle</a> dateStyle,
                                                    <a href="../../../java/time/format/FormatStyle.html" title="enum in java.time.format">FormatStyle</a> timeStyle)</pre>
<div class="block">
<span>返回ISO时代的特定日期和时间格式。</span>
<p> <span>这将返回格式化程序，以格式化或解析日期时间。</span> <span>所使用的确切格式模式因地区而异。</span> </p>
<p> <span>区域设置是从格式化程序确定的。</span> <span>通过此方法直接返回的格式化程序将使用<a href="../../../java/util/Locale.html#getDefault--"><code>default FORMAT locale</code></a> 。</span> <span>可以使用<a href="../../../java/time/format/DateTimeFormatter.html#withLocale-java.util.Locale-"><code>withLocale(Locale)</code></a>对该方法的结果进行控制。</span> </p>
<p> <span>请注意，本地化模式被懒惰地查找。</span> <span>这个<code>DateTimeFormatter</code>拥有所需的风格和语言环境，查找需要的模式。</span> </p>
<p> <span>返回的格式化程序具有ISO设置的时间顺序，以确保其他日历系统中的日期正确转换。</span> <span>它没有覆盖区域，并使用<a href="../../../java/time/format/ResolverStyle.html#SMART"><code>SMART</code></a>解析器样式。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>dateStyle</code> - 获取的日期格式化程序样式，不为null 
           </dd>
<dd>
<code>timeStyle</code> - 获取的时间格式化器样式，不为null 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             日期，时间或日期时间格式化程序，不为空 
           </dd>
</dl> </li>
</ul> <a name="parsedExcessDays--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parsedExcessDays</h4> <pre>public static final <a href="../../../java/time/temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;<a href="../../../java/time/Period.html" title="class in java.time">Period</a>&gt; parsedExcessDays()</pre>
<div class="block">
<span>一个查询，可以访问已解析的多余天数。</span>
<p> <span>这将返回一个单例<a href="../../../java/time/temporal/TemporalQuery.html" title="java.time.temporal中的接口">query</a> ，它可以从解析中访问附加信息。</span> <span>查询始终返回一个非空期，返回零期，而不是null。</span> </p>
<p> <span>有两种情况，即该查询可能返回非零期。</span> </p>
<ul>
<li> <span>如果<code>ResolverStyle</code>是<code>LENIENT</code> ，并且没有日期的时间被解析，则解析的完整结果由天数<code>LocalTime</code>和过剩的<code>Period</code>组成。</span> </li>
<li> <span>如果<code>ResolverStyle</code>是<code>SMART</code> ，并在那里的时间是24:00:00，一时间不注日期的解析，则解析的完整结果由的<code>LocalTime</code> 00:00:00和过量<code>Period</code>一天。</span> </li>
</ul>
<p> <span>在这两种情况下，如果完整的<code>ChronoLocalDateTime</code>或<code>Instant</code>被解析，则多余的天数将添加到日期部分。</span> <span>因此，此查询将返回零期。</span> </p>
<p> <span><code>SMART</code>行为处理常见的“结束”24:00的值。</span> <span>在<code>LENIENT</code>模式下处理也产生相同的结果：</span> </p>
<pre>  <span>Text to parse        Parsed object                         Excess days
  "2012-12-03T00:00"   LocalDateTime.of(2012, 12, 3, 0, 0)   ZERO
  "2012-12-03T24:00"   LocalDateTime.of(2012, 12, 4, 0, 0)   ZERO
  "00:00"              LocalTime.of(0, 0)                    ZERO
  "24:00"              LocalTime.of(0, 0)                    Period.ofDays(1)</span> </pre>
<span>查询可以使用如下：</span>
<pre>  <span>TemporalAccessor parsed = formatter.parse(str);
  LocalTime time = parsed.query(LocalTime::from);
  Period extraDays = parsed.query(DateTimeFormatter.parsedExcessDays());</span> </pre>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个查询，可以访问已解析的多余天数 
           </dd>
</dl> </li>
</ul> <a name="parsedLeapSecond--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parsedLeapSecond</h4> <pre>public static final <a href="../../../java/time/temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;<a href="../../../java/lang/Boolean.html" title="class in java.lang">Boolean</a>&gt; parsedLeapSecond()</pre>
<div class="block">
<span>提供访问是否解析了跨越秒的查询。</span>
<p> <span>这将返回一个单例<a href="../../../java/time/temporal/TemporalQuery.html" title="java.time.temporal中的接口">query</a> ，它提供对解析中附加信息的访问。</span> <span>查询总是返回一个非空的布尔值，如果解析看到一个闰秒，则返回true，否则返回false。</span> </p>
<p> <span>即时解析处理“23：59：60”的特殊“闰秒”时间。</span> <span>在UTC时区的“23：59：60”发生跳跃秒，但在不同时区的其他本地时间。</span> <span>为了避免这种潜在的歧义，闰秒的处理限制为<a href="../../../java/time/format/DateTimeFormatterBuilder.html#appendInstant--"><code>DateTimeFormatterBuilder.appendInstant()</code></a> ，因为该方法总是使用UTC区域偏移解析瞬间。</span> </p>
<p> <span>如果接收到'23：59：60'的时间，则应用简单的转换，用59替换第60分钟。该查询可以用于解析结果，以确定闰秒调整是否为制作。</span> <span>查询将返回一秒的超量，如果它调整以删除闰秒，零如果不是。</span> <span>请注意，应用跨平台的平滑机制，如UTC-SLS，是应用程序的责任，如下所示：</span> </p>
<pre>  <span>TemporalAccessor parsed = formatter.parse(str);
  Instant instant = parsed.query(Instant::from);
  if (parsed.query(DateTimeFormatter.parsedLeapSecond())) {
    // validate leap-second is correct and apply correct smoothing
  }</span> </pre>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个提供访问是否解析了闰秒的查询 
           </dd>
</dl> </li>
</ul> <a name="getLocale--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getLocale</h4> <pre>public <a href="../../../java/util/Locale.html" title="class in java.util">Locale</a> getLocale()</pre>
<div class="block">
<span>获取格式化期间要使用的区域设置。</span>
<p> <span>这用于查找需要特定本地化的格式化程序的任何部分，例如文本或本地化模式。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个格式化程序的区域设置不为空 
           </dd>
</dl> </li>
</ul> <a name="withLocale-java.util.Locale-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>withLocale</h4> <pre>public <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> withLocale(<a href="../../../java/util/Locale.html" title="class in java.util">Locale</a> locale)</pre>
<div class="block">
<span>使用新的语言环境返回此格式化程序的副本。</span>
<p> <span>这用于查找需要特定本地化的格式化程序的任何部分，例如文本或本地化模式。</span> </p>
<p> <span>此实例是不可变的，不受此方法调用的影响。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>locale</code> - 新的区域设置，不为null 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个基于格式化程序的格式化程序，具有所请求的区域设置，不为null 
           </dd>
</dl> </li>
</ul> <a name="getDecimalStyle--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getDecimalStyle</h4> <pre>public <a href="../../../java/time/format/DecimalStyle.html" title="class in java.time.format">DecimalStyle</a> getDecimalStyle()</pre>
<div class="block">
            获取在格式化期间使用的DecimalStyle。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个格式化程序的区域设置不为空 
           </dd>
</dl> </li>
</ul> <a name="withDecimalStyle-java.time.format.DecimalStyle-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>withDecimalStyle</h4> <pre>public <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> withDecimalStyle(<a href="../../../java/time/format/DecimalStyle.html" title="class in java.time.format">DecimalStyle</a> decimalStyle)</pre>
<div class="block">
<span>使用新的DecimalStyle返回此格式化程序的副本。</span>
<p> <span>此实例是不可变的，不受此方法调用的影响。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>decimalStyle</code> - 新的DecimalStyle，不为null 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个格式化程序基于该格式化程序与请求的DecimalStyle，不为null 
           </dd>
</dl> </li>
</ul> <a name="getChronology--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getChronology</h4> <pre>public <a href="../../../java/time/chrono/Chronology.html" title="interface in java.time.chrono">Chronology</a> getChronology()</pre>
<div class="block">
<span>获得在格式化期间使用的压倒一记的年表。</span>
<p> <span>这将返回覆盖年表，用于转换日期。</span> <span>默认情况下，格式化程序没有覆盖时间顺序，返回null。</span> <span>有关<a href="../../../java/time/format/DateTimeFormatter.html#withChronology-java.time.chrono.Chronology-">覆盖</a>的更多细节，请参阅<code>withChronology(Chronology)</code>。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个格式化器的覆盖年表，如果没有覆盖，则为null 
           </dd>
</dl> </li>
</ul> <a name="withChronology-java.time.chrono.Chronology-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>withChronology</h4> <pre>public <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> withChronology(<a href="../../../java/time/chrono/Chronology.html" title="interface in java.time.chrono">Chronology</a> chrono)</pre>
<div class="block">
<span>使用新的覆盖年表返回此格式化程序的副本。</span>
<p> <span>这会返回一个格式化器，具有与该格式化程序相似的状态，但是覆盖时间顺序集。</span> <span>默认情况下，格式化程序没有覆盖时间顺序，返回null。</span> </p>
<p> <span>如果添加了覆盖，则格式化或解析的任何日期都将受到影响。</span> </p>
<p> <span>格式化时，如果时间对象包含日期，那么它将被转换为覆盖年表中的日期。</span> <span>是否包含日期是通过查询<a href="../../../java/time/temporal/ChronoField.html#EPOCH_DAY"><code>EPOCH_DAY</code></a>字段来确定的。</span> <span>任何时间或区域将保留不变，除非被覆盖。</span> </p>
<p> <span>如果时间对象不包含日期，但包含一个或多个<code>ChronoField</code>日期字段，则抛出<code>DateTimeException</code> 。</span> <span>在所有其他情况下，覆盖年表被添加到时间，替换任何以前的年表，但不更改日期/时间。</span> </p>
<p> <span>解析时有两种不同的情况需要考虑。</span> <span>如果一个年表从文本中直接解析出来，也许因为使用了<a href="../../../java/time/format/DateTimeFormatterBuilder.html#appendChronologyId--"><code>DateTimeFormatterBuilder.appendChronologyId()</code></a> ，那么这个覆盖年表没有任何效果。</span> <span>如果没有分区被解析，那么这个覆盖年表将用于根据年表的日期解析规则将<code>ChronoField</code>值解释为日期。</span> </p>
<p> <span>此实例是不可变的，不受此方法调用的影响。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>chrono</code> - 新的年表，如果不覆盖，则为null 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个基于该格式化器的格式化程序，具有请求的覆盖时间顺序，不为null 
           </dd>
</dl> </li>
</ul> <a name="getZone--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getZone</h4> <pre>public <a href="../../../java/time/ZoneId.html" title="class in java.time">ZoneId</a> getZone()</pre>
<div class="block">
<span>获取在格式化期间使用的覆盖区域。</span>
<p> <span>这将返回覆盖区域，用于转换时刻。</span> <span>默认情况下，格式化程序没有覆盖区域，返回null。</span> <span>有关<a href="../../../java/time/format/DateTimeFormatter.html#withZone-java.time.ZoneId-">覆盖</a>的更多细节，请参阅<code>withZone(ZoneId)</code>。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             该格式化程序的覆盖区域为null，如果不覆盖则为null 
           </dd>
</dl> </li>
</ul> <a name="withZone-java.time.ZoneId-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>withZone</h4> <pre>public <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> withZone(<a href="../../../java/time/ZoneId.html" title="class in java.time">ZoneId</a> zone)</pre>
<div class="block">
<span>使用新的覆盖区域返回此格式化程序的副本。</span>
<p> <span>这将返回一个格式化程序，具有与该格式化程序类似的状态，但是覆盖区域设置。</span> <span>默认情况下，格式化程序没有覆盖区域，返回null。</span> </p>
<p> <span>如果添加了覆盖，则格式化或解析的任何即时将受到影响。</span> </p>
<p> <span>格式化时，如果时间对象包含一个瞬间，则将使用覆盖区域将其转换为分区的日期时间。</span> <span>是否通过查询<a href="../../../java/time/temporal/ChronoField.html#INSTANT_SECONDS"><code>INSTANT_SECONDS</code></a>字段确定时间是否即时。</span> <span>如果输入具有时间顺序，那么它将被保留，除非被覆盖。</span> <span>如果输入没有时间顺序，例如<code>Instant</code> ，那么将使用ISO年表。</span> </p>
<p> <span>如果时间对象不包含一个时刻，但是包含一个偏移量，则进行额外的检查。</span> <span>如果归一化覆盖区域是与时间偏移量不同的偏移量，则抛出<code>DateTimeException</code> 。</span> <span>在所有其他情况下，将覆盖区域添加到时间，替换任何先前的区域，但不更改日期/时间。</span> </p>
<p> <span>解析时有两种不同的情况需要考虑。</span> <span>如果一个区域直接从文本中解析出来，也许是因为使用了<a href="../../../java/time/format/DateTimeFormatterBuilder.html#appendZoneId--"><code>DateTimeFormatterBuilder.appendZoneId()</code></a> ，那么这个覆盖区域就没有效果。</span> <span>如果没有分区被解析，那么这个覆盖区域将包含在解析结果中，可以用于构建时间和日期时间。</span> </p>
<p> <span>此实例是不可变的，不受此方法调用的影响。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>zone</code> - 新的覆盖区域，如果不覆盖，则为null 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个格式化程序基于该格式化程序与请求的覆盖区域，不为null 
           </dd>
</dl> </li>
</ul> <a name="getResolverStyle--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getResolverStyle</h4> <pre>public <a href="../../../java/time/format/ResolverStyle.html" title="enum in java.time.format">ResolverStyle</a> getResolverStyle()</pre>
<div class="block">
<span>获取在解析过程中使用的解析器样式。</span>
<p> <span>这将返回解析器样式，当字段解析为日期和时间时，在解析的第二阶段使用。</span> <span>默认情况下， <a href="../../../java/time/format/ResolverStyle.html#SMART">格式化</a>程序具有<a href="../../../java/time/format/ResolverStyle.html#SMART"><code>SMART</code></a>解析器样式。</span> <span>详见<a href="../../../java/time/format/DateTimeFormatter.html#withResolverStyle-java.time.format.ResolverStyle-"><code>withResolverStyle(ResolverStyle)</code></a> 。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个格式化程序的解析器样式，不为null 
           </dd>
</dl> </li>
</ul> <a name="withResolverStyle-java.time.format.ResolverStyle-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>withResolverStyle</h4> <pre>public <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> withResolverStyle(<a href="../../../java/time/format/ResolverStyle.html" title="enum in java.time.format">ResolverStyle</a> resolverStyle)</pre>
<div class="block">
<span>使用新的解析器样式返回此格式化程序的副本。</span>
<p> <span>这会返回一个格式化程序，与格式化程序具有类似的状态，但是会使用解析器样式集。</span> <span>默认情况下， <a href="../../../java/time/format/ResolverStyle.html#SMART">格式化</a>程序具有<a href="../../../java/time/format/ResolverStyle.html#SMART"><code>SMART</code></a>解析器样式。</span> </p>
<p> <span>更改解析器样式只能在解析过程中产生效果。</span> <span>解析文本字符串分两个阶段。</span> <span>阶段1是根据添加到构建器的字段的基本文本解析。</span> <span>阶段2将解析的字段值对解析为日期和/或时间对象。</span> <span>解析器样式用于控制阶段2，解决方式的发生。</span> <span>有关<code>ResolverStyle</code>选项的更多信息，请参阅ResolverStyle。</span> </p>
<p> <span>此实例是不可变的，不受此方法调用的影响。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>resolverStyle</code> - 新的解析器样式，不为null 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个基于格式化器的格式化程序，具有请求的解析器样式，不为空 
           </dd>
</dl> </li>
</ul> <a name="getResolverFields--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getResolverFields</h4> <pre>public <a href="../../../java/util/Set.html" title="interface in java.util">Set</a>&lt;<a href="../../../java/time/temporal/TemporalField.html" title="interface in java.time.temporal">TemporalField</a>&gt; getResolverFields()</pre>
<div class="block">
<span>获取在解析期间使用的解析器字段。</span>
<p> <span>这将返回解析器字段，当字段解析为日期和时间时，在解析的第二阶段使用。</span> <span>默认情况下，格式化程序没有解析器字段，因此返回null。</span> <span>详见<a href="../../../java/time/format/DateTimeFormatter.html#withResolverFields-java.util.Set-"><code>withResolverFields(Set)</code></a> 。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个格式化程序的不可变解析器字段集合，如果没有字段则为null 
           </dd>
</dl> </li>
</ul> <a name="withResolverFields-java.time.temporal.TemporalField...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>withResolverFields</h4> <pre>public <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> withResolverFields(<a href="../../../java/time/temporal/TemporalField.html" title="interface in java.time.temporal">TemporalField</a>... resolverFields)</pre>
<div class="block">
<span>使用一组新的解析器字段返回此格式化程序的副本。</span>
<p> <span>这将返回一个格式化程序，与格式化程序具有相似的状态，但解析器字段设置。</span> <span>默认情况下，格式化程序没有解析器字段。</span> </p>
<p> <span>在解析过程中，更改解析器字段仅具有效果。</span> <span>解析文本字符串分两个阶段。</span> <span>阶段1是根据添加到构建器的字段的基本文本解析。</span> <span>阶段2将解析的字段值对解析为日期和/或时间对象。</span> <span>解析器字段用于过滤阶段1和阶段2之间的字段值对。</span> </p>
<p> <span>这可以用于在日期或时间可能被解决的两种或更多种方式之间进行选择。</span> <span>例如，如果格式化程序由年，月，日，月和日等组成，那么有两种方法来解决日期。</span> <span>使用参数<a href="../../../java/time/temporal/ChronoField.html#YEAR"><code>YEAR</code></a>和<a href="../../../java/time/temporal/ChronoField.html#DAY_OF_YEAR"><code>DAY_OF_YEAR</code></a>调用此方法将确保使用年份和日期解决日期，有效地意味着在解决阶段忽略月份和日期。</span> </p>
<p> <span>以类似的方式，该方法可以用于忽略否则将被交叉检查的次级字段。</span> <span>例如，如果格式化程序由年份，月份，月份和星期几组成，则只有一种方法可以解决日期，但是每周的解析值将被交叉检查反对解决日期。</span> <span>调用此方法与参数<a href="../../../java/time/temporal/ChronoField.html#YEAR"><code>YEAR</code></a> ， <a href="../../../java/time/temporal/ChronoField.html#MONTH_OF_YEAR"><code>MONTH_OF_YEAR</code></a>和<a href="../../../java/time/temporal/ChronoField.html#DAY_OF_MONTH"><code>DAY_OF_MONTH</code></a>将确保日期是正确解决，但没有任何交叉检查的某一天的一周。</span> </p>
<p> <span>在实现方面，该方法的行为如下。</span> <span>分析阶段的结果可以被认为是一个字段到值的映射。</span> <span>此方法的行为是使该映射在阶段1和阶段2之间进行过滤，除去除了指定为该方法的参数之外的所有字段。</span> </p>
<p> <span>此实例是不可变的，不受此方法调用的影响。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>resolverFields</code> - 新的解析器字段集合，如果没有字段则为null 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个基于格式化器的格式化程序，具有请求的解析器样式，不为空 
           </dd>
</dl> </li>
</ul> <a name="withResolverFields-java.util.Set-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>withResolverFields</h4> <pre>public <a href="../../../java/time/format/DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> withResolverFields(<a href="../../../java/util/Set.html" title="interface in java.util">Set</a>&lt;<a href="../../../java/time/temporal/TemporalField.html" title="interface in java.time.temporal">TemporalField</a>&gt; resolverFields)</pre>
<div class="block">
<span>使用一组新的解析器字段返回此格式化程序的副本。</span>
<p> <span>这将返回一个格式化程序，与格式化程序具有相似的状态，但解析器字段设置。</span> <span>默认情况下，格式化程序没有解析器字段。</span> </p>
<p> <span>在解析过程中，更改解析器字段仅具有效果。</span> <span>解析文本字符串分两个阶段。</span> <span>阶段1是根据添加到构建器的字段的基本文本解析。</span> <span>阶段2将解析的字段值对解析为日期和/或时间对象。</span> <span>解析器字段用于过滤阶段1和阶段2之间的字段值对。</span> </p>
<p> <span>这可以用于在日期或时间可能被解决的两种或更多种方式之间进行选择。</span> <span>例如，如果格式化程序由年，月，日，月和日等组成，那么有两种方法来解决日期。</span> <span>使用参数<a href="../../../java/time/temporal/ChronoField.html#YEAR"><code>YEAR</code></a>和<a href="../../../java/time/temporal/ChronoField.html#DAY_OF_YEAR"><code>DAY_OF_YEAR</code></a>调用此方法将确保使用年份和日期解决日期，有效地意味着在解决阶段忽略月份和日期。</span> </p>
<p> <span>以类似的方式，该方法可以用于忽略否则将被交叉检查的次级字段。</span> <span>例如，如果格式化程序由年份，月份，月份和星期几组成，则只有一种方法可以解决日期，但是每周的解析值将被交叉检查反对解决日期。</span> <span>调用此方法与参数<a href="../../../java/time/temporal/ChronoField.html#YEAR"><code>YEAR</code></a> ， <a href="../../../java/time/temporal/ChronoField.html#MONTH_OF_YEAR"><code>MONTH_OF_YEAR</code></a>和<a href="../../../java/time/temporal/ChronoField.html#DAY_OF_MONTH"><code>DAY_OF_MONTH</code></a>将确保日期是正确解决，但没有任何交叉检查的某一天的一周。</span> </p>
<p> <span>在实现方面，该方法的行为如下。</span> <span>分析阶段的结果可以被认为是一个字段到值的映射。</span> <span>此方法的行为是使该映射在阶段1和阶段2之间进行过滤，除去除了指定为该方法的参数之外的所有字段。</span> </p>
<p> <span>此实例是不可变的，不受此方法调用的影响。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>resolverFields</code> - 新的解析器字段集合，如果没有字段，则为null 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个基于格式化器的格式化程序，具有请求的解析器样式，不为空 
           </dd>
</dl> </li>
</ul> <a name="format-java.time.temporal.TemporalAccessor-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>format</h4> <pre>public <a href="../../../java/lang/String.html" title="class in java.lang">String</a> format(<a href="../../../java/time/temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a> temporal)</pre>
<div class="block">
<span>使用此格式化程序格式化日期时间对象。</span>
<p> <span>这将使用格式化程序的规则将日期时间格式化为String。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>temporal</code> - 要格式化的时间对象，不为空 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             格式化的字符串，不为null 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/time/DateTimeException.html" title="class in java.time">DateTimeException</a></code> - 格式化过程中是否发生错误 
           </dd>
</dl> </li>
</ul> <a name="formatTo-java.time.temporal.TemporalAccessor-java.lang.Appendable-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>formatTo</h4> <pre>public void formatTo(<a href="../../../java/time/temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a> temporal,
                     <a href="../../../java/lang/Appendable.html" title="interface in java.lang">Appendable</a> appendable)</pre>
<div class="block">
<span>格式化一个日期时间对象到<code>Appendable</code>使用这种格式。</span>
<p> <span>这将格式化的日期时间输出到指定的目的地。</span> <span><a href="../../../java/lang/Appendable.html" title="java.lang中的接口"><code>Appendable</code></a>是由所有关键字符输出类实现的<code>StringBuffer</code> <code>StringBuilder</code> ， <code>PrintStream</code>和<code>Writer</code> 。</span> </p>
<p> <span>虽然<code>Appendable</code>方法抛出一个<code>IOException</code> ，这个方法不行。</span> <span>相反，任何<code>IOException</code>都被包装在运行时异常中。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>temporal</code> - 要格式化的时间对象，不为null 
           </dd>
<dd>
<code>appendable</code> - 可附加格式化，不为空 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/time/DateTimeException.html" title="class in java.time">DateTimeException</a></code> - 如果在格式化期间发生错误 
           </dd>
</dl> </li>
</ul> <a name="parse-java.lang.CharSequence-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parse</h4> <pre>public <a href="../../../java/time/temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a> parse(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a> text)</pre>
<div class="block">
<span>完全解析产生时间对象的文本。</span>
<p> <span>这解析整个文本，产生一个时间对象。</span> <span>通常使用<a href="../../../java/time/format/DateTimeFormatter.html#parse-java.lang.CharSequence-java.time.temporal.TemporalQuery-"><code>parse(CharSequence, TemporalQuery)</code></a>更有用。</span> <span>该方法的结果是<code>TemporalAccessor</code>已被解决，应用基本的验证检查以帮助确保有效的日期时间。</span> </p>
<p> <span>如果解析完成，而不读取文本的整个长度，或者在解析或合并期间发生问题，则抛出异常。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>text</code> - 要解析的文本，不为null 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             解析的时间对象，不为null 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/time/format/DateTimeParseException.html" title="class in java.time.format">DateTimeParseException</a></code> - 如果无法解析请求的结果 
           </dd>
</dl> </li>
</ul> <a name="parse-java.lang.CharSequence-java.text.ParsePosition-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parse</h4> <pre>public <a href="../../../java/time/temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a> parse(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a> text,
                              <a href="../../../java/text/ParsePosition.html" title="class in java.text">ParsePosition</a> position)</pre>
<div class="block">
<span>使用此格式化器解析文本，提供对文本位置的控制。</span>
<p> <span>这样解析文本，而不需要解析从字符串的开头开始，或者在结尾处完成。</span> <span>该方法的结果是<code>TemporalAccessor</code>已被解决，应用基本的验证检查以帮助确保有效的日期时间。</span> </p>
<p> <span>文本将从指定的开始<code>ParsePosition</code>解析。</span> <span>文本的整个长度不需要解析， <code>ParsePosition</code>将在解析结束时用索引进行更新。</span> </p>
<p> <span>该方法的操作与使用<code>ParsePosition</code>上的<code>java.text.Format</code>类似方法<code>ParsePosition</code> <code>java.text.Format</code> 。</span> <span>该类将使用<code>ParsePosition</code>上的错误索引返回错误。</span> <span>相比之下，如果发生错误，此方法将抛出一个<a href="../../../java/time/format/DateTimeParseException.html" title="java.time.format中的类"><code>DateTimeParseException</code></a> ，而异常包含错误索引。</span> <span>由于在此API中解析和解析日期/时间的复杂性增加，因此行为变化是必要的。</span> </p>
<p> <span>如果格式化程序用不同的值解析相同的字段多次，结果将是一个错误。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>text</code> - 要解析的文本，不为null 
           </dd>
<dd>
<code>position</code> - 解析的位置，更新长度解析和任何错误的索引，不为空 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             解析的时间对象，不为null 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/time/format/DateTimeParseException.html" title="class in java.time.format">DateTimeParseException</a></code> - 如果无法解析请求的结果 
           </dd>
<dd>
<code><a href="../../../java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - 如果该位置无效 
           </dd>
</dl> </li>
</ul> <a name="parse-java.lang.CharSequence-java.time.temporal.TemporalQuery-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parse</h4> <pre>public &lt;T&gt; T parse(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a> text,
                   <a href="../../../java/time/temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;T&gt; query)</pre>
<div class="block">
<span>完全解析产生指定类型对象的文本。</span>
<p> <span>大多数应用程序应该使用此方法进行解析。</span> <span>它解析整个文本以产生所需的日期时间。</span> <span>该查询典型地是一种方法参照<code>from(TemporalAccessor)</code>方法。</span> <span>例如：</span> </p>
<pre>  <span>LocalDateTime dt = parser.parse(str, LocalDateTime::from);</span> </pre>
<span>如果解析完成，而不读取文本的整个长度，或者在解析或合并期间发生问题，则抛出异常。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 解析日期时间的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>text</code> - 要解析的文本，不为null 
           </dd>
<dd>
<code>query</code> - 定义要解析的类型的查询，不为空 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             解析的日期时间，不为null 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/time/format/DateTimeParseException.html" title="class in java.time.format">DateTimeParseException</a></code> - 如果无法解析请求的结果 
           </dd>
</dl> </li>
</ul> <a name="parseBest-java.lang.CharSequence-java.time.temporal.TemporalQuery...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parseBest</h4> <pre>public <a href="../../../java/time/temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a> parseBest(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a> text,
                                  <a href="../../../java/time/temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;?&gt;... queries)</pre>
<div class="block">
<span>完全解析产生指定类型之一的对象的文本。</span>
<p> <span>当解析器可以处理可选元素时，此解析方法便于使用。</span> <span>例如，'uuuu-MM-dd HH.mm [VV]'的模式可以完全解析为<code>ZonedDateTime</code> ，或部分解析为<code>LocalDateTime</code> 。</span> <span>必须按顺序指定查询，从最佳匹配的全解析选项开始，以最差匹配的最小分析选项结束。</span> <span>该查询典型地是一种方法参照<code>from(TemporalAccessor)</code>方法。</span> </p>
<p> <span>结果与成功解析的第一种类型相关联。</span> <span>通常，应用程序将使用<code>instanceof</code>来检查结果。</span> <span>例如：</span> </p>
<pre>  <span>TemporalAccessor dt = parser.parseBest(str, ZonedDateTime::from, LocalDateTime::from);
  if (dt instanceof ZonedDateTime) {
   ...
  } else {
   ...
  }</span> </pre>
<span>如果解析完成，而不读取文本的整个长度，或者在解析或合并期间发生问题，则抛出异常。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>text</code> - 要解析的文本，不为null 
           </dd>
<dd>
<code>queries</code> - 定义尝试解析的类型的查询必须实现 
            <code>TemporalAccessor</code> ，不为空 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             解析的日期时间，不为null 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果指定少于2种类型 
           </dd>
<dd>
<code><a href="../../../java/time/format/DateTimeParseException.html" title="class in java.time.format">DateTimeParseException</a></code> - 如果无法解析请求的结果 
           </dd>
</dl> </li>
</ul> <a name="parseUnresolved-java.lang.CharSequence-java.text.ParsePosition-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parseUnresolved</h4> <pre>public <a href="../../../java/time/temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a> parseUnresolved(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a> text,
                                        <a href="../../../java/text/ParsePosition.html" title="class in java.text">ParsePosition</a> position)</pre>
<div class="block">
<span>使用此格式化程序解析文本，而无需解析结果，用于高级用例。</span>
<p> <span>解析实现为两阶段操作。</span> <span>首先，使用格式化程序定义的布局解析文本，产生一个<code>Map</code>的字段值，一个<code>ZoneId</code>和一个<code>Chronology</code> 。</span> <span>第二，通过验证，组合和简化各种领域，使解析的数据<em>得到解决</em> 。</span> <span>该方法执行解析阶段，但不执行解析阶段。</span> </p>
<p> <span>该方法的结果是<code>TemporalAccessor</code> ，表示输入中所见的数据。</span> <span>价值观不验证，因此解析“2012-00-65”的日期字符串将导致三个字段的时间 - “2012”年份，“0”月份和“65”的月份。</span> </p>
<p> <span>文本将从指定的开始<code>ParsePosition</code>解析。</span> <span>文本的整个长度不需要解析， <code>ParsePosition</code>将在解析结束时用索引进行更新。</span> </p>
<p> <span>使用<code>ParsePosition</code>而不是<code>DateTimeParseException</code>的错误索引字段返回错误。</span> <span>返回的错误索引将被设置为指示错误的索引。</span> <span>使用上下文之前，来电者必须检查错误。</span> </p>
<p> <span>如果格式化程序用不同的值解析相同的字段多次，结果将是一个错误。</span> </p>
<p> <span>此方法适用于在解析期间需要访问内部状态的高级用例。</span> <span>典型应用代码应使用<a href="../../../java/time/format/DateTimeFormatter.html#parse-java.lang.CharSequence-java.time.temporal.TemporalQuery-"><code>parse(CharSequence, TemporalQuery)</code></a>或目标类型的解析方法。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>text</code> - 要解析的文本，不为null 
           </dd>
<dd>
<code>position</code> - 解析的位置，更新长度解析和任何错误的索引，不为空 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             解析文本，如果解析导致错误，则为null 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/time/DateTimeException.html" title="class in java.time">DateTimeException</a></code> - 如果在解析期间发生某些问题 
           </dd>
<dd>
<code><a href="../../../java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - 位置无效 
           </dd>
</dl> </li>
</ul> <a name="toFormat--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toFormat</h4> <pre>public <a href="../../../java/text/Format.html" title="class in java.text">Format</a> toFormat()</pre>
<div class="block">
<span>将此格式化程序作为<code>java.text.Format</code>实例返回。</span>
<p> <span>返回的<a href="../../../java/text/Format.html" title="java.text中的类"><code>Format</code></a>实例将格式化任何<a href="../../../java/time/temporal/TemporalAccessor.html" title="java.time.temporal中的接口"><code>TemporalAccessor</code></a>并解析到解析的<a href="../../../java/time/temporal/TemporalAccessor.html" title="java.time.temporal中的接口"><code>TemporalAccessor</code></a> 。</span> </p>
<p> <span>例外将遵循Format的<code>Format</code> ，有关详细信息，请参阅<code>IllegalArgumentException</code>格式和<code>ParseException</code>中的详细信息，或解析时为空。</span> <span>格式不支持返回格式字符串的属性。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个格式化程序作为一个经典的格式实例，不为null 
           </dd>
</dl> </li>
</ul> <a name="toFormat-java.time.temporal.TemporalQuery-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toFormat</h4> <pre>public <a href="../../../java/text/Format.html" title="class in java.text">Format</a> toFormat(<a href="../../../java/time/temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;?&gt; parseQuery)</pre>
<div class="block">
<span>将此格式化程序作为<code>java.text.Format</code>实例返回，使用指定的查询进行解析。</span>
<p> <span>返回的<a href="../../../java/text/Format.html" title="java.text中的类"><code>Format</code></a>实例将格式化任何<a href="../../../java/time/temporal/TemporalAccessor.html" title="java.time.temporal中的接口"><code>TemporalAccessor</code></a>并解析到指定的类型。</span> <span>该类型必须是<code>parse(java.lang.CharSequence)</code>支持的<a href="../../../java/time/format/DateTimeFormatter.html#parse-java.lang.CharSequence-">类型</a> 。</span> </p>
<p> <span>例外将遵循Format的<code>Format</code> ，有关<code>IllegalArgumentException</code>过程中有关<code>IllegalArgumentException</code>的详细信息，请参阅这些方法， <code>ParseException</code>或解析期间为空。</span> <span>格式不支持返回格式字符串的属性。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>parseQuery</code> - 定义要解析的类型的查询，不为空 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个格式化程序作为一个经典的格式实例，不为null 
           </dd>
</dl> </li>
</ul> <a name="toString--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>toString</h4> <pre>public <a href="../../../java/lang/String.html" title="class in java.lang">String</a> toString()</pre>
<div class="block">
            返回底层格式化程序的描述。 
          </div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../../java/lang/Object.html#toString--">toString</a></code>在类别 
            <code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             a description of this formatter, not null 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>