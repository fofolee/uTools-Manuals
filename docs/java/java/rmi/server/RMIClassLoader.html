<div class="header">
<div class="subTitle">
     compact2, compact3 
   </div>
<div class="subTitle">
     java.rmi.server 
   </div>
<h2 class="title" title="Class RMIClassLoader">Class RMIClassLoader</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.rmi.server.RMIClassLoader</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre>public class <span class="typeNameLabel">RMIClassLoader</span>
extends <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></pre>
<div class="block">
<span><code>RMIClassLoader</code>包括使用RMI支持动态类加载的静态方法。</span>
<span>包括用于从网络位置（一个或多个URL）加载类的方法，并获取远程方应由其加载现有类的位置。</span>
<span>这些方法由RMI运行时使用，当编组和解组合包含在远程方法调用的参数和返回值中时，它们也可以由应用程序直接调用，以模仿RMI的动态类加载行为。</span>
<p> <span>执行以下静态方法</span> </p>
<ul>
<li> <span><a href="../../../java/rmi/server/RMIClassLoader.html#loadClass-java.net.URL-java.lang.String-"><code>loadClass(URL,String)</code></a></span> </li>
<li> <span><a href="../../../java/rmi/server/RMIClassLoader.html#loadClass-java.lang.String-java.lang.String-"><code>loadClass(String,String)</code></a></span> </li>
<li> <span><a href="../../../java/rmi/server/RMIClassLoader.html#loadClass-java.lang.String-java.lang.String-java.lang.ClassLoader-"><code>loadClass(String,String,ClassLoader)</code></a></span> </li>
<li> <span><a href="../../../java/rmi/server/RMIClassLoader.html#loadProxyClass-java.lang.String-java.lang.String:A-java.lang.ClassLoader-"><code>loadProxyClass(String,String[],ClassLoader)</code></a></span> </li>
<li> <span><a href="../../../java/rmi/server/RMIClassLoader.html#getClassLoader-java.lang.String-"><code>getClassLoader(String)</code></a></span> </li>
<li> <span><a href="../../../java/rmi/server/RMIClassLoader.html#getClassAnnotation-java.lang.Class-"><code>getClassAnnotation(Class)</code></a></span> </li>
</ul>
<span>由<a href="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server中的类"><code>RMIClassLoaderSpi</code></a>的实例提供，这些方法的服务提供者接口。</span>
<span>当调用其中一种方法时，其行为是委托给服务提供者实例上的相应方法。</span>
<span>每个方法委托给提供者实例的详细信息，请参见每个特定方法的文档。</span>
<p> <span>服务提供商实例选择如下：</span> </p>
<ul>
<li> <span>如果定义了系统属性<code>java.rmi.server.RMIClassLoaderSpi</code> ，那么如果其值等于字符串<code>"default"</code> ，则提供者实例将是通过调用<a href="../../../java/rmi/server/RMIClassLoader.html#getDefaultProviderInstance--"><code>getDefaultProviderInstance()</code></a>方法返回的值，对于任何其他值，如果使用属性值命名的类可以由系统类加载器加载（参见<a href="../../../java/lang/ClassLoader.html#getSystemClassLoader--"><code>ClassLoader.getSystemClassLoader()</code></a> ），该类可以分配给<a href="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server中的类"><code>RMIClassLoaderSpi</code></a>并具有公共无参数构造函数，那么将调用该构造函数来创建提供者实例。</span> <span>如果属性被定义，但这些条件中的任何其他条件都不为真，那么未指定的<code>Error</code>将被抛出到尝试使用<code>RMIClassLoader</code>代码中，表示无法获取提供者实例。</span> </li>
<li> <span>如果名为<code>META-INF/services/java.rmi.server.RMIClassLoaderSpi</code>的资源对于系统类加载器是可见的，那么该资源的内容将被解释为提供者配置文件，并且该文件中指定的第一个类名被用作提供者类名称。</span> <span>如果具有该名称的类可以由系统类加载器加载，并且该类可以分配给<a href="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server中的类"><code>RMIClassLoaderSpi</code></a>并具有公共无参构造函数，则将调用该构造函数来创建提供者实例。</span> <span>如果找到资源，但提供者无法按照描述进行实例化，那么未指定的<code>Error</code>将被<code>Error</code>到尝试使用<code>RMIClassLoader</code>代码，指示无法获取提供程序实例。</span> </li>
<li> <span>否则，提供者实例将是<a href="../../../java/rmi/server/RMIClassLoader.html#getDefaultProviderInstance--">调用<code>getDefaultProviderInstance()</code></a>方法返回的值。</span> </li>
</ul>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         JDK1.1 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server中的类"><code>RMIClassLoaderSpi</code></a></span>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t1"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t6"><span><a href="javascript:show(32);">弃用的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>static <a href="../../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/rmi/server/RMIClassLoader.html#getClassAnnotation-java.lang.Class-">getClassAnnotation</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; cl)</code>
<div class="block">
              返回在编组给定类的对象时，RMI将用于注释类描述符的注释字符串（表示类定义的位置）。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>static <a href="../../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/rmi/server/RMIClassLoader.html#getClassLoader-java.lang.String-">getClassLoader</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> codebase)</code>
<div class="block">
              返回从给定的代码库URL路径加载类的类加载器。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>static <a href="../../../java/rmi/server/RMIClassLoaderSpi.html" title="class in java.rmi.server">RMIClassLoaderSpi</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/rmi/server/RMIClassLoader.html#getDefaultProviderInstance--">getDefaultProviderInstance</a></span>()</code>
<div class="block">
<span>返回服务提供商接口<a href="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server中的类"><code>RMIClassLoaderSpi</code></a>的默认提供程序的规范<a href="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server中的类">实例</a> 。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>static <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/rmi/server/RMIClassLoader.html#getSecurityContext-java.lang.ClassLoader-">getSecurityContext</a></span>(<a href="../../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> loader)</code>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<div class="block">
<span><span class="deprecationComment">没有替换。</span></span>
<span><span class="deprecationComment">从Java 2平台v1.2开始，RMI不再使用此方法来获取类加载器的安全上下文。</span></span>
</div>
</div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>static <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/rmi/server/RMIClassLoader.html#loadClass-java.lang.String-">loadClass</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> name)</code>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<div class="block">
<span><span class="deprecationComment">取代<code>loadClass(String,String)</code>法</span></span>
</div>
</div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>static <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/rmi/server/RMIClassLoader.html#loadClass-java.lang.String-java.lang.String-">loadClass</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> codebase, <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name)</code>
<div class="block">
              从代码库URL路径加载一个类。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>static <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/rmi/server/RMIClassLoader.html#loadClass-java.lang.String-java.lang.String-java.lang.ClassLoader-">loadClass</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> codebase, <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name, <a href="../../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> defaultLoader)</code>
<div class="block">
              从代码库URL路径加载类，可选地使用提供的加载程序。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>static <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/rmi/server/RMIClassLoader.html#loadClass-java.net.URL-java.lang.String-">loadClass</a></span>(<a href="../../../java/net/URL.html" title="class in java.net">URL</a> codebase, <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name)</code>
<div class="block">
              从代码库URL加载一个类。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>static <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/rmi/server/RMIClassLoader.html#loadProxyClass-java.lang.String-java.lang.String:A-java.lang.ClassLoader-">loadProxyClass</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> codebase, <a href="../../../java/lang/String.html" title="class in java.lang">String</a>[] interfaces, <a href="../../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> defaultLoader)</code>
<div class="block">
<span>加载动态代理类（参见<a href="../../../java/lang/reflect/Proxy.html" title="class java.lang.reflect"><code>Proxy</code></a> ），它从代码库URL路径中实现了一组具有给定名称的接口。</span>
</div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#toString--">toString</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="loadClass-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>loadClass</h4> <pre><a href="../../../java/lang/Deprecated.html" title="annotation in java.lang">@Deprecated</a>
public static <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; loadClass(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> name)
                                      throws <a href="../../../java/net/MalformedURLException.html" title="class in java.net">MalformedURLException</a>,
                                             <a href="../../../java/lang/ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a></pre>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<span><span class="deprecationComment">取代<code>loadClass(String,String)</code>法</span></span>
</div>
<div class="block">
<span>用指定的name <code>name</code> 。</span>
<p> <span>该方法代表<a href="../../../java/rmi/server/RMIClassLoader.html#loadClass-java.lang.String-java.lang.String-"><code>loadClass(String,String)</code></a> ，作为第一个参数传递<code>null</code> ，第8个参数为<code>name</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>name</code> - 要加载的类的名称 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             表示加载的类的 
            <code>类</code>对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/net/MalformedURLException.html" title="class in java.net">MalformedURLException</a></code> - 如果用于加载类的提供者特定URL无效 
           </dd>
<dd>
<code><a href="../../../java/lang/ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a></code> - 如果在代码库位置找不到类的定义 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/rmi/server/RMIClassLoader.html#loadClass-java.lang.String-java.lang.String-"><code>loadClass(String,String)</code></a>
</dd>
</dl> </li>
</ul> <a name="loadClass-java.net.URL-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>loadClass</h4> <pre>public static <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; loadClass(<a href="../../../java/net/URL.html" title="class in java.net">URL</a> codebase,
                                 <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name)
                          throws <a href="../../../java/net/MalformedURLException.html" title="class in java.net">MalformedURLException</a>,
                                 <a href="../../../java/lang/ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a></pre>
<div class="block">
<span>从代码库URL加载一个类。</span>
<span>如果<code>codebase</code>是<code>null</code> ，那么这个方法的行为与<a href="../../../java/rmi/server/RMIClassLoader.html#loadClass-java.lang.String-java.lang.String-"><code>loadClass(String,String)</code>一样</a> ，具有<code>null</code> <code>codebase</code>和给定的类名。</span>
<p> <span>此方法委托给<a href="../../../java/rmi/server/RMIClassLoaderSpi.html#loadClass-java.lang.String-java.lang.String-java.lang.ClassLoader-"><code>RMIClassLoaderSpi.loadClass(String,String,ClassLoader)</code></a>提供程序实例的方法，并传递调用的结果<a href="../../../java/net/URL.html#toString--"><code>URL.toString()</code></a>在给定的URL（或<code>null</code>如果<code>codebase</code>为null）作为第一个参数， <code>name</code>作为第二个参数，和<code>null</code>作为第三个参数。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>codebase</code> - 加载类的URL，或 
            <code>null</code>
</dd>
<dd>
<code>name</code> - 要加载的类的名称 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             表示加载类的 
            <code>类</code>对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/net/MalformedURLException.html" title="class in java.net">MalformedURLException</a></code> - 如果 
            <code>codebase</code>是 
            <code>null</code> ，用于加载类的提供者特定的URL是无效的 
           </dd>
<dd>
<code><a href="../../../java/lang/ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a></code> - 如果在指定的URL处找不到类的定义 
           </dd>
</dl> </li>
</ul> <a name="loadClass-java.lang.String-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>loadClass</h4> <pre>public static <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; loadClass(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> codebase,
                                 <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name)
                          throws <a href="../../../java/net/MalformedURLException.html" title="class in java.net">MalformedURLException</a>,
                                 <a href="../../../java/lang/ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a></pre>
<div class="block">
<span>从代码库URL路径加载一个类。</span>
<p> <span>该方法委托给提供者实例的<a href="../../../java/rmi/server/RMIClassLoaderSpi.html#loadClass-java.lang.String-java.lang.String-java.lang.ClassLoader-"><code>RMIClassLoaderSpi.loadClass(String,String,ClassLoader)</code></a>方法，以<code>codebase</code>作为第一个参数， <code>name</code>作为第二个参数， <code>null</code>作为第三个参数。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>codebase</code> - 加载类的URL列表（由空格分隔）或 
            <code>null</code>
</dd>
<dd>
<code>name</code> - 要加载的类的名称 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>类</code>加载类的 
            <code>类</code>对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/net/MalformedURLException.html" title="class in java.net">MalformedURLException</a></code> - 如果 
            <code>codebase</code>不是 
            <code>null</code>并且包含无效的URL，或者如果 
            <code>codebase</code>是 
            <code>null</code> ，并且用于加载类的提供者特定URL无效 
           </dd>
<dd>
<code><a href="../../../java/lang/ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a></code> - 如果在指定位置找不到类的定义 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.2 
           </dd>
</dl> </li>
</ul> <a name="loadClass-java.lang.String-java.lang.String-java.lang.ClassLoader-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>loadClass</h4> <pre>public static <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; loadClass(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> codebase,
                                 <a href="../../../java/lang/String.html" title="class in java.lang">String</a> name,
                                 <a href="../../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> defaultLoader)
                          throws <a href="../../../java/net/MalformedURLException.html" title="class in java.net">MalformedURLException</a>,
                                 <a href="../../../java/lang/ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a></pre>
<div class="block">
<span>从代码库URL路径加载类，可选地使用提供的加载程序。</span>
<span>当调用者想要向提供者实现提供一个要考虑的附加上下文类加载器时，应该使用此方法，例如堆栈上的调用者的加载程序。</span>
<span>通常，在尝试从代码库URL路径解析类之前，提供者实现将尝试使用给定的<code>defaultLoader</code> （如果指定）来解析命名类。</span>
<p> <span>此方法委托给<a href="../../../java/rmi/server/RMIClassLoaderSpi.html#loadClass-java.lang.String-java.lang.String-java.lang.ClassLoader-"><code>RMIClassLoaderSpi.loadClass(String,String,ClassLoader)</code></a>提供程序实例的方法，传递<code>codebase</code>作为第一个参数， <code>name</code>作为第二个参数，和<code>defaultLoader</code>作为第三个参数。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>codebase</code> - 加载类的URL列表（由空格分隔）或 
            <code>null</code>
</dd>
<dd>
<code>name</code> - 要加载的类的名称 
           </dd>
<dd>
<code>defaultLoader</code> - 要使用的附加上下文类加载器，或 
            <code>null</code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>类</code>加载类的 
            <code>类</code>对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/net/MalformedURLException.html" title="class in java.net">MalformedURLException</a></code> - 如果 
            <code>codebase</code>不是 
            <code>null</code>并且包含无效的URL，或者如果 
            <code>codebase</code>是 
            <code>null</code> ，并且用于加载类的提供者特定的URL无效 
           </dd>
<dd>
<code><a href="../../../java/lang/ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a></code> - 如果在指定位置找不到类的定义 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
</dl> </li>
</ul> <a name="loadProxyClass-java.lang.String-java.lang.String:A-java.lang.ClassLoader-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>loadProxyClass</h4> <pre>public static <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; loadProxyClass(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> codebase,
                                      <a href="../../../java/lang/String.html" title="class in java.lang">String</a>[] interfaces,
                                      <a href="../../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> defaultLoader)
                               throws <a href="../../../java/lang/ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a>,
                                      <a href="../../../java/net/MalformedURLException.html" title="class in java.net">MalformedURLException</a></pre>
<div class="block">
<span>加载动态代理类（请参阅<a href="../../../java/lang/reflect/Proxy.html" title="class java.lang.reflect"><code>Proxy</code></a> ），它从代码库URL路径中实现了一组具有给定名称的接口。</span>
<p> <span>这些接口将被解析为类似于使用给定的<code>codebase</code>通过<a href="../../../java/rmi/server/RMIClassLoader.html#loadClass-java.lang.String-java.lang.String-"><code>loadClass(String,String)</code></a>方法加载的类。</span> </p>
<p> <span>该方法委托给提供者实例的<a href="../../../java/rmi/server/RMIClassLoaderSpi.html#loadProxyClass-java.lang.String-java.lang.String:A-java.lang.ClassLoader-"><code>RMIClassLoaderSpi.loadProxyClass(String,String[],ClassLoader)</code></a>方法，以<code>codebase</code>作为第一个参数，以<code>interfaces</code>作为第二个参数，以<code>defaultLoader</code>作为第三个参数。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>codebase</code> - 加载类的URL列表（空格分隔），或 
            <code>null</code>
</dd>
<dd>
<code>interfaces</code> - 要实现的代理类的接口的名称 
           </dd>
<dd>
<code>defaultLoader</code> - 附加的上下文类加载器使用，或 
            <code>null</code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个实现命名接口的动态代理类 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/net/MalformedURLException.html" title="class in java.net">MalformedURLException</a></code> - 如果 
            <code>codebase</code>不是 
            <code>null</code>并且包含无效的URL，或者如果 
            <code>codebase</code>是 
            <code>null</code> ，并且用于加载类的提供者特定URL无效 
           </dd>
<dd>
<code><a href="../../../java/lang/ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a></code> -如果指定的接口之一的定义无法在指定位置找到，或者如果动态代理类的创建失败（例如，如果 
            <a href="../../../java/lang/reflect/Proxy.html#getProxyClass-java.lang.ClassLoader-java.lang.Class...-"><code>Proxy.getProxyClass(ClassLoader,Class[])</code></a>将抛出一个 
            <code>IllegalArgumentException</code>对于给定的接口列表） 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
</dl> </li>
</ul> <a name="getClassLoader-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getClassLoader</h4> <pre>public static <a href="../../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> getClassLoader(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> codebase)
                                  throws <a href="../../../java/net/MalformedURLException.html" title="class in java.net">MalformedURLException</a>,
                                         <a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></pre>
<div class="block">
<span>返回从给定的代码库URL路径加载类的类加载器。</span>
<p> <span>返回的类加载器是<a href="../../../java/rmi/server/RMIClassLoader.html#loadClass-java.lang.String-java.lang.String-"><code>loadClass(String,String)</code></a>方法用于为相同的<code>codebase</code>参数加载类的类加载器。</span> </p>
<p> <span>该方法委托给提供者实例的<a href="../../../java/rmi/server/RMIClassLoaderSpi.html#getClassLoader-java.lang.String-"><code>RMIClassLoaderSpi.getClassLoader(String)</code></a>方法，传递<code>codebase</code>作为参数。</span> </p>
<p> <span>如果有安全管理员，其<code>checkPermission</code>方法将被调用<code>RuntimePermission("getClassLoader")</code>权限;</span> <span>这可能会导致一个<code>SecurityException</code> 。</span> <span>该方法的提供者实现还可以执行进一步的安全检查，以验证呼叫上下文是否具有连接到代码库URL路径中的所有URL的权限。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>codebase</code> - 返回的类加载器从其加载类的URL（空格分隔）列表，或 
            <code>null</code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个类加载器，它从给定的代码库URL路径加载类 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/net/MalformedURLException.html" title="class in java.net">MalformedURLException</a></code> - 如果 
            <code>codebase</code>是非 
            <code>null</code>并且包含无效的URL，或者如果 
            <code>codebase</code>是 
            <code>null</code> ，并且用于标识类加载器的提供者特定的URL是无效的 
           </dd>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果有一个安全管理器，并且其 
            <code>checkPermission</code>方法的调用失败，或者如果调用者没有权限连接到代码库URL路径中的所有URL 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.3 
           </dd>
</dl> </li>
</ul> <a name="getClassAnnotation-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getClassAnnotation</h4> <pre>public static <a href="../../../java/lang/String.html" title="class in java.lang">String</a> getClassAnnotation(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; cl)</pre>
<div class="block">
<span>返回在编组给定类的对象时，RMI将用于注释类描述符的注释字符串（表示类定义的位置）。</span>
<p> <span>该方法委托给提供者实例的<a href="../../../java/rmi/server/RMIClassLoaderSpi.html#getClassAnnotation-java.lang.Class-"><code>RMIClassLoaderSpi.getClassAnnotation(Class)</code></a>方法，传递<code>cl</code>作为参数。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>cl</code> - 获取注释的类 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个字符串，用于在给定的类进行编组时用于注释，或者是 
            <code>null</code>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>cl</code>是 
            <code>null</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.2 
           </dd>
</dl> </li>
</ul> <a name="getDefaultProviderInstance--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getDefaultProviderInstance</h4> <pre>public static <a href="../../../java/rmi/server/RMIClassLoaderSpi.html" title="class in java.rmi.server">RMIClassLoaderSpi</a> getDefaultProviderInstance()</pre>
<div class="block">
<span>返回服务提供商界面<a href="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server中的类"><code>RMIClassLoaderSpi</code></a>的默认提供程序的规范<a href="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server中的类">实例</a> 。</span>
<span>如果系统属性<code>java.rmi.server.RMIClassLoaderSpi</code>未定义，那么<code>RMIClassLoader</code>静态方法</span>
<ul>
<li> <span><a href="../../../java/rmi/server/RMIClassLoader.html#loadClass-java.net.URL-java.lang.String-"><code>loadClass(URL,String)</code></a></span> </li>
<li> <span><a href="../../../java/rmi/server/RMIClassLoader.html#loadClass-java.lang.String-java.lang.String-"><code>loadClass(String,String)</code></a></span> </li>
<li> <span><a href="../../../java/rmi/server/RMIClassLoader.html#loadClass-java.lang.String-java.lang.String-java.lang.ClassLoader-"><code>loadClass(String,String,ClassLoader)</code></a></span> </li>
<li> <span><a href="../../../java/rmi/server/RMIClassLoader.html#loadProxyClass-java.lang.String-java.lang.String:A-java.lang.ClassLoader-"><code>loadProxyClass(String,String[],ClassLoader)</code></a></span> </li>
<li> <span><a href="../../../java/rmi/server/RMIClassLoader.html#getClassLoader-java.lang.String-"><code>getClassLoader(String)</code></a></span> </li>
<li> <span><a href="../../../java/rmi/server/RMIClassLoader.html#getClassAnnotation-java.lang.Class-"><code>getClassAnnotation(Class)</code></a></span> </li>
</ul>
<span>将使用默认提供者的规范实例作为服务提供者实例。</span>
<p> <span>如果有安全管理员，其<code>checkPermission</code>方法将被调用<code>RuntimePermission("setFactory")</code>权限;</span> <span>这可能会导致一个<code>SecurityException</code> 。</span> </p>
<p> <span>默认服务提供者实例实现<a href="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server中的类"><code>RMIClassLoaderSpi</code></a>如下：</span> </p>
<blockquote>
<span><p>The <b><a href="../../../java/rmi/server/RMIClassLoaderSpi.html#getClassAnnotation-java.lang.Class-"><code>getClassAnnotation</code></a></b> method returns a <code>String</code> representing the codebase URL path that a remote party should use to download the definition for the specified class. The format of the returned string is a path of URLs separated by spaces. The codebase string returned depends on the defining class loader of the specified class: </p>
<ul>
<li><p>If the class loader is the system class loader (see <a href="../../../java/lang/ClassLoader.html#getSystemClassLoader--"><code>ClassLoader.getSystemClassLoader()</code></a>), a parent of the system class loader such as the loader used for installed extensions, or the bootstrap class loader (which may be represented by <code>null</code>), then the value of the <code>java.rmi.server.codebase</code> property (or possibly an earlier cached value) is returned, or <code>null</code> is returned if that property is not set. </p></li>
<li><p>Otherwise, if the class loader is an instance of <code>URLClassLoader</code>, then the returned string is a space-separated list of the external forms of the URLs returned by invoking the <code>getURLs</code> methods of the loader. If the <code>URLClassLoader</code> was created by this provider to service an invocation of its <code>loadClass</code> or <code>loadProxyClass</code> methods, then no permissions are required to get the associated codebase string. If it is an arbitrary other <code>URLClassLoader</code> instance, then if there is a security manager, its <code>checkPermission</code> method will be invoked once for each URL returned by the <code>getURLs</code> method, with the permission returned by invoking <code>openConnection().getPermission()</code> on each URL; if any of those invocations throws a <code>SecurityException</code> or an <code>IOException</code>, then the value of the <code>java.rmi.server.codebase</code> property (or possibly an earlier cached value) is returned, or <code>null</code> is returned if that property is not set. </p></li>
<li><p>Finally, if the class loader is not an instance of <code>URLClassLoader</code>, then the value of the <code>java.rmi.server.codebase</code> property (or possibly an earlier cached value) is returned, or <code>null</code> is returned if that property is not set. </p></li>
</ul> <p>For the implementations of the methods described below, which all take a <code>String</code> parameter named <code>codebase</code> that is a space-separated list of URLs, each invocation has an associated <i>codebase loader</i> that is identified using the <code>codebase</code> argument in conjunction with the current thread's context class loader (see <a href="../../../java/lang/Thread.html#getContextClassLoader--"><code>Thread.getContextClassLoader()</code></a>). When there is a security manager, this provider maintains an internal table of class loader instances (which are at least instances of <a href="../../../java/net/URLClassLoader.html" title="class in java.net"><code>URLClassLoader</code></a>) keyed by the pair of their parent class loader and their codebase URL path (an ordered list of URLs). If the <code>codebase</code> argument is <code>null</code>, the codebase URL path is the value of the system property <code>java.rmi.server.codebase</code> or possibly an earlier cached value. For a given codebase URL path passed as the <code>codebase</code> argument to an invocation of one of the below methods in a given context, the codebase loader is the loader in the table with the specified codebase URL path and the current thread's context class loader as its parent. If no such loader exists, then one is created and added to the table. The table does not maintain strong references to its contained loaders, in order to allow them and their defined classes to be garbage collected when not otherwise reachable. In order to prevent arbitrary untrusted code from being implicitly loaded into a virtual machine with no security manager, if there is no security manager set, the codebase loader is just the current thread's context class loader (the supplied codebase URL path is ignored, so remote class loading is disabled). </p> <p>The <b><a href="../../../java/rmi/server/RMIClassLoaderSpi.html#getClassLoader-java.lang.String-"><code>getClassLoader</code></a></b> method returns the codebase loader for the specified codebase URL path. If there is a security manager, then if the calling context does not have permission to connect to all of the URLs in the codebase URL path, a <code>SecurityException</code> will be thrown. </p> <p>The <b><a href="../../../java/rmi/server/RMIClassLoaderSpi.html#loadClass-java.lang.String-java.lang.String-java.lang.ClassLoader-"><code>loadClass</code></a></b> method attempts to load the class with the specified name as follows: </p>
<blockquote>
               If the 
              <code>defaultLoader</code> argument is non- 
              <code>null</code>, it first attempts to load the class with the specified 
              <code>name</code> using the 
              <code>defaultLoader</code>, such as by evaluating 
              <pre>
     Class.forName(name, false, defaultLoader)
 </pre> If the class is successfully loaded from the 
              <code>defaultLoader</code>, that class is returned. If an exception other than 
              <code>ClassNotFoundException</code> is thrown, that exception is thrown to the caller. 
              <p>Next, the <code>loadClass</code> method attempts to load the class with the specified <code>name</code> using the codebase loader for the specified codebase URL path. If there is a security manager, then the calling context must have permission to connect to all of the URLs in the codebase URL path; otherwise, the current thread's context class loader will be used instead of the codebase loader. </p>
</blockquote> <p>The <b><a href="../../../java/rmi/server/RMIClassLoaderSpi.html#loadProxyClass-java.lang.String-java.lang.String:A-java.lang.ClassLoader-"><code>loadProxyClass</code></a></b> method attempts to return a dynamic proxy class with the named interface as follows: </p>
<blockquote>
<p>If the <code>defaultLoader</code> argument is non-<code>null</code> and all of the named interfaces can be resolved through that loader, then, </p>
<ul>
<li>if all of the resolved interfaces are <code>public</code>, then it first attempts to obtain a dynamic proxy class (using <a href="../../../java/lang/reflect/Proxy.html#getProxyClass-java.lang.ClassLoader-java.lang.Class...-"><code>Proxy.getProxyClass</code></a>) for the resolved interfaces defined in the codebase loader; if that attempt throws an <code>IllegalArgumentException</code>, it then attempts to obtain a dynamic proxy class for the resolved interfaces defined in the <code>defaultLoader</code>. If both attempts throw <code>IllegalArgumentException</code>, then this method throws a <code>ClassNotFoundException</code>. If any other exception is thrown, that exception is thrown to the caller. </li>
<li>if all of the non-<code>public</code> resolved interfaces are defined in the same class loader, then it attempts to obtain a dynamic proxy class for the resolved interfaces defined in that loader. </li>
<li>otherwise, a <code>LinkageError</code> is thrown (because a class that implements all of the specified interfaces cannot be defined in any loader). </li>
</ul>
<p>Otherwise, if all of the named interfaces can be resolved through the codebase loader, then, </p>
<ul>
<li>if all of the resolved interfaces are <code>public</code>, then it attempts to obtain a dynamic proxy class for the resolved interfaces in the codebase loader. If the attempt throws an <code>IllegalArgumentException</code>, then this method throws a <code>ClassNotFoundException</code>. </li>
<li>if all of the non-<code>public</code> resolved interfaces are defined in the same class loader, then it attempts to obtain a dynamic proxy class for the resolved interfaces defined in that loader. </li>
<li>otherwise, a <code>LinkageError</code> is thrown (because a class that implements all of the specified interfaces cannot be defined in any loader). </li>
</ul>
<p>Otherwise, a <code>ClassNotFoundException</code> is thrown for one of the named interfaces that could not be resolved. </p>
</blockquote></span>
</blockquote>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             默认服务提供商的规范实例 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果有安全管理器，并且调用其 
            <code>checkPermission</code>方法失败 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
</dl> </li>
</ul> <a name="getSecurityContext-java.lang.ClassLoader-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>getSecurityContext</h4> <pre><a href="../../../java/lang/Deprecated.html" title="annotation in java.lang">@Deprecated</a>
public static <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> getSecurityContext(<a href="../../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> loader)</pre>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<span><span class="deprecationComment">没有替换。</span></span>
<span><span class="deprecationComment">从Java 2平台v1.2开始，RMI不再使用此方法来获取类加载器的安全上下文。</span></span>
</div>
<div class="block">
            返回给定类加载器的安全上下文。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>loader</code> - 从中获取安全上下文的类加载器 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             安全上下文 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/SecurityManager.html#getSecurityContext--"><code>SecurityManager.getSecurityContext()</code></a>
</dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>