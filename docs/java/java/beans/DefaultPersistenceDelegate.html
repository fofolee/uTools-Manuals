<div class="header">
<div class="subTitle">
     java.beans 
   </div>
<h2 class="title" title="Class DefaultPersistenceDelegate">Class DefaultPersistenceDelegate</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li><a href="../../java/beans/PersistenceDelegate.html" title="class in java.beans">java.beans.PersistenceDelegate</a></li>
<li>
<ul class="inheritance">
<li>java.beans.DefaultPersistenceDelegate</li>
</ul> </li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre>public class <span class="typeNameLabel">DefaultPersistenceDelegate</span>
extends <a href="../../java/beans/PersistenceDelegate.html" title="class in java.beans">PersistenceDelegate</a></pre>
<div class="block">
<span><code>DefaultPersistenceDelegate</code>是抽象<code>PersistenceDelegate</code>类的具体实现，是默认情况下用于没有信息可用的类的委托。</span>
<span><code>DefaultPersistenceDelegate</code>提供了基于公共API的基于公共API的持久性，用于遵循JavaBeans的惯例而不需要任何类特定配置的类。</span>
<p> <span>关键的假设是类具有一个无效构造函数，并且它的状态按照由Introspector返回的顺序由“setter”和“getter”对匹配对精确地表示。</span> <span>除了为JavaBeans提供无代码的持久性之外， <code>DefaultPersistenceDelegate</code>还提供了一种方便的方法来为具有构造函数的类实现持久存储，而构造函数虽然不是空值，但只需要一些属性值作为参数。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.4 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/beans/DefaultPersistenceDelegate.html#DefaultPersistenceDelegate-java.lang.String:A-"><code>DefaultPersistenceDelegate(String[])</code></a> ， <a href="../../java/beans/Introspector.html" title="java.beans中的类"><code>Introspector</code></a></span>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!-- --> </a> <h3>构造方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Constructor Summary table, listing constructors, and an explanation">
<caption>
<span>构造方法</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../java/beans/DefaultPersistenceDelegate.html#DefaultPersistenceDelegate--">DefaultPersistenceDelegate</a></span>()</code>
<div class="block">
              为具有无效构造函数的类创建持久性委托。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../java/beans/DefaultPersistenceDelegate.html#DefaultPersistenceDelegate-java.lang.String:A-">DefaultPersistenceDelegate</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a>[] constructorPropertyNames)</code>
<div class="block">
              创建一类默认持久委托构造方法的参数由指定的属性名称的值 
             <code>constructorPropertyNames</code> 。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/beans/DefaultPersistenceDelegate.html#initialize-java.lang.Class-java.lang.Object-java.lang.Object-java.beans.Encoder-">initialize</a></span>(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; type, <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> oldInstance, <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> newInstance, <a href="../../java/beans/Encoder.html" title="class in java.beans">Encoder</a> out)</code>
<div class="block">
<code>initialize</code>方法的这种默认实现假定这种类型的对象中保持的所有状态都是通过匹配的“setter”和“getter”方法按照Introspector返回的顺序公开的。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>protected <a href="../../java/beans/Expression.html" title="class in java.beans">Expression</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/beans/DefaultPersistenceDelegate.html#instantiate-java.lang.Object-java.beans.Encoder-">instantiate</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> oldInstance, <a href="../../java/beans/Encoder.html" title="class in java.beans">Encoder</a> out)</code>
<div class="block">
<code>instantiate</code>方法的此默认实现返回一个表达式，其中包含预定义方法名“new”，表示使用DefaultPersistenceDelegate的构造函数中指定的 
             <code>DefaultPersistenceDelegate</code>对构造函数进行调用。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/beans/DefaultPersistenceDelegate.html#mutatesTo-java.lang.Object-java.lang.Object-">mutatesTo</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> oldInstance, <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> newInstance)</code>
<div class="block">
              如果指定构造函数中的参数数量不为零，并且 
             <code>oldInstance</code>类 
             <code>oldInstance</code>式声明“equals”方法，则此方法返回值为 
             <code>oldInstance.equals(newInstance)</code> 。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.beans.PersistenceDelegate">
<!-- --> </a> <h3>Methods inherited from class java.beans.<a href="../../java/beans/PersistenceDelegate.html" title="class in java.beans">PersistenceDelegate</a></h3> <code><a href="../../java/beans/PersistenceDelegate.html#writeObject-java.lang.Object-java.beans.Encoder-">writeObject</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../java/lang/Object.html#clone--">clone</a>, <a href="../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../java/lang/Object.html#notify--">notify</a>, <a href="../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../java/lang/Object.html#toString--">toString</a>, <a href="../../java/lang/Object.html#wait--">wait</a>, <a href="../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!-- --> </a> <h3>构造方法详细信息</h3> <a name="DefaultPersistenceDelegate--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>DefaultPersistenceDelegate</h4> <pre>public DefaultPersistenceDelegate()</pre>
<div class="block">
            为具有无效构造函数的类创建持久性委托。 
          </div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/beans/DefaultPersistenceDelegate.html#DefaultPersistenceDelegate-java.lang.String:A-"><code>DefaultPersistenceDelegate(java.lang.String[])</code></a>
</dd>
</dl> </li>
</ul> <a name="DefaultPersistenceDelegate-java.lang.String:A-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>DefaultPersistenceDelegate</h4> <pre>public DefaultPersistenceDelegate(<a href="../../java/lang/String.html" title="class in java.lang">String</a>[] constructorPropertyNames)</pre>
<div class="block">
<span>创建一类默认持久委托构造方法的参数由指定的属性名称的值<code>constructorPropertyNames</code> 。</span>
<span>构造函数参数是通过按照提供的顺序评估属性名来创建的。</span>
<span>要使用此类来指定用于特定类型的序列化的单个首选构造函数，我们将声明组成构造函数参数的属性的名称。</span>
<span>例如，不能定义<code>Font</code>构造函数的<code>Font</code>类可以使用以下持久性委托来处理：</span>
<pre>  <span>new DefaultPersistenceDelegate(new String[]{"name", "style", "size"});</span> </pre>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>constructorPropertyNames</code> - 此 
            <code>constructorPropertyNames</code>的属性名称。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/beans/DefaultPersistenceDelegate.html#instantiate-java.lang.Object-java.beans.Encoder-"><code>instantiate(java.lang.Object, java.beans.Encoder)</code></a>
</dd>
</dl> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="mutatesTo-java.lang.Object-java.lang.Object-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>mutatesTo</h4> <pre>protected boolean mutatesTo(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> oldInstance,
                            <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> newInstance)</pre>
<div class="block">
<span>如果指定构造函数中的参数数量不为零，并且<code>oldInstance</code>类<code>oldInstance</code>式声明“equals”方法，则此方法返回值为<code>oldInstance.equals(newInstance)</code> 。</span>
<span>否则，此方法使用超类的定义，如果两个实例的类相等，则返回true。</span>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../java/beans/PersistenceDelegate.html#mutatesTo-java.lang.Object-java.lang.Object-">mutatesTo</a></code>在类别 
            <code><a href="../../java/beans/PersistenceDelegate.html" title="class in java.beans">PersistenceDelegate</a></code>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>oldInstance</code> - 要复制的实例。 
           </dd>
<dd>
<code>newInstance</code> - 要修改的实例。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             真要是的等效副本 
            <code>newInstance</code>可通过应用一系列突变要创建 
            <code>oldInstance</code> 。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/beans/DefaultPersistenceDelegate.html#DefaultPersistenceDelegate-java.lang.String:A-"><code>DefaultPersistenceDelegate(String[])</code></a>
</dd>
</dl> </li>
</ul> <a name="instantiate-java.lang.Object-java.beans.Encoder-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>instantiate</h4> <pre>protected <a href="../../java/beans/Expression.html" title="class in java.beans">Expression</a> instantiate(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> oldInstance,
                                 <a href="../../java/beans/Encoder.html" title="class in java.beans">Encoder</a> out)</pre>
<div class="block">
<code>instantiate</code>方法的默认实现返回一个表达式，其中包含预定义的方法名“new”，表示使用DefaultPersistenceDelegate的构造函数中指定的 
           <code>DefaultPersistenceDelegate</code>对构造函数进行调用。 
          </div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../java/beans/PersistenceDelegate.html#instantiate-java.lang.Object-java.beans.Encoder-">instantiate</a></code>在 
            <code><a href="../../java/beans/PersistenceDelegate.html" title="class in java.beans">PersistenceDelegate</a></code>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>oldInstance</code> - 要实例化的实例。 
           </dd>
<dd>
<code>out</code> - 代码输出流。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             值为 
            <code>oldInstance</code> 。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>out</code>为 
            <code>null</code> ，并且该值用于该方法 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/beans/DefaultPersistenceDelegate.html#DefaultPersistenceDelegate-java.lang.String:A-"><code>DefaultPersistenceDelegate(String[])</code></a>
</dd>
</dl> </li>
</ul> <a name="initialize-java.lang.Class-java.lang.Object-java.lang.Object-java.beans.Encoder-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>initialize</h4> <pre>protected void initialize(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; type,
                          <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> oldInstance,
                          <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> newInstance,
                          <a href="../../java/beans/Encoder.html" title="class in java.beans">Encoder</a> out)</pre>
<div class="block">
<span><code>initialize</code>方法的这种默认实现假定这种类型的对象中保存的所有状态都是通过匹配的“setter”和“getter”方法按Introspector返回的顺序公开的。</span>
<span>如果属性描述符定义了一个等于<code>Boolean.TRUE</code>的值的“transient”属性，则此默认实现将忽略此属性。</span>
<span>请注意，“瞬态”一词的使用与ObjectOutputStream使用的字段修饰符<code>ObjectOutputStream</code> 。</span>
<p> <span>对于每个非瞬态属性，创建一个表达式，其中将“getter”方法应用于<code>oldInstance</code> 。</span> <span>此表达式的值是要序列化的实例中的属性值。</span> <span>如果此表达式的值在克隆环境<code>mutatesTo</code>的目标值为<code>mutatesTo</code> ，则新值将被初始化，使其等同于旧值。</span> <span>在这种情况下，由于属性值没有改变，所以不需要调用相应的“setter”方法，并且不会发出语句。</span> <span>如果不是，则该值的表达式将替换为另一个表达式（通常是构造函数），并调用相应的“setter”方法来在对象中安装新的属性值。</span> <span>此方案从使用此委托的流中生成的输出中删除默认信息。</span> </p>
<p> <span>在将这些语句传递给输出流时，它们将被执行， <code>newInstance</code>产生副作用。</span> <span>在大多数情况下，这允许其值相互依赖的属性的问题实际上帮助序列化过程，使需要写入输出的语句数量更小。</span> <span>一般来说，处理相互依赖的属性的问题减少到为一个类中的属性找到顺序的问题，使得没有属性值取决于后续属性的值。</span> </p>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../java/beans/PersistenceDelegate.html#initialize-java.lang.Class-java.lang.Object-java.lang.Object-java.beans.Encoder-">initialize</a></code>在类别 
            <code><a href="../../java/beans/PersistenceDelegate.html" title="class in java.beans">PersistenceDelegate</a></code>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>type</code> - 
            <code>type</code>的类型 
           </dd>
<dd>
<code>oldInstance</code> - 要复制的实例。 
           </dd>
<dd>
<code>newInstance</code> - 要修改的实例。 
           </dd>
<dd>
<code>out</code> - 应写入任何初始化语句的流。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>out</code>是 
            <code>null</code>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/beans/Introspector.html#getBeanInfo-java.lang.Class-"><code>Introspector.getBeanInfo(java.lang.Class&lt;?&gt;)</code></a> ， <a href="../../java/beans/PropertyDescriptor.html" title="java.beans中的类"><code>PropertyDescriptor</code></a></span>
</dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>