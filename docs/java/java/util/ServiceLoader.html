<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.util 
   </div>
<h2 class="title" title="Class ServiceLoader">Class ServiceLoader&lt;S&gt;</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.util.ServiceLoader&lt;S&gt;</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>S</code> - 此装载器要加载的服务类型 
       </dd>
</dl>
<dl>
<dt>
         All Implemented Interfaces: 
       </dt>
<dd>
<span><a href="../../java/lang/Iterable.html" title="java.lang中的接口">Iterable</a> &lt;S&gt;</span>
</dd>
</dl>
<hr/> <br/> <pre>public final class <span class="typeNameLabel">ServiceLoader&lt;S&gt;</span>
extends <a href="../../java/lang/Object.html" title="class in java.lang">Object</a>
implements <a href="../../java/lang/Iterable.html" title="interface in java.lang">Iterable</a>&lt;S&gt;</pre>
<div class="block">
<span>一个简单的服务提供商加载工具。</span>
<p> <span>一个<i>服务</i>是一组众所周知的接口（通常是抽象的）类。</span> <span><i>服务提供商</i>是<i>服务</i>的具体实现。</span> <span>提供者中的类通常实现接口并对服务本身定义的类进行子类化。</span> <span>服务提供商可以以Java扩展的形式安装在Java平台的实现中，也就是将jar文件放置到任何通常的扩展目录中。</span> <span>提供商也可以通过将它们添加到应用程序的类路径或某些其他平台特定的方式来提供。</span> </p>
<p> <span>为了加载，服务由单一类型表示，即单个接口或抽象类。</span> <span>（可以使用一个具体的类，但不建议使用）。给定服务的提供者包含一个或多个具体的类，以扩展此<i>服务类型</i> ，并提供特定于该提供者的数据和代码。</span> <span><i>提供程序类</i>通常不是整个提供程序本身，而是一个包含足够信息的代理，以确定提供程序是否能够满足特定请求以及可以根据需要创建实际提供程序的代码。</span> <span>提供者类的细节往往是高度服务特定的;</span> <span>没有一个类或接口可能会统一它们，所以在这里不定义这样的类型。</span> <span>该工具强制执行的唯一要求是提供程序类必须具有零参数构造函数，以便在加载期间实例化它们。</span> </p>
<p> <span><a name="format">A service provider is identified by placing a <i>provider-configuration file</i> in the resource directory <tt>META-INF/services</tt>.</a>该文件的名称是服务类型的全资格<a href="../lang/ClassLoader.html#name">binary name</a> 。</span> <span>该文件包含具体提供程序类的完全限定二进制名称列表，每行一个。</span> <span>忽略每个名称周围的空格和制表符，以及空白行。</span> <span>注释字符为<tt>'#'</tt> （ <tt>'\u0023'</tt> ， <font style="font-size:smaller;">NUMBER SIGN</font> ）;</span> <span>在每行上，忽略第一个注释字符之后的所有字符。</span> <span>文件必须以UTF-8编码。</span> </p>
<p> <span>如果一个特定的具体提供程序类在多个配置文件中命名，或者在同一配置文件中多次命名，则忽略重复的配置文件。</span> <span>命名特定提供者的配置文件不需要与提供者本身在同一个jar文件或其他分发单元中。</span> <span>提供程序必须可以从初始查询的相同类加载器访问以查找配置文件;</span> <span>请注意，这不一定是文件实际加载的类加载器。</span> </p>
<p> <span>供应商懒惰地定位和实例化，也就是按需。</span> <span>服务加载器维护到目前为止已经加载的提供程序的缓存。</span> <span>每次调用<a href="../../java/util/ServiceLoader.html#iterator--"><code>iterator</code></a>方法<a href="../../java/util/ServiceLoader.html#iterator--">都会</a>返回一个迭代器，首先按照实例化顺序生成缓存的所有元素，然后懒惰地定位和实例化任何剩余的提供程序，依次将每个元素添加到缓存中。</span> <span>缓存可以通过<a href="../../java/util/ServiceLoader.html#reload--"><code>reload</code></a>方法清除。</span> </p>
<p> <span>服务加载器总是在调用者的安全上下文中执行。</span> <span>受信任的系统代码应通常调用此类中的方法，以及从特权安全上下文中返回的迭代器的方法。</span> </p>
<p> <span>此类的实例不能安全地被多个并发线程使用。</span> </p>
<p> <span>除非另有说明，否则传递<tt>null</tt>参数到此类中的任何方法将导致抛出<a href="../../java/lang/NullPointerException.html" title="java.lang中的类"><code>NullPointerException</code></a> 。</span> </p>
<p> <span><span style="font-weight: bold; padding-right: 1em">示例</span>假设我们有一个服务类型<tt>com.example.CodecSet</tt> ，用于表示一些协议的编码器/解码器对的集合。</span> <span>在这种情况下，它是一个抽象类，有两个抽象方法：</span> </p>
<blockquote>
<span><pre>
 public abstract Encoder getEncoder(String encodingName);
 public abstract Decoder getDecoder(String encodingName);</pre></span>
</blockquote>
<span>如果提供程序不支持给定的编码，每个方法返回一个适当的对象或<tt>null</tt> 。</span>
<span>典型的提供商支持多个编码。</span>
<p> <span>如果<tt>com.example.impl.StandardCodecs</tt>是<tt>CodecSet</tt>服务的实现，那么它的jar文件也包含一个名为</span> </p>
<blockquote>
<span><pre>
 META-INF/services/com.example.CodecSet</pre></span>
</blockquote>
<p> <span>此文件包含单行：</span> </p>
<blockquote>
<span><pre>
 com.example.impl.StandardCodecs    # Standard codecs</pre></span>
</blockquote>
<p> <span><tt>CodecSet</tt>类在<tt>初始化时</tt>创建并保存单个服务实例：</span> </p>
<blockquote>
<span><pre>
 private static ServiceLoader&lt;CodecSet&gt; codecSetLoader
     = ServiceLoader.load(CodecSet.class);</pre></span>
</blockquote>
<p> <span>为了找到一个给定的编码名称的编码器，它定义了一个静态工厂方法，它遍历已知和可用的提供者，只有当它找到一个合适的编码器或已经用完提供者时才返回。</span> </p>
<blockquote>
<span><pre>
 public static Encoder getEncoder(String encodingName) {
     for (CodecSet cp : codecSetLoader) {
         Encoder enc = cp.getEncoder(encodingName);
         if (enc != null)
             return enc;
     }
     return null;
 }</pre></span>
</blockquote>
<p> <span><tt>类似地</tt>定义了getDecoder方法。</span> </p>
<p> <span><span style="font-weight: bold; padding-right: 1em">用法注意</span>如果用于提供程序加载的类加载器的类路径包括远程网络URL，则在搜索提供程序配置文件的过程中将取消引用这些URL。</span> </p>
<p> <span>此活动是正常的，尽管它可能会导致在Web服务器日志中创建令人困惑的条目。</span> <span>但是，如果Web服务器配置不正确，则此活动可能导致提供程序加载算法发生故障。</span> </p>
<p> <span>当所请求的资源不存在时，Web服务器应返回HTTP 404（未找到）响应。</span> <span>然而，有时，网络服务器错误地配置为在这种情况下返回HTTP 200（OK）响应以及有用的HTML错误页面。</span> <span>这将导致一个<a href="../../java/util/ServiceConfigurationError.html" title="java.util中的类"><code>ServiceConfigurationError</code></a>当这个类尝试解析HTML页面作为提供者配置文件被抛出。</span> <span>解决此问题的最佳方法是修复配置错误的Web服务器，以返回正确的响应代码（HTTP 404）以及HTML错误页面。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.6 
       </dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t1"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code><a href="../../java/util/Iterator.html" title="interface in java.util">Iterator</a>&lt;<a href="../../java/util/ServiceLoader.html" title="type parameter in ServiceLoader">S</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/ServiceLoader.html#iterator--">iterator</a></span>()</code>
<div class="block">
              懒洋洋地加载这个装载机服务的可用提供商。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>static &lt;S&gt; <a href="../../java/util/ServiceLoader.html" title="class in java.util">ServiceLoader</a>&lt;S&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/ServiceLoader.html#load-java.lang.Class-">load</a></span>(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;S&gt; service)</code>
<div class="block">
              使用当前线程的 
             <a href="../../java/lang/Thread.html#getContextClassLoader--">context class loader</a>为给定的服务类型创建一个新的服务加载器。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>static &lt;S&gt; <a href="../../java/util/ServiceLoader.html" title="class in java.util">ServiceLoader</a>&lt;S&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/ServiceLoader.html#load-java.lang.Class-java.lang.ClassLoader-">load</a></span>(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;S&gt; service, <a href="../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> loader)</code>
<div class="block">
              为给定的服务类型和类加载器创建一个新的服务加载器。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>static &lt;S&gt; <a href="../../java/util/ServiceLoader.html" title="class in java.util">ServiceLoader</a>&lt;S&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/ServiceLoader.html#loadInstalled-java.lang.Class-">loadInstalled</a></span>(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;S&gt; service)</code>
<div class="block">
              使用扩展类加载器为给定的服务类型创建一个新的服务加载器。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/ServiceLoader.html#reload--">reload</a></span>()</code>
<div class="block">
              清除此加载程序的提供程序缓存，以便所有提供程序都将重新加载。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code><a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/ServiceLoader.html#toString--">toString</a></span>()</code>
<div class="block">
              返回描述此服务的字符串。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../java/lang/Object.html#clone--">clone</a>, <a href="../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../java/lang/Object.html#notify--">notify</a>, <a href="../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../java/lang/Object.html#wait--">wait</a>, <a href="../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Iterable">
<!-- --> </a> <h3>Methods inherited from interface java.lang.<a href="../../java/lang/Iterable.html" title="interface in java.lang">Iterable</a></h3> <code><a href="../../java/lang/Iterable.html#forEach-java.util.function.Consumer-">forEach</a>, <a href="../../java/lang/Iterable.html#spliterator--">spliterator</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="reload--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>reload</h4> <pre>public void reload()</pre>
<div class="block">
<span>清除此加载程序的提供程序缓存，以便所有提供程序都将重新加载。</span>
<p> <span>调用此方法后，<code>iterator</code>方法的<a href="../../java/util/ServiceLoader.html#iterator--">后续</a>调用将从头开始轻松查找和实例化提供程序，就像新创建的加载程序一样。</span> </p>
<p> <span>此方法适用于将新提供程序安装到正在运行的Java虚拟机中的情况。</span> </p>
</div> </li>
</ul> <a name="iterator--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>iterator</h4> <pre>public <a href="../../java/util/Iterator.html" title="interface in java.util">Iterator</a>&lt;<a href="../../java/util/ServiceLoader.html" title="type parameter in ServiceLoader">S</a>&gt; iterator()</pre>
<div class="block">
<span>懒洋洋地加载这个装载机服务的可用提供商。</span>
<p> <span>该方法返回的迭代器首先以实例化顺序生成提供程序缓存的所有元素。</span> <span>然后它懒惰地加载和实例化任何剩余的提供商，依次将每个提供者添加到缓存。</span> </p>
<p> <span>为了实现懒惰，解析可用的提供者配置文件和实例提供者的实际工作必须由迭代器本身完成。</span> <span><a href="../../java/util/Iterator.html#hasNext--">因此</a> ，如果提供商配置文件违反了指定的格式，或者如果命名了一个无法找到和实例化的提供程序类，或者实例化该类的结果不能分配给服务类型，那么它的<a href="../../java/util/Iterator.html#hasNext--"><code>hasNext</code></a>和<a href="../../java/util/Iterator.html#next--"><code>next</code></a>方法可能会抛出一个<a href="../../java/util/ServiceConfigurationError.html" title="java.util中的类"><code>ServiceConfigurationError</code></a> ，或者如果下一个提供程序位于和实例化时抛出任何其他类型的异常或错误。</span> <span>要编写稳健的代码，只<a href="../../java/util/ServiceConfigurationError.html" title="java.util中的类">需要</a>在使用服务迭代器时捕获<a href="../../java/util/ServiceConfigurationError.html" title="java.util中的类"><code>ServiceConfigurationError</code></a> 。</span> </p>
<p> <span>如果抛出了这样的错误，那么迭代器的后续调用将尽可能地定位和实例化下一个可用的提供程序，但是一般来说这种恢复是无法保证的。</span> </p>
<blockquote style="font-size: smaller; line-height: 1.2">
<span><span style="padding-right: 1em; font-weight: bold">Design Note</span> Throwing an error in these cases may seem extreme. The rationale for this behavior is that a malformed provider-configuration file, like a malformed class file, indicates a serious problem with the way the Java virtual machine is configured or is being used. As such it is preferable to throw an error rather than try to recover or, even worse, fail silently.</span>
</blockquote>
<p> <span>该方法返回的迭代器不支持删除。</span> <span>调用其<a href="../../java/util/Iterator.html#remove--"><code>remove</code></a>方法将导致抛出<a href="../../java/lang/UnsupportedOperationException.html" title="java.lang中的类"><code>UnsupportedOperationException</code></a> 。</span> </p>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../java/lang/Iterable.html#iterator--">iterator</a></code>在接口 
            <code><a href="../../java/lang/Iterable.html" title="interface in java.lang">Iterable</a>&lt;<a href="../../java/util/ServiceLoader.html" title="type parameter in ServiceLoader">S</a>&gt;</code>
</dd>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
             当向缓存添加提供程序时， 
            <a href="../../java/util/ServiceLoader.html#iterator--"><code>Iterator</code></a>按照 
            <a href="../../java/lang/ClassLoader.html#getResources-java.lang.String-"><code>ClassLoader.getResources(String)</code></a>方法查找服务配置文件的顺序处理 
            <a href="../../java/lang/ClassLoader.html#getResources-java.lang.String-">资源</a> 。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个迭代器，它为这个加载程序的服务懒惰地加载提供程序 
           </dd>
</dl> </li>
</ul> <a name="load-java.lang.Class-java.lang.ClassLoader-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>load</h4> <pre>public static &lt;S&gt; <a href="../../java/util/ServiceLoader.html" title="class in java.util">ServiceLoader</a>&lt;S&gt; load(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;S&gt; service,
                                        <a href="../../java/lang/ClassLoader.html" title="class in java.lang">ClassLoader</a> loader)</pre>
<div class="block">
            为给定的服务类型和类加载器创建一个新的服务加载器。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>S</code> - 服务类的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>service</code> - 表示服务的接口或抽象类 
           </dd>
<dd>
<code>loader</code> -类加载器用于加载提供者配置文件和提供者类，或 
            <tt>null</tt>如果系统类加载器（或，如若不然，引导类加载器）是用来 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个新的服务装载机 
           </dd>
</dl> </li>
</ul> <a name="load-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>load</h4> <pre>public static &lt;S&gt; <a href="../../java/util/ServiceLoader.html" title="class in java.util">ServiceLoader</a>&lt;S&gt; load(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;S&gt; service)</pre>
<div class="block">
<span>使用当前线程的<a href="../../java/lang/Thread.html#getContextClassLoader--">context class loader</a>为给定的服务类型创建一个新的服务加载器。</span>
<p> <span>调用这种方便的方式的形式</span> </p>
<blockquote>
<span><pre>
 ServiceLoader.load(<i>service</i>)</pre></span>
</blockquote>
<span>相当于</span>
<blockquote>
<span><pre>
 ServiceLoader.load(<i>service</i>,
                    Thread.currentThread().getContextClassLoader())</pre></span>
</blockquote>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>S</code> - 服务类型的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>service</code> - 表示服务的接口或抽象类 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个新的服务装载机 
           </dd>
</dl> </li>
</ul> <a name="loadInstalled-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>loadInstalled</h4> <pre>public static &lt;S&gt; <a href="../../java/util/ServiceLoader.html" title="class in java.util">ServiceLoader</a>&lt;S&gt; loadInstalled(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;S&gt; service)</pre>
<div class="block">
<span>使用扩展类加载器为给定的服务类型创建一个新的服务加载器。</span>
<p> <span>这种方便的方法只是定位扩展类加载器，调用它<tt><i>extClassLoader</i></tt> ，然后返回</span> </p>
<blockquote>
<span><pre>
 ServiceLoader.load(<i>service</i>, <i>extClassLoader</i>)</pre></span>
</blockquote>
<p> <span>如果无法找到扩展类加载器，则使用系统类加载器;</span> <span>如果没有系统类加载器，则使用引导类加载器。</span> </p>
<p> <span>此方法仅在需要安装的提供程序时使用。</span> <span>所产生的服务将只找到并加载已安装到当前Java虚拟机中的提供程序;</span> <span>应用程序的类路径上的提供程序将被忽略。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>S</code> - 服务类的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>service</code> - 表示服务的接口或抽象类 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个新的服务装载机 
           </dd>
</dl> </li>
</ul> <a name="toString--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>toString</h4> <pre>public <a href="../../java/lang/String.html" title="class in java.lang">String</a> toString()</pre>
<div class="block">
            返回描述此服务的字符串。 
          </div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../java/lang/Object.html#toString--">toString</a></code>在类 
            <code><a href="../../java/lang/Object.html" title="class in java.lang">Object</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             A descriptive string 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>