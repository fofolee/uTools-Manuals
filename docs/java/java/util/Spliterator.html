<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.util 
   </div>
<h2 class="title" title="Interface Spliterator">Interface Spliterator&lt;T&gt;</h2>
</div><div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 此Spliter的返回元素的类型 
       </dd>
</dl>
<dl>
<dt>
         All Known Subinterfaces: 
       </dt>
<dd>
<span><a href="../../java/util/Spliterator.OfDouble.html" title="java.util中的接口">Spliterator.OfDouble</a> ， <a href="../../java/util/Spliterator.OfInt.html" title="java.util中的接口">Spliterator.OfInt</a> ， <a href="../../java/util/Spliterator.OfLong.html" title="java.util中的接口">Spliterator.OfLong</a> ， <a href="../../java/util/Spliterator.OfPrimitive.html" title="java.util中的接口">Spliterator.OfPrimitive</a> &lt;T，T_CONS，T_SPLITR&gt;</span>
</dd>
</dl>
<dl>
<dt>
        所有已知实现类：
       </dt>
<dd>
<span><a href="../../java/util/Spliterators.AbstractDoubleSpliterator.html" title="java.util中的类">Spliterators.AbstractDoubleSpliterator</a> ， <a href="../../java/util/Spliterators.AbstractIntSpliterator.html" title="java.util中的类">Spliterators.AbstractIntSpliterator</a> ， <a href="../../java/util/Spliterators.AbstractLongSpliterator.html" title="java.util中的类">Spliterators.AbstractLongSpliterator</a> ， <a href="../../java/util/Spliterators.AbstractSpliterator.html" title="java.util中的类">Spliterators.AbstractSpliterator</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public interface <span class="typeNameLabel">Spliterator&lt;T&gt;</span></pre>
<div class="block">
<span>用于遍历和分割源的元素的对象。</span>
<span>Spliterator涵盖的元素的来源可以是例如阵列， <a href="../../java/util/Collection.html" title="java.util中的接口"><code>Collection</code></a> ，IO通道或生成器函数。</span>
<p> <span>分割器可以逐个遍历元素（ <a href="../../java/util/Spliterator.html#tryAdvance-java.util.function.Consumer-"><code>tryAdvance()</code></a> ）或批量（ <a href="../../java/util/Spliterator.html#forEachRemaining-java.util.function.Consumer-"><code>forEachRemaining()</code></a> ）。</span> </p>
<p> <span>分割器也可以将其某些元素（使用<a href="../../java/util/Spliterator.html#trySplit--"><code>trySplit()</code></a> ） <a href="../../java/util/Spliterator.html#trySplit--">分割</a>为另一个分割器，以在可能的并行操作中使用。</span> <span>使用不能分割的Spliter的操作或者以非常不平衡或低效的方式进行的操作不太可能受益于并行性。</span> <span>穿透和分流排气元件;</span> <span>每个Spliterator仅对单个批量计算有用。</span> </p>
<p> <span>甲Spliterator还报告一组<a href="../../java/util/Spliterator.html#characteristics--"><code>characteristics()</code></a>选自其结构，源极和元件的<a href="../../java/util/Spliterator.html#ORDERED"><code>ORDERED</code></a> ， <a href="../../java/util/Spliterator.html#DISTINCT"><code>DISTINCT</code></a> ， <a href="../../java/util/Spliterator.html#SORTED"><code>SORTED</code></a> ， <a href="../../java/util/Spliterator.html#SIZED"><code>SIZED</code></a> ， <a href="../../java/util/Spliterator.html#NONNULL"><code>NONNULL</code></a> ， <a href="../../java/util/Spliterator.html#IMMUTABLE"><code>IMMUTABLE</code></a> ， <a href="../../java/util/Spliterator.html#CONCURRENT"><code>CONCURRENT</code></a>和<a href="../../java/util/Spliterator.html#SUBSIZED"><code>SUBSIZED</code></a> 。</span> <span>这些可以由Spliterator客户端使用来控制，专门化或简化计算。</span> <span>例如，<code>Collection</code>的<a href="../../java/util/Collection.html" title="java.util中的接口">Spliterator</a>将报告<code>SIZED</code> ，一个用于<a href="../../java/util/Set.html" title="java.util中的接口"><code>Set</code>的Spliterator</a>将报告<code>DISTINCT</code> ，一个用于<a href="../../java/util/SortedSet.html" title="java.util中的接口"><code>SortedSet</code>的Spliterator</a>也将报告<code>SORTED</code> 。</span> <span>特性报告为简单的单位位。</span> <span>一些特征还限制了方法行为;</span> <span>例如，如果<code>ORDERED</code> ，遍历方法必须符合其记录的顺序。</span> <span>未来可能会定义新特性，因此实现者不应将含义分配给未列出的值。</span> </p>
<p> <span><a name="binding">A Spliterator that does not report <code>IMMUTABLE</code> or <code>CONCURRENT</code> is expected to have a documented policy concerning: when the spliterator <em>binds</em> to the element source; and detection of structural interference of the element source detected after binding.</a> <em>后期绑定的</em> Spliterator在第一次遍历，第一次拆分或第一个查询时针对估计大小而不是在创建Spliter时绑定到元素的来源。</span> <span>没有<em>晚期绑定</em>的拼接器在构造或首次调用任何方法时绑定到元素的来源。</span> <span>在绑定之前对源进行的修改在Spliter运行时被反映。</span> <span>绑定后，如果检测到结构性干扰，拼图器应尽可能地抛出<a href="../../java/util/ConcurrentModificationException.html" title="java.util中的类"><code>ConcurrentModificationException</code></a> 。</span> <span>这样做的分割器称为<em>故障快速</em> 。</span> <span>Spliter的批量遍历方法（ <a href="../../java/util/Spliterator.html#forEachRemaining-java.util.function.Consumer-"><code>forEachRemaining()</code></a> ）可以优化遍历并检查所有元素已经遍历之后的结构干扰，而不是立即检查每个元素并失败。</span> </p>
<p> <span>分配器可以通过<a href="../../java/util/Spliterator.html#estimateSize--"><code>estimateSize()</code></a>方法提供剩余元素数量的估计。</span> <span>理想情况下，如特征<code>SIZED</code>中所反映的<a href="../../java/util/Spliterator.html#SIZED">那样</a> ，该值完全对应于成功<a href="../../java/util/Spliterator.html#SIZED">遍历</a>时遇到的元素的数量。</span> <span>然而，即使不是完全知道的，估计的值值对于在源上执行的操作仍然有用，例如有助于确定是否优选进一步分割或者顺序地遍历剩余的元素。</span> </p>
<p> <span>尽管它们在并行算法中具有明显的实用性，但拼接器并不期望是线程安全的;</span> <span>相反，使用分割器的并行算法的实现应该确保分割器一次只被一个线程使用。</span> <span>这通常是通过<em>串行线程</em>限制来获得的，这通常是通过递归分解工作的典型并行算法的自然结果。</span> <span>调用<a href="../../java/util/Spliterator.html#trySplit--"><code>trySplit()</code></a>的线程可能会将返回的Spliterator移交给另一个线程，而该线程又可以遍历或进一步拆分该分割器。</span> <span>如果两个或多个线程在同一个分割器上同时运行，则分割和遍历的行为是未定义的。</span> <span>如果原来的线程将一个分线器关闭到另一个线程进行处理，则最好是在任何元素消耗<a href="../../java/util/Spliterator.html#tryAdvance-java.util.function.Consumer-"><code>tryAdvance()</code></a>之前发生切换，因为某些保证（例如<a href="../../java/util/Spliterator.html#estimateSize--">SIZED分频器</a>的<code>SIZED</code>精度）仅在遍历开始之前有效。</span> </p>
<p> <span>的原始亚型特<code>Spliterator</code>被提供用于<a href="../../java/util/Spliterator.OfInt.html" title="java.util中的接口"><code>int</code></a> ， <a href="../../java/util/Spliterator.OfLong.html" title="java.util中的接口"><code>long</code></a>和<a href="../../java/util/Spliterator.OfDouble.html" title="java.util中的接口"><code>double</code></a>值。</span> <span>子类型默认实现<a href="../../java/util/Spliterator.html#tryAdvance-java.util.function.Consumer-"><code>tryAdvance(java.util.function.Consumer)</code></a>和<a href="../../java/util/Spliterator.html#forEachRemaining-java.util.function.Consumer-"><code>forEachRemaining(java.util.function.Consumer)</code></a>框原始值到其对应的包装器类的实例。</span> <span>这种拳击可能会破坏使用原始专长所获得的任何性能优势。</span> <span>为了避免拳击，应该使用相应的基于图元的方法。</span> <span>例如， <a href="../../java/util/Spliterator.OfInt.html#tryAdvance-java.util.function.IntConsumer-"><code>Spliterator.OfInt.tryAdvance(java.util.function.IntConsumer)</code></a>和<a href="../../java/util/Spliterator.OfInt.html#forEachRemaining-java.util.function.IntConsumer-"><code>Spliterator.OfInt.forEachRemaining(java.util.function.IntConsumer)</code></a>应优先于<a href="../../java/util/Spliterator.OfInt.html#tryAdvance-java.util.function.Consumer-"><code>Spliterator.OfInt.tryAdvance(java.util.function.Consumer)</code></a>和<a href="../../java/util/Spliterator.OfInt.html#forEachRemaining-java.util.function.Consumer-"><code>Spliterator.OfInt.forEachRemaining(java.util.function.Consumer)</code>使用</a> 。</span> <span>使用基于拳击的方法<a href="../../java/util/Spliterator.html#tryAdvance-java.util.function.Consumer-"><code>tryAdvance()</code></a>和<code>forEachRemaining()</code>对原始值的<a href="../../java/util/Spliterator.html#forEachRemaining-java.util.function.Consumer-">遍历</a>不会影响遇到转换为框值的值的顺序。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">API Note:</span>
</dt>
<dd>
<p> <span>分流器，如<code>Iterators</code> s，用于遍历源的元素。</span> <span><code>Spliterator</code> API旨在通过支持分解和单元素迭代来支持除顺序遍历之外的高效并行遍历。</span> <span>此外，用于通过Spliterator访问元素的协议被设计为比<code>Iterator</code>施加更小的每元素开销，并且避免为<code>hasNext()</code>和<code>next()</code>分开方法所涉及的固有竞争。</span> </p>
<p> <span>对于可变源，如果在Striterator绑定到其数据源的时间与遍历结束之间，源在结构上受到干扰（添加，替换或删除的元素），则可能会发生任意和非确定性行为。</span> <span>例如，当使用<code>java.util.stream</code>框架时，这种干扰将产生任意的非确定性结果。</span> </p>
<p> <span>源的结构干扰可以通过以下方式进行管理（大概顺序为减少的可取性）：</span> </p>
<ul>
<li> <span>来源不能在结构上受到干扰。</span> <br/> <span>例如， <a href="../../java/util/concurrent/CopyOnWriteArrayList.html" title="java.util.concurrent中的类"><code>CopyOnWriteArrayList</code>的</a>一个实例是一个不可变的来源。</span> <span>从源头创建的Spliterator报告了IMMUTABLE的<code>IMMUTABLE</code> 。</span> </li>
<li> <span>源代码管理并发修改。</span> <br/> <span>例如，一个<a href="../../java/util/concurrent/ConcurrentHashMap.html" title="java.util.concurrent中的类"><code>ConcurrentHashMap</code></a>的密钥集是并发源。</span> <span>从源头创建的Spliterator报告了CONCURRENT的<code>CONCURRENT</code> 。</span> </li>
<li> <span>可变源提供后期绑定和故障切换快速分割器。</span> <br/> <span>后期约束使窗口缩小，在此期间干扰可影响计算;</span> <span>故障快速检测在尽力而为的基础上，遍历开始后发生结构性干扰，并抛出<a href="../../java/util/ConcurrentModificationException.html" title="java.util中的类"><code>ConcurrentModificationException</code></a> 。</span> <span>例如， <a href="../../java/util/ArrayList.html" title="java.util中的类"><code>ArrayList</code></a>和JDK中的许多其他非并发的<code>Collection</code>类，提供了后期绑定，故障快速分片器。</span> </li>
<li> <span>可变源提供了一个非后期绑定但是故障快速的分割器。</span> <br/> <span>源可能会增加投掷<code>ConcurrentModificationException</code>因为潜在的干扰窗口较大。</span> </li>
<li> <span>可变源提供后期绑定和非故障快速的分割器。</span> <br/> <span>由于没有检测到干扰，因此源头在遍历之后出现任意的非确定性行为。</span> </li>
<li> <span>可变源提供非后期绑定和非故障快速的分割器。</span> <br/> <span>来源增加了任意非确定性行为的风险，因为在建设后可能会发生非检测到的干扰。</span> </li>
</ul>
<p> <span><b>例。</b></span> <span>这是一个类（不是非常有用的，除了说明），它维护一个数组，其中实际数据保存在偶数位置，而不相关的标签数据保存在奇数位置。</span> <span>它的Spliterator忽略标签。</span> </p>
<pre>  <span><code> class TaggedArray&lt;T&gt; { private final Object[] elements; // immutable after construction TaggedArray(T[] data, Object[] tags) { int size = data.length; if (tags.length != size) throw new IllegalArgumentException(); this.elements = new Object[2 * size]; for (int i = 0, j = 0; i &lt; size; ++i) { elements[j++] = data[i]; elements[j++] = tags[i]; } } public Spliterator&lt;T&gt; spliterator() { return new TaggedArraySpliterator&lt;&gt;(elements, 0, elements.length); } static class TaggedArraySpliterator&lt;T&gt; implements Spliterator&lt;T&gt; { private final Object[] array; private int origin; // current index, advanced on split or traversal private final int fence; // one past the greatest index TaggedArraySpliterator(Object[] array, int origin, int fence) { this.array = array; this.origin = origin; this.fence = fence; } public void forEachRemaining(Consumer&lt;? super T&gt; action) { for (; origin &lt; fence; origin += 2) action.accept((T) array[origin]); } public boolean tryAdvance(Consumer&lt;? super T&gt; action) { if (origin &lt; fence) { action.accept((T) array[origin]); origin += 2; return true; } else // cannot advance return false; } public Spliterator&lt;T&gt; trySplit() { int lo = origin; // divide range in half int mid = ((lo + fence) &gt;&gt;&gt; 1) &amp; ~1; // force midpoint to be even if (lo &lt; mid) { // split out left half origin = mid; // reset this Spliterator's origin return new TaggedArraySpliterator&lt;&gt;(array, lo, mid); } else // too small to split return null; } public long estimateSize() { return (long)((fence - origin) / 2); } public int characteristics() { return ORDERED | SIZED | IMMUTABLE | SUBSIZED; } } }</code></span> </pre>
<p> <span>作为示例，并行计算框架（如<code>java.util.stream</code>程序包）将在并行计算中使用Spliterator，这里是实现相关联的并行forEach的一种方法，它说明了拆分子任务的主要用法，直到估计工作量足够小以顺序执行。</span> <span>这里我们假设子任务处理的顺序并不重要;</span> <span>不同的（分叉）任务可以进一步拆分并以未确定的顺序处理元素。</span> <span>本例使用<a href="../../java/util/concurrent/CountedCompleter.html" title="java.util.concurrent中的类"><code>CountedCompleter</code></a> ;</span> <span>类似的用法适用于其他并行任务构造。</span> </p>
<pre>  <span><code> static &lt;T&gt; void parEach(TaggedArray&lt;T&gt; a, Consumer&lt;T&gt; action) { Spliterator&lt;T&gt; s = a.spliterator(); long targetBatchSize = s.estimateSize() / (ForkJoinPool.getCommonPoolParallelism() * 8); new ParEach(null, s, action, targetBatchSize).invoke(); } static class ParEach&lt;T&gt; extends CountedCompleter&lt;Void&gt; { final Spliterator&lt;T&gt; spliterator; final Consumer&lt;T&gt; action; final long targetBatchSize; ParEach(ParEach&lt;T&gt; parent, Spliterator&lt;T&gt; spliterator, Consumer&lt;T&gt; action, long targetBatchSize) { super(parent); this.spliterator = spliterator; this.action = action; this.targetBatchSize = targetBatchSize; } public void compute() { Spliterator&lt;T&gt; sub; while (spliterator.estimateSize() &gt; targetBatchSize &amp;&amp; (sub = spliterator.trySplit()) != null) { addToPendingCount(1); new ParEach&lt;&gt;(this, sub, action, targetBatchSize).fork(); } spliterator.forEachRemaining(action); propagateCompletion(); } }</code></span> </pre>
</dd>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
         如果布尔系统属性 
        <code>org.openjdk.java.util.stream.tripwire</code>设置为 
        <code>true</code>则在对原始子类型专门化进行操作时，如果出现原始值的封锁，则会报告诊断警告。 
       </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.8 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/util/Collection.html" title="java.util中的接口"><code>Collection</code></a></span>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!-- --> </a> <h3>Nested Class Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption>
<span>Nested Classes</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Interface and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static interface </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.OfDouble.html" title="interface in java.util">Spliterator.OfDouble</a></span></code>
<div class="block">
              A Spliterator专门为 
             <code>double</code>值。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static interface </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.OfInt.html" title="interface in java.util">Spliterator.OfInt</a></span></code>
<div class="block">
              A Spliterator专门为 
             <code>int</code>值。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static interface </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.OfLong.html" title="interface in java.util">Spliterator.OfLong</a></span></code>
<div class="block">
              A Spliterator专门为 
             <code>long</code>值。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static interface </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.OfPrimitive.html" title="interface in java.util">Spliterator.OfPrimitive</a>&lt;<a href="../../java/util/Spliterator.OfPrimitive.html" title="type parameter in Spliterator.OfPrimitive">T</a>,<a href="../../java/util/Spliterator.OfPrimitive.html" title="type parameter in Spliterator.OfPrimitive">T_CONS</a>,<a href="../../java/util/Spliterator.OfPrimitive.html" title="type parameter in Spliterator.OfPrimitive">T_SPLITR</a> extends <a href="../../java/util/Spliterator.OfPrimitive.html" title="interface in java.util">Spliterator.OfPrimitive</a>&lt;<a href="../../java/util/Spliterator.OfPrimitive.html" title="type parameter in Spliterator.OfPrimitive">T</a>,<a href="../../java/util/Spliterator.OfPrimitive.html" title="type parameter in Spliterator.OfPrimitive">T_CONS</a>,<a href="../../java/util/Spliterator.OfPrimitive.html" title="type parameter in Spliterator.OfPrimitive">T_SPLITR</a>&gt;&gt;</span></code>
<div class="block">
              专门针对原始价值观的Spliterator。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!-- --> </a> <h3>Field Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Field Summary table, listing fields, and an explanation">
<caption>
<span>Fields</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.html#CONCURRENT">CONCURRENT</a></span></code>
<div class="block">
              特征值表示可以通过多个线程安全同时修改元素源（允许添加，替换和/或删除），而无需外部同步。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.html#DISTINCT">DISTINCT</a></span></code>
<div class="block">
              特性值这标志着，对于每对遇到的元件 
             <code>x, y</code> ， 
             <code>!x.equals(y)</code> 。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.html#IMMUTABLE">IMMUTABLE</a></span></code>
<div class="block">
<span>特征值表示元素源不能在结构上进行修改;</span>
<span>也就是说，不能添加，替换或删除元素，因此在遍历过程中不会发生这种更改。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.html#NONNULL">NONNULL</a></span></code>
<div class="block">
              特征值表示源保证遇到的元素不会为 
             <code>null</code> 。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.html#ORDERED">ORDERED</a></span></code>
<div class="block">
              特征值表示为元素定义遇到顺序。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.html#SIZED">SIZED</a></span></code>
<div class="block">
              表示在遍历或 
             <code>estimateSize()</code>之前从 
             <code>estimateSize()</code>返回的值的特征值表示在没有结构源修改的情况下表示完全遍历将遇到的元素数量的精确计数的有限大小。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.html#SORTED">SORTED</a></span></code>
<div class="block">
              特征值表示遇到的顺序遵循定义的排序顺序。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.html#SUBSIZED">SUBSIZED</a></span></code>
<div class="block">
              特征值这标志着从产生的所有Spliterators 
             <code>trySplit()</code>将是既 
             <a href="../../java/util/Spliterator.html#SIZED"><code>SIZED</code></a>和 
             <a href="../../java/util/Spliterator.html#SUBSIZED"><code>SUBSIZED</code></a> 。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t3"><span><a href="javascript:show(4);">抽象方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t5"><span><a href="javascript:show(16);">Default Methods</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.html#characteristics--">characteristics</a></span>()</code>
<div class="block">
              返回此Spliterator及其元素的一组特征。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.html#estimateSize--">estimateSize</a></span>()</code>
<div class="block">
              返回 
             <a href="../../java/util/Spliterator.html#forEachRemaining-java.util.function.Consumer-"><code>forEachRemaining(java.util.function.Consumer&lt;? super T&gt;)</code></a>遍历将遇到的元素数量的估计，如果无穷大，未知数或计算 
             <a href="../../java/util/Spliterator.html#forEachRemaining-java.util.function.Consumer-">成本</a>太高，则返回 
             <a href="../../java/lang/Long.html#MAX_VALUE"><code>Long.MAX_VALUE</code></a> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>default void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.html#forEachRemaining-java.util.function.Consumer-">forEachRemaining</a></span>(<a href="../../java/util/function/Consumer.html" title="interface in java.util.function">Consumer</a>&lt;? super <a href="../../java/util/Spliterator.html" title="type parameter in Spliterator">T</a>&gt; action)</code>
<div class="block">
              在当前线程中依次执行每个剩余元素的给定操作，直到所有元素都被处理或动作引发异常。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>default <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super <a href="../../java/util/Spliterator.html" title="type parameter in Spliterator">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.html#getComparator--">getComparator</a></span>()</code>
<div class="block">
<span>如果这个Spliterator的来源是<a href="../../java/util/Spliterator.html#SORTED"><code>SORTED</code></a>由<a href="../../java/util/Comparator.html" title="java.util中的接口"><code>Comparator</code></a> ，返回<code>Comparator</code> 。</span>
</div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>default long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.html#getExactSizeIfKnown--">getExactSizeIfKnown</a></span>()</code>
<div class="block">
              方便的方法返回 
             <a href="../../java/util/Spliterator.html#estimateSize--"><code>estimateSize()</code></a>如果这个Spliterator是 
             <a href="../../java/util/Spliterator.html#SIZED"><code>SIZED</code></a> ，否则 
             <code>-1</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>default boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.html#hasCharacteristics-int-">hasCharacteristics</a></span>(int characteristics)</code>
<div class="block">
              返回 
             <code>true</code>如果Spliterator的 
             <a href="../../java/util/Spliterator.html#characteristics--"><code>characteristics()</code></a>包含所有给定的特性。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.html#tryAdvance-java.util.function.Consumer-">tryAdvance</a></span>(<a href="../../java/util/function/Consumer.html" title="interface in java.util.function">Consumer</a>&lt;? super <a href="../../java/util/Spliterator.html" title="type parameter in Spliterator">T</a>&gt; action)</code>
<div class="block">
<span>如果剩下的元素存在，执行给定的操作，返回<code>true</code> ;</span>
<span>否则返回<code>false</code> 。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code><a href="../../java/util/Spliterator.html" title="interface in java.util">Spliterator</a>&lt;<a href="../../java/util/Spliterator.html" title="type parameter in Spliterator">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Spliterator.html#trySplit--">trySplit</a></span>()</code>
<div class="block">
              如果此分割器可以被分区，返回一个包含元素的Spliter，当从该方法返回时，它不会被该Spliter所覆盖。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!-- --> </a> <h3>字段详细信息</h3> <a name="ORDERED">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ORDERED</h4> <pre>static final int ORDERED</pre>
<div class="block">
<span>特征值表示为元素定义遇到顺序。</span>
<span>如果是这样，这个Spliterer保证方法<a href="../../java/util/Spliterator.html#trySplit--"><code>trySplit()</code></a>按照前缀顺序将元素的严格前缀，方法<a href="../../java/util/Spliterator.html#tryAdvance-java.util.function.Consumer-"><code>tryAdvance(java.util.function.Consumer&lt;? super T&gt;)</code></a>按一个元素<a href="../../java/util/Spliterator.html#forEachRemaining-java.util.function.Consumer-">分隔</a> ，并且<a href="../../java/util/Spliterator.html#forEachRemaining-java.util.function.Consumer-"><code>forEachRemaining(java.util.function.Consumer&lt;? super T&gt;)</code></a>以遇到的顺序执行操作。</span>
<p> <span>A <a href="../../java/util/Collection.html" title="java.util中的接口"><code>Collection</code></a>有相应的顺序，如果对应的<a href="../../java/util/Collection.html#iterator--"><code>Collection.iterator()</code></a>文件订单。</span> <span>如果是这样，遇到的订单与记录的订单相同。</span> <span>否则，集合没有遇到订单。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">API Note:</span>
</dt>
<dd>
<span>对于任何<a href="../../java/util/List.html" title="java.util中的接口"><code>List</code>，</a>遇到的订单保证是升序索引顺序。</span>
<span>但是，对于基于哈希的集合，如<a href="../../java/util/HashSet.html" title="java.util中的类"><code>HashSet</code></a>没有保证任何顺序。</span>
<span>报告<code>ORDERED</code>客户端将预期在非交换并行计算中保留排序约束。</span>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.util.Spliterator.ORDERED">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="DISTINCT">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>DISTINCT</h4> <pre>static final int DISTINCT</pre>
<div class="block">
<span>特性值这标志着，对于每对遇到的元件<code>x, y</code> ， <code>!x.equals(y)</code> 。</span>
<span>这适用于例如基于<a href="../../java/util/Set.html" title="java.util中的接口"><code>Set</code>的Spliterator</a> 。</span>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.util.Spliterator.DISTINCT">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="SORTED">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>SORTED</h4> <pre>static final int SORTED</pre>
<div class="block">
<span>特征值表示遇到的顺序遵循定义的排序顺序。</span>
<span>如果是这样，方法<a href="../../java/util/Spliterator.html#getComparator--"><code>getComparator()</code></a>返回相关的比较器，或<code>null</code>如果所有元素都是<a href="../../java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a> ，并按其自然排序进行排序。</span>
<p> <span>报告<code>SORTED</code>也必须报<code>ORDERED</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">API Note:</span>
</dt>
<dd>
<span>JDK中的<code>Collection</code>类的编译器<a href="../../java/util/NavigableSet.html" title="java.util中的接口">实现<code>NavigableSet</code></a>或<a href="../../java/util/SortedSet.html" title="java.util中的接口"><code>SortedSet</code></a>报告<code>SORTED</code> 。</span>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.util.Spliterator.SORTED">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="SIZED">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>SIZED</h4> <pre>static final int SIZED</pre>
<div class="block">
            表示在遍历或 
           <code>estimateSize()</code>之前从 
           <code>estimateSize()</code>返回的值的特征值表示在没有结构源修改的情况下表示完全遍历将遇到的元素数量的精确计数的有限大小。 
          </div>
<dl>
<dt>
<span class="simpleTagLabel">API Note:</span>
</dt>
<dd>
<span>大多数Spliterators对于集合，这涵盖的所有元素<code>Collection</code>报告这一特点。</span>
<span>子分割器，例如<a href="../../java/util/HashSet.html" title="java.util中的类"><code>HashSet</code></a>的子<a href="../../java/util/HashSet.html" title="java.util中的类">分割器</a> ，不包括覆盖元素的子集并且近似其报告的大小。</span>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.util.Spliterator.SIZED">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="NONNULL">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>NONNULL</h4> <pre>static final int NONNULL</pre>
<div class="block">
<span>特征值表示源保证遇到的元素不会是<code>null</code> 。</span>
<span>（这适用于大多数并发集合，队列和映射）。</span>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.util.Spliterator.NONNULL">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="IMMUTABLE">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>IMMUTABLE</h4> <pre>static final int IMMUTABLE</pre>
<div class="block">
<span>特征值表示元素源不能在结构上进行修改;</span>
<span>也就是说，不能添加，替换或删除元素，因此在遍历过程中不会发生这种更改。</span>
<span>不报告<code>IMMUTABLE</code>或<code>CONCURRENT</code>预计将有关于在遍历期间检测到的结构性干扰的文件化策略（例如投掷<a href="../../java/util/ConcurrentModificationException.html" title="java.util中的类"><code>ConcurrentModificationException</code></a> ）。</span>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.util.Spliterator.IMMUTABLE">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="CONCURRENT">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>CONCURRENT</h4> <pre>static final int CONCURRENT</pre>
<div class="block">
<span>特征值表示可以通过多个线程安全同时修改元素源（允许添加，替换和/或删除），而无需外部同步。</span>
<span>如果是这样，那么Spliterator应该有一个关于在遍历过程中修改影响的文件化政策。</span>
<p> <span>顶级Spliterator不应同时报告<code>CONCURRENT</code>和<code>SIZED</code> ，因为如果已知的有限大小可能会在遍历期间同时修改源时发生更改。</span> <span>这样的分割器是不一致的，并且不能保证使用该分割器的任何计算。</span> <span>子分割器可以报告<code>SIZED</code>如果子分割大小是已知的，并且在遍历时不反映源的添加或移除。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">API Note:</span>
</dt>
<dd>
             大多数并发收藏集保持一致性政策，保证在Spliterator构建点存在的元素的准确性，但可能不反映随后的添加或删除。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.util.Spliterator.CONCURRENT">Constant Field Values</a>
</dd>
</dl> </li>
</ul> <a name="SUBSIZED">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>SUBSIZED</h4> <pre>static final int SUBSIZED</pre>
<div class="block">
<span>特征值这标志着从产生的所有Spliterators <code>trySplit()</code>将是既<a href="../../java/util/Spliterator.html#SIZED"><code>SIZED</code></a>和<a href="../../java/util/Spliterator.html#SUBSIZED"><code>SUBSIZED</code></a> 。</span>
<span>（这意味着无论是直接还是间接的，所有的小孩拼写器都将是<code>SIZED</code> ）</span>
<p> <span>根据SUBSIZED的要求不会报告<code>SIZED</code>的<code>SUBSIZED</code>不一致，并且不能保证使用该Spliter的任何计算。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">API Note:</span>
</dt>
<dd>
             一些拼接器，例如用于大致平衡的二叉树的顶级拼接器，将报告 
            <code>SIZED</code>而不是 
            <code>SUBSIZED</code> ，因为通常知道整个树的大小，而不知道子树的确切大小。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.util.Spliterator.SUBSIZED">Constant Field Values</a>
</dd>
</dl> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="tryAdvance-java.util.function.Consumer-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>tryAdvance</h4> <pre>boolean tryAdvance(<a href="../../java/util/function/Consumer.html" title="interface in java.util.function">Consumer</a>&lt;? super <a href="../../java/util/Spliterator.html" title="type parameter in Spliterator">T</a>&gt; action)</pre>
<div class="block">
<span>如果剩下的元素存在，执行给定的操作，返回<code>true</code> ;</span>
<span>否则返回<code>false</code> 。</span>
<span>如果此Spliterator是<a href="../../java/util/Spliterator.html#ORDERED"><code>ORDERED</code></a> ，则会在遇到的顺序的下一个元素上执行该操作。</span>
<span>动作抛出的异常被转发给呼叫者。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>action</code> - 行动 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>false</code>如果在进入该方法时没有剩余元素，否则 
            <code>true</code> 。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果指定的动作为空 
           </dd>
</dl> </li>
</ul> <a name="forEachRemaining-java.util.function.Consumer-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>forEachRemaining</h4> <pre>default void forEachRemaining(<a href="../../java/util/function/Consumer.html" title="interface in java.util.function">Consumer</a>&lt;? super <a href="../../java/util/Spliterator.html" title="type parameter in Spliterator">T</a>&gt; action)</pre>
<div class="block">
<span>在当前线程中依次执行每个剩余元素的给定操作，直到所有元素都被处理或动作引发异常。</span>
<span>如果这个Spliterator是<a href="../../java/util/Spliterator.html#ORDERED"><code>ORDERED</code></a> ，则按照遇到的顺序执行操作。</span>
<span>动作抛出的异常被转发给呼叫者。</span>
</div>
<dl>
<dt>
<span class="simpleTagLabel">实现要求：</span>
</dt>
<dd>
<span>默认实现反复调用<a href="../../java/util/Spliterator.html#tryAdvance-java.util.function.Consumer-"><code>tryAdvance(java.util.function.Consumer&lt;? super T&gt;)</code></a> ，直到它返回<code>false</code> 。</span>
<span>应尽可能覆盖。</span>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>action</code> - 行动 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果指定的动作为空 
           </dd>
</dl> </li>
</ul> <a name="trySplit--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>trySplit</h4> <pre><a href="../../java/util/Spliterator.html" title="interface in java.util">Spliterator</a>&lt;<a href="../../java/util/Spliterator.html" title="type parameter in Spliterator">T</a>&gt; trySplit()</pre>
<div class="block">
<span>如果此分割器可以被分区，返回一个包含元素的Spliter，当从该方法返回时，它不会被该Spliter所覆盖。</span>
<p> <span>如果此Spliterator为<a href="../../java/util/Spliterator.html#ORDERED"><code>ORDERED</code></a> ，则返回的Spliterator必须覆盖元素的严格前缀。</span> </p>
<p> <span>除非这个Spliterator包含无数个元素，否则重复调用<code>trySplit()</code>必须最终返回<code>null</code> 。</span> <span>非空返回：</span> </p>
<ul>
<li> <span>报告的值<code>estimateSize()</code>分割之前，必须分割后，大于或等于<code>estimateSize()</code> ，这和返回Spliterator;</span> <span>和</span> </li>
<li> <span>如果这Spliterator是<code>SUBSIZED</code> ，然后<code>estimateSize()</code>这个spliterator分裂之前必须等于总和<code>estimateSize()</code> ，这和拆分后返回Spliterator。</span> </li>
</ul>
<p> <span>该方法可能由于任何原因返回<code>null</code> ，包括空虚，遍历开始后无法拆分，数据结构约束和效率考虑。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">API Note:</span>
</dt>
<dd>
<span>理想的<code>trySplit</code>方法有效（无遍历）将其元素精确地分成两半，允许平衡的并行计算。</span>
<span>许多离开这个理想的人仍然是非常有效的;</span>
<span>例如，仅近似分裂近似平衡的树，或者对于叶节点可以包含一个或两个元素的树，不能进一步分割这些节点。</span>
<span>然而，平衡和/或过低<code>trySplit</code>大偏差<code>trySplit</code>机械通常导致较差的并行性能。</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Spliterator</code>覆盖部分元素，或 
            <code>null</code>如果此拼接器无法拆分 
           </dd>
</dl> </li>
</ul> <a name="estimateSize--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>estimateSize</h4> <pre>long estimateSize()</pre>
<div class="block">
<span>返回<a href="../../java/util/Spliterator.html#forEachRemaining-java.util.function.Consumer-"><code>forEachRemaining(java.util.function.Consumer&lt;? super T&gt;)</code></a>遍历将遇到的元素数量的估计值，如果无穷大，未知数或计算<a href="../../java/util/Spliterator.html#forEachRemaining-java.util.function.Consumer-">成本</a>太高，则返回<a href="../../java/lang/Long.html#MAX_VALUE"><code>Long.MAX_VALUE</code></a> 。</span>
<p> <span>如果此Spliterator为<a href="../../java/util/Spliterator.html#SIZED"><code>SIZED</code></a>且尚未部分遍历或拆分，或该Spliterator为<a href="../../java/util/Spliterator.html#SUBSIZED"><code>SUBSIZED</code></a>并且尚未部分遍历，则此估计必须是完整遍历将遇到的元素的精确计数。</span> <span>否则，此估计可能是任意不准确的，但必须按照<code>trySplit()</code>的调用规定<a href="../../java/util/Spliterator.html#trySplit--">减少</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">API Note:</span>
</dt>
<dd>
<span>即使不精确的估计通常是有用的并且计算成本低廉。</span>
<span>例如，近似平衡的二叉树的子拼接器可以返回将元素的数量估计为其父代的元素的数量的值;</span>
<span>如果根分割器不能保持准确的计数，则可以将尺寸估计为对应于其最大深度的两倍。</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             估计的大小，或 
            <code>Long.MAX_VALUE</code>如果无限，未知或太贵的计算。 
           </dd>
</dl> </li>
</ul> <a name="getExactSizeIfKnown--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getExactSizeIfKnown</h4> <pre>default long getExactSizeIfKnown()</pre>
<div class="block">
            方便的方法返回 
           <a href="../../java/util/Spliterator.html#estimateSize--"><code>estimateSize()</code></a>如果这个Spliterator是 
           <a href="../../java/util/Spliterator.html#SIZED"><code>SIZED</code></a> ，否则 
           <code>-1</code> 。 
          </div>
<dl>
<dt>
<span class="simpleTagLabel">实现要求：</span>
</dt>
<dd>
             默认实现返回的结果 
            <code>estimateSize()</code>如果Spliterator报告的特性 
            <code>SIZED</code>和 
            <code>-1</code>其他。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             确切的大小，如果知道，否则 
            <code>-1</code> 。 
           </dd>
</dl> </li>
</ul> <a name="characteristics--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>characteristics</h4> <pre>int characteristics()</pre>
<div class="block">
<span>返回此Spliterator及其元素的一组特征。</span>
<span>结果从表示为或运算值<a href="../../java/util/Spliterator.html#ORDERED"><code>ORDERED</code></a> ， <a href="../../java/util/Spliterator.html#DISTINCT"><code>DISTINCT</code></a> ， <a href="../../java/util/Spliterator.html#SORTED"><code>SORTED</code></a> ， <a href="../../java/util/Spliterator.html#SIZED"><code>SIZED</code></a> ， <a href="../../java/util/Spliterator.html#NONNULL"><code>NONNULL</code></a> ， <a href="../../java/util/Spliterator.html#IMMUTABLE"><code>IMMUTABLE</code></a> ， <a href="../../java/util/Spliterator.html#CONCURRENT"><code>CONCURRENT</code></a> ， <a href="../../java/util/Spliterator.html#SUBSIZED"><code>SUBSIZED</code></a> 。</span>
<span>重复调用<code>characteristics()</code>在给定的spliterator之前或在两者之间的调用， <code>trySplit</code> ，应始终返回相同的结果。</span>
<p> <span>如果Spliterator报告不一致的特征集（从单个调用返回的或多个调用返回的），则不能保证使用此Spliter的任何计算。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">API Note:</span>
</dt>
<dd>
<span>分裂之前的给定分配器的特性可能与分裂后的特性不同。</span>
<span>对于具体的例子看到的特性值<a href="../../java/util/Spliterator.html#SIZED"><code>SIZED</code></a> ， <a href="../../java/util/Spliterator.html#SUBSIZED"><code>SUBSIZED</code></a>和<a href="../../java/util/Spliterator.html#CONCURRENT"><code>CONCURRENT</code></a> 。</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             特征的表征 
           </dd>
</dl> </li>
</ul> <a name="hasCharacteristics-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>hasCharacteristics</h4> <pre>default boolean hasCharacteristics(int characteristics)</pre>
<div class="block">
            返回 
           <code>true</code>如果Spliterator的 
           <a href="../../java/util/Spliterator.html#characteristics--"><code>characteristics()</code></a>包含所有给定的特性。 
          </div>
<dl>
<dt>
<span class="simpleTagLabel">实现要求：</span>
</dt>
<dd>
             如果给定特征的相应位被设置，默认实现将返回true。 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>characteristics</code> - 检查的特点 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果所有指定的特性都存在，否则 
            <code>false</code>
</dd>
</dl> </li>
</ul> <a name="getComparator--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>getComparator</h4> <pre>default <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super <a href="../../java/util/Spliterator.html" title="type parameter in Spliterator">T</a>&gt; getComparator()</pre>
<div class="block">
<span>如果这个Spliterator的来源是<a href="../../java/util/Spliterator.html#SORTED"><code>SORTED</code></a>由<a href="../../java/util/Comparator.html" title="java.util中的接口"><code>Comparator</code></a> ，返回<code>Comparator</code> 。</span>
<span>如果来源是<code>SORTED</code>在<a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural order</a> ，返回<code>null</code> 。</span>
<span>否则，如果源不是<code>SORTED</code> ，则抛出<a href="../../java/lang/IllegalStateException.html" title="java.lang中的类"><code>IllegalStateException</code></a> 。</span>
</div>
<dl>
<dt>
<span class="simpleTagLabel">实现要求：</span>
</dt>
<dd>
<span>默认实现总是抛出<a href="../../java/lang/IllegalStateException.html" title="java.lang中的类"><code>IllegalStateException</code></a> 。</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             比较器，或 
            <code>null</code>如果元素按照自然顺序排序。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - 如果拼接器没有报告SORTED的 
            <code>SORTED</code> 。 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>