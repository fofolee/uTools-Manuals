<div class="header">
<h1 class="title" title="Package">Package java.util.concurrent</h1>
<div class="docSummary">
<div class="block">
      实用程序类通常在并发编程中很有用。 
    </div>
</div>
<p>See: <a href="#package.description">描述</a></p>
</div><div class="contentContainer">
<ul class="blockList">
<li class="blockList">
<table border="0" cellpadding="3" cellspacing="0" class="typeSummary" summary="Interface Summary table, listing interfaces, and an explanation">
<caption>
<span>接口摘要</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">接口</th>
<th class="colLast" scope="col">描述</th>
</tr>
</tbody>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/BlockingDeque.html" title="interface in java.util.concurrent">BlockingDeque</a>&lt;E&gt;</td>
<td class="colLast">
<div class="block">
<span>A <a href="../../../java/util/Deque.html" title="java.util中的接口"><code>Deque</code></a>另外支持在检索元素时等待deque变为非空的阻塞操作，并且在存储元素时等待空白在deque中可用。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</a>&lt;E&gt;</td>
<td class="colLast">
<div class="block">
<span>A <a href="../../../java/util/Queue.html" title="java.util中的接口"><code>Queue</code></a>还支持在检索元素时等待队列变为非空的操作，并在存储元素时等待队列中的空间变得可用。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;V&gt;</td>
<td class="colLast">
<div class="block">
           返回结果并可能引发异常的任务。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/CompletableFuture.AsynchronousCompletionTask.html" title="interface in java.util.concurrent">CompletableFuture.AsynchronousCompletionTask</a></td>
<td class="colLast">
<div class="block">
           标识接口，用于标识 
          <code>async</code>方法生成的 
          <code>async</code>任务。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/CompletionService.html" title="interface in java.util.concurrent">CompletionService</a>&lt;V&gt;</td>
<td class="colLast">
<div class="block">
           一种将新异步任务的生产与已完成任务的结果消耗相分离的服务。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/CompletionStage.html" title="interface in java.util.concurrent">CompletionStage</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">
           可能的异步计算的阶段，当另一个完成时间完成时，执行一个动作或计算一个值。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,V&gt;</td>
<td class="colLast">
<div class="block">
<span>A <a href="../../../java/util/Map.html" title="java.util中的接口"><code>Map</code></a>提供线程安全和原子性保证。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ConcurrentNavigableMap.html" title="interface in java.util.concurrent">ConcurrentNavigableMap</a>&lt;K,V&gt;</td>
<td class="colLast">
<div class="block">
<span>A <a href="../../../java/util/concurrent/ConcurrentMap.html" title="java.util.concurrent中的接口"><code>ConcurrentMap</code></a>支持<a href="../../../java/util/NavigableMap.html" title="java.util中的接口"><code>NavigableMap</code></a>操作，并且递归地为其可导航的子地图。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/Delayed.html" title="interface in java.util.concurrent">Delayed</a></td>
<td class="colLast">
<div class="block">
           一个混合样式界面，用于标记在给定延迟后应该执行的对象。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/Executor.html" title="interface in java.util.concurrent">Executor</a></td>
<td class="colLast">
<div class="block">
<span>执行提交的对象<a href="../../../java/lang/Runnable.html" title="java.lang中的接口"><code>Runnable</code></a>任务。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a></td>
<td class="colLast">
<div class="block">
<span>一个<a href="../../../java/util/concurrent/Executor.html" title="java.util.concurrent中的接口"><code>Executor</code></a> ，提供方法来管理终端和方法，可以产生<a href="../../../java/util/concurrent/Future.html" title="java.util.concurrent中的接口"><code>Future</code></a>为跟踪一个或多个异步任务执行。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ForkJoinPool.ForkJoinWorkerThreadFactory.html" title="interface in java.util.concurrent">ForkJoinPool.ForkJoinWorkerThreadFactory</a></td>
<td class="colLast">
<div class="block">
<span>创建新的<a href="../../../java/util/concurrent/ForkJoinWorkerThread.html" title="java.util.concurrent中的类">工厂<code>ForkJoinWorkerThread</code></a> s。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ForkJoinPool.ManagedBlocker.html" title="interface in java.util.concurrent">ForkJoinPool.ManagedBlocker</a></td>
<td class="colLast">
<div class="block">
<span>用于扩展管理并行性的接口，用于运行在<a href="../../../java/util/concurrent/ForkJoinPool.html" title="java.util.concurrent中的类"><code>ForkJoinPool</code>中</a>的任务。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/Future.html" title="interface in java.util.concurrent">Future</a>&lt;V&gt;</td>
<td class="colLast">
<div class="block">
           A 
          <code>Future</code>计算的结果。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/RejectedExecutionHandler.html" title="interface in java.util.concurrent">RejectedExecutionHandler</a></td>
<td class="colLast">
<div class="block">
<span><a href="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent中的类"><code>ThreadPoolExecutor</code></a>无法执行的任务的处理程序。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/RunnableFuture.html" title="interface in java.util.concurrent">RunnableFuture</a>&lt;V&gt;</td>
<td class="colLast">
<div class="block">
<span>A <a href="../../../java/util/concurrent/Future.html" title="java.util.concurrent中的接口"><code>Future</code></a>那是<a href="../../../java/lang/Runnable.html" title="java.lang中的接口"><code>Runnable</code></a> 。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/RunnableScheduledFuture.html" title="interface in java.util.concurrent">RunnableScheduledFuture</a>&lt;V&gt;</td>
<td class="colLast">
<div class="block">
<span>A <a href="../../../java/util/concurrent/ScheduledFuture.html" title="java.util.concurrent中的接口"><code>ScheduledFuture</code></a>那是<a href="../../../java/lang/Runnable.html" title="java.lang中的接口"><code>Runnable</code></a> 。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="interface in java.util.concurrent">ScheduledExecutorService</a></td>
<td class="colLast">
<div class="block">
<span>一个<a href="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent中的接口"><code>ExecutorService</code></a> ，可以调度命令在给定的延迟之后运行，或定期执行。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ScheduledFuture.html" title="interface in java.util.concurrent">ScheduledFuture</a>&lt;V&gt;</td>
<td class="colLast">
<div class="block">
           可以取消延迟结果的行动。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a></td>
<td class="colLast">
<div class="block">
           根据需要创建新线程的对象。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/TransferQueue.html" title="interface in java.util.concurrent">TransferQueue</a>&lt;E&gt;</td>
<td class="colLast">
<div class="block">
<span>A <a href="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent中的接口"><code>BlockingQueue</code></a> ，其中生产者可等待消费者接收元素。</span>
</div> </td>
</tr>
</tbody>
</table> </li>
<li class="blockList">
<table border="0" cellpadding="3" cellspacing="0" class="typeSummary" summary="Class Summary table, listing classes, and an explanation">
<caption>
<span>类摘要</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">类</th>
<th class="colLast" scope="col">描述</th>
</tr>
</tbody>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/AbstractExecutorService.html" title="class in java.util.concurrent">AbstractExecutorService</a></td>
<td class="colLast">
<div class="block">
<span>提供<a href="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent中的接口"><code>ExecutorService</code></a>执行方法的默认实现。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ArrayBlockingQueue.html" title="class in java.util.concurrent">ArrayBlockingQueue</a>&lt;E&gt;</td>
<td class="colLast">
<div class="block">
<span>一个有限的<a href="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent中的接口">blocking queue</a>由数组支持。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/CompletableFuture.html" title="class in java.util.concurrent">CompletableFuture</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">
<span>A <a href="../../../java/util/concurrent/Future.html" title="java.util.concurrent中的接口"><code>Future</code></a>可以明确完成（设置其值和状态），并可用作<a href="../../../java/util/concurrent/CompletionStage.html" title="java.util.concurrent中的接口"><code>CompletionStage</code></a> ，支持在<a href="../../../java/util/concurrent/CompletionStage.html" title="java.util.concurrent中的接口">完成</a>后触发的依赖功能和动作。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ConcurrentHashMap.html" title="class in java.util.concurrent">ConcurrentHashMap</a>&lt;K,V&gt;</td>
<td class="colLast">
<div class="block">
           支持检索的完全并发性和更新的高预期并发性的哈希表。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ConcurrentHashMap.KeySetView.html" title="class in java.util.concurrent">ConcurrentHashMap.KeySetView</a>&lt;K,V&gt;</td>
<td class="colLast">
<div class="block">
<span>ConcurrentHashMap视图为<a href="../../../java/util/Set.html" title="java.util中的接口"><code>Set</code></a>的密钥，其中可以通过映射到公共值来选择添加。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ConcurrentLinkedDeque.html" title="class in java.util.concurrent">ConcurrentLinkedDeque</a>&lt;E&gt;</td>
<td class="colLast">
<div class="block">
<span>基于链接节点的无界并发<a href="../../../java/util/Deque.html" title="java.util中的接口">deque</a> 。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ConcurrentLinkedQueue.html" title="class in java.util.concurrent">ConcurrentLinkedQueue</a>&lt;E&gt;</td>
<td class="colLast">
<div class="block">
<span>基于链接节点的无界线程安全<a href="../../../java/util/Queue.html" title="java.util中的接口">queue</a> 。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ConcurrentSkipListMap.html" title="class in java.util.concurrent">ConcurrentSkipListMap</a>&lt;K,V&gt;</td>
<td class="colLast">
<div class="block">
<span>一个可扩展的并发<a href="../../../java/util/concurrent/ConcurrentNavigableMap.html" title="java.util.concurrent中的接口"><code>ConcurrentNavigableMap</code></a>实现。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ConcurrentSkipListSet.html" title="class in java.util.concurrent">ConcurrentSkipListSet</a>&lt;E&gt;</td>
<td class="colLast">
<div class="block">
<span>基于<code>ConcurrentSkipListMap</code>的可扩展并发<a href="../../../java/util/NavigableSet.html" title="java.util中的接口"><code>NavigableSet</code></a> <a href="../../../java/util/concurrent/ConcurrentSkipListMap.html" title="java.util.concurrent中的类">实现</a> 。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/CopyOnWriteArrayList.html" title="class in java.util.concurrent">CopyOnWriteArrayList</a>&lt;E&gt;</td>
<td class="colLast">
<div class="block">
<span>的一个线程安全的变体<a href="../../../java/util/ArrayList.html" title="java.util中的类"><code>ArrayList</code></a> ，其中所有可变操作（ <code>add</code> ， <code>set</code> ，等等）通过对底层数组的最新副本实现。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/CopyOnWriteArraySet.html" title="class in java.util.concurrent">CopyOnWriteArraySet</a>&lt;E&gt;</td>
<td class="colLast">
<div class="block">
<span>一个<a href="../../../java/util/Set.html" title="java.util中的接口"><code>Set</code></a>使用内部<a href="../../../java/util/concurrent/CopyOnWriteArrayList.html" title="java.util.concurrent中的类"><code>CopyOnWriteArrayList</code></a>其所有操作。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/CountDownLatch.html" title="class in java.util.concurrent">CountDownLatch</a></td>
<td class="colLast">
<div class="block">
           允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">
<span>A <a href="../../../java/util/concurrent/ForkJoinTask.html" title="java.util.concurrent中的类"><code>ForkJoinTask</code></a> ，当触发时执行完成操作，并且没有剩余的待处理操作。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/CyclicBarrier.html" title="class in java.util.concurrent">CyclicBarrier</a></td>
<td class="colLast">
<div class="block">
           允许一组线程全部等待彼此达到共同屏障点的同步辅助。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/DelayQueue.html" title="class in java.util.concurrent">DelayQueue</a>&lt;E extends <a href="../../../java/util/concurrent/Delayed.html" title="interface in java.util.concurrent">Delayed</a>&gt;</td>
<td class="colLast">
<div class="block">
<span><code>Delayed</code>元素的无<a href="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent中的接口">界</a> <code>Delayed</code>元素，其中元素只能在其延迟到期时才被使用。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/Exchanger.html" title="class in java.util.concurrent">Exchanger</a>&lt;V&gt;</td>
<td class="colLast">
<div class="block">
           线程可以在成对内配对和交换元素的同步点。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ExecutorCompletionService.html" title="class in java.util.concurrent">ExecutorCompletionService</a>&lt;V&gt;</td>
<td class="colLast">
<div class="block">
<span>A <a href="../../../java/util/concurrent/CompletionService.html" title="java.util.concurrent中的接口"><code>CompletionService</code></a>使用提供的<a href="../../../java/util/concurrent/Executor.html" title="java.util.concurrent中的接口"><code>Executor</code></a>执行任务。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/Executors.html" title="class in java.util.concurrent">Executors</a></td>
<td class="colLast">
<div class="block">
<span>工厂和工具方法<a href="../../../java/util/concurrent/Executor.html" title="java.util.concurrent中的接口"><code>Executor</code></a> ， <a href="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent中的接口"><code>ExecutorService</code></a> ， <a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent中的接口"><code>ScheduledExecutorService</code></a> ， <a href="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent中的接口"><code>ThreadFactory</code></a>和<a href="../../../java/util/concurrent/Callable.html" title="java.util.concurrent中的接口"><code>Callable</code></a>在此包中定义的类。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ForkJoinPool.html" title="class in java.util.concurrent">ForkJoinPool</a></td>
<td class="colLast">
<div class="block">
<span>一个<a href="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent中的接口"><code>ExecutorService</code></a>运行<a href="../../../java/util/concurrent/ForkJoinTask.html" title="java.util.concurrent中的类"><code>ForkJoinTask</code></a> s。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;V&gt;</td>
<td class="colLast">
<div class="block">
<span>在<a href="../../../java/util/concurrent/ForkJoinPool.html" title="java.util.concurrent中的类"><code>ForkJoinPool</code></a>内运行的任务的抽象基类。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ForkJoinWorkerThread.html" title="class in java.util.concurrent">ForkJoinWorkerThread</a></td>
<td class="colLast">
<div class="block">
<span>一个由<a href="../../../java/util/concurrent/ForkJoinPool.html" title="java.util.concurrent中的类"><code>ForkJoinPool</code></a>管理的线程，执行<a href="../../../java/util/concurrent/ForkJoinTask.html" title="java.util.concurrent中的类"><code>ForkJoinTask</code></a> s。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/FutureTask.html" title="class in java.util.concurrent">FutureTask</a>&lt;V&gt;</td>
<td class="colLast">
<div class="block">
           可取消的异步计算。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/LinkedBlockingDeque.html" title="class in java.util.concurrent">LinkedBlockingDeque</a>&lt;E&gt;</td>
<td class="colLast">
<div class="block">
<span>基于链接节点的可选限定的<a href="../../../java/util/concurrent/BlockingDeque.html" title="java.util.concurrent中的接口">blocking deque</a> 。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/LinkedBlockingQueue.html" title="class in java.util.concurrent">LinkedBlockingQueue</a>&lt;E&gt;</td>
<td class="colLast">
<div class="block">
<span>基于链接节点的可选限定的<a href="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent中的接口">blocking queue</a> 。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/LinkedTransferQueue.html" title="class in java.util.concurrent">LinkedTransferQueue</a>&lt;E&gt;</td>
<td class="colLast">
<div class="block">
<span>基于链接节点的无界<a href="../../../java/util/concurrent/TransferQueue.html" title="java.util.concurrent中的接口"><code>TransferQueue</code></a> 。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/Phaser.html" title="class in java.util.concurrent">Phaser</a></td>
<td class="colLast">
<div class="block">
<span>一个可重复使用的同步屏障，功能类似于<a href="../../../java/util/concurrent/CyclicBarrier.html" title="java.util.concurrent中的类"><code>CyclicBarrier</code></a>和<a href="../../../java/util/concurrent/CountDownLatch.html" title="java.util.concurrent中的类"><code>CountDownLatch</code>，</a>但支持更灵活的使用。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/PriorityBlockingQueue.html" title="class in java.util.concurrent">PriorityBlockingQueue</a>&lt;E&gt;</td>
<td class="colLast">
<div class="block">
<span>一个无界的<a href="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent中的接口">blocking queue</a>使用与<a href="../../../java/util/PriorityQueue.html" title="java.util中的类"><code>PriorityQueue</code></a>类相同的排序规则，并提供阻止检索操作。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/RecursiveAction.html" title="class in java.util.concurrent">RecursiveAction</a></td>
<td class="colLast">
<div class="block">
<span>递归结果<a href="../../../java/util/concurrent/ForkJoinTask.html" title="java.util.concurrent中的类"><code>ForkJoinTask</code></a> 。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/RecursiveTask.html" title="class in java.util.concurrent">RecursiveTask</a>&lt;V&gt;</td>
<td class="colLast">
<div class="block">
<span>递归结果<a href="../../../java/util/concurrent/ForkJoinTask.html" title="java.util.concurrent中的类"><code>ForkJoinTask</code></a> 。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ScheduledThreadPoolExecutor.html" title="class in java.util.concurrent">ScheduledThreadPoolExecutor</a></td>
<td class="colLast">
<div class="block">
<span>A <a href="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent中的类"><code>ThreadPoolExecutor</code></a>还可以调度在给定延迟之后运行的命令，或定期执行。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/Semaphore.html" title="class in java.util.concurrent">Semaphore</a></td>
<td class="colLast">
<div class="block">
           一个计数信号量。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/SynchronousQueue.html" title="class in java.util.concurrent">SynchronousQueue</a>&lt;E&gt;</td>
<td class="colLast">
<div class="block">
<span>A <a href="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent中的接口">blocking queue</a>其中每个插入操作必须等待另一个线程相应的删除操作，反之亦然。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ThreadLocalRandom.html" title="class in java.util.concurrent">ThreadLocalRandom</a></td>
<td class="colLast">
<div class="block">
           与当前线程隔离的随机数生成器。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html" title="class in java.util.concurrent">ThreadPoolExecutor</a></td>
<td class="colLast">
<div class="block">
<span>一个<a href="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent中的接口"><code>ExecutorService</code></a> ，使用可能的几个合并的线程执行每个提交的任务，通常使用<a href="../../../java/util/concurrent/Executors.html" title="java.util.concurrent中的类"><code>Executors</code></a>工厂方法配置。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="class in java.util.concurrent">ThreadPoolExecutor.AbortPolicy</a></td>
<td class="colLast">
<div class="block">
           被拒绝的任务的处理程序，抛出一个 
          <code>RejectedExecutionException</code> 。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ThreadPoolExecutor.CallerRunsPolicy.html" title="class in java.util.concurrent">ThreadPoolExecutor.CallerRunsPolicy</a></td>
<td class="colLast">
<div class="block">
           一个被拒绝的任务的处理程序，直接在 
          <code>execute</code>方法的调用线程中运行被拒绝的任务，除非执行程序已被关闭，否则任务被丢弃。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ThreadPoolExecutor.DiscardOldestPolicy.html" title="class in java.util.concurrent">ThreadPoolExecutor.DiscardOldestPolicy</a></td>
<td class="colLast">
<div class="block">
           被拒绝的任务的处理程序，丢弃最旧的未处理请求，然后重试 
          <code>execute</code> ，除非执行程序被关闭，否则任务被丢弃。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ThreadPoolExecutor.DiscardPolicy.html" title="class in java.util.concurrent">ThreadPoolExecutor.DiscardPolicy</a></td>
<td class="colLast">
<div class="block">
           被拒绝的任务的处理程序静默地丢弃被拒绝的任务。 
         </div> </td>
</tr>
</tbody>
</table> </li>
<li class="blockList">
<table border="0" cellpadding="3" cellspacing="0" class="typeSummary" summary="Enum Summary table, listing enums, and an explanation">
<caption>
<span>枚举摘要</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Enum</th>
<th class="colLast" scope="col">描述</th>
</tr>
</tbody>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a></td>
<td class="colLast">
<div class="block">
           A 
          <code>TimeUnit</code>表示给定的粒度单位的持续时间，并提供了跨单位转换的实用方法，并在这些单元中执行定时和延迟操作。 
         </div> </td>
</tr>
</tbody>
</table> </li>
<li class="blockList">
<table border="0" cellpadding="3" cellspacing="0" class="typeSummary" summary="Exception Summary table, listing exceptions, and an explanation">
<caption>
<span>异常摘要</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">异常</th>
<th class="colLast" scope="col">描述</th>
</tr>
</tbody>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/BrokenBarrierException.html" title="class in java.util.concurrent">BrokenBarrierException</a></td>
<td class="colLast">
<div class="block">
           当线程尝试等待处于断开状态的屏障或线程等待时进入断开状态时抛出异常。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/CancellationException.html" title="class in java.util.concurrent">CancellationException</a></td>
<td class="colLast">
<div class="block">
<span>异常表示由于任务被取消，无法检索值生成任务的结果，如<a href="../../../java/util/concurrent/FutureTask.html" title="java.util.concurrent中的类"><code>FutureTask</code></a> 。</span>
</div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/CompletionException.html" title="class in java.util.concurrent">CompletionException</a></td>
<td class="colLast">
<div class="block">
           在完成结果或任务的过程中遇到错误或其他异常时抛出异常。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/ExecutionException.html" title="class in java.util.concurrent">ExecutionException</a></td>
<td class="colLast">
<div class="block">
           尝试检索通过抛出异常中止的任务的结果时抛出的异常。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/concurrent/RejectedExecutionException.html" title="class in java.util.concurrent">RejectedExecutionException</a></td>
<td class="colLast">
<div class="block">
<span>异常通过抛出<a href="../../../java/util/concurrent/Executor.html" title="java.util.concurrent中的接口"><code>Executor</code></a>当任务不能执行所接受。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/concurrent/TimeoutException.html" title="class in java.util.concurrent">TimeoutException</a></td>
<td class="colLast">
<div class="block">
           阻塞操作超时时抛出异常。 
         </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<a name="package.description">
<!-- --> </a>
<h2 title="Package java.util.concurrent Description">Package java.util.concurrent Description</h2>
<div class="block">
<span>实用程序类通常在并发编程中很有用。</span>
<span>这个包包括一些小的标准化可扩展框架，以及一些类，它们提供有用的功能，而不是繁琐或难以实现。</span>
<span>以下是主要组件的简要说明。</span>
<span>另请参阅<a href="../../../java/util/concurrent/locks/package-summary.html"><code>java.util.concurrent.locks</code></a>和<a href="../../../java/util/concurrent/atomic/package-summary.html"><code>java.util.concurrent.atomic</code></a>软件包。</span>
<h2> <span>执行人员</span> </h2>
<span><b>接口</b></span>
<span><a href="../../../java/util/concurrent/Executor.html" title="java.util.concurrent中的接口"><code>Executor</code></a>是一个简单的标准化接口，用于定义线程类自定义子系统，包括线程池，异步I / O和轻量级任务框架。</span>
<span>根据使用的具体的Executor类，任务可以在新创建的线程，现有任务执行线程或线程调用<a href="../../../java/util/concurrent/Executor.html#execute-java.lang.Runnable-"><code>execute</code></a>中执行，并且可以顺序执行或同时执行。</span>
<span><a href="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent中的接口"><code>ExecutorService</code></a>提供了一个更完整的异步任务执行框架。</span>
<span>ExecutorService管理任务的排队和调度，并允许受控关闭。</span>
<span><a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent中的接口"><code>ScheduledExecutorService</code>子</a>接口和关联接口增加了对延迟和周期性任务执行的支持。</span>
<span>ExecutorServices提供了排列异步执行方法的方法，表示为<a href="../../../java/util/concurrent/Callable.html" title="java.util.concurrent中的接口"><code>Callable</code></a> ，结果轴承类型为<a href="../../../java/lang/Runnable.html" title="java.lang中的接口"><code>Runnable</code></a> 。</span>
<span>A <a href="../../../java/util/concurrent/Future.html" title="java.util.concurrent中的接口"><code>Future</code></a>返回函数的结果，允许确定执行是否已完成，并提供取消执行的方法。</span>
<span>A <a href="../../../java/util/concurrent/RunnableFuture.html" title="java.util.concurrent中的接口"><code>RunnableFuture</code></a>是一个<code>Future</code> ，拥有一个<code>run</code>方法，在执行时，设置其结果。</span>
<p> <span><b>实施。</b></span> <span>类别<a href="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent中的类"><code>ThreadPoolExecutor</code></a>和<a href="../../../java/util/concurrent/ScheduledThreadPoolExecutor.html" title="java.util.concurrent中的类"><code>ScheduledThreadPoolExecutor</code></a>提供可调谐，灵活的线程池。</span> <span><a href="../../../java/util/concurrent/Executors.html" title="java.util.concurrent中的类"><code>Executors</code></a>类为执行程序的最常见种类和配置提供工厂方法，以及一些使用它们的实用方法。</span> <span>基于<code>Executors</code>其他实用<code>Executors</code>包括具体的类别<a href="../../../java/util/concurrent/FutureTask.html" title="java.util.concurrent中的类"><code>FutureTask</code>，</a>提供了Futures的共同可扩展的实现，以及<a href="../../../java/util/concurrent/ExecutorCompletionService.html" title="java.util.concurrent中的类"><code>ExecutorCompletionService</code></a> ，它有助于协调异步任务组的处理。</span> </p>
<p> <span>类<a href="../../../java/util/concurrent/ForkJoinPool.html" title="java.util.concurrent中的类"><code>ForkJoinPool</code></a>提供主要设计用于加工实例一个Executor <a href="../../../java/util/concurrent/ForkJoinTask.html" title="java.util.concurrent中的类"><code>ForkJoinTask</code></a>和它的子类。</span> <span>这些类采用一个工作窃取调度程序，它可以满足在计算密集型并行处理中经常保持的限制的任务的高吞吐量。</span> </p>
<h2> <span>队列</span> </h2>
<span><a href="../../../java/util/concurrent/ConcurrentLinkedQueue.html" title="java.util.concurrent中的类"><code>ConcurrentLinkedQueue</code></a>类提供了一个高效的可伸缩线程安全非阻塞FIFO队列。</span>
<span><a href="../../../java/util/concurrent/ConcurrentLinkedDeque.html" title="java.util.concurrent中的类"><code>ConcurrentLinkedDeque</code></a>类是类似的，但另外支持<a href="../../../java/util/Deque.html" title="java.util中的接口"><code>Deque</code></a>接口。</span>
<p> <span>五个实现都<code>java.util.concurrent</code>支持扩展<a href="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent中的接口"><code>BlockingQueue</code></a>接口中，定义阻塞put和take的版本： <a href="../../../java/util/concurrent/LinkedBlockingQueue.html" title="java.util.concurrent中的类"><code>LinkedBlockingQueue</code></a> ， <a href="../../../java/util/concurrent/ArrayBlockingQueue.html" title="java.util.concurrent中的类"><code>ArrayBlockingQueue</code></a> ， <a href="../../../java/util/concurrent/SynchronousQueue.html" title="java.util.concurrent中的类"><code>SynchronousQueue</code></a> ， <a href="../../../java/util/concurrent/PriorityBlockingQueue.html" title="java.util.concurrent中的类"><code>PriorityBlockingQueue</code></a>和<a href="../../../java/util/concurrent/DelayQueue.html" title="java.util.concurrent中的类"><code>DelayQueue</code></a> 。</span> <span>不同的类涵盖了生产者 - 消费者，消息传递，并行任务和相关并发设计的最常见的使用上下文。</span> </p>
<p> <span>扩展接口<a href="../../../java/util/concurrent/TransferQueue.html" title="java.util.concurrent中的接口"><code>TransferQueue</code></a>和实现<a href="../../../java/util/concurrent/LinkedTransferQueue.html" title="java.util.concurrent中的类"><code>LinkedTransferQueue</code></a>引入同步<code>transfer</code>方法（以及相关特征），其中生产者可以可选地阻止等待其消费者。</span> </p>
<p> <span><a href="../../../java/util/concurrent/BlockingDeque.html" title="java.util.concurrent中的接口"><code>BlockingDeque</code></a>接口扩展了<code>BlockingQueue</code>以支持FIFO和LIFO（基于堆栈）的操作。</span> <span><a href="../../../java/util/concurrent/LinkedBlockingDeque.html" title="java.util.concurrent中的类"><code>LinkedBlockingDeque</code>课程</a>提供了一个实现。</span> </p>
<h2> <span>定时</span> </h2>
<span><a href="../../../java/util/concurrent/TimeUnit.html" title="枚举在java.util.concurrent中"><code>TimeUnit</code></a>类提供了多个粒度（包括纳秒），用于指定和控制基于超时的操作。</span>
<span>软件包中的大多数类除了无限期的等待之外还包含基于超时的操作。</span>
<span>在所有使用超时的情况下，超时指定方法在指示超时之前应等待的最短时间。</span>
<span>实施做出“尽力而为”，在发现之后尽快检测超时。</span>
<span>然而，在超时检测到的时间和在该超时之后实际执行的线程之间可能经过不定期的时间。</span>
<span>接受超时参数的所有方法都将小于或等于0的值视为不等待。</span>
<span>要等待“永远”，可以使用<code>Long.MAX_VALUE</code>的值。</span>
<h2> <span>同步器</span> </h2>
<span>五类帮助常用的专用同步成语。</span>
<ul>
<li> <span><a href="../../../java/util/concurrent/Semaphore.html" title="java.util.concurrent中的类"><code>Semaphore</code></a>是一个经典的并发工具。</span> </li>
<li> <span><a href="../../../java/util/concurrent/CountDownLatch.html" title="java.util.concurrent中的类"><code>CountDownLatch</code></a>是一个非常简单但非常通用的实用程序，直到给定数量的信号，事件或条件成立为止。</span> </li>
<li> <span>A <a href="../../../java/util/concurrent/CyclicBarrier.html" title="java.util.concurrent中的类"><code>CyclicBarrier</code></a>是一种可复用的多路同步点，可用于某些类型的并行编程。</span> </li>
<li> <span>A <a href="../../../java/util/concurrent/Phaser.html" title="java.util.concurrent中的类"><code>Phaser</code></a>提供了可以用于在多个线程之间控制相位计算的更灵活的障碍形式。</span> </li>
<li> <span><a href="../../../java/util/concurrent/Exchanger.html" title="java.util.concurrent中的类"><code>Exchanger</code></a>允许两个线程在会合点交换对象，并且在多个管道设计中是有用的。</span> </li>
</ul>
<h2> <span>并发收藏</span> </h2>
<span>除了队列，这个包提供的集合实现在多线程环境中设计用于： <a href="../../../java/util/concurrent/ConcurrentHashMap.html" title="java.util.concurrent中的类"><code>ConcurrentHashMap</code></a> ， <a href="../../../java/util/concurrent/ConcurrentSkipListMap.html" title="java.util.concurrent中的类"><code>ConcurrentSkipListMap</code></a> ， <a href="../../../java/util/concurrent/ConcurrentSkipListSet.html" title="java.util.concurrent中的类"><code>ConcurrentSkipListSet</code></a> ， <a href="../../../java/util/concurrent/CopyOnWriteArrayList.html" title="java.util.concurrent中的类"><code>CopyOnWriteArrayList</code></a>和<a href="../../../java/util/concurrent/CopyOnWriteArraySet.html" title="java.util.concurrent中的类"><code>CopyOnWriteArraySet</code></a> 。</span>
<span>当预期许多线程访问给定的集合时， <code>ConcurrentHashMap</code>通常优于同步的<code>HashMap</code> ，并且<code>ConcurrentSkipListMap</code>通常优于同步的<code>TreeMap</code> 。</span>
<span>甲<code>CopyOnWriteArrayList</code>优选同步<code>ArrayList</code>时的预期数量的读取和遍历的数量大大超过更新的数量的列表。</span>
<p> <span>与此包中某些类使用的“并发”前缀是一个简写，表示与类似“同步”类的几个差异。</span> <span>例如<code>java.util.Hashtable</code>和<code>Collections.synchronizedMap(new HashMap())</code>被同步。</span> <span>但<a href="../../../java/util/concurrent/ConcurrentHashMap.html" title="java.util.concurrent中的类"><code>ConcurrentHashMap</code></a>是“并发”。</span> <span>并发集合是线程安全的，但不受单个排除锁的约束。</span> <span>在ConcurrentHashMap的特定情况下，它可以安全地允许任意数量的并发读取以及可调整数量的并发写入。</span> <span>当您需要通过单个锁来阻止对集合的所有访问时，“同步”类可能会有用，而不损害可扩展性。</span> <span>在预期多个线程访问公共集合的其他情况下，“并发”版本通常是可取的。</span> <span>并且当两个集合都是非共享的时候，不同步的集合是可取的，或者只有在持有其他锁时才可访问。</span> </p>
<p id="Weakly"> <span>大多数并发收集实现（包括大多数队列）也与通常的<code>java.util</code>约定不同，因为它们的<a href="../../../java/util/Iterator.html" title="java.util中的接口">Iterators</a>和<a href="../../../java/util/Spliterator.html" title="java.util中的接口">Spliterators</a>提供<em>弱一致</em>而不是快速失败遍历：</span> </p>
<ul>
<li> <span>他们可能会同时进行其他行动</span> </li>
<li> <span>他们永远不会投掷<a href="../../../java/util/ConcurrentModificationException.html" title="java.util中的类"><code>ConcurrentModificationException</code></a></span> </li>
<li> <span>它们被保证能够在建筑物上存在一次元素，并且可能（但不能保证）反映施工后的任何修改。</span> </li>
</ul>
<h2 id="MemoryVisibility"> <span>内存一致性属性</span> </h2>
<span><a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5">Chapter 17 of the Java Language Specification</a>定义了内存操作（例如共享变量的读取和写入） <i>之前</i>的<i>发生</i>关系。</span>
<span>只有在写操作<i>发生之前</i> ，一个线程的写入结果才能保证对另一个线程的读取可见。</span>
<span><code>synchronized</code>和<code>volatile</code>构造以及<code>Thread.start()</code>和<code>Thread.join()</code>方法可以形成<i>发生之前的</i>关系。</span>
<span>尤其是：</span>
<ul>
<li> <span>在线程中的每个动作<i>发生</i>在该线程中的每个动作<i>之前</i> ，程序的顺序将稍后。</span> </li>
<li> <span>在同一监视器<i>的</i>每个后续锁定（ <code>synchronized</code>块或方法条目） <i>之前，发生</i>监视器的解锁（ <code>synchronized</code>块或方法退出）。</span> <span>并且因为<i>事件发生之前的</i>关系是可传递的，所以在解锁之前的线程的所有动作都<i>发生在</i>所有线程锁定<i>之后的</i>所有动作<i>之前</i> 。</span> </li>
<li> <span>写入一个<code>volatile</code>字段<i>发生在</i>该同一字段的每个后续读取<i>之前</i> 。</span> <span>写入和读取<code>volatile</code>字段具有与进入和退出显示器相似的内存一致性效果，但<em>不</em>要求互斥锁定。</span> </li>
<li> <span>在线程中调用<code>start</code> <i>发生</i>在启动的线程中的任何动作<i>之前</i> 。</span> </li>
<li> <span>线索中的全部动作<i>发生，之前</i>的任何其他线程成功地从返回<code>join</code>该线程。</span> </li>
</ul>
<span><code>java.util.concurrent</code>及其子包中的所有类的方法将这些保证扩展到更高级别的同步。</span>
<span>尤其是：</span>
<ul>
<li> <span>在将对象放入任何并发集合之前，线程中的操作<i>发生</i>在另一个线程中从该集合访问或删除该元素<i>之后的</i>操作<i>之前</i> 。</span> </li>
<li> <span>在<code>Runnable</code>到<code>Executor</code>之前，线程中的<code>Executor</code> <i>发生在</i>其执行开始<i>之前</i> 。</span> <span>同样为<code>Callables</code>提交到一个<code>ExecutorService</code> 。</span> </li>
<li> <span>由一个代表异步计算采取的行动<code>Future</code> <i>发生，之前</i>通过对结果的检索后续行动<code>Future.get()</code>在另一个线程。</span> </li>
<li> <span>操作之前为“释放”同步器的方法，如<code>Lock.unlock</code> ， <code>Semaphore.release</code>和<code>CountDownLatch.countDown</code> <i>发生-前</i>行动一个成功的“获取”方法如后续<code>Lock.lock</code> ， <code>Semaphore.acquire</code> ， <code>Condition.await</code>和<code>CountDownLatch.await</code>在另一个线程相同的同步对象。</span> </li>
<li> <span>对于每对经由成功交换对象的线程的<code>Exchanger</code> ，现有的行动<code>exchange()</code>在每个线程中<i>发生，</i>这些<i>前</i>向对应的后续<code>exchange()</code>在另一个线程。</span> </li>
<li> <span>调用<code>CyclicBarrier.await</code>和<code>Phaser.awaitAdvance</code> <i>之前的</i>操作（以及其变体） <i>发生</i>在屏障动作执行的动作之前，以及由屏障动作执行的动作<i>发生在</i>从其他线程中的相应<code>await</code>成功返回<i>之后的</i>动作<i>之前</i> 。</span> </li>
</ul>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
      1.5 
    </dd>
</dl>
</div>