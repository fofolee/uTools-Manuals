<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.util.concurrent 
   </div>
<h2 class="title" title="Class ThreadPoolExecutor">Class ThreadPoolExecutor</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li><a href="../../../java/util/concurrent/AbstractExecutorService.html" title="class in java.util.concurrent">java.util.concurrent.AbstractExecutorService</a></li>
<li>
<ul class="inheritance">
<li>java.util.concurrent.ThreadPoolExecutor</li>
</ul> </li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
         All Implemented Interfaces: 
       </dt>
<dd>
<span><a href="../../../java/util/concurrent/Executor.html" title="java.util.concurrent中的接口">Executor</a> ， <a href="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent中的接口">ExecutorService</a></span>
</dd>
</dl>
<dl>
<dt>
        已知直接子类：
       </dt>
<dd>
<span><a href="../../../java/util/concurrent/ScheduledThreadPoolExecutor.html" title="java.util.concurrent中的类">ScheduledThreadPoolExecutor</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public class <span class="typeNameLabel">ThreadPoolExecutor</span>
extends <a href="../../../java/util/concurrent/AbstractExecutorService.html" title="class in java.util.concurrent">AbstractExecutorService</a></pre>
<div class="block">
<span>一个<a href="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent中的接口"><code>ExecutorService</code></a> ，使用可能的几个合并的线程执行每个提交的任务，通常使用<a href="../../../java/util/concurrent/Executors.html" title="java.util.concurrent中的类"><code>Executors</code></a>工厂方法配置。</span>
<p> <span>线程池解决两个不同的问题：由于每个任务的调用开销减少，它们通常在执行大量异步任务时提供改进的性能，并且它们提供了一种限制和管理资源（包括执行一个任务。</span> <span>每个<code>ThreadPoolExecutor</code>还维护一些基本统计信息，例如已完成任务的数量。</span> </p>
<p> <span>为了在广泛的上下文中有用，此类提供了许多可调参数和可扩展性钩子。</span> <span>然而，程序员被敦促使用更方便的<a href="../../../java/util/concurrent/Executors.html" title="java.util.concurrent中的类"><code>Executors</code></a>工厂方法<a href="../../../java/util/concurrent/Executors.html#newCachedThreadPool--"><code>Executors.newCachedThreadPool()</code></a> （无限线程池，具有自动线程回收）， <a href="../../../java/util/concurrent/Executors.html#newFixedThreadPool-int-"><code>Executors.newFixedThreadPool(int)</code></a> （固定大小的线程池）和<a href="../../../java/util/concurrent/Executors.html#newSingleThreadExecutor--"><code>Executors.newSingleThreadExecutor()</code></a> （单个后台线程），可以预先配置最常用的使用场景设置。</span> <span>否则，手动配置和调优此类时，请使用以下指南：</span> </p>
<dl>
<dt>
<span>核心和最大池大小</span>
</dt>
<dd>
<span>甲<code>ThreadPoolExecutor</code>将自动调整池大小（见<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getPoolSize--"><code>getPoolSize()</code></a>根据corePoolSize（参见设定的界限） <a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize--"><code>getCorePoolSize()</code></a> ）和maximumPoolSize（参见<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getMaximumPoolSize--"><code>getMaximumPoolSize()</code></a> ）。</span>
<span>当方法<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#execute-java.lang.Runnable-"><code>execute(Runnable)</code></a>中提交了新任务，并且运行的corePoolSize线程少于一个，即使其他工作线程处于空闲状态，也会创建一个新的线程来处理该请求。</span>
<span>如果超过corePoolSize但小于maximumPoolSize线程运行，则仅当队列已满时才会创建一个新线程。</span>
<span>通过将corePoolSize和maximumPoolSize设置为相同，您将创建一个固定大小的线程池。</span>
<span>通过将maximumPoolSize设置为本质上无限制的值（如<code>Integer.MAX_VALUE</code> ，您可以允许池容纳任意数量的并发任务。</span>
<span>最典型的是，核心和最大池大小只能在构建时进行设置，但也可以使用<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#setCorePoolSize-int-"><code>setCorePoolSize(int)</code></a>和<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#setMaximumPoolSize-int-"><code>setMaximumPoolSize(int)</code></a>进行<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#setCorePoolSize-int-">动态</a> <a href="../../../java/util/concurrent/ThreadPoolExecutor.html#setMaximumPoolSize-int-">更改</a> 。</span>
</dd>
<dt>
<span>按需施工</span>
</dt>
<dd>
<span>默认情况下，即使核心线程最初创建并且只有在新任务到达时才启动，但是可以使用方法<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartCoreThread--"><code>prestartCoreThread()</code></a>或<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartAllCoreThreads--"><code>prestartAllCoreThreads()</code>动态地覆盖</a> 。</span>
<span>如果您使用非空队列构建池，则可能需要预先提供线程。</span>
</dd>
<dt>
<span>创建新线程</span>
</dt>
<dd>
<span>新线程使用<a href="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent中的接口"><code>ThreadFactory</code></a>创建。</span>
<span>如果没有另外指定，则使用<a href="../../../java/util/concurrent/Executors.html#defaultThreadFactory--"><code>Executors.defaultThreadFactory()</code></a> ，它创建所有线程与所有相同的<a href="../../../java/lang/ThreadGroup.html" title="java.lang中的类"><code>ThreadGroup</code></a>并且具有相同的优先级和非守护进程状态<code>NORM_PRIORITY</code> 。</span>
<span>通过提供不同的ThreadFactory，您可以更改线程的名称，线程组，优先级，守护进程状态等。如果<code>ThreadFactory</code>在从<code>newThread</code>返回null请求时无法创建线程，则执行程序将继续，但可能无法执行任务</span>
<span>线程应该拥有“modifyThread” <code>RuntimePermission</code> 。</span>
<span>如果使用池的工作线程或其他线程不具有此权限，则服务可能会降级：配置更改可能不会及时生效，并且关闭池可能仍处于可能终止但未完成的状态。</span>
</dd>
<dt>
<span>活着的时代</span>
</dt>
<dd>
<span>如果池当前具有多于corePoolSize线程，则如果空闲超过keepAliveTime（见<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getKeepAliveTime-java.util.concurrent.TimeUnit-"><code>getKeepAliveTime(TimeUnit)</code></a> ），则多余的线程将被终止。</span>
<span>这提供了当池未被主动使用时减少资源消耗的方法。</span>
<span>如果稍后池变得更加活跃，将构建新的线程。</span>
<span>此参数也可以使用方法<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#setKeepAliveTime-long-java.util.concurrent.TimeUnit-"><code>setKeepAliveTime(long, TimeUnit)</code>动态更改</a> 。</span>
<span>使用值<code>Long.MAX_VALUE</code> <a href="../../../java/util/concurrent/TimeUnit.html#NANOSECONDS"><code>TimeUnit.NANOSECONDS</code></a>有效地禁用空闲线程在关闭之前终止。</span>
<span>默认情况下，仅当存在多于corePoolSize线程时，保持活动策略才适用。</span>
<span>但是方法<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#allowCoreThreadTimeOut-boolean-"><code>allowCoreThreadTimeOut(boolean)</code></a>也可以用于将这个超时策略应用于核心线程，只要keepAliveTime值不为零。</span>
</dd>
<dt>
<span>排队</span>
</dt>
<dd>
<span>任何<a href="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent中的接口"><code>BlockingQueue</code></a>可用于传送和保留提交的任务。</span>
<span>这个队列的使用与池大小相互作用：</span>
<ul>
<li> <span>如果少于corePoolSize线程正在运行，Executor总是喜欢添加一个新线程，而不是排队。</span> </li>
<li> <span>如果corePoolSize或更多的线程正在运行，Executor总是喜欢排队请求而不是添加一个新的线程。</span> </li>
<li> <span>如果请求无法排队，则会创建一个新线程，除非这将超出maximumPoolSize，否则任务将被拒绝。</span> </li>
</ul>
<span>排队有三种一般策略：</span>
<ol>
<li> <span><em>直接切换</em></span> <span>一个工作队列的一个很好的默认选择是一个<a href="../../../java/util/concurrent/SynchronousQueue.html" title="java.util.concurrent中的类"><code>SynchronousQueue</code></a> ，将任务交给线程，无需另外控制。</span> <span>在这里，如果没有线程可以立即运行，那么尝试排队任务会失败，因此将构建一个新的线程。</span> <span>处理可能具有内部依赖关系的请求集时，此策略可避免锁定。</span> <span>直接切换通常需要无限制的maximumPoolSizes，以避免拒绝新提交的任务。</span> <span>这反过来允许无限线程增长的可能性，当命令继续以平均速度比他们可以处理的速度更快地到达时。</span> </li>
<li> <span><em>无界队列</em></span> <span>使用无界队列（例如<a href="../../../java/util/concurrent/LinkedBlockingQueue.html" title="java.util.concurrent中的类"><code>LinkedBlockingQueue</code></a>没有预定容量）会导致新的任务，在队列中等待，当所有corePoolSize线程都很忙。</span> <span>因此，不会再创建corePoolSize线程。</span> <span>（因此，最大值大小的值没有任何影响。）每个任务完全独立于其他任务时，这可能是适当的，因此任务不会影响其他执行;</span> <span>例如，在网页服务器中。</span> <span>虽然这种排队风格可以有助于平滑瞬态突发的请求，但是当命令继续达到的平均速度比可以处理的速度更快时，它承认无界工作队列增长的可能性。</span> </li>
<li> <span><em>有边界的队列。</em></span> <span>有限队列（例如， <a href="../../../java/util/concurrent/ArrayBlockingQueue.html" title="java.util.concurrent中的类"><code>ArrayBlockingQueue</code></a> ）有助于在使用有限maxPoolSizes时防止资源耗尽，但可能更难调整和控制。</span> <span>队列大小和最大池大小可能彼此交易：使用大队列和小型池可以最大限度地减少CPU使用率，OS资源和上下文切换开销，但可能导致人为的低吞吐量。</span> <span>如果任务频繁阻塞（例如，如果它们是I / O绑定），则系统可能能够安排比您允许的更多线程的时间。</span> <span>使用小型队列通常需要较大的池大小，这样可以使CPU繁忙，但可能会遇到不可接受的调度开销，这也降低了吞吐量。</span> </li>
</ol>
</dd>
<dt>
<span>被拒绝的任务</span>
</dt>
<dd>
<span>方法<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#execute-java.lang.Runnable-"><code>execute(Runnable)</code>中提交的</a>新任务将在执行程序关闭时被<em>拒绝</em> ，并且当执行程序对最大线程和工作队列容量使用有限边界并且饱和时。</span>
<span>在任一情况下， <code>execute</code>方法调用<a href="../../../java/util/concurrent/RejectedExecutionHandler.html#rejectedExecution-java.lang.Runnable-java.util.concurrent.ThreadPoolExecutor-"><code>RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor)</code></a>其的方法<a href="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent中的接口"><code>RejectedExecutionHandler</code></a> 。</span>
<span>提供了四个预定义的处理程序策略：</span>
<ol>
<li> <span>在默认<a href="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="java.util.concurrent中的类"><code>ThreadPoolExecutor.AbortPolicy</code></a> ，处理程序会引发运行<a href="../../../java/util/concurrent/RejectedExecutionException.html" title="java.util.concurrent中的类"><code>RejectedExecutionException</code></a>后排斥反应。</span> </li>
<li> <span>在<a href="../../../java/util/concurrent/ThreadPoolExecutor.CallerRunsPolicy.html" title="java.util.concurrent中的类"><code>ThreadPoolExecutor.CallerRunsPolicy</code></a>中，调用<code>execute</code>本身的线程运行任务。</span> <span>这提供了一个简单的反馈控制机制，将降低新任务提交的速度。</span> </li>
<li> <span>在<a href="../../../java/util/concurrent/ThreadPoolExecutor.DiscardPolicy.html" title="java.util.concurrent中的类"><code>ThreadPoolExecutor.DiscardPolicy</code>中</a> ，简单地删除无法执行的任务。</span> </li>
<li> <span>在<a href="../../../java/util/concurrent/ThreadPoolExecutor.DiscardOldestPolicy.html" title="java.util.concurrent中的类"><code>ThreadPoolExecutor.DiscardOldestPolicy</code>中</a> ，如果执行程序没有关闭，则工作队列头部的任务被删除，然后重试执行（可能会再次失败，导致重复）。</span> </li>
</ol>
<span>可以定义和使用其他类型的<a href="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent中的接口"><code>RejectedExecutionHandler</code></a>类。</span>
<span>这样做需要特别注意，特别是当策略被设计为仅在特定容量或排队策略下工作时。</span>
</dd>
<dt>
<span>钩子方法</span>
</dt>
<dd>
<span>该类提供了在每个任务执行之前和之后调用的<code>protected</code>覆盖的<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#beforeExecute-java.lang.Thread-java.lang.Runnable-"><code>beforeExecute(Thread, Runnable)</code></a>和<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#afterExecute-java.lang.Runnable-java.lang.Throwable-"><code>afterExecute(Runnable, Throwable)</code></a>方法。</span>
<span>这些可以用来操纵执行环境;</span>
<span>例如，重新初始化ThreadLocals，收集统计信息或添加日志条目。</span>
<span>另外，方法<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#terminated--"><code>terminated()</code></a>可以被覆盖，以执行执行程序完全终止后需要执行的任何特殊处理。</span>
<p> <span>如果钩子或回调方法抛出异常，内部工作线程可能会失败并突然终止。</span> </p>
</dd>
<dt>
<span>队列维护</span>
</dt>
<dd>
<span>方法<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getQueue--"><code>getQueue()</code></a>允许访问工作队列以进行监视和调试。</span>
<span>强烈不鼓励将此方法用于任何其他目的。</span>
<span>当提供大量排队任务被取消时，两种提供的方法<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#remove-java.lang.Runnable-"><code>remove(Runnable)</code></a>和<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#purge--"><code>purge()</code></a>可用于协助进行存储回收。</span>
</dd>
<dt>
<span>定稿</span>
</dt>
<dd>
<span>即不再在程序中引用， <em>并</em>没有剩余的线程将成为池<code>shutdown</code>自动。</span>
<span>如果您希望确保未引用的池被回收，即使用户忘记调用<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#shutdown--"><code>shutdown()</code></a> ，则必须安排未使用的线程最终死机，通过设置适当的保持活动时间，使用零个核心线程的下限和/或设置<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#allowCoreThreadTimeOut-boolean-"><code>allowCoreThreadTimeOut(boolean)</code></a> 。</span>
</dd>
</dl>
<p> <span><b>扩展示例</b> 。</span> <span>这个类的大部分扩展覆盖了一个或多个受保护的钩子方法。</span> <span>例如，这里是一个添加一个简单的暂停/恢复功能的子类：</span> </p>
<pre>  <span><code> class PausableThreadPoolExecutor extends ThreadPoolExecutor { private boolean isPaused; private ReentrantLock pauseLock = new ReentrantLock(); private Condition unpaused = pauseLock.newCondition(); public PausableThreadPoolExecutor(...) { super(...); } protected void beforeExecute(Thread t, Runnable r) { super.beforeExecute(t, r); pauseLock.lock(); try { while (isPaused) unpaused.await(); } catch (InterruptedException ie) { t.interrupt(); } finally { pauseLock.unlock(); } } public void pause() { pauseLock.lock(); try { isPaused = true; } finally { pauseLock.unlock(); } } public void resume() { pauseLock.lock(); try { isPaused = false; unpaused.signalAll(); } finally { pauseLock.unlock(); } } }</code></span> </pre>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.5 
       </dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!-- --> </a> <h3>Nested Class Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption>
<span>Nested Classes</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Class and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="class in java.util.concurrent">ThreadPoolExecutor.AbortPolicy</a></span></code>
<div class="block">
              被拒绝的任务的处理程序，抛出一个 
             <code>RejectedExecutionException</code> 。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.CallerRunsPolicy.html" title="class in java.util.concurrent">ThreadPoolExecutor.CallerRunsPolicy</a></span></code>
<div class="block">
              一个被拒绝的任务的处理程序，直接在 
             <code>execute</code>方法的调用线程中运行被拒绝的任务，除非执行程序已经被关闭，否则这个任务被丢弃。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.DiscardOldestPolicy.html" title="class in java.util.concurrent">ThreadPoolExecutor.DiscardOldestPolicy</a></span></code>
<div class="block">
              被拒绝的任务的处理程序，丢弃最旧的未处理请求，然后重试 
             <code>execute</code> ，除非执行程序关闭，在这种情况下，任务被丢弃。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.DiscardPolicy.html" title="class in java.util.concurrent">ThreadPoolExecutor.DiscardPolicy</a></span></code>
<div class="block">
              被拒绝的任务的处理程序静默地丢弃被拒绝的任务。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!-- --> </a> <h3>构造方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Constructor Summary table, listing constructors, and an explanation">
<caption>
<span>构造方法</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor-int-int-long-java.util.concurrent.TimeUnit-java.util.concurrent.BlockingQueue-">ThreadPoolExecutor</a></span>(int corePoolSize, int maximumPoolSize, long keepAliveTime, <a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit, <a href="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</a>&lt;<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a>&gt; workQueue)</code>
<div class="block">
              创建一个新的 
             <code>ThreadPoolExecutor</code>与给定的初始参数和默认线程工厂和拒绝执行处理程序。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor-int-int-long-java.util.concurrent.TimeUnit-java.util.concurrent.BlockingQueue-java.util.concurrent.RejectedExecutionHandler-">ThreadPoolExecutor</a></span>(int corePoolSize, int maximumPoolSize, long keepAliveTime, <a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit, <a href="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</a>&lt;<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a>&gt; workQueue, <a href="../../../java/util/concurrent/RejectedExecutionHandler.html" title="interface in java.util.concurrent">RejectedExecutionHandler</a> handler)</code>
<div class="block">
              创建一个新的 
             <code>ThreadPoolExecutor</code>与给定的初始参数和默认线程工厂。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor-int-int-long-java.util.concurrent.TimeUnit-java.util.concurrent.BlockingQueue-java.util.concurrent.ThreadFactory-">ThreadPoolExecutor</a></span>(int corePoolSize, int maximumPoolSize, long keepAliveTime, <a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit, <a href="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</a>&lt;<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a>&gt; workQueue, <a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a> threadFactory)</code>
<div class="block">
              创建一个新的 
             <code>ThreadPoolExecutor</code>与给定的初始参数和默认拒绝执行处理程序。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor-int-int-long-java.util.concurrent.TimeUnit-java.util.concurrent.BlockingQueue-java.util.concurrent.ThreadFactory-java.util.concurrent.RejectedExecutionHandler-">ThreadPoolExecutor</a></span>(int corePoolSize, int maximumPoolSize, long keepAliveTime, <a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit, <a href="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</a>&lt;<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a>&gt; workQueue, <a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a> threadFactory, <a href="../../../java/util/concurrent/RejectedExecutionHandler.html" title="interface in java.util.concurrent">RejectedExecutionHandler</a> handler)</code>
<div class="block">
              创建一个新 
             <code>ThreadPoolExecutor</code>给定的初始参数。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#afterExecute-java.lang.Runnable-java.lang.Throwable-">afterExecute</a></span>(<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> r, <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a> t)</code>
<div class="block">
              完成指定Runnable的执行后调用方法。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#allowCoreThreadTimeOut-boolean-">allowCoreThreadTimeOut</a></span>(boolean value)</code>
<div class="block">
              设置策略是否核心线程可能会超时，如果任务没有在活着的时间内到达，则在新任务到达时被替换。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#allowsCoreThreadTimeOut--">allowsCoreThreadTimeOut</a></span>()</code>
<div class="block">
              如果此池允许核心线程超时并终止，如果没有任务在keepAlive时间内到达，则返回true，如果新任务到达时需要更换。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#awaitTermination-long-java.util.concurrent.TimeUnit-">awaitTermination</a></span>(long timeout, <a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit)</code>
<div class="block">
              阻止所有任务在关闭请求完成后执行，或发生超时，或当前线程中断，以先到者为准。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#beforeExecute-java.lang.Thread-java.lang.Runnable-">beforeExecute</a></span>(<a href="../../../java/lang/Thread.html" title="class in java.lang">Thread</a> t, <a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> r)</code>
<div class="block">
              在给定的线程中执行给定的Runnable之前调用方法。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#execute-java.lang.Runnable-">execute</a></span>(<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> command)</code>
<div class="block">
              在将来某个时候执行给定的任务。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#finalize--">finalize</a></span>()</code>
<div class="block">
              当这个执行器不再被引用并且没有线程时，调用 
             <code>shutdown</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getActiveCount--">getActiveCount</a></span>()</code>
<div class="block">
              返回正在执行任务的线程的大概数量。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getCompletedTaskCount--">getCompletedTaskCount</a></span>()</code>
<div class="block">
              返回完成执行的任务的大致总数。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize--">getCorePoolSize</a></span>()</code>
<div class="block">
              返回核心线程数。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getKeepAliveTime-java.util.concurrent.TimeUnit-">getKeepAliveTime</a></span>(<a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit)</code>
<div class="block">
              返回线程保持活动时间，这是超过核心池大小的线程在终止之前可能保持空闲的时间量。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getLargestPoolSize--">getLargestPoolSize</a></span>()</code>
<div class="block">
              返回在池中同时进行的最大线程数。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getMaximumPoolSize--">getMaximumPoolSize</a></span>()</code>
<div class="block">
              返回允许的最大线程数。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getPoolSize--">getPoolSize</a></span>()</code>
<div class="block">
              返回池中当前的线程数。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code><a href="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</a>&lt;<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getQueue--">getQueue</a></span>()</code>
<div class="block">
              返回此执行程序使用的任务队列。 
            </div> </td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code><a href="../../../java/util/concurrent/RejectedExecutionHandler.html" title="interface in java.util.concurrent">RejectedExecutionHandler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getRejectedExecutionHandler--">getRejectedExecutionHandler</a></span>()</code>
<div class="block">
              返回不可执行任务的当前处理程序。 
            </div> </td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getTaskCount--">getTaskCount</a></span>()</code>
<div class="block">
              返回计划执行的任务的大概总数。 
            </div> </td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code><a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getThreadFactory--">getThreadFactory</a></span>()</code>
<div class="block">
              返回用于创建新线程的线程工厂。 
            </div> </td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#isShutdown--">isShutdown</a></span>()</code>
<div class="block">
              如果此执行者已关闭，则返回 
             <code>true</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#isTerminated--">isTerminated</a></span>()</code>
<div class="block">
              如果所有任务在关闭后完成，则返回 
             <code>true</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#isTerminating--">isTerminating</a></span>()</code>
<div class="block">
              如果此执行者在 
             <a href="../../../java/util/concurrent/ThreadPoolExecutor.html#shutdown--"><code>shutdown()</code></a>或 
             <a href="../../../java/util/concurrent/ThreadPoolExecutor.html#shutdownNow--"><code>shutdownNow()</code></a>之后 
             <a href="../../../java/util/concurrent/ThreadPoolExecutor.html#shutdown--">终止</a> ，但尚未完全终止，则返回true。 
            </div> </td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartAllCoreThreads--">prestartAllCoreThreads</a></span>()</code>
<div class="block">
              启动所有核心线程，导致他们等待工作。 
            </div> </td>
</tr>
<tr class="altColor" id="i22">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartCoreThread--">prestartCoreThread</a></span>()</code>
<div class="block">
              启动核心线程，使其无法等待工作。 
            </div> </td>
</tr>
<tr class="rowColor" id="i23">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#purge--">purge</a></span>()</code>
<div class="block">
<span>尝试从工作队列中删除已取消的所有<a href="../../../java/util/concurrent/Future.html" title="java.util.concurrent中的接口"><code>Future</code></a>任务。</span>
</div> </td>
</tr>
<tr class="altColor" id="i24">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#remove-java.lang.Runnable-">remove</a></span>(<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> task)</code>
<div class="block">
              如果此任务存在，则从执行程序的内部队列中删除此任务，从而导致该任务尚未运行。 
            </div> </td>
</tr>
<tr class="rowColor" id="i25">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#setCorePoolSize-int-">setCorePoolSize</a></span>(int corePoolSize)</code>
<div class="block">
              设置核心线程数。 
            </div> </td>
</tr>
<tr class="altColor" id="i26">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#setKeepAliveTime-long-java.util.concurrent.TimeUnit-">setKeepAliveTime</a></span>(long time, <a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit)</code>
<div class="block">
              设置线程在终止之前可能保持空闲的时间限制。 
            </div> </td>
</tr>
<tr class="rowColor" id="i27">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#setMaximumPoolSize-int-">setMaximumPoolSize</a></span>(int maximumPoolSize)</code>
<div class="block">
              设置允许的最大线程数。 
            </div> </td>
</tr>
<tr class="altColor" id="i28">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#setRejectedExecutionHandler-java.util.concurrent.RejectedExecutionHandler-">setRejectedExecutionHandler</a></span>(<a href="../../../java/util/concurrent/RejectedExecutionHandler.html" title="interface in java.util.concurrent">RejectedExecutionHandler</a> handler)</code>
<div class="block">
              为不可执行的任务设置一个新的处理程序。 
            </div> </td>
</tr>
<tr class="rowColor" id="i29">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#setThreadFactory-java.util.concurrent.ThreadFactory-">setThreadFactory</a></span>(<a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a> threadFactory)</code>
<div class="block">
              设置用于创建新线程的线程工厂。 
            </div> </td>
</tr>
<tr class="altColor" id="i30">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#shutdown--">shutdown</a></span>()</code>
<div class="block">
              启动有序关闭，其中先前提交的任务将被执行，但不会接受任何新任务。 
            </div> </td>
</tr>
<tr class="rowColor" id="i31">
<td class="colFirst"><code><a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#shutdownNow--">shutdownNow</a></span>()</code>
<div class="block">
              尝试停止所有主动执行的任务，停止等待任务的处理，并返回正在等待执行的任务列表。 
            </div> </td>
</tr>
<tr class="altColor" id="i32">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#terminated--">terminated</a></span>()</code>
<div class="block">
              执行程序已终止时调用方法。 
            </div> </td>
</tr>
<tr class="rowColor" id="i33">
<td class="colFirst"><code><a href="../../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ThreadPoolExecutor.html#toString--">toString</a></span>()</code>
<div class="block">
              返回标识此池的字符串及其状态，包括运行状态和估计的工作人员和任务计数的指示。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.util.concurrent.AbstractExecutorService">
<!-- --> </a> <h3>Methods inherited from class java.util.concurrent.<a href="../../../java/util/concurrent/AbstractExecutorService.html" title="class in java.util.concurrent">AbstractExecutorService</a></h3> <code><a href="../../../java/util/concurrent/AbstractExecutorService.html#invokeAll-java.util.Collection-">invokeAll</a>, <a href="../../../java/util/concurrent/AbstractExecutorService.html#invokeAll-java.util.Collection-long-java.util.concurrent.TimeUnit-">invokeAll</a>, <a href="../../../java/util/concurrent/AbstractExecutorService.html#invokeAny-java.util.Collection-">invokeAny</a>, <a href="../../../java/util/concurrent/AbstractExecutorService.html#invokeAny-java.util.Collection-long-java.util.concurrent.TimeUnit-">invokeAny</a>, <a href="../../../java/util/concurrent/AbstractExecutorService.html#newTaskFor-java.util.concurrent.Callable-">newTaskFor</a>, <a href="../../../java/util/concurrent/AbstractExecutorService.html#newTaskFor-java.lang.Runnable-T-">newTaskFor</a>, <a href="../../../java/util/concurrent/AbstractExecutorService.html#submit-java.util.concurrent.Callable-">submit</a>, <a href="../../../java/util/concurrent/AbstractExecutorService.html#submit-java.lang.Runnable-">submit</a>, <a href="../../../java/util/concurrent/AbstractExecutorService.html#submit-java.lang.Runnable-T-">submit</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!-- --> </a> <h3>构造方法详细信息</h3> <a name="ThreadPoolExecutor-int-int-long-java.util.concurrent.TimeUnit-java.util.concurrent.BlockingQueue-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ThreadPoolExecutor</h4> <pre>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          <a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit,
                          <a href="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</a>&lt;<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a>&gt; workQueue)</pre>
<div class="block">
<span>使用给定的初始参数和默认线程工厂创建一个新的<code>ThreadPoolExecutor</code> ，并拒绝执行处理程序。</span>
<span>使用<a href="../../../java/util/concurrent/Executors.html" title="java.util.concurrent中的类"><code>Executors</code></a>工厂方法之一可能更方便，而不是这种通用构造函数。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>corePoolSize</code> - 即使空闲时仍保留在池中的线程数，除非设置 
            <code>allowCoreThreadTimeOut</code>
</dd>
<dd>
<code>maximumPoolSize</code> - 池中允许的最大线程数 
           </dd>
<dd>
<code>keepAliveTime</code> - 当线程数大于核心时，这是多余的空闲线程在终止之前等待新任务的最大时间。 
           </dd>
<dd>
<code>unit</code> - 
            <code>keepAliveTime</code>参数的时间单位 
           </dd>
<dd>
<span><code>workQueue</code> - 在执行任务之前用于保存任务的队列。</span>
<span>该队列将仅保存<code>execute</code>方法提交的<code>Runnable</code>任务。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果以下某项成立： 
            <br/>
<code>corePoolSize &lt; 0</code>
<br/>
<code>keepAliveTime &lt; 0</code>
<br/>
<code>maximumPoolSize &lt;= 0</code>
<br/>
<code>maximumPoolSize &lt; corePoolSize</code>
</dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>workQueue</code>为空 
           </dd>
</dl> </li>
</ul> <a name="ThreadPoolExecutor-int-int-long-java.util.concurrent.TimeUnit-java.util.concurrent.BlockingQueue-java.util.concurrent.ThreadFactory-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ThreadPoolExecutor</h4> <pre>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          <a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit,
                          <a href="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</a>&lt;<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a>&gt; workQueue,
                          <a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a> threadFactory)</pre>
<div class="block">
            创建一个新的 
           <code>ThreadPoolExecutor</code>与给定的初始参数和默认拒绝执行处理程序。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>corePoolSize</code> - 要保留在池中的线程数，即使它们处于空闲状态，除非设置了 
            <code>allowCoreThreadTimeOut</code>
</dd>
<dd>
<code>maximumPoolSize</code> - 池中允许的最大线程数 
           </dd>
<dd>
<code>keepAliveTime</code> - 当线程数大于核心时，这是多余的空闲线程在终止之前等待新任务的最大时间。 
           </dd>
<dd>
<code>unit</code> - 
            <code>keepAliveTime</code>参数的时间单位 
           </dd>
<dd>
<span><code>workQueue</code> - 在执行任务之前用于保存任务的队列。</span>
<span>这个队列只会保存<code>execute</code>方法提交的<code>Runnable</code>任务。</span>
</dd>
<dd>
<code>threadFactory</code> - 执行程序创建新线程时使用的工厂 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果以下某项成立： 
            <br/>
<code>corePoolSize &lt; 0</code>
<br/>
<code>keepAliveTime &lt; 0</code>
<br/>
<code>maximumPoolSize &lt;= 0</code>
<br/>
<code>maximumPoolSize &lt; corePoolSize</code>
</dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>workQueue</code>或 
            <code>threadFactory</code>为空 
           </dd>
</dl> </li>
</ul> <a name="ThreadPoolExecutor-int-int-long-java.util.concurrent.TimeUnit-java.util.concurrent.BlockingQueue-java.util.concurrent.RejectedExecutionHandler-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ThreadPoolExecutor</h4> <pre>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          <a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit,
                          <a href="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</a>&lt;<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a>&gt; workQueue,
                          <a href="../../../java/util/concurrent/RejectedExecutionHandler.html" title="interface in java.util.concurrent">RejectedExecutionHandler</a> handler)</pre>
<div class="block">
            创建一个新的 
           <code>ThreadPoolExecutor</code>与给定的初始参数和默认线程工厂。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>corePoolSize</code> - 要保留在池中的线程数，即使它们处于空闲状态，除非设置了 
            <code>allowCoreThreadTimeOut</code>
</dd>
<dd>
<code>maximumPoolSize</code> - 池中允许的最大线程数 
           </dd>
<dd>
<code>keepAliveTime</code> - 当线程数大于核心时，这是多余的空闲线程在终止之前等待新任务的最大时间。 
           </dd>
<dd>
<code>unit</code> - 
            <code>keepAliveTime</code>参数的时间单位 
           </dd>
<dd>
<span><code>workQueue</code> - 在执行任务之前用于保存任务的队列。</span>
<span>该队列将仅保存<code>execute</code>方法提交的<code>Runnable</code>任务。</span>
</dd>
<dd>
<code>handler</code> - 执行被阻止时使用的处理程序，因为达到线程限制和队列容量 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果以下之一成立： 
            <br/>
<code>corePoolSize &lt; 0</code>
<br/>
<code>keepAliveTime &lt; 0</code>
<br/>
<code>maximumPoolSize &lt;= 0</code>
<br/>
<code>maximumPoolSize &lt; corePoolSize</code>
</dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>workQueue</code>或 
            <code>handler</code>为空 
           </dd>
</dl> </li>
</ul> <a name="ThreadPoolExecutor-int-int-long-java.util.concurrent.TimeUnit-java.util.concurrent.BlockingQueue-java.util.concurrent.ThreadFactory-java.util.concurrent.RejectedExecutionHandler-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>ThreadPoolExecutor</h4> <pre>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          <a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit,
                          <a href="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</a>&lt;<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a>&gt; workQueue,
                          <a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a> threadFactory,
                          <a href="../../../java/util/concurrent/RejectedExecutionHandler.html" title="interface in java.util.concurrent">RejectedExecutionHandler</a> handler)</pre>
<div class="block">
            创建一个新的 
           <code>ThreadPoolExecutor</code>与给定的初始参数。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>corePoolSize</code> - 即使空闲时仍保留在池中的线程数，除非设置 
            <code>allowCoreThreadTimeOut</code>
</dd>
<dd>
<code>maximumPoolSize</code> - 池中允许的最大线程数 
           </dd>
<dd>
<code>keepAliveTime</code> - 当线程数大于内核时，这是多余的空闲线程在终止前等待新任务的最大时间。 
           </dd>
<dd>
<code>unit</code> - 
            <code>keepAliveTime</code>参数的时间单位 
           </dd>
<dd>
<span><code>workQueue</code> - 用于在执行任务之前使用的队列。</span>
<span>这个队列将仅保存<code>execute</code>方法提交的<code>Runnable</code>任务。</span>
</dd>
<dd>
<code>threadFactory</code> - 执行程序创建新线程时使用的工厂 
           </dd>
<dd>
<code>handler</code> - 执行被阻止时使用的处理程序，因为达到线程限制和队列容量 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果以下某项成立： 
            <br/>
<code>corePoolSize &lt; 0</code>
<br/>
<code>keepAliveTime &lt; 0</code>
<br/>
<code>maximumPoolSize &lt;= 0</code>
<br/>
<code>maximumPoolSize &lt; corePoolSize</code>
</dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>workQueue</code>或 
            <code>threadFactory</code>或 
            <code>handler</code>为空 
           </dd>
</dl> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="execute-java.lang.Runnable-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>execute</h4> <pre>public void execute(<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> command)</pre>
<div class="block">
<span>在将来某个时候执行给定的任务。</span>
<span>任务可以在新线程或现有的合并的线程中执行。</span>
<span>如果任务无法提交执行，由于此执行程序已关闭或已达到其容量，该任务将由当前的<code>RejectedExecutionHandler</code>处理。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>command</code> - 要执行的任务 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/util/concurrent/RejectedExecutionException.html" title="class in java.util.concurrent">RejectedExecutionException</a></code> - 由RejectedExecutionHandler自行 
            <code>RejectedExecutionHandler</code> ，如果任务不能被接受执行 
           </dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>command</code>为空 
           </dd>
</dl> </li>
</ul> <a name="shutdown--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>shutdown</h4> <pre>public void shutdown()</pre>
<div class="block">
<span>启动有序关闭，其中先前提交的任务将被执行，但不会接受任何新任务。</span>
<span>如果已经关闭，调用没有额外的作用。</span>
<p> <span>此方法不等待以前提交的任务完成执行。</span> <span>使用<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#awaitTermination-long-java.util.concurrent.TimeUnit-"><code>awaitTermination</code></a>做到这一点。</span> </p>
</div>
<dl>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理器存在并关闭，则ExecutorService可能会操纵调用者不允许修改的线程，因为它不保留<a href="../../../java/lang/RuntimePermission.html" title="java.lang中的类"><code>RuntimePermission</code></a> <code>("modifyThread")</code>或安全管理器的<code>checkAccess</code>方法拒绝访问。</span>
</dd>
</dl> </li>
</ul> <a name="shutdownNow--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>shutdownNow</h4> <pre>public <a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a>&gt; shutdownNow()</pre>
<div class="block">
<span>尝试停止所有主动执行的任务，停止等待任务的处理，并返回正在等待执行的任务列表。</span>
<span>从此方法返回时，这些任务将从任务队列中排除（删除）。</span>
<p> <span>此方法不等待主动执行的任务终止。</span> <span>使用<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#awaitTermination-long-java.util.concurrent.TimeUnit-"><code>awaitTermination</code></a>做到这一点。</span> </p>
<p> <span>除了努力尝试停止处理积极执行任务之外，没有任何保证。</span> <span>此实现通过取消任务<a href="../../../java/lang/Thread.html#interrupt--"><code>Thread.interrupt()</code></a> ，让未能响应中断任何任务可能永远不会终止。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             从未开始执行的任务列表 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理器存在并关闭，则ExecutorService可能会操纵调用者不允许修改的线程，因为它不保留<a href="../../../java/lang/RuntimePermission.html" title="java.lang中的类"><code>RuntimePermission</code></a> <code>("modifyThread")</code>或安全管理器的<code>checkAccess</code>方法拒绝访问。</span>
</dd>
</dl> </li>
</ul> <a name="isShutdown--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isShutdown</h4> <pre>public boolean isShutdown()</pre>
<div class="block">
<span class="descfrmTypeLabel">说明从界面： <code><a href="../../../java/util/concurrent/ExecutorService.html#isShutdown--">ExecutorService</a></code>复制</span>
</div>
<div class="block">
            如果执行者已关闭，则返回 
           <code>true</code> 。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果这个执行者已被关闭 
           </dd>
</dl> </li>
</ul> <a name="isTerminating--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isTerminating</h4> <pre>public boolean isTerminating()</pre>
<div class="block">
<span>如果此执行者在<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#shutdown--"><code>shutdown()</code></a>或<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#shutdownNow--"><code>shutdownNow()</code></a>之后<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#shutdown--">终止</a> ，但尚未完全终止，则返回true。</span>
<span>此方法可能对调试有用。</span>
<span>返回<code>true</code>报告了关机后的足够的时间可能表明提交的任务已经忽略或抑制中断，导致执行者不能正常终止。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果终止但尚未终止 
           </dd>
</dl> </li>
</ul> <a name="isTerminated--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isTerminated</h4> <pre>public boolean isTerminated()</pre>
<div class="block">
<span class="descfrmTypeLabel">说明从界面： <code><a href="../../../java/util/concurrent/ExecutorService.html#isTerminated--">ExecutorService</a></code>复制</span>
</div>
<div class="block">
<span>如果所有任务在关闭后完成，则返回<code>true</code> 。</span>
<span>请注意， <code>isTerminated</code>从不是<code>true</code> ，除非<code>shutdown</code>或<code>shutdownNow</code>被称为第一个。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果所有任务已完成关闭 
           </dd>
</dl> </li>
</ul> <a name="awaitTermination-long-java.util.concurrent.TimeUnit-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>awaitTermination</h4> <pre>public boolean awaitTermination(long timeout,
                                <a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit)
                         throws <a href="../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></pre>
<div class="block">
<span class="descfrmTypeLabel">说明从界面： <code><a href="../../../java/util/concurrent/ExecutorService.html#awaitTermination-long-java.util.concurrent.TimeUnit-">ExecutorService</a></code>复制</span>
</div>
<div class="block">
            阻止所有任务在关闭请求完成后执行，或发生超时，或当前线程中断，以先到者为准。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>timeout</code> - 等待的最长时间 
           </dd>
<dd>
<code>unit</code> - 超时参数的时间单位 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果这个执行者终止了 
            <code>false</code>如果在终止之前超时了 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></code> - 如果中断等待 
           </dd>
</dl> </li>
</ul> <a name="finalize--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>finalize</h4> <pre>protected void finalize()</pre>
<div class="block">
            当这个执行器不再被引用并且没有线程时，调用 
           <code>shutdown</code> 。 
          </div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../../java/lang/Object.html#finalize--">finalize</a></code>在类别 
            <code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../../java/lang/ref/WeakReference.html" title="java.lang.ref中的类"><code>WeakReference</code></a> ， <a href="../../../java/lang/ref/PhantomReference.html" title="java.lang.ref中的类"><code>PhantomReference</code></a></span>
</dd>
</dl> </li>
</ul> <a name="setThreadFactory-java.util.concurrent.ThreadFactory-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setThreadFactory</h4> <pre>public void setThreadFactory(<a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a> threadFactory)</pre>
<div class="block">
            设置用于创建新线程的线程工厂。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>threadFactory</code> - 新线工厂 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果threadFactory为null 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getThreadFactory--"><code>getThreadFactory()</code></a>
</dd>
</dl> </li>
</ul> <a name="getThreadFactory--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getThreadFactory</h4> <pre>public <a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a> getThreadFactory()</pre>
<div class="block">
            返回用于创建新线程的线程工厂。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             当前线程工厂 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#setThreadFactory-java.util.concurrent.ThreadFactory-"><code>setThreadFactory(ThreadFactory)</code></a>
</dd>
</dl> </li>
</ul> <a name="setRejectedExecutionHandler-java.util.concurrent.RejectedExecutionHandler-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setRejectedExecutionHandler</h4> <pre>public void setRejectedExecutionHandler(<a href="../../../java/util/concurrent/RejectedExecutionHandler.html" title="interface in java.util.concurrent">RejectedExecutionHandler</a> handler)</pre>
<div class="block">
            为不可执行的任务设置一个新的处理程序。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>handler</code> - 新的处理程序 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果处理程序为空 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getRejectedExecutionHandler--"><code>getRejectedExecutionHandler()</code></a>
</dd>
</dl> </li>
</ul> <a name="getRejectedExecutionHandler--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getRejectedExecutionHandler</h4> <pre>public <a href="../../../java/util/concurrent/RejectedExecutionHandler.html" title="interface in java.util.concurrent">RejectedExecutionHandler</a> getRejectedExecutionHandler()</pre>
<div class="block">
            返回不可执行任务的当前处理程序。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             当前处理程序 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#setRejectedExecutionHandler-java.util.concurrent.RejectedExecutionHandler-"><code>setRejectedExecutionHandler(RejectedExecutionHandler)</code></a>
</dd>
</dl> </li>
</ul> <a name="setCorePoolSize-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setCorePoolSize</h4> <pre>public void setCorePoolSize(int corePoolSize)</pre>
<div class="block">
<span>设置核心线程数。</span>
<span>这将覆盖在构造函数中设置的任何值。</span>
<span>如果新值小于当前值，则过多的现有线程在下一个空闲时将被终止。</span>
<span>如果更大，则如果需要，新线程将被启动以执行任何排队的任务。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>corePoolSize</code> - 新的核心尺寸 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>corePoolSize &lt; 0</code>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize--"><code>getCorePoolSize()</code></a>
</dd>
</dl> </li>
</ul> <a name="getCorePoolSize--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getCorePoolSize</h4> <pre>public int getCorePoolSize()</pre>
<div class="block">
            返回核心线程数。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             核心线程数 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#setCorePoolSize-int-"><code>setCorePoolSize(int)</code></a>
</dd>
</dl> </li>
</ul> <a name="prestartCoreThread--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>prestartCoreThread</h4> <pre>public boolean prestartCoreThread()</pre>
<div class="block">
<span>启动核心线程，使其无法等待工作。</span>
<span>这将覆盖仅在执行新任务时启动核心线程的默认策略。</span>
<span>如果所有核心线程已经启动，此方法将返回<code>false</code> 。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果线程启动 
           </dd>
</dl> </li>
</ul> <a name="prestartAllCoreThreads--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>prestartAllCoreThreads</h4> <pre>public int prestartAllCoreThreads()</pre>
<div class="block">
<span>启动所有核心线程，导致他们等待工作。</span>
<span>这将覆盖仅在执行新任务时启动核心线程的默认策略。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             线程数已启动 
           </dd>
</dl> </li>
</ul> <a name="allowsCoreThreadTimeOut--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>allowsCoreThreadTimeOut</h4> <pre>public boolean allowsCoreThreadTimeOut()</pre>
<div class="block">
<span>如果此池允许核心线程超时并终止，如果没有任务在keepAlive时间内到达，则返回true，如果新任务到达时需要更换。</span>
<span>当为true时，应用于非核心线程的同样的保持活动策略也适用于核心线程。</span>
<span>当为false（默认值）时，由于缺少传入任务，核心线程不会终止。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果核心线程被允许超时，否则 
            <code>false</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="allowCoreThreadTimeOut-boolean-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>allowCoreThreadTimeOut</h4> <pre>public void allowCoreThreadTimeOut(boolean value)</pre>
<div class="block">
<span>设置策略是否核心线程可能会超时，如果任务没有在活着的时间内到达，则在新任务到达时被替换。</span>
<span>当虚假时，核心线程由于缺少传入任务而永远不会被终止。</span>
<span>当为true时，应用于非核心线程的同样的保持活动策略也适用于核心线程。</span>
<span>为避免连续更换线，设置<code>true</code>时，保持活动时间必须大于零。</span>
<span>这个方法一般应该在池被主动使用之前调用。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>value</code> - 
            <code>true</code>如果要超时，否则 
            <code>false</code>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果值为 
            <code>true</code> ，并且当前保持活动时间不大于零 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="setMaximumPoolSize-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setMaximumPoolSize</h4> <pre>public void setMaximumPoolSize(int maximumPoolSize)</pre>
<div class="block">
<span>设置允许的最大线程数。</span>
<span>这将覆盖在构造函数中设置的任何值。</span>
<span>如果新值小于当前值，则过多的现有线程在下一个空闲时将被终止。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>maximumPoolSize</code> - 新的最大值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果新的最大值小于或等于零，或小于 
            <a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize--">core pool size</a>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getMaximumPoolSize--"><code>getMaximumPoolSize()</code></a>
</dd>
</dl> </li>
</ul> <a name="getMaximumPoolSize--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getMaximumPoolSize</h4> <pre>public int getMaximumPoolSize()</pre>
<div class="block">
            返回允许的最大线程数。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             允许的最大线程数 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#setMaximumPoolSize-int-"><code>setMaximumPoolSize(int)</code></a>
</dd>
</dl> </li>
</ul> <a name="setKeepAliveTime-long-java.util.concurrent.TimeUnit-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setKeepAliveTime</h4> <pre>public void setKeepAliveTime(long time,
                             <a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit)</pre>
<div class="block">
<span>设置线程在终止之前可能保持空闲的时间限制。</span>
<span>如果存在超过当前在池中的线程核心数量，则在等待这段时间而不处理任务之后，多余的线程将被终止。</span>
<span>这将覆盖在构造函数中设置的任何值。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>time</code> - 等待的时间</span>
<span>时间值为零将导致多余的线程在执行任务后立即终止。</span>
</dd>
<dd>
<code>unit</code> - 
            <code>time</code>参数的时间单位 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>time</code>小于零或 
            <code>time</code>为零， 
            <code>allowsCoreThreadTimeOut</code>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#getKeepAliveTime-java.util.concurrent.TimeUnit-"><code>getKeepAliveTime(TimeUnit)</code></a>
</dd>
</dl> </li>
</ul> <a name="getKeepAliveTime-java.util.concurrent.TimeUnit-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getKeepAliveTime</h4> <pre>public long getKeepAliveTime(<a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit)</pre>
<div class="block">
            返回线程保持活动时间，这是超过核心池大小的线程在终止之前可能保持空闲的时间量。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>unit</code> - 结果所需的时间单位 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             时间限制 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#setKeepAliveTime-long-java.util.concurrent.TimeUnit-"><code>setKeepAliveTime(long, TimeUnit)</code></a>
</dd>
</dl> </li>
</ul> <a name="getQueue--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getQueue</h4> <pre>public <a href="../../../java/util/concurrent/BlockingQueue.html" title="interface in java.util.concurrent">BlockingQueue</a>&lt;<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a>&gt; getQueue()</pre>
<div class="block">
<span>返回此执行程序使用的任务队列。</span>
<span>访问任务队列主要用于调试和监视。</span>
<span>此队列可能正在使用中。</span>
<span>检索任务队列不会阻止排队的任务执行。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             任务队列 
           </dd>
</dl> </li>
</ul> <a name="remove-java.lang.Runnable-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>remove</h4> <pre>public boolean remove(<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> task)</pre>
<div class="block">
<span>如果此任务存在，则从执行程序的内部队列中删除此任务，从而导致该任务尚未运行。</span>
<p> <span>该方法作为取消方案的一部分可能是有用的。</span> <span>在放入内部队列之前，可能无法删除已转换为其他表单的任务。</span> <span>例如，使用<code>submit</code>输入的任务可能会转换为维护<code>Future</code>状态的表单。</span> <span>然而，在这种情况下，可以使用方法<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#purge--"><code>purge()</code></a>去除已被取消的那些期货。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>task</code> - 要删除的任务 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果任务被删除 
           </dd>
</dl> </li>
</ul> <a name="purge--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>purge</h4> <pre>public void purge()</pre>
<div class="block">
<span>尝试从工作队列中删除已取消的所有<a href="../../../java/util/concurrent/Future.html" title="java.util.concurrent中的接口"><code>Future</code></a>任务。</span>
<span>此方法可用作存储回收操作，对功能没有其他影响。</span>
<span>取消的任务永远不会执行，但可能会累积在工作队列中，直到工作线程可以主动删除它们。</span>
<span>现在调用此方法会尝试删除它。</span>
<span>但是，该方法可能无法在其他线程的干扰存在的情况下删除任务。</span>
</div> </li>
</ul> <a name="getPoolSize--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getPoolSize</h4> <pre>public int getPoolSize()</pre>
<div class="block">
            返回池中当前的线程数。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             线程数 
           </dd>
</dl> </li>
</ul> <a name="getActiveCount--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getActiveCount</h4> <pre>public int getActiveCount()</pre>
<div class="block">
            返回正在执行任务的线程的大概数量。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             线程数 
           </dd>
</dl> </li>
</ul> <a name="getLargestPoolSize--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getLargestPoolSize</h4> <pre>public int getLargestPoolSize()</pre>
<div class="block">
            返回在池中同时进行的最大线程数。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             线程数 
           </dd>
</dl> </li>
</ul> <a name="getTaskCount--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getTaskCount</h4> <pre>public long getTaskCount()</pre>
<div class="block">
<span>返回计划执行的任务的大概总数。</span>
<span>因为任务和线程的状态在计算过程中可能会动态地改变，所以返回的值只是一个近似值。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             任务数量 
           </dd>
</dl> </li>
</ul> <a name="getCompletedTaskCount--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getCompletedTaskCount</h4> <pre>public long getCompletedTaskCount()</pre>
<div class="block">
<span>返回完成执行的任务的大致总数。</span>
<span>因为任务和线程的状态可能在计算过程中动态地改变，所以返回的值只是一个近似值，但是在连续的调用中并不会减少。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             任务数量 
           </dd>
</dl> </li>
</ul> <a name="toString--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toString</h4> <pre>public <a href="../../../java/lang/String.html" title="class in java.lang">String</a> toString()</pre>
<div class="block">
            返回标识此池的字符串及其状态，包括运行状态和估计的工作人员和任务计数的指示。 
          </div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../../java/lang/Object.html#toString--">toString</a></code>在类别 
            <code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个标识这个池的字符串，以及它的状态 
           </dd>
</dl> </li>
</ul> <a name="beforeExecute-java.lang.Thread-java.lang.Runnable-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>beforeExecute</h4> <pre>protected void beforeExecute(<a href="../../../java/lang/Thread.html" title="class in java.lang">Thread</a> t,
                             <a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> r)</pre>
<div class="block">
<span>在给定的线程中执行给定的Runnable之前调用方法。</span>
<span>该方法由执行任务<code>r</code>的线程<code>t</code>调用，并可用于重新初始化ThreadLocals或执行日志记录。</span>
<p> <span>此实现不执行任何操作，但可以在子类中进行自定义。</span> <span>注意：为了正确嵌套多个重复数据，子类<code>super.beforeExecute</code>在此方法结束时调用<code>super.beforeExecute</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>t</code> - 将运行任务 
            <code>r</code>的线程 
           </dd>
<dd>
<code>r</code> - 将执行的任务 
           </dd>
</dl> </li>
</ul> <a name="afterExecute-java.lang.Runnable-java.lang.Throwable-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>afterExecute</h4> <pre>protected void afterExecute(<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> r,
                            <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a> t)</pre>
<div class="block">
<span>完成指定Runnable的执行后调用方法。</span>
<span>该方法由执行该任务的线程调用。</span>
<span>如果非空，则Throwable是<code>RuntimeException</code>或<code>Error</code> ，导致执行突然终止。</span>
<p> <span>此实现不执行任何操作，但可以在子类中进行自定义。</span> <span>注意：为了正确嵌套多个覆盖，子类应该在此方法开始时调用<code>super.afterExecute</code> 。</span> </p>
<p> <span><b>注意：</b>当操作被<a href="../../../java/util/concurrent/FutureTask.html" title="java.util.concurrent中的类">明确地</a>包含在任务（如<a href="../../../java/util/concurrent/FutureTask.html" title="java.util.concurrent中的类"><code>FutureTask</code></a> ）中或通过诸如<code>submit</code>之类的方法被<code>submit</code>时，这些任务对象捕获和维护计算异常，因此它们不会引起突然终止，并且内部异常<em>不会</em>传递给该方法。</span> <span>如果您希望在此方法中捕获两种故障，您可以进一步探测这种情况，如在此示例子类中，如果任务已中止，则会打印直接原因或底层异常：</span> </p>
<pre>  <span><code> class ExtendedExecutor extends ThreadPoolExecutor { // ... protected void afterExecute(Runnable r, Throwable t) { super.afterExecute(r, t); if (t == null &amp;&amp; r instanceof Future&lt;?&gt;) { try { Object result = ((Future&lt;?&gt;) r).get(); } catch (CancellationException ce) { t = ce; } catch (ExecutionException ee) { t = ee.getCause(); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); // ignore/reset } } if (t != null) System.out.println(t); } }</code></span> </pre>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>r</code> - 已完成的runnable 
           </dd>
<dd>
<code>t</code> - 导致终止的异常，如果执行正常完成，则为null 
           </dd>
</dl> </li>
</ul> <a name="terminated--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>terminated</h4> <pre>protected void terminated()</pre>
<div class="block">
<span>执行程序已终止时调用方法。</span>
<span>默认实现什么都不做。</span>
<span>注意：为了正确嵌套多个覆盖，子类应<code>super.terminated</code>在此方法中调用<code>super.terminated</code> 。</span>
</div> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>