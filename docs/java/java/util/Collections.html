<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.util 
   </div>
<h2 class="title" title="Class Collections">Class Collections</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.util.Collections</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre>public class <span class="typeNameLabel">Collections</span>
extends <a href="../../java/lang/Object.html" title="class in java.lang">Object</a></pre>
<div class="block">
<span>此类仅由静态方法组合或返回集合。</span>
<span>它包含对集合进行操作的多态算法，“包装器”，返回由指定集合支持的新集合，以及其他一些可能的和最终的。</span>
<p> <span>如果提供给它们的集合或类对象为null，则此类的方法都抛出一个<tt>NullPointerException</tt> 。</span> </p>
<p> <span>该类中包含的多态算法的文档通常包括实现的简要<i>说明</i> 。</span> <span>这些描述应被视为<i>实施说明</i> ，而不是<i>说明书的一部分</i> 。</span> <span>只要规范本身得到遵守，实现者就可以随意替代其他算法。</span> <span>（例如，sort使用的<tt>算法</tt>不一定是一个mergeesort，但它必须是<i>稳定的</i> 。）</span> </p>
<p> <span>如果集合不支持适当的突变原语，例如<tt>set</tt>方法，则该类中包含的“破坏性”算法，即修改其操作的集合的算法被指定为抛出<tt>UnsupportedOperationException</tt> 。</span> <span>如果调用对集合没有影响，这些算法可能但不是必须抛出此异常。</span> <span>例如，在已经排序的不可修改列表上调用<tt>sort</tt>方法可以抛出<tt>UnsupportedOperationException</tt> 。</span> </p>
<p> <span>这个班是<a href="../../../technotes/guides/collections/index.html">Java Collections Framework的会员</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.2 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/util/Collection.html" title="java.util中的接口"><code>Collection</code></a> ， <a href="../../java/util/Set.html" title="java.util中的接口"><code>Set</code></a> ， <a href="../../java/util/List.html" title="java.util中的接口"><code>List</code></a> ， <a href="../../java/util/Map.html" title="java.util中的接口"><code>Map</code></a></span>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!-- --> </a> <h3>Field Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Field Summary table, listing fields, and an explanation">
<caption>
<span>Fields</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../java/util/List.html" title="interface in java.util">List</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#EMPTY_LIST">EMPTY_LIST</a></span></code>
<div class="block">
              空列表（不可变）。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../java/util/Map.html" title="interface in java.util">Map</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#EMPTY_MAP">EMPTY_MAP</a></span></code>
<div class="block">
              空地图（immutable）。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../java/util/Set.html" title="interface in java.util">Set</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#EMPTY_SET">EMPTY_SET</a></span></code>
<div class="block">
              空集（不可变）。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t1"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>static &lt;T&gt; boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#addAll-java.util.Collection-T...-">addAll</a></span>(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;? super T&gt; c, T... elements)</code>
<div class="block">
              将所有指定的元素添加到指定的集合。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/Queue.html" title="interface in java.util">Queue</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#asLifoQueue-java.util.Deque-">asLifoQueue</a></span>(<a href="../../java/util/Deque.html" title="interface in java.util">Deque</a>&lt;T&gt; deque)</code>
<div class="block">
<span>返回<a href="../../java/util/Deque.html" title="java.util中的接口"><code>Deque</code></a>作为先进先出（ <a href="../../java/util/Queue.html" title="java.util中的接口">Lifo</a> ） <a href="../../java/util/Queue.html" title="java.util中的接口"><code>Queue</code>的视图</a> 。</span>
</div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>static &lt;T&gt; int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#binarySearch-java.util.List-T-">binarySearch</a></span>(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;? extends <a href="../../java/lang/Comparable.html" title="interface in java.lang">Comparable</a>&lt;? super T&gt;&gt; list, T key)</code>
<div class="block">
              使用二叉搜索算法搜索指定对象的指定列表。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>static &lt;T&gt; int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#binarySearch-java.util.List-T-java.util.Comparator-">binarySearch</a></span>(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;? extends T&gt; list, T key, <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; c)</code>
<div class="block">
              使用二叉搜索算法搜索指定对象的指定列表。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>static &lt;E&gt; <a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;E&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#checkedCollection-java.util.Collection-java.lang.Class-">checkedCollection</a></span>(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;E&gt; c, <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;E&gt; type)</code>
<div class="block">
              返回指定集合的动态类型安全视图。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>static &lt;E&gt; <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;E&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#checkedList-java.util.List-java.lang.Class-">checkedList</a></span>(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;E&gt; list, <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;E&gt; type)</code>
<div class="block">
              返回指定列表的动态类型安全视图。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>static &lt;K,V&gt; <a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#checkedMap-java.util.Map-java.lang.Class-java.lang.Class-">checkedMap</a></span>(<a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,V&gt; m, <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;K&gt; keyType, <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;V&gt; valueType)</code>
<div class="block">
              返回指定地图的动态类型安全视图。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>static &lt;K,V&gt; <a href="../../java/util/NavigableMap.html" title="interface in java.util">NavigableMap</a>&lt;K,V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#checkedNavigableMap-java.util.NavigableMap-java.lang.Class-java.lang.Class-">checkedNavigableMap</a></span>(<a href="../../java/util/NavigableMap.html" title="interface in java.util">NavigableMap</a>&lt;K,V&gt; m, <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;K&gt; keyType, <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;V&gt; valueType)</code>
<div class="block">
              返回指定可导航地图的动态类型安全视图。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>static &lt;E&gt; <a href="../../java/util/NavigableSet.html" title="interface in java.util">NavigableSet</a>&lt;E&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#checkedNavigableSet-java.util.NavigableSet-java.lang.Class-">checkedNavigableSet</a></span>(<a href="../../java/util/NavigableSet.html" title="interface in java.util">NavigableSet</a>&lt;E&gt; s, <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;E&gt; type)</code>
<div class="block">
              返回指定的可导航集的动态类型安全视图。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>static &lt;E&gt; <a href="../../java/util/Queue.html" title="interface in java.util">Queue</a>&lt;E&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#checkedQueue-java.util.Queue-java.lang.Class-">checkedQueue</a></span>(<a href="../../java/util/Queue.html" title="interface in java.util">Queue</a>&lt;E&gt; queue, <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;E&gt; type)</code>
<div class="block">
              返回指定队列的动态类型安全视图。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>static &lt;E&gt; <a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;E&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#checkedSet-java.util.Set-java.lang.Class-">checkedSet</a></span>(<a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;E&gt; s, <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;E&gt; type)</code>
<div class="block">
              返回指定集合的动态类型安全视图。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>static &lt;K,V&gt; <a href="../../java/util/SortedMap.html" title="interface in java.util">SortedMap</a>&lt;K,V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#checkedSortedMap-java.util.SortedMap-java.lang.Class-java.lang.Class-">checkedSortedMap</a></span>(<a href="../../java/util/SortedMap.html" title="interface in java.util">SortedMap</a>&lt;K,V&gt; m, <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;K&gt; keyType, <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;V&gt; valueType)</code>
<div class="block">
              返回指定排序映射的动态类型安全视图。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>static &lt;E&gt; <a href="../../java/util/SortedSet.html" title="interface in java.util">SortedSet</a>&lt;E&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#checkedSortedSet-java.util.SortedSet-java.lang.Class-">checkedSortedSet</a></span>(<a href="../../java/util/SortedSet.html" title="interface in java.util">SortedSet</a>&lt;E&gt; s, <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;E&gt; type)</code>
<div class="block">
              返回指定排序集的动态类型安全视图。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>static &lt;T&gt; void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#copy-java.util.List-java.util.List-">copy</a></span>(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;? super T&gt; dest, <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;? extends T&gt; src)</code>
<div class="block">
              将所有元素从一个列表复制到另一个列表中。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#disjoint-java.util.Collection-java.util.Collection-">disjoint</a></span>(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;?&gt; c1, <a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;?&gt; c2)</code>
<div class="block">
              如果两个指定的集合没有共同的元素，则返回 
             <code>true</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/Enumeration.html" title="interface in java.util">Enumeration</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#emptyEnumeration--">emptyEnumeration</a></span>()</code>
<div class="block">
              返回没有元素的枚举。 
            </div> </td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/Iterator.html" title="interface in java.util">Iterator</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#emptyIterator--">emptyIterator</a></span>()</code>
<div class="block">
              返回没有元素的迭代器。 
            </div> </td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#emptyList--">emptyList</a></span>()</code>
<div class="block">
              返回空列表（immutable）。 
            </div> </td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/ListIterator.html" title="interface in java.util">ListIterator</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#emptyListIterator--">emptyListIterator</a></span>()</code>
<div class="block">
              返回没有元素的列表迭代器。 
            </div> </td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>static &lt;K,V&gt; <a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#emptyMap--">emptyMap</a></span>()</code>
<div class="block">
              返回空的地图（不可变）。 
            </div> </td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code>static &lt;K,V&gt; <a href="../../java/util/NavigableMap.html" title="interface in java.util">NavigableMap</a>&lt;K,V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#emptyNavigableMap--">emptyNavigableMap</a></span>()</code>
<div class="block">
              返回空导航地图（不可变）。 
            </div> </td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code>static &lt;E&gt; <a href="../../java/util/NavigableSet.html" title="interface in java.util">NavigableSet</a>&lt;E&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#emptyNavigableSet--">emptyNavigableSet</a></span>()</code>
<div class="block">
              返回一个空导航集（immutable）。 
            </div> </td>
</tr>
<tr class="altColor" id="i22">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#emptySet--">emptySet</a></span>()</code>
<div class="block">
              返回一个空集（immutable）。 
            </div> </td>
</tr>
<tr class="rowColor" id="i23">
<td class="colFirst"><code>static &lt;K,V&gt; <a href="../../java/util/SortedMap.html" title="interface in java.util">SortedMap</a>&lt;K,V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#emptySortedMap--">emptySortedMap</a></span>()</code>
<div class="block">
              返回空的排序映射（immutable）。 
            </div> </td>
</tr>
<tr class="altColor" id="i24">
<td class="colFirst"><code>static &lt;E&gt; <a href="../../java/util/SortedSet.html" title="interface in java.util">SortedSet</a>&lt;E&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#emptySortedSet--">emptySortedSet</a></span>()</code>
<div class="block">
              返回一个空的排序集（immutable）。 
            </div> </td>
</tr>
<tr class="rowColor" id="i25">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/Enumeration.html" title="interface in java.util">Enumeration</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#enumeration-java.util.Collection-">enumeration</a></span>(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;T&gt; c)</code>
<div class="block">
              返回指定集合的枚举。 
            </div> </td>
</tr>
<tr class="altColor" id="i26">
<td class="colFirst"><code>static &lt;T&gt; void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#fill-java.util.List-T-">fill</a></span>(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;? super T&gt; list, T obj)</code>
<div class="block">
              用指定的元素代替指定列表的所有元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i27">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#frequency-java.util.Collection-java.lang.Object-">frequency</a></span>(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;?&gt; c, <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> o)</code>
<div class="block">
              返回指定集合中与指定对象相等的元素数。 
            </div> </td>
</tr>
<tr class="altColor" id="i28">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#indexOfSubList-java.util.List-java.util.List-">indexOfSubList</a></span>(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; source, <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; target)</code>
<div class="block">
              返回指定源列表中指定目标列表的第一次出现的起始位置，如果没有此类事件，则返回-1。 
            </div> </td>
</tr>
<tr class="rowColor" id="i29">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#lastIndexOfSubList-java.util.List-java.util.List-">lastIndexOfSubList</a></span>(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; source, <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; target)</code>
<div class="block">
              返回指定源列表中指定目标列表的最后一次出现的起始位置，如果没有此类事件则返回-1。 
            </div> </td>
</tr>
<tr class="altColor" id="i30">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/ArrayList.html" title="class in java.util">ArrayList</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#list-java.util.Enumeration-">list</a></span>(<a href="../../java/util/Enumeration.html" title="interface in java.util">Enumeration</a>&lt;T&gt; e)</code>
<div class="block">
              返回一个数组列表，其中包含由枚举返回的顺序由指定的枚举返回的元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i31">
<td class="colFirst"><code>static &lt;T extends <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> &amp; <a href="../../java/lang/Comparable.html" title="interface in java.lang">Comparable</a>&lt;? super T&gt;&gt;<br/>T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#max-java.util.Collection-">max</a></span>(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;? extends T&gt; coll)</code>
<div class="block">
              根据其元素的 
             <i>自然顺序</i>返回给定集合的最大元素。 
            </div> </td>
</tr>
<tr class="altColor" id="i32">
<td class="colFirst"><code>static &lt;T&gt; T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#max-java.util.Collection-java.util.Comparator-">max</a></span>(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;? extends T&gt; coll, <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; comp)</code>
<div class="block">
              根据指定的比较器引发的顺序返回给定集合的最大元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i33">
<td class="colFirst"><code>static &lt;T extends <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> &amp; <a href="../../java/lang/Comparable.html" title="interface in java.lang">Comparable</a>&lt;? super T&gt;&gt;<br/>T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#min-java.util.Collection-">min</a></span>(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;? extends T&gt; coll)</code>
<div class="block">
              根据其元素的 
             <i>自然顺序</i>返回给定集合的最小元素。 
            </div> </td>
</tr>
<tr class="altColor" id="i34">
<td class="colFirst"><code>static &lt;T&gt; T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#min-java.util.Collection-java.util.Comparator-">min</a></span>(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;? extends T&gt; coll, <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; comp)</code>
<div class="block">
              根据指定的比较器引发的顺序返回给定集合的最小元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i35">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#nCopies-int-T-">nCopies</a></span>(int n, T o)</code>
<div class="block">
              返回由指定对象的 
             <tt>n</tt>副本组成的不可变列表。 
            </div> </td>
</tr>
<tr class="altColor" id="i36">
<td class="colFirst"><code>static &lt;E&gt; <a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;E&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#newSetFromMap-java.util.Map-">newSetFromMap</a></span>(<a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;E,<a href="../../java/lang/Boolean.html" title="class in java.lang">Boolean</a>&gt; map)</code>
<div class="block">
              返回由指定地图支持的集合。 
            </div> </td>
</tr>
<tr class="rowColor" id="i37">
<td class="colFirst"><code>static &lt;T&gt; boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#replaceAll-java.util.List-T-T-">replaceAll</a></span>(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt; list, T oldVal, T newVal)</code>
<div class="block">
              将列表中一个指定值的所有出现替换为另一个。 
            </div> </td>
</tr>
<tr class="altColor" id="i38">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#reverse-java.util.List-">reverse</a></span>(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; list)</code>
<div class="block">
              反转指定列表中元素的顺序。 
            </div> </td>
</tr>
<tr class="rowColor" id="i39">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#reverseOrder--">reverseOrder</a></span>()</code>
<div class="block">
              返回一个比较器，它对实现 
             <code>Comparable</code>接口的对象集合施加了 
             <em>自然排序</em>的相反。 
            </div> </td>
</tr>
<tr class="altColor" id="i40">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#reverseOrder-java.util.Comparator-">reverseOrder</a></span>(<a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;T&gt; cmp)</code>
<div class="block">
              返回一个比较器，它强制指定比较器的反向排序。 
            </div> </td>
</tr>
<tr class="rowColor" id="i41">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#rotate-java.util.List-int-">rotate</a></span>(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; list, int distance)</code>
<div class="block">
              将指定列表中的元素旋转指定的距离。 
            </div> </td>
</tr>
<tr class="altColor" id="i42">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#shuffle-java.util.List-">shuffle</a></span>(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; list)</code>
<div class="block">
              使用默认的随机源随机排列指定的列表。 
            </div> </td>
</tr>
<tr class="rowColor" id="i43">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#shuffle-java.util.List-java.util.Random-">shuffle</a></span>(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; list, <a href="../../java/util/Random.html" title="class in java.util">Random</a> rnd)</code>
<div class="block">
              使用指定的随机源随机排列指定的列表。 
            </div> </td>
</tr>
<tr class="altColor" id="i44">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#singleton-T-">singleton</a></span>(T o)</code>
<div class="block">
              返回一个只包含指定对象的不可变集。 
            </div> </td>
</tr>
<tr class="rowColor" id="i45">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#singletonList-T-">singletonList</a></span>(T o)</code>
<div class="block">
              返回一个只包含指定对象的不可变列表。 
            </div> </td>
</tr>
<tr class="altColor" id="i46">
<td class="colFirst"><code>static &lt;K,V&gt; <a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#singletonMap-K-V-">singletonMap</a></span>(K key, V value)</code>
<div class="block">
              返回一个不可变的地图，只将指定的键映射到指定的值。 
            </div> </td>
</tr>
<tr class="rowColor" id="i47">
<td class="colFirst"><code>static &lt;T extends <a href="../../java/lang/Comparable.html" title="interface in java.lang">Comparable</a>&lt;? super T&gt;&gt;<br/>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#sort-java.util.List-">sort</a></span>(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt; list)</code>
<div class="block">
<span>根据其元素的<a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a>对指定的列表进行排序。</span>
</div> </td>
</tr>
<tr class="altColor" id="i48">
<td class="colFirst"><code>static &lt;T&gt; void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#sort-java.util.List-java.util.Comparator-">sort</a></span>(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt; list, <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; c)</code>
<div class="block">
              根据指定的比较器引起的顺序对指定的列表进行排序。 
            </div> </td>
</tr>
<tr class="rowColor" id="i49">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#swap-java.util.List-int-int-">swap</a></span>(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; list, int i, int j)</code>
<div class="block">
              交换指定列表中指定位置的元素。 
            </div> </td>
</tr>
<tr class="altColor" id="i50">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#synchronizedCollection-java.util.Collection-">synchronizedCollection</a></span>(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;T&gt; c)</code>
<div class="block">
              返回由指定集合支持的同步（线程安全）集合。 
            </div> </td>
</tr>
<tr class="rowColor" id="i51">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#synchronizedList-java.util.List-">synchronizedList</a></span>(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt; list)</code>
<div class="block">
              返回由指定列表支持的同步（线程安全）列表。 
            </div> </td>
</tr>
<tr class="altColor" id="i52">
<td class="colFirst"><code>static &lt;K,V&gt; <a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#synchronizedMap-java.util.Map-">synchronizedMap</a></span>(<a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,V&gt; m)</code>
<div class="block">
              返回由指定地图支持的同步（线程安全）映射。 
            </div> </td>
</tr>
<tr class="rowColor" id="i53">
<td class="colFirst"><code>static &lt;K,V&gt; <a href="../../java/util/NavigableMap.html" title="interface in java.util">NavigableMap</a>&lt;K,V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#synchronizedNavigableMap-java.util.NavigableMap-">synchronizedNavigableMap</a></span>(<a href="../../java/util/NavigableMap.html" title="interface in java.util">NavigableMap</a>&lt;K,V&gt; m)</code>
<div class="block">
              返回由指定的可导航地图支持的同步（线程安全）可导航地图。 
            </div> </td>
</tr>
<tr class="altColor" id="i54">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/NavigableSet.html" title="interface in java.util">NavigableSet</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#synchronizedNavigableSet-java.util.NavigableSet-">synchronizedNavigableSet</a></span>(<a href="../../java/util/NavigableSet.html" title="interface in java.util">NavigableSet</a>&lt;T&gt; s)</code>
<div class="block">
              返回由指定的可导航集支持的同步（线程安全）可导航集。 
            </div> </td>
</tr>
<tr class="rowColor" id="i55">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#synchronizedSet-java.util.Set-">synchronizedSet</a></span>(<a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;T&gt; s)</code>
<div class="block">
              返回由指定集合支持的同步（线程安全）集。 
            </div> </td>
</tr>
<tr class="altColor" id="i56">
<td class="colFirst"><code>static &lt;K,V&gt; <a href="../../java/util/SortedMap.html" title="interface in java.util">SortedMap</a>&lt;K,V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#synchronizedSortedMap-java.util.SortedMap-">synchronizedSortedMap</a></span>(<a href="../../java/util/SortedMap.html" title="interface in java.util">SortedMap</a>&lt;K,V&gt; m)</code>
<div class="block">
              返回由指定的排序映射支持的同步（线程安全）排序映射。 
            </div> </td>
</tr>
<tr class="rowColor" id="i57">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/SortedSet.html" title="interface in java.util">SortedSet</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#synchronizedSortedSet-java.util.SortedSet-">synchronizedSortedSet</a></span>(<a href="../../java/util/SortedSet.html" title="interface in java.util">SortedSet</a>&lt;T&gt; s)</code>
<div class="block">
              返回由指定的排序集支持的同步（线程安全）排序集。 
            </div> </td>
</tr>
<tr class="altColor" id="i58">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#unmodifiableCollection-java.util.Collection-">unmodifiableCollection</a></span>(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;? extends T&gt; c)</code>
<div class="block">
              返回指定集合的不可修改视图。 
            </div> </td>
</tr>
<tr class="rowColor" id="i59">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#unmodifiableList-java.util.List-">unmodifiableList</a></span>(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;? extends T&gt; list)</code>
<div class="block">
              返回指定列表的不可修改视图。 
            </div> </td>
</tr>
<tr class="altColor" id="i60">
<td class="colFirst"><code>static &lt;K,V&gt; <a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#unmodifiableMap-java.util.Map-">unmodifiableMap</a></span>(<a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;? extends K,? extends V&gt; m)</code>
<div class="block">
              返回指定地图的不可修改视图。 
            </div> </td>
</tr>
<tr class="rowColor" id="i61">
<td class="colFirst"><code>static &lt;K,V&gt; <a href="../../java/util/NavigableMap.html" title="interface in java.util">NavigableMap</a>&lt;K,V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#unmodifiableNavigableMap-java.util.NavigableMap-">unmodifiableNavigableMap</a></span>(<a href="../../java/util/NavigableMap.html" title="interface in java.util">NavigableMap</a>&lt;K,? extends V&gt; m)</code>
<div class="block">
              返回指定可导航地图的不可修改视图。 
            </div> </td>
</tr>
<tr class="altColor" id="i62">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/NavigableSet.html" title="interface in java.util">NavigableSet</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#unmodifiableNavigableSet-java.util.NavigableSet-">unmodifiableNavigableSet</a></span>(<a href="../../java/util/NavigableSet.html" title="interface in java.util">NavigableSet</a>&lt;T&gt; s)</code>
<div class="block">
              返回指定的可导航集合的不可修改的视图。 
            </div> </td>
</tr>
<tr class="rowColor" id="i63">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#unmodifiableSet-java.util.Set-">unmodifiableSet</a></span>(<a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;? extends T&gt; s)</code>
<div class="block">
              返回指定集合的不可修改视图。 
            </div> </td>
</tr>
<tr class="altColor" id="i64">
<td class="colFirst"><code>static &lt;K,V&gt; <a href="../../java/util/SortedMap.html" title="interface in java.util">SortedMap</a>&lt;K,V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#unmodifiableSortedMap-java.util.SortedMap-">unmodifiableSortedMap</a></span>(<a href="../../java/util/SortedMap.html" title="interface in java.util">SortedMap</a>&lt;K,? extends V&gt; m)</code>
<div class="block">
              返回指定排序映射的不可修改视图。 
            </div> </td>
</tr>
<tr class="rowColor" id="i65">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/SortedSet.html" title="interface in java.util">SortedSet</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Collections.html#unmodifiableSortedSet-java.util.SortedSet-">unmodifiableSortedSet</a></span>(<a href="../../java/util/SortedSet.html" title="interface in java.util">SortedSet</a>&lt;T&gt; s)</code>
<div class="block">
              返回指定排序集的不可修改视图。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../java/lang/Object.html#clone--">clone</a>, <a href="../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../java/lang/Object.html#notify--">notify</a>, <a href="../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../java/lang/Object.html#toString--">toString</a>, <a href="../../java/lang/Object.html#wait--">wait</a>, <a href="../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!-- --> </a> <h3>字段详细信息</h3> <a name="EMPTY_SET">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>EMPTY_SET</h4> <pre>public static final <a href="../../java/util/Set.html" title="interface in java.util">Set</a> EMPTY_SET</pre>
<div class="block">
<span>空集（不可变）。</span>
<span>这个集是可序列化的。</span>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/util/Collections.html#emptySet--"><code>emptySet()</code></a>
</dd>
</dl> </li>
</ul> <a name="EMPTY_LIST">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>EMPTY_LIST</h4> <pre>public static final <a href="../../java/util/List.html" title="interface in java.util">List</a> EMPTY_LIST</pre>
<div class="block">
<span>空列表（不可变）。</span>
<span>此列表是可序列化的。</span>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/util/Collections.html#emptyList--"><code>emptyList()</code></a>
</dd>
</dl> </li>
</ul> <a name="EMPTY_MAP">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>EMPTY_MAP</h4> <pre>public static final <a href="../../java/util/Map.html" title="interface in java.util">Map</a> EMPTY_MAP</pre>
<div class="block">
<span>空地图（immutable）。</span>
<span>这张地图是可序列化的。</span>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.3 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/util/Collections.html#emptyMap--"><code>emptyMap()</code></a>
</dd>
</dl> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="sort-java.util.List-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static &lt;T extends <a href="../../java/lang/Comparable.html" title="interface in java.lang">Comparable</a>&lt;? super T&gt;&gt; void sort(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt; list)</pre>
<div class="block">
<span>根据其元素的<a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a> ，按照升序排列指定的列表。</span>
<span>列表中的所有元素必须实现<a href="../../java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a>接口。</span>
<span>此外，列表中的所有元素都必须<i>相互可比较</i> （即<code>e1.compareTo(e2)</code>不能为<code>ClassCastException</code>中的任何元素<code>e1</code>和<code>e2</code> ）。</span>
<p> <span>这种保证是<i>稳定的</i> ：等同的元素将不会被排序作为排序的结果。</span> </p>
<p> <span>指定的列表必须是可修改的，但不能调整大小。</span> </p>
<p> <span>实现注意事项：这个实现是一个稳定的，自适应的，迭代的mergeesort，当输入数组被部分排序时，需要比n lg（n）的比较少得多，同时在输入数组被随机排列时提供传统的mergeesort的性能。</span> <span>如果输入数组几乎被排序，则实现需要大致n个比较。</span> <span>临时存储要求从几乎排序的输入数组的小常数到随机排序的输入数组的n / 2对象引用。</span> </p>
<p> <span>该实现在其输入数组中具有上升和下降的同等优势，并且可以在同一输入数组的不同部分中利用升序和降序。</span> <span>它非常适合合并两个或多个排序的数组：简单地连接数组并排序生成的数组。</span> </p>
<p> <span>实施从Tim Peters的Python列表排序（ <a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">TimSort</a> ）进行了<a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">改编</a> 。</span> <span>它使用Peter McIlroy的“乐观排序和信息理论复杂性”中的技术，在第四届ACM-SIAM离散算法研讨会论文集，pp 467-474，1993年1月。</span> </p>
<p> <span>该实现将指定的列表转储到数组中，对数组进行排序，并在列表中迭代，从列表中的相应位置重新设置每个元素。</span> <span>这样可以避免尝试将链表排序到目前为止的n <sup>2</sup> log（n）性能。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 列表中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>list</code> - 要排序的列表。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果列表包含不 
            <i>相互比较的元素</i> （例如，字符串和整数）。 
           </dd>
<dd>
<code><a href="../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果指定列表的list-iterator不支持 
            <code>set</code>操作。 
           </dd>
<dd>
<span><code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - （可选）如果实现检测到发现列表元素的自然排序违反了<a href="../../java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a>合同</span>
</dd>
</dl> </li>
</ul> <a name="sort-java.util.List-java.util.Comparator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static &lt;T&gt; void sort(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt; list,
                            <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; c)</pre>
<div class="block">
<span>根据指定的比较器引起的顺序对指定的列表进行排序。</span>
<span>列表中的所有元素必须使用指定的比较器<i>相互比较</i> （即， <code>c.compare(e1, e2)</code>不能为<code>ClassCastException</code>中的任何元素<code>e1</code>和<code>e2</code> ）。</span>
<p> <span>这种保证是<i>稳定的</i> ：等同的元素将不会被排序作为排序的结果。</span> </p>
<p> <span>指定的列表必须是可修改的，但不能调整大小。</span> </p>
<p> <span>实现注意事项：这个实现是一个稳定的，自适应的，迭代的mergeesort，当输入数组被部分排序时，需要比n lg（n）的比较少得多，同时在输入数组被随机排列时提供传统的mergeesort的性能。</span> <span>如果输入数组几乎被排序，则实现需要大致n个比较。</span> <span>临时存储要求从几乎排序的输入数组的小常数到随机排序的输入数组的n / 2对象引用。</span> </p>
<p> <span>该实现在其输入数组中具有上升和下降的同等优势，并且可以在同一输入数组的不同部分中利用升序和降序。</span> <span>它非常适合合并两个或多个排序的数组：简单地连接数组并排序生成的数组。</span> </p>
<p> <span>该实现从Tim Peters的Python列表（ <a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">TimSort</a> ）进行了<a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">改编</a> 。</span> <span>它使用Peter McIlroy的“乐观排序和信息理论复杂性”中的技术，在第四届ACM-SIAM离散算法研讨会论文集，pp 467-474，1993年1月。</span> </p>
<p> <span>该实现将指定的列表转储到数组中，对数组进行排序，并在列表中迭代，从列表中的相应位置重新设置每个元素。</span> <span>这样可以避免尝试将链表排序到目前为止的n <sup>2</sup> log（n）性能。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 列表中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>list</code> - 要排序的列表。 
           </dd>
<dd>
<span><code>c</code> - 比较器来确定列表的顺序。</span>
<span>一个<code>null</code>值表示元素的<i>自然排序</i>应该被使用。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果列表包含使用指定的比较器不 
            <i>相互比较</i>的元素。 
           </dd>
<dd>
<code><a href="../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果指定的列表的list-iterator不支持 
            <code>set</code>操作。 
           </dd>
<dd>
<span><code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - （可选）如果比较方发现违反<a href="../../java/util/Comparator.html" title="java.util中的接口"><code>Comparator</code></a>合同</span>
</dd>
</dl> </li>
</ul> <a name="binarySearch-java.util.List-java.lang.Object-">
<!-- --> </a><a name="binarySearch-java.util.List-T-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static &lt;T&gt; int binarySearch(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;? extends <a href="../../java/lang/Comparable.html" title="interface in java.lang">Comparable</a>&lt;? super T&gt;&gt; list,
                                   T key)</pre>
<div class="block">
<span>使用二叉搜索算法搜索指定对象的指定列表。</span>
<span>该列表必须根据被按升序排列<a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a>元素（如由<a href="../../java/util/Collections.html#sort-java.util.List-"><code>sort(List)</code></a>方法）之前使该呼叫。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>如果列表包含与指定对象相等的多个元素，则不能保证将找到哪个元素。</span>
<p> <span>该方法以log（n）时间运行“随机访问”列表（提供近常数位置访问）。</span> <span>如果指定的列表没有实现<a href="../../java/util/RandomAccess.html" title="java.util中的接口"><code>RandomAccess</code></a>接口并且很大，则该方法将执行基于迭代器的二进制搜索，执行O（n）链接遍历和O（log n）元素比较。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 列表中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>list</code> - 要搜索的列表。 
           </dd>
<dd>
<code>key</code> - 要搜索的关键。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索关键字的索引，如果它包含在列表中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果列表中的所有元素都小于指定键的第一元件比所述键时，或<tt>list.size()</tt>的索引： <i>插入点</i>被定义为将键插入到列表中的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果列表包含不 
            <i>相互比较的元素</i> （例如，字符串和整数），或者搜索关键字与列表的元素不能相互比较。 
           </dd>
</dl> </li>
</ul> <a name="binarySearch-java.util.List-java.lang.Object-java.util.Comparator-">
<!-- --> </a><a name="binarySearch-java.util.List-T-java.util.Comparator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static &lt;T&gt; int binarySearch(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;? extends T&gt; list,
                                   T key,
                                   <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; c)</pre>
<div class="block">
<span>使用二叉搜索算法搜索指定对象的指定列表。</span>
<span>在进行此呼叫之前，列表必须根据指定的比较器（如<a href="../../java/util/Collections.html#sort-java.util.List-java.util.Comparator-"><code>sort(List, Comparator)</code></a>方法）按升序排序。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>如果列表包含与指定对象相等的多个元素，则不能保证将找到哪个元素。</span>
<p> <span>该方法以log（n）时间运行“随机访问”列表（提供近常数位置访问）。</span> <span>如果指定的列表没有实现<a href="../../java/util/RandomAccess.html" title="java.util中的接口"><code>RandomAccess</code></a>接口并且很大，则该方法将执行基于迭代器的二进制搜索，执行O（n）链接遍历和O（log n）元素比较。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 列表中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>list</code> - 要搜索的列表。 
           </dd>
<dd>
<code>key</code> - 要搜索的关键。 
           </dd>
<dd>
<span><code>c</code> - 排序列表的比较器。</span>
<span>A <tt>null</tt>值表示应使用元素' <a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a> '。</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索关键字的索引，如果它包含在列表中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果列表中的所有元素都小于指定键的第一元件比所述键时，或<tt>list.size()</tt>的索引： <i>插入点</i>被定义为将键插入到列表中的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> -如果列表中包含使用指定的比较器不可 
            <i>相互比较的</i>元素，或者检索关键字是不使用此比较的列表的元素相互比较。 
           </dd>
</dl> </li>
</ul> <a name="reverse-java.util.List-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>reverse</h4> <pre>public static void reverse(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; list)</pre>
<div class="block">
<span>反转指定列表中元素的顺序。</span>
<p> <span>该方法运行在线性时间。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>list</code> - 要反转其元素的列表。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果指定的列表或其列表迭代器不支持 
            <tt>set</tt>操作。 
           </dd>
</dl> </li>
</ul> <a name="shuffle-java.util.List-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>shuffle</h4> <pre>public static void shuffle(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; list)</pre>
<div class="block">
<span>使用默认的随机源随机排列指定的列表。</span>
<span>所有排列都以大致相等的可能性发生。</span>
<p> <span>在前面的描述中使用了“大约”对冲，因为默认的随机源仅仅是独立选择的比特的无偏差源。</span> <span>如果它是随机选择位的完美来源，则算法将选择具有完美均匀性的排列。</span> </p>
<p> <span>该实现从最后一个元素向后移动列表，重复地将随机选择的元素交换到“当前位置”中。</span> <span>从从第一个元素运行到当前位置（包括）的列表的部分中随机选择元素。</span> </p>
<p> <span>该方法运行在线性时间。</span> <span>如果指定的列表没有实现<a href="../../java/util/RandomAccess.html" title="java.util中的接口"><code>RandomAccess</code></a>接口并且很大，则此实现将混合之前将指定的列表转储到数组中，并将该混洗的数组转储回列表中。</span> <span>这避免了将“顺序访问”列表进行混洗所产生的二次行为。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>list</code> - 要洗牌的列表。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果指定的列表或其列表迭代器不支持 
            <tt>set</tt>操作。 
           </dd>
</dl> </li>
</ul> <a name="shuffle-java.util.List-java.util.Random-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>shuffle</h4> <pre>public static void shuffle(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; list,
                           <a href="../../java/util/Random.html" title="class in java.util">Random</a> rnd)</pre>
<div class="block">
<span>使用指定的随机源随机排列指定的列表。</span>
<span>如果随机性的来源是公平的，则所有排列都以相等的可能性发生。</span>
<p> <span>该实现从最后一个元素向后移动列表，重复地将随机选择的元素交换到“当前位置”中。</span> <span>从从第一个元素运行到当前位置（包括）的列表的部分中随机选择元素。</span> </p>
<p> <span>该方法运行在线性时间。</span> <span>如果指定的列表没有实现<a href="../../java/util/RandomAccess.html" title="java.util中的接口"><code>RandomAccess</code></a>接口，并且很大，那么这个实现会将指定的列表转储到数组中，然后再进行混洗，然后将该混洗后的数组转储回列表中。</span> <span>这避免了将“顺序访问”列表进行混洗所产生的二次行为。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>list</code> - 要洗牌的列表。 
           </dd>
<dd>
<code>rnd</code> - 用于随机播放列表的随机源。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果指定的列表或其列表迭代器不支持 
            <tt>set</tt>操作。 
           </dd>
</dl> </li>
</ul> <a name="swap-java.util.List-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>swap</h4> <pre>public static void swap(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; list,
                        int i,
                        int j)</pre>
<div class="block">
<span>交换指定列表中指定位置的元素。</span>
<span>（如果指定的位置相等，调用此方法将保持不变。）</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>list</code> - 交换元素的列表。 
           </dd>
<dd>
<code>i</code> - 要交换的一个元素的索引。 
           </dd>
<dd>
<code>j</code> - 要交换的其他元素的索引。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - 如果 
            <tt>i</tt>或 
            <tt>j</tt>超出范围（i &lt;0 || i&gt; = list.size（）|| j &lt;0 || j&gt; = list.size（））。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
</dl> </li>
</ul> <a name="fill-java.util.List-java.lang.Object-">
<!-- --> </a><a name="fill-java.util.List-T-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fill</h4> <pre>public static &lt;T&gt; void fill(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;? super T&gt; list,
                            T obj)</pre>
<div class="block">
<span>用指定的元素代替指定列表的所有元素。</span>
<p> <span>该方法运行在线性时间。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 列表中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>list</code> - 要填充指定元素的列表。 
           </dd>
<dd>
<code>obj</code> - 用于填充指定列表的元素。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果指定的列表或其列表迭代器不支持 
            <tt>set</tt>操作。 
           </dd>
</dl> </li>
</ul> <a name="copy-java.util.List-java.util.List-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copy</h4> <pre>public static &lt;T&gt; void copy(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;? super T&gt; dest,
                            <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;? extends T&gt; src)</pre>
<div class="block">
<span>将所有元素从一个列表复制到另一个列表中。</span>
<span>操作完成后，目标列表中每个复制元素的索引将与源列表中的其索引相同。</span>
<span>目的地列表必须至少与源列表一样长。</span>
<span>如果它更长，则目的地列表中的剩余元素不受影响。</span>
<p> <span>该方法运行在线性时间。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 列表中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>dest</code> - 目的地列表。 
           </dd>
<dd>
<code>src</code> - 源列表。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - 如果目的地列表太小，不能包含整个源列表。 
           </dd>
<dd>
<code><a href="../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果目标列表的list-iterator不支持 
            <tt>set</tt>操作。 
           </dd>
</dl> </li>
</ul> <a name="min-java.util.Collection-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>min</h4> <pre>public static &lt;T extends <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> &amp; <a href="../../java/lang/Comparable.html" title="interface in java.lang">Comparable</a>&lt;? super T&gt;&gt; T min(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;? extends T&gt; coll)</pre>
<div class="block">
<span>根据其元素的<i>自然顺序</i>返回给定集合的最小元素。</span>
<span>集合中的所有元素必须实现<tt>Comparable</tt>界面。</span>
<span>此外，集合中的所有元素必须<i>相互可比较</i> （即， <tt>e1.compareTo(e2)</tt>不得为<tt>集合</tt>中的任何元素<tt>e1</tt>和<tt>e2</tt>提供ClassCastException）。</span>
<p> <span>该方法遍历整个集合，因此它需要与集合的大小成比例的时间。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 集合中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>coll</code> - 要确定其最小元素的集合。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             根据其元素的 
            <i>自然顺序</i> ，给定集合的最小元素。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果集合包含不 
            <i>相互比较的元素</i> （例如字符串和整数）。 
           </dd>
<dd>
<code><a href="../../java/util/NoSuchElementException.html" title="class in java.util">NoSuchElementException</a></code> - 如果集合为空。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a></span>
</dd>
</dl> </li>
</ul> <a name="min-java.util.Collection-java.util.Comparator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>min</h4> <pre>public static &lt;T&gt; T min(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;? extends T&gt; coll,
                        <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; comp)</pre>
<div class="block">
<span>根据指定的比较器引发的顺序返回给定集合的最小元素。</span>
<span>集合中的所有元素必须由指定的比较器<i>相互比较</i> （即， <tt>comp.compare(e1, e2)</tt>不得为<tt>集合</tt>中的任何元素<tt>e1</tt>和<tt>e2</tt>引发ClassCastException）。</span>
<p> <span>该方法遍历整个集合，因此它需要与集合的大小成比例的时间。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 集合中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>coll</code> - 要确定其最小元素的集合。 
           </dd>
<dd>
<span><code>comp</code> - 用于确定最小元素的比较器。</span>
<span>甲<tt>null</tt>值表示元素的<i>自然顺序</i>应该被使用。</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             根据指定的比较器，给定集合的最小元素。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果集合包含使用指定比较器不 
            <i>相互比较</i>的元素。 
           </dd>
<dd>
<code><a href="../../java/util/NoSuchElementException.html" title="class in java.util">NoSuchElementException</a></code> - 如果集合为空。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a></span>
</dd>
</dl> </li>
</ul> <a name="max-java.util.Collection-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>max</h4> <pre>public static &lt;T extends <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> &amp; <a href="../../java/lang/Comparable.html" title="interface in java.lang">Comparable</a>&lt;? super T&gt;&gt; T max(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;? extends T&gt; coll)</pre>
<div class="block">
<span>根据其元素的<i>自然顺序</i>返回给定集合的最大元素。</span>
<span>集合中的所有元素必须实现<tt>Comparable</tt>接口。</span>
<span>此外，集合中的所有元素必须<i>相互可比较</i> （即<tt>e1.compareTo(e2)</tt>不得为<tt>集合</tt>中的任何元素<tt>e1</tt>和<tt>e2</tt>投掷ClassCastException）。</span>
<p> <span>该方法遍历整个集合，因此它需要与集合的大小成比例的时间。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 集合中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>coll</code> - 要确定其最大元素的集合。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             根据其元素的 
            <i>自然排序</i> ，给定集合的最大元素。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果集合包含不 
            <i>相互比较的元素</i> （例如，字符串和整数）。 
           </dd>
<dd>
<code><a href="../../java/util/NoSuchElementException.html" title="class in java.util">NoSuchElementException</a></code> - 如果集合为空。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a></span>
</dd>
</dl> </li>
</ul> <a name="max-java.util.Collection-java.util.Comparator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>max</h4> <pre>public static &lt;T&gt; T max(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;? extends T&gt; coll,
                        <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; comp)</pre>
<div class="block">
<span>根据指定的比较器引发的顺序返回给定集合的最大元素。</span>
<span>集合中的所有元素必须由指定的比较器<i>相互比较</i> （即， <tt>comp.compare(e1, e2)</tt>不得为<tt>集合</tt>中的任何元素<tt>e1</tt>和<tt>e2</tt>投放ClassCastException）。</span>
<p> <span>该方法遍历整个集合，因此它需要与集合的大小成比例的时间。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 集合中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>coll</code> - 要确定其最大元素的集合。 
           </dd>
<dd>
<span><code>comp</code> - 用于确定最大元素的比较器。</span>
<span>一个<tt>null</tt>值表示应该使用元素的<i>自然排序</i> 。</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             给定集合的最大元素，根据指定的比较器。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果集合包含使用指定的比较器不 
            <i>相互比较</i>的元素。 
           </dd>
<dd>
<code><a href="../../java/util/NoSuchElementException.html" title="class in java.util">NoSuchElementException</a></code> - 如果集合为空。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a></span>
</dd>
</dl> </li>
</ul> <a name="rotate-java.util.List-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>rotate</h4> <pre>public static void rotate(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; list,
                          int distance)</pre>
<div class="block">
<span>将指定列表中的元素旋转指定的距离。</span>
<span>调用此方法后，在索引<tt>i</tt>的元件将是元件预先在索引<tt>(i - distance)</tt> <tt>list.size()</tt> MOD，用于<tt>0</tt>和<tt>list.size()-1（</tt>含）之间的<tt>i</tt>所有值。</span>
<span>（此方法对列表的大小没有影响。）</span>
<p> <span>例如，假设<tt>list</tt>包括<tt>[t, a, n, k, s]</tt> 。</span> <span>在调用<tt>Collections.rotate(list, 1)</tt> （或<tt>Collections.rotate(list, -4)</tt> ）后， <tt>list</tt>将包括<tt>[s, t, a, n, k]</tt> 。</span> </p>
<p> <span>请注意，该方法可以有效地应用于子列表以移动列表中的一个或多个元素，同时保留剩余元素的顺序。</span> <span>例如，以下成语将索引<tt>j</tt>处的元素向前移动到位置<tt>k</tt> （必须大于或等于<tt>j</tt> ）：</span> </p>
<pre>  <span>Collections.rotate(list.subList(j, k+1), -1);</span> </pre>
<span>为了使这个具体，假设<tt>list</tt>包括<tt>[a, b, c, d, e]</tt> 。</span>
<span>要将索引<tt>1</tt> （ <tt>b</tt> ）上的元素向前移动两个位置，请执行以下调用：</span>
<pre>  <span>Collections.rotate(l.subList(1, 4), -1);</span> </pre>
<span>得到的列表是<tt>[a, c, d, b, e]</tt> 。</span>
<p> <span>要向前移动多个元素，请增加旋转距离的绝对值。</span> <span>要向后移动元素，请使用正移位距离。</span> </p>
<p> <span>如果指定的列表较小或实现了<a href="../../java/util/RandomAccess.html" title="java.util中的接口"><code>RandomAccess</code></a>接口，则该实现将第一个元素交换到应该进行的位置，然后重复地将移位的元素交换到应该进行的位置，直到被替换的元素被交换到第一个元素中。</span> <span>如果需要，在第二和连续元件上重复该过程，直到旋转完成。</span> <span>如果指定的列表很大并且没有实现<tt>RandomAccess</tt>接口，则该实现将列表分成索引<tt>-distance mod size</tt>周围的两个子列表视图。</span> <span>然后在每个子列表视图中调用<a href="../../java/util/Collections.html#reverse-java.util.List-"><code>reverse(List)</code></a>方法，最后在整个列表中调用它。</span> <span>有关这两种算法的更完整的描述，请参见Jon Bentley <i>编程珍珠的</i>第2.3节（Addison-Wesley，1986）。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>list</code> - 要旋转的列表。 
           </dd>
<dd>
<span><code>distance</code> - 旋转列表的距离。</span>
<span>这个价值没有约束;</span>
<span>它可能为零，负或大于<tt>list.size()</tt> 。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果指定的列表或其列表迭代器不支持 
            <tt>set</tt>操作。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
</dl> </li>
</ul> <a name="replaceAll-java.util.List-java.lang.Object-java.lang.Object-">
<!-- --> </a><a name="replaceAll-java.util.List-T-T-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>replaceAll</h4> <pre>public static &lt;T&gt; boolean replaceAll(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt; list,
                                     T oldVal,
                                     T newVal)</pre>
<div class="block">
<span>将列表中一个指定值的所有出现替换为另一个。</span>
<span>更正式地，替换<tt>newVal</tt>每个元素<tt>e</tt>在<tt>list</tt> ，使<tt>(oldVal==null ? e==null : oldVal.equals(e))</tt> 。</span>
<span>（此方法对列表的大小没有影响。）</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 列表中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>list</code> - 要 
            <code>list</code>的列表。 
           </dd>
<dd>
<code>oldVal</code> - 要替换的旧值。 
           </dd>
<dd>
<code>newVal</code> - 要替换 
            <tt>oldVal</tt>的新值。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<tt>true</tt>如果 
            <tt>list</tt>包含一个或多个元素 
            <tt>e</tt> ，使得 
            <tt>(oldVal==null ? e==null : oldVal.equals(e))</tt> 。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果指定的列表或其列表迭代器不支持 
            <tt>set</tt>操作。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
</dl> </li>
</ul> <a name="indexOfSubList-java.util.List-java.util.List-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>indexOfSubList</h4> <pre>public static int indexOfSubList(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; source,
                                 <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; target)</pre>
<div class="block">
<span>返回指定源列表中指定目标列表的第一次出现的起始位置，如果没有此类事件，则返回-1。</span>
<span>更正式地，返回最低指数<tt>i</tt> ，使<code>source.subList(i, i+target.size()).equals(target)</code> ，或-1如果没有这样的索引。</span>
<span>（如果<code>target.size() &gt; source.size()</code>则返回-1）</span>
<p> <span>该实现使用扫描源列表的“强力”技术，依次寻找与目标的匹配。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>source</code> - 搜索第一次发生的 
            <tt>列表target</tt> 。 
           </dd>
<dd>
<code>target</code> -列表搜索为 
            <tt>source</tt>子列表。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             在指定源列表中首次出现指定目标列表的起始位置，如果没有此类事件，则为-1。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
</dl> </li>
</ul> <a name="lastIndexOfSubList-java.util.List-java.util.List-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>lastIndexOfSubList</h4> <pre>public static int lastIndexOfSubList(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; source,
                                     <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt; target)</pre>
<div class="block">
<span>返回指定源列表中指定目标列表的最后一次出现的起始位置，如果没有此类事件则返回-1。</span>
<span>更正式地，返回最高指数<tt>i</tt> ，使<code>source.subList(i, i+target.size()).equals(target)</code> ，或-1如果没有这样的索引。</span>
<span>（如果<code>target.size() &gt; source.size()</code>返回-1）</span>
<p> <span>该实现使用在源列表上迭代的“强力”技术，依次查找每个位置上的目标匹配。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>source</code> - 搜索最后一次发生的 
            <tt>列表target</tt> 。 
           </dd>
<dd>
<code>target</code> -列表搜索为 
            <tt>source</tt>子列表。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定源列表中指定目标列表的最后一次出现的起始位置，如果没有此类事件，则为-1。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
</dl> </li>
</ul> <a name="unmodifiableCollection-java.util.Collection-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmodifiableCollection</h4> <pre>public static &lt;T&gt; <a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;T&gt; unmodifiableCollection(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;? extends T&gt; c)</pre>
<div class="block">
<span>返回指定集合的不可修改视图。</span>
<span>该方法允许模块向用户提供对内部集合的“只读”访问。</span>
<span>对返回的集合“读取”查询操作到指定的集合，并尝试修改返回的集合，无论是直接还是通过其迭代器，导致<tt>UnsupportedOperationException</tt> 。</span>
<p> <span>返回的集合<i>不会</i>通过hashCode并将操作等同于后台集合，而是依赖于<tt>Object</tt>的<tt>equals</tt>和<tt>hashCode</tt>方法。</span> <span>在后台集合是集合或列表的情况下，必须保留这些操作的合同。</span> </p>
<p> <span>如果指定的集合是可序列化的，则返回的集合将是可序列化的。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 集合中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>c</code> - 要返回不可修改的视图的集合。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定集合的不可修改视图。 
           </dd>
</dl> </li>
</ul> <a name="unmodifiableSet-java.util.Set-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmodifiableSet</h4> <pre>public static &lt;T&gt; <a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;T&gt; unmodifiableSet(<a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;? extends T&gt; s)</pre>
<div class="block">
<span>返回指定集合的不可修改视图。</span>
<span>该方法允许模块向用户提供对内部集的“只读”访问。</span>
<span>对返回的集合“读取”查询操作到指定的集合，并尝试修改返回的集合，无论是直接还是通过其迭代器，导致<tt>UnsupportedOperationException</tt> 。</span>
<p> <span>如果指定的集合是可序列化的，则返回的集合将是可序列化的。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 集合中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>s</code> - 要为其返回不可修改的视图的集合。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定集合的不可修改视图。 
           </dd>
</dl> </li>
</ul> <a name="unmodifiableSortedSet-java.util.SortedSet-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmodifiableSortedSet</h4> <pre>public static &lt;T&gt; <a href="../../java/util/SortedSet.html" title="interface in java.util">SortedSet</a>&lt;T&gt; unmodifiableSortedSet(<a href="../../java/util/SortedSet.html" title="interface in java.util">SortedSet</a>&lt;T&gt; s)</pre>
<div class="block">
<span>返回指定排序集的不可修改视图。</span>
<span>该方法允许模块向用户提供对内部排序集的“只读”访问。</span>
<span>对返回的排序集查询操作“读取”到指定的排序集。</span>
<span>试图修改返回的有序集合，无论是直接的，通过其迭代器，或通过其<tt><tt>subSet，headSet，</tt></tt>或<tt>tailSet</tt>意见，导致<tt>UnsupportedOperationException。</tt></span>
<p> <span>如果指定的排序集是可序列化的，则返回的排序集将是可序列化的。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 集合中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>s</code> - 要为其返回不可修改视图的排序集。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定排序集的不可修改视图。 
           </dd>
</dl> </li>
</ul> <a name="unmodifiableNavigableSet-java.util.NavigableSet-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmodifiableNavigableSet</h4> <pre>public static &lt;T&gt; <a href="../../java/util/NavigableSet.html" title="interface in java.util">NavigableSet</a>&lt;T&gt; unmodifiableNavigableSet(<a href="../../java/util/NavigableSet.html" title="interface in java.util">NavigableSet</a>&lt;T&gt; s)</pre>
<div class="block">
<span>返回指定的可导航集合的不可修改的视图。</span>
<span>这种方法允许模块向用户提供对内部导航集的“只读”访问。</span>
<span>对返回的导航集“查阅”查询操作到指定的导航集。</span>
<span>试图修改返回的导航set，不管是直接的，通过其迭代器，或通过其<code>subSet</code> ， <code>headSet</code> ，或<code>tailSet</code>意见，导致<code>UnsupportedOperationException</code> 。</span>
<p> <span>如果指定的导航集是可序列化的，返回的导航集将是可序列化的。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 集合中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>s</code> - 要返回不可修改的视图的导航集 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定导航集的不可修改的视图 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="unmodifiableList-java.util.List-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmodifiableList</h4> <pre>public static &lt;T&gt; <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt; unmodifiableList(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;? extends T&gt; list)</pre>
<div class="block">
<span>返回指定列表的不可修改视图。</span>
<span>该方法允许模块向用户提供对内部列表的“只读”访问。</span>
<span>将返回的列表上的查询操作“读取”到指定的列表，并尝试修改返回的列表，无论是直接还是通过其迭代器， <tt>都会</tt>导致<tt>UnsupportedOperationException</tt> 。</span>
<p> <span>如果指定的列表是可序列化的，则返回的列表将是可序列化的。</span> <span>类似地，如果指定的列表，返回的列表将实现<a href="../../java/util/RandomAccess.html" title="java.util中的接口"><code>RandomAccess</code></a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 列表中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>list</code> - 要返回不可修改视图的列表。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定列表的不可修改的视图。 
           </dd>
</dl> </li>
</ul> <a name="unmodifiableMap-java.util.Map-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmodifiableMap</h4> <pre>public static &lt;K,V&gt; <a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,V&gt; unmodifiableMap(<a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;? extends K,? extends V&gt; m)</pre>
<div class="block">
<span>返回指定地图的不可修改视图。</span>
<span>该方法允许模块向用户提供对内部地图的“只读”访问。</span>
<span>在返回的地图上查询操作“读取”到指定的地图，并尝试修改返回的地图，无论是直接还是通过其集合视图，都会导致<tt>UnsupportedOperationException</tt> 。</span>
<p> <span>如果指定的地图是可序列化的，返回的地图将是可序列化的。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>K</code> - 地图键的类 
           </dd>
<dd>
<code>V</code> - 地图值的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>m</code> - 要返回不可修改视图的地图。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定地图的不可修改视图。 
           </dd>
</dl> </li>
</ul> <a name="unmodifiableSortedMap-java.util.SortedMap-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmodifiableSortedMap</h4> <pre>public static &lt;K,V&gt; <a href="../../java/util/SortedMap.html" title="interface in java.util">SortedMap</a>&lt;K,V&gt; unmodifiableSortedMap(<a href="../../java/util/SortedMap.html" title="interface in java.util">SortedMap</a>&lt;K,? extends V&gt; m)</pre>
<div class="block">
<span>返回指定排序映射的不可修改视图。</span>
<span>该方法允许模块向用户提供对内部排序映射的“只读”访问。</span>
<span>对返回的排序映射查询操作“读取”到指定的排序映射。</span>
<span>试图修改返回的有序映射，无论是直接的，通过其收集的意见，或通过其<tt><tt>subMap，headMap，</tt></tt>或<tt>tailMap</tt>意见，导致<tt>UnsupportedOperationException。</tt></span>
<p> <span>如果指定的排序映射是可序列化的，返回的排序映射将是可序列化的。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>K</code> - 地图键的类 
           </dd>
<dd>
<code>V</code> - 地图值的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>m</code> - 要返回不可修改视图的排序映射。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定排序地图的不可修改视图。 
           </dd>
</dl> </li>
</ul> <a name="unmodifiableNavigableMap-java.util.NavigableMap-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmodifiableNavigableMap</h4> <pre>public static &lt;K,V&gt; <a href="../../java/util/NavigableMap.html" title="interface in java.util">NavigableMap</a>&lt;K,V&gt; unmodifiableNavigableMap(<a href="../../java/util/NavigableMap.html" title="interface in java.util">NavigableMap</a>&lt;K,? extends V&gt; m)</pre>
<div class="block">
<span>返回指定可导航地图的不可修改视图。</span>
<span>这种方法允许模块向用户提供对内部可导航地图的“只读”访问。</span>
<span>在返回的导航地图上查询操作“通读”到指定的可导航地图。</span>
<span>试图修改返回的导航地图，无论是直接的，通过其收集的意见，或通过其<code>subMap</code> ， <code>headMap</code> ，或<code>tailMap</code>意见，导致<code>UnsupportedOperationException</code> 。</span>
<p> <span>如果指定的可导航地图是可序列化的，返回的导航地图将是可序列化的。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>K</code> - 地图键的类 
           </dd>
<dd>
<code>V</code> - 地图值的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>m</code> - 要返回不可修改视图的导航地图 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定可导航地图的不可修改视图 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="synchronizedCollection-java.util.Collection-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>synchronizedCollection</h4> <pre>public static &lt;T&gt; <a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;T&gt; synchronizedCollection(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;T&gt; c)</pre>
<div class="block">
<span>返回由指定集合支持的同步（线程安全）集合。</span>
<span>为了保证串行访问，重要的是通过返回的集合完成对后台集合的<strong>所有</strong>访问。</span>
<p> <span>当通过<a href="../../java/util/Spliterator.html" title="java.util中的接口"><code>Iterator</code>，<code>Spliterator</code></a>或<a href="../../java/util/stream/Stream.html" title="java.util.stream中的接口"><code>Stream</code></a>进行<a href="../../java/util/Iterator.html" title="java.util中的接口">遍历</a>时，用户手动同步返回的集合是<a href="../../java/util/stream/Stream.html" title="java.util.stream中的接口">至关重要的</a> ：</span> </p>
<pre>  <span>Collection c = Collections.synchronizedCollection(myCollection);
     ...
  synchronized (c) {
      Iterator i = c.iterator(); // Must be in the synchronized block
      while (i.hasNext())
         foo(i.next());
  }</span> </pre>
<span>不遵循此建议可能会导致非确定性行为。</span>
<p> <span>返回的集合<i>没有</i>通过<code>hashCode</code>和<code>equals</code>操作到支持集合，而是依赖于<code>Object</code>的equals和hashCode方法。</span> <span>在后台集合是集合或列表的情况下，必须保留这些操作的合同。</span> </p>
<p> <span>如果指定的集合是可序列化的，则返回的集合将是可序列化的。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 集合中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>c</code> - 要在同步集合中“包装”的集合。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定集合的同步视图。 
           </dd>
</dl> </li>
</ul> <a name="synchronizedSet-java.util.Set-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>synchronizedSet</h4> <pre>public static &lt;T&gt; <a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;T&gt; synchronizedSet(<a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;T&gt; s)</pre>
<div class="block">
<span>返回由指定集合支持的同步（线程安全）集。</span>
<span>为了保证串行访问，通过返回的集合完成对后台集的<strong>所有</strong>访问都是至关重要的。</span>
<p> <span>用户在迭代过程中手动同步返回的集合是必不可少的：</span> </p>
<pre>  <span>Set s = Collections.synchronizedSet(new HashSet());
      ...
  synchronized (s) {
      Iterator i = s.iterator(); // Must be in the synchronized block
      while (i.hasNext())
          foo(i.next());
  }</span> </pre>
<span>不遵循此建议可能会导致非确定性行为。</span>
<p> <span>如果指定的集合是可序列化的，则返回的集合将是可序列化的。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 集合中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>s</code> - 要在同步集中“包装”的集合。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定集合的同步视图。 
           </dd>
</dl> </li>
</ul> <a name="synchronizedSortedSet-java.util.SortedSet-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>synchronizedSortedSet</h4> <pre>public static &lt;T&gt; <a href="../../java/util/SortedSet.html" title="interface in java.util">SortedSet</a>&lt;T&gt; synchronizedSortedSet(<a href="../../java/util/SortedSet.html" title="interface in java.util">SortedSet</a>&lt;T&gt; s)</pre>
<div class="block">
<span>返回由指定的排序集支持的同步（线程安全）排序集。</span>
<span>为了保证串行访问，重要的是通过返回的排序集（或其视图）完成对后台排序集的<strong>所有</strong>访问。</span>
<p> <span>至关重要的是，用户迭代，或任何其<tt><tt>subSet，headSet，</tt></tt>或<tt>tailSet</tt>意见时，在返回的有序集合手动同步。</span> </p>
<pre>  <span>SortedSet s = Collections.synchronizedSortedSet(new TreeSet());
      ...
  synchronized (s) {
      Iterator i = s.iterator(); // Must be in the synchronized block
      while (i.hasNext())
          foo(i.next());
  }</span> </pre>
<span>要么：</span>
<pre>  <span>SortedSet s = Collections.synchronizedSortedSet(new TreeSet());
  SortedSet s2 = s.headSet(foo);
      ...
  synchronized (s) {  // Note: s, not s2!!!
      Iterator i = s2.iterator(); // Must be in the synchronized block
      while (i.hasNext())
          foo(i.next());
  }</span> </pre>
<span>不遵循此建议可能会导致非确定性行为。</span>
<p> <span>如果指定的排序集是可序列化的，则返回的排序集将是可序列化的。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 集合中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>s</code> - 排序集合在同步排序集中被“包装”。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定排序集合的同步视图。 
           </dd>
</dl> </li>
</ul> <a name="synchronizedNavigableSet-java.util.NavigableSet-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>synchronizedNavigableSet</h4> <pre>public static &lt;T&gt; <a href="../../java/util/NavigableSet.html" title="interface in java.util">NavigableSet</a>&lt;T&gt; synchronizedNavigableSet(<a href="../../java/util/NavigableSet.html" title="interface in java.util">NavigableSet</a>&lt;T&gt; s)</pre>
<div class="block">
<span>返回由指定的可导航集支持的同步（线程安全）可导航集。</span>
<span>为了保证串行访问，重要的是可以通过返回的可导航集（或其视图）来完成对后台导航集的<strong>所有</strong>访问。</span>
<p> <span>当务之急是用户遍历其或其任何时候对返回导航set手动同步<code>subSet</code> ， <code>headSet</code> ，或<code>tailSet</code>意见。</span> </p>
<pre>  <span>NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet());
      ...
  synchronized (s) {
      Iterator i = s.iterator(); // Must be in the synchronized block
      while (i.hasNext())
          foo(i.next());
  }</span> </pre>
<span>要么：</span>
<pre>  <span>NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet());
  NavigableSet s2 = s.headSet(foo, true);
      ...
  synchronized (s) {  // Note: s, not s2!!!
      Iterator i = s2.iterator(); // Must be in the synchronized block
      while (i.hasNext())
          foo(i.next());
  }</span> </pre>
<span>不遵循此建议可能会导致非确定性行为。</span>
<p> <span>如果指定的导航集是可序列化的，返回的导航集将是可序列化的。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 集合中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>s</code> - 可导航组在同步导航集中被“包装” 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定的导航集合的同步视图 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="synchronizedList-java.util.List-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>synchronizedList</h4> <pre>public static &lt;T&gt; <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt; synchronizedList(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt; list)</pre>
<div class="block">
<span>返回由指定列表支持的同步（线程安全）列表。</span>
<span>为了保证串行访问，重要的是通过返回的列表完成对后台列表的<strong>所有</strong>访问。</span>
<p> <span>在迭代时，用户必须在返回的列表上手动同步：</span> </p>
<pre>  <span>List list = Collections.synchronizedList(new ArrayList());
      ...
  synchronized (list) {
      Iterator i = list.iterator(); // Must be in synchronized block
      while (i.hasNext())
          foo(i.next());
  }</span> </pre>
<span>不遵循此建议可能会导致非确定性行为。</span>
<p> <span>如果指定的列表是可序列化的，则返回的列表将是可序列化的。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 列表中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>list</code> - 要在同步列表中“包装”的列表。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定列表的同步视图。 
           </dd>
</dl> </li>
</ul> <a name="synchronizedMap-java.util.Map-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>synchronizedMap</h4> <pre>public static &lt;K,V&gt; <a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,V&gt; synchronizedMap(<a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,V&gt; m)</pre>
<div class="block">
<span>返回由指定地图支持的同步（线程安全）映射。</span>
<span>为了保证串行访问，重要的是通过返回的映射完成对后台映射的<strong>所有</strong>访问。</span>
<p> <span>在迭代其任何集合视图时，用户必须在返回的映射上手动同步：</span> </p>
<pre>  <span>Map m = Collections.synchronizedMap(new HashMap());
      ...
  Set s = m.keySet();  // Needn't be in synchronized block
      ...
  synchronized (m) {  // Synchronizing on m, not s!
      Iterator i = s.iterator(); // Must be in synchronized block
      while (i.hasNext())
          foo(i.next());
  }</span> </pre>
<span>不遵循此建议可能会导致非确定性行为。</span>
<p> <span>如果指定的地图是可序列化的，返回的地图将是可序列化的。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>K</code> - 地图键的类 
           </dd>
<dd>
<code>V</code> - 地图值的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>m</code> - 要在同步地图中“包裹”的地图。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定地图的同步视图。 
           </dd>
</dl> </li>
</ul> <a name="synchronizedSortedMap-java.util.SortedMap-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>synchronizedSortedMap</h4> <pre>public static &lt;K,V&gt; <a href="../../java/util/SortedMap.html" title="interface in java.util">SortedMap</a>&lt;K,V&gt; synchronizedSortedMap(<a href="../../java/util/SortedMap.html" title="interface in java.util">SortedMap</a>&lt;K,V&gt; m)</pre>
<div class="block">
<span>返回由指定的排序映射支持的同步（线程安全）排序映射。</span>
<span>为了保证串行访问，至关重要的是，通过返回的排序映射（或其视图）完成对后台排序映射的<strong>所有</strong>访问。</span>
<p> <span>至关重要的是，用户迭代它的任何collection视图，或任何其<tt><tt>subMap，headMap</tt></tt>或<tt>tailMap</tt>意见集合视图时返回的有序地图上手动进行同步。</span> </p>
<pre>  <span>SortedMap m = Collections.synchronizedSortedMap(new TreeMap());
      ...
  Set s = m.keySet();  // Needn't be in synchronized block
      ...
  synchronized (m) {  // Synchronizing on m, not s!
      Iterator i = s.iterator(); // Must be in synchronized block
      while (i.hasNext())
          foo(i.next());
  }</span> </pre>
<span>要么：</span>
<pre>  <span>SortedMap m = Collections.synchronizedSortedMap(new TreeMap());
  SortedMap m2 = m.subMap(foo, bar);
      ...
  Set s2 = m2.keySet();  // Needn't be in synchronized block
      ...
  synchronized (m) {  // Synchronizing on m, not m2 or s2!
      Iterator i = s.iterator(); // Must be in synchronized block
      while (i.hasNext())
          foo(i.next());
  }</span> </pre>
<span>不遵循此建议可能会导致非确定性行为。</span>
<p> <span>如果指定的排序映射是可序列化的，返回的排序映射将是可序列化的。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>K</code> - 地图键的类 
           </dd>
<dd>
<code>V</code> - 地图值的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>m</code> - 要在同步排序的映射中“包装”的排序映射。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定排序地图的同步视图。 
           </dd>
</dl> </li>
</ul> <a name="synchronizedNavigableMap-java.util.NavigableMap-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>synchronizedNavigableMap</h4> <pre>public static &lt;K,V&gt; <a href="../../java/util/NavigableMap.html" title="interface in java.util">NavigableMap</a>&lt;K,V&gt; synchronizedNavigableMap(<a href="../../java/util/NavigableMap.html" title="interface in java.util">NavigableMap</a>&lt;K,V&gt; m)</pre>
<div class="block">
<span>返回由指定的可导航地图支持的同步（线程安全）可导航地图。</span>
<span>为了保证串行访问，重要的是可以通过返回的可导航地图（或其视图）来完成对后退导航地图的<strong>所有</strong>访问。</span>
<p> <span>至关重要的是，用户迭代它的任何collection视图，或任何其集合视图时返回的导航地图上手动同步<code>subMap</code> ， <code>headMap</code>或<code>tailMap</code>意见。</span> </p>
<pre>  <span>NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap());
      ...
  Set s = m.keySet();  // Needn't be in synchronized block
      ...
  synchronized (m) {  // Synchronizing on m, not s!
      Iterator i = s.iterator(); // Must be in synchronized block
      while (i.hasNext())
          foo(i.next());
  }</span> </pre>
<span>要么：</span>
<pre>  <span>NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap());
  NavigableMap m2 = m.subMap(foo, true, bar, false);
      ...
  Set s2 = m2.keySet();  // Needn't be in synchronized block
      ...
  synchronized (m) {  // Synchronizing on m, not m2 or s2!
      Iterator i = s.iterator(); // Must be in synchronized block
      while (i.hasNext())
          foo(i.next());
  }</span> </pre>
<span>不遵循此建议可能会导致非确定性行为。</span>
<p> <span>如果指定的可导航地图是可序列化的，返回的导航地图将是可序列化的。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>K</code> - 地图键的类 
           </dd>
<dd>
<code>V</code> - 地图值的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>m</code> - 可导航地图在同步导航地图中被“包裹” 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定可导航地图的同步视图。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="checkedCollection-java.util.Collection-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>checkedCollection</h4> <pre>public static &lt;E&gt; <a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;E&gt; checkedCollection(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;E&gt; c,
                                                  <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;E&gt; type)</pre>
<div class="block">
<span>返回指定集合的动态类型安全视图。</span>
<span>任何插入错误类型的元素的尝试将导致立即的<a href="../../java/lang/ClassCastException.html" title="java.lang中的类"><code>ClassCastException</code></a> 。</span>
<span>假设集合在生成动态类型安全视图之前不包含不正确类型的元素，并且通过视图发生对集合的所有后续访问，则可以<i>确保</i>集合不能包含不正确类型的元素。</span>
<p> <span>该语言中的泛型机制提供了编译时（静态）类型检查，但是可以用未经检查的转换来击败此机制。</span> <span>通常这不是问题，因为编译器在所有这些未经检查的操作上发出警告。</span> <span>然而，有一次静态类型检查是不够的。</span> <span>例如，假设集合被传递给第三方库，并且库代码不会通过插入错误类型的元素来破坏集合。</span> </p>
<p> <span>动态类型安全视图的另一个用途是调试。</span> <span>假设一个程序失败，一个<code>ClassCastException</code> ，表示一个不正确的类型的元素被放入一个参数化的集合。</span> <span>不幸的是，异常可以在插入错误元素之后的任何时间发生，因此它通常提供很少或没有关于问题的真正来源的信息。</span> <span>如果问题是可重复的，可以通过临时修改程序来快速确定其来源，以便使用动态类型安全视图来包装该集合。</span> <span>例如，这个声明：</span> </p>
<pre>  <span><code> Collection&lt;String&gt; c = new HashSet&lt;&gt;(); </code></span> </pre>
<span>可以暂时用这个替换：</span>
<pre>  <span><code> Collection&lt;String&gt; c = Collections.checkedCollection( new HashSet&lt;&gt;(), String.class); </code></span> </pre>
<span>再次运行该程序将导致它在将不正确类型的元素插入到集合中的位置失败，并清楚地标识出问题的根源。</span>
<span>一旦问题得到解决，修改的声明可能会恢复原来的。</span>
<p> <span>返回的集合<i>不</i>将hashCode并传递给底层集合等于操作，而是依赖于<code>Object</code>的<code>equals</code>种<code>hashCode</code>方法。</span> <span>在后台集合是集合或列表的情况下，必须保留这些操作的合同。</span> </p>
<p> <span>如果指定的集合是可序列化的，则返回的集合将是可序列化的。</span> </p>
<p> <span>由于<code>null</code>被认为是任何引用类型的值，所以返回的集合允许在后端集合执行时插入空元素。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>E</code> - 集合中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>c</code> - 要为其返回动态类型安全视图的集合 
           </dd>
<dd>
<code>type</code> -该元素的类型 
            <code>c</code>被允许保持 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定集合的动态类型安全视图 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="checkedQueue-java.util.Queue-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>checkedQueue</h4> <pre>public static &lt;E&gt; <a href="../../java/util/Queue.html" title="interface in java.util">Queue</a>&lt;E&gt; checkedQueue(<a href="../../java/util/Queue.html" title="interface in java.util">Queue</a>&lt;E&gt; queue,
                                        <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;E&gt; type)</pre>
<div class="block">
<span>返回指定队列的动态类型安全视图。</span>
<span>任何尝试插入错误类型的元素将导致立即<a href="../../java/lang/ClassCastException.html" title="java.lang中的类"><code>ClassCastException</code></a> 。</span>
<span>假设一个队列不包含任何类型不正确的生成动态类型安全视图的时间之前的元件，并且该队列的所有后续访问通过该视图发生时，它<i>保证</i>了队列不能包含类型不正确的元素。</span>
<p> <span>关于使用动态类型安全视图的讨论可以在<a href="../../java/util/Collections.html#checkedCollection-java.util.Collection-java.lang.Class-"><code>checkedCollection</code></a>方法的文档中找到。</span> </p>
<p> <span>如果指定的队列是可序列化的，则返回的队列将是可序列化的。</span> </p>
<p> <span>由于<code>null</code>被认为是任何引用类型的值，返回的队列允许在支持队列执行时<code>null</code>元素。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>E</code> - 队列中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>queue</code> - 要为其返回动态类型安全视图的队列 
           </dd>
<dd>
<code>type</code> - 允许保持 
            <code>queue</code>的元素的类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定队列的动态类型安全视图 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="checkedSet-java.util.Set-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>checkedSet</h4> <pre>public static &lt;E&gt; <a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;E&gt; checkedSet(<a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;E&gt; s,
                                    <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;E&gt; type)</pre>
<div class="block">
<span>返回指定集合的动态类型安全视图。</span>
<span>任何插入错误类型的元素的尝试都会立即导致<a href="../../java/lang/ClassCastException.html" title="java.lang中的类"><code>ClassCastException</code></a> 。</span>
<span>假设一组不包含任何类型不正确的生成动态类型安全视图的时间之前的元件，并且该组的所有后续访问通过该视图发生时，它<i>保证</i>了集不能包含类型不正确的元素。</span>
<p> <span>关于使用动态类型安全视图的讨论可以在<a href="../../java/util/Collections.html#checkedCollection-java.util.Collection-java.lang.Class-"><code>checkedCollection</code></a>方法的文档中找到。</span> </p>
<p> <span>如果指定的集合是可序列化的，则返回的集合将是可序列化的。</span> </p>
<p> <span>由于<code>null</code>被认为是任何引用类型的值，所以返回的集合允许在后台集合中插入空元素。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>E</code> - 集合中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>s</code> - 要为其返回动态类型安全视图的集合 
           </dd>
<dd>
<code>type</code> -该元素的类型 
            <code>s</code>被允许保持 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定集合的动态类型安全视图 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="checkedSortedSet-java.util.SortedSet-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>checkedSortedSet</h4> <pre>public static &lt;E&gt; <a href="../../java/util/SortedSet.html" title="interface in java.util">SortedSet</a>&lt;E&gt; checkedSortedSet(<a href="../../java/util/SortedSet.html" title="interface in java.util">SortedSet</a>&lt;E&gt; s,
                                                <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;E&gt; type)</pre>
<div class="block">
<span>返回指定排序集的动态类型安全视图。</span>
<span>任何插入错误类型的元素的尝试将导致立即的<a href="../../java/lang/ClassCastException.html" title="java.lang中的类"><code>ClassCastException</code></a> 。</span>
<span>假设一个有序集合不包含任何错误键入之前生成动态类型安全视图时的元件，并且，为有序集合的所有后续访问通过该视图发生时，可以<i>保证</i>有序集合不能包含类型不正确的元素。</span>
<p> <span>关于使用动态类型安全视图的讨论可以在<a href="../../java/util/Collections.html#checkedCollection-java.util.Collection-java.lang.Class-"><code>checkedCollection</code></a>方法的文档中找到。</span> </p>
<p> <span>如果指定的排序集是可序列化的，则返回的排序集将是可序列化的。</span> </p>
<p> <span>由于<code>null</code>被认为是任何引用类型的值，所以返回的排序集允许在后台排序集合时插入空元素。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>E</code> - 集合中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>s</code> - 要为其返回动态类型安全视图的排序集 
           </dd>
<dd>
<code>type</code> -该元素的类型 
            <code>s</code>被允许保持 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定排序集的动态类型安全视图 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="checkedNavigableSet-java.util.NavigableSet-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>checkedNavigableSet</h4> <pre>public static &lt;E&gt; <a href="../../java/util/NavigableSet.html" title="interface in java.util">NavigableSet</a>&lt;E&gt; checkedNavigableSet(<a href="../../java/util/NavigableSet.html" title="interface in java.util">NavigableSet</a>&lt;E&gt; s,
                                                      <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;E&gt; type)</pre>
<div class="block">
<span>返回指定的可导航集的动态类型安全视图。</span>
<span>任何插入错误类型的元素的尝试将导致立即的<a href="../../java/lang/ClassCastException.html" title="java.lang中的类"><code>ClassCastException</code></a> 。</span>
<span>假设可导航集在生成动态类型安全视图之前不包含不正确类型的元素，并且通过视图进行对导航集的所有后续访问，则可以<em>确保</em>导航集不能包含不正确类型的元素。</span>
<p> <span>关于使用动态类型安全视图的讨论可以在<a href="../../java/util/Collections.html#checkedCollection-java.util.Collection-java.lang.Class-"><code>checkedCollection</code></a>方法的文档中找到。</span> </p>
<p> <span>如果指定的导航集是可序列化的，返回的导航集将是可序列化的。</span> </p>
<p> <span>由于<code>null</code>被认为是任何引用类型的值，所以返回的导航集允许在后台排序集合时插入空元素。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>E</code> - 集合中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>s</code> - 要为其返回动态类型安全视图的导航集 
           </dd>
<dd>
<code>type</code> -该元素的类型 
            <code>s</code>被允许保持 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定可导航集的动态类型安全视图 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="checkedList-java.util.List-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>checkedList</h4> <pre>public static &lt;E&gt; <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;E&gt; checkedList(<a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;E&gt; list,
                                      <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;E&gt; type)</pre>
<div class="block">
<span>返回指定列表的动态类型安全视图。</span>
<span>任何插入错误类型的元素的尝试都将立即<a href="../../java/lang/ClassCastException.html" title="java.lang中的类">产生<code>ClassCastException</code></a> 。</span>
<span>假设一个列表不包含错误键入的生成动态类型安全视图的时间之前的元件，并且其到列表中的所有后续访问通过该视图发生时，它<i>保证</i>了列表不能包含类型不正确的元素。</span>
<p> <span>关于使用动态类型安全视图的讨论可以在<a href="../../java/util/Collections.html#checkedCollection-java.util.Collection-java.lang.Class-"><code>checkedCollection</code></a>方法的文档中找到。</span> </p>
<p> <span>如果指定的列表是可序列化的，则返回的列表将是可序列化的。</span> </p>
<p> <span>由于<code>null</code>被认为是任何引用类型的值，所以返回的列表允许在支持列表中插入空元素。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>E</code> - 列表中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>list</code> - 要为其返回动态类型安全视图的列表 
           </dd>
<dd>
<code>type</code> -该元素的类型 
            <code>list</code>被允许保持 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定列表的动态类型安全视图 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="checkedMap-java.util.Map-java.lang.Class-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>checkedMap</h4> <pre>public static &lt;K,V&gt; <a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,V&gt; checkedMap(<a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,V&gt; m,
                                        <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;K&gt; keyType,
                                        <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;V&gt; valueType)</pre>
<div class="block">
<span>返回指定地图的动态类型安全视图。</span>
<span>任何插入其键或值类型错误的映射的尝试将立即<a href="../../java/lang/ClassCastException.html" title="java.lang中的类">导致<code>ClassCastException</code></a> 。</span>
<span>类似地，任何修改当前与密钥相关联的值的尝试将立即导致<a href="../../java/lang/ClassCastException.html" title="java.lang中的类"><code>ClassCastException</code></a> ，无论是通过地图本身直接尝试修改，还是通过从地图的<a href="../../java/util/Map.html#entrySet--"><code>entry set</code></a>视图获取的<a href="../../java/util/Map.Entry.html" title="java.util中的接口"><code>Map.Entry</code></a>实例。</span>
<p> <span>假设映射不包含不正确时，所产生的动态类型安全视图的时间之前为键入的键或值，并且其相对于地图的所有后续访问通过该视图发生（或它的集合视图之一），它<i>保证</i>了地图不能包含错误键入的键或值。</span> </p>
<p> <span>关于使用动态类型安全视图的讨论可以在<a href="../../java/util/Collections.html#checkedCollection-java.util.Collection-java.lang.Class-"><code>checkedCollection</code></a>方法的文档中找到。</span> </p>
<p> <span>如果指定的地图是可序列化的，返回的地图将是可序列化的。</span> </p>
<p> <span>由于<code>null</code>被认为是任何引用类型的值，所以返回的映射允许每当支持地图执行时插入空值或值。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>K</code> - 地图键的类 
           </dd>
<dd>
<code>V</code> - 地图值的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>m</code> - 要为其返回动态类型安全视图的地图 
           </dd>
<dd>
<code>keyType</code> - 
            <code>m</code>被允许保存的密钥的类型 
           </dd>
<dd>
<code>valueType</code> - 允许持有的 
            <code>m</code>的值的类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定地图的动态类型安全视图 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="checkedSortedMap-java.util.SortedMap-java.lang.Class-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>checkedSortedMap</h4> <pre>public static &lt;K,V&gt; <a href="../../java/util/SortedMap.html" title="interface in java.util">SortedMap</a>&lt;K,V&gt; checkedSortedMap(<a href="../../java/util/SortedMap.html" title="interface in java.util">SortedMap</a>&lt;K,V&gt; m,
                                                    <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;K&gt; keyType,
                                                    <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;V&gt; valueType)</pre>
<div class="block">
<span>返回指定排序映射的动态类型安全视图。</span>
<span>任何尝试插入其键或值的类型错误的映射将立即<a href="../../java/lang/ClassCastException.html" title="java.lang中的类">导致<code>ClassCastException</code></a> 。</span>
<span>类似地，任何修改当前与密钥相关联的值的尝试将立即导致<a href="../../java/lang/ClassCastException.html" title="java.lang中的类"><code>ClassCastException</code></a> ，无论是通过地图本身直接尝试修改，还是通过从地图的<a href="../../java/util/Map.html#entrySet--"><code>entry set</code></a>视图获取的<a href="../../java/util/Map.Entry.html" title="java.util中的接口"><code>Map.Entry</code></a>实例。</span>
<p> <span>假设映射不包含不正确时，所产生的动态类型安全视图的时间之前为键入的键或值，并且其相对于地图的所有后续访问通过该视图发生（或它的集合视图之一），它<i>保证</i>了地图不能包含错误键入的键或值。</span> </p>
<p> <span>关于使用动态类型安全视图的讨论可以在<a href="../../java/util/Collections.html#checkedCollection-java.util.Collection-java.lang.Class-"><code>checkedCollection</code></a>方法的文档中找到。</span> </p>
<p> <span>如果指定的地图是可序列化的，返回的地图将是可序列化的。</span> </p>
<p> <span>由于<code>null</code>被认为是任何引用类型的值，所以返回的映射允许每当支持地图执行时插入空值或值。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>K</code> - 地图键的类 
           </dd>
<dd>
<code>V</code> - 地图值的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>m</code> - 要为其返回动态类型安全视图的地图 
           </dd>
<dd>
<code>keyType</code> - 
            <code>m</code>被允许持有的密钥的类型 
           </dd>
<dd>
<code>valueType</code> -即值的类型 
            <code>m</code>被允许保持 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定地图的动态类型安全视图 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="checkedNavigableMap-java.util.NavigableMap-java.lang.Class-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>checkedNavigableMap</h4> <pre>public static &lt;K,V&gt; <a href="../../java/util/NavigableMap.html" title="interface in java.util">NavigableMap</a>&lt;K,V&gt; checkedNavigableMap(<a href="../../java/util/NavigableMap.html" title="interface in java.util">NavigableMap</a>&lt;K,V&gt; m,
                                                          <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;K&gt; keyType,
                                                          <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;V&gt; valueType)</pre>
<div class="block">
<span>返回指定可导航地图的动态类型安全视图。</span>
<span>任何插入其键或值类型错误的映射的尝试将立即<a href="../../java/lang/ClassCastException.html" title="java.lang中的类">导致<code>ClassCastException</code></a> 。</span>
<span>类似地，任何修改当前与密钥相关联的值的尝试将立即导致<a href="../../java/lang/ClassCastException.html" title="java.lang中的类"><code>ClassCastException</code></a> ，无论是通过地图本身直接尝试修改，还是通过从地图的<a href="../../java/util/Map.html#entrySet--"><code>entry set</code></a>视图获取的<a href="../../java/util/Map.Entry.html" title="java.util中的接口"><code>Map.Entry</code></a>实例。</span>
<p> <span>假设映射不包含不正确时，所产生的动态类型安全视图的时间之前为键入的键或值，并且其相对于地图的所有后续访问通过该视图发生（或它的集合视图之一），它<em>保证</em>了地图不能包含错误键入的键或值。</span> </p>
<p> <span>关于使用动态类型安全视图的讨论可以在<a href="../../java/util/Collections.html#checkedCollection-java.util.Collection-java.lang.Class-"><code>checkedCollection</code></a>方法的文档中找到。</span> </p>
<p> <span>如果指定的地图是可序列化的，返回的地图将是可序列化的。</span> </p>
<p> <span>由于<code>null</code>被认为是任何引用类型的值，所以返回的映射允许每当支持地图执行时插入空值或值。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>K</code> - 地图键的类型 
           </dd>
<dd>
<code>V</code> - 地图值的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>m</code> - 要为其返回动态类型安全视图的地图 
           </dd>
<dd>
<code>keyType</code> - 
            <code>m</code>被允许持有的密钥的类型 
           </dd>
<dd>
<code>valueType</code> - 允许持有的值为 
            <code>m</code>的值的类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定地图的动态类型安全视图 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="emptyIterator--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>emptyIterator</h4> <pre>public static &lt;T&gt; <a href="../../java/util/Iterator.html" title="interface in java.util">Iterator</a>&lt;T&gt; emptyIterator()</pre>
<div class="block">
<span>返回没有元素的迭代器。</span>
<span>更确切地说，</span>
<ul>
<li> <span><a href="../../java/util/Iterator.html#hasNext--"><code>hasNext</code></a>总是返回<code>false</code> 。</span> </li>
<li> <span><a href="../../java/util/Iterator.html#next--"><code>next</code></a>总是抛出<a href="../../java/util/NoSuchElementException.html" title="java.util中的类"><code>NoSuchElementException</code></a> 。</span> </li>
<li> <span><a href="../../java/util/Iterator.html#remove--"><code>remove</code></a>总是抛出<a href="../../java/lang/IllegalStateException.html" title="java.lang中的类"><code>IllegalStateException</code></a> 。</span> </li>
</ul>
<p> <span>允许这种方法的实现，但不是必需的，从多个调用返回相同的对象。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 迭代器中元素的类型，如果有的话 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个空的迭代器 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.7 
           </dd>
</dl> </li>
</ul> <a name="emptyListIterator--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>emptyListIterator</h4> <pre>public static &lt;T&gt; <a href="../../java/util/ListIterator.html" title="interface in java.util">ListIterator</a>&lt;T&gt; emptyListIterator()</pre>
<div class="block">
<span>返回没有元素的列表迭代器。</span>
<span>更确切地说，</span>
<ul>
<li> <span><a href="../../java/util/Iterator.html#hasNext--"><code>hasNext</code></a>和<a href="../../java/util/ListIterator.html#hasPrevious--"><code>hasPrevious</code></a>总是返回<code>false</code> 。</span> </li>
<li> <span><a href="../../java/util/Iterator.html#next--"><code>next</code></a>和<a href="../../java/util/ListIterator.html#previous--"><code>previous</code></a>总是抛出<a href="../../java/util/NoSuchElementException.html" title="java.util中的类"><code>NoSuchElementException</code></a> 。</span> </li>
<li> <span><a href="../../java/util/Iterator.html#remove--"><code>remove</code></a>和<a href="../../java/util/ListIterator.html#set-E-"><code>set</code></a>总是抛出<a href="../../java/lang/IllegalStateException.html" title="java.lang中的类"><code>IllegalStateException</code></a> 。</span> </li>
<li> <span><a href="../../java/util/ListIterator.html#add-E-"><code>add</code></a>总是抛出<a href="../../java/lang/UnsupportedOperationException.html" title="java.lang中的类"><code>UnsupportedOperationException</code></a> 。</span> </li>
<li> <span><a href="../../java/util/ListIterator.html#nextIndex--"><code>nextIndex</code></a>总是返回<code>0</code> 。</span> </li>
<li> <span><a href="../../java/util/ListIterator.html#previousIndex--"><code>previousIndex</code></a>总是返回<code>-1</code> 。</span> </li>
</ul>
<p> <span>允许这种方法的实现，但不是必需的，从多个调用返回相同的对象。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 迭代器中元素的类型，如果有的话 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个空列表迭代器 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.7 
           </dd>
</dl> </li>
</ul> <a name="emptyEnumeration--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>emptyEnumeration</h4> <pre>public static &lt;T&gt; <a href="../../java/util/Enumeration.html" title="interface in java.util">Enumeration</a>&lt;T&gt; emptyEnumeration()</pre>
<div class="block">
<span>返回没有元素的枚举。</span>
<span>更确切地说，</span>
<ul>
<li> <span><a href="../../java/util/Enumeration.html#hasMoreElements--"><code>hasMoreElements</code></a>总是返回<code>false</code> 。</span> </li>
<li> <span><a href="../../java/util/Enumeration.html#nextElement--"><code>nextElement</code></a>总是抛出<a href="../../java/util/NoSuchElementException.html" title="java.util中的类"><code>NoSuchElementException</code></a> 。</span> </li>
</ul>
<p> <span>允许这种方法的实现，但不是必需的，从多个调用返回相同的对象。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 
            <code>T</code>中对象的类 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个空的枚举 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.7 
           </dd>
</dl> </li>
</ul> <a name="emptySet--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>emptySet</h4> <pre>public static final &lt;T&gt; <a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;T&gt; emptySet()</pre>
<div class="block">
<span>返回一个空集（immutable）。</span>
<span>这个集是可序列化的。</span>
<span>与类似命名的字段不同，该方法被参数化。</span>
<p> <span>此示例说明了获取空集合的类型安全方式：</span> </p>
<pre>  <span>Set&lt;String&gt; s = Collections.emptySet();</span> </pre>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>该方法的实现不需要为每个调用创建单独的<code>Set</code>对象。</span>
<span>使用此方法可能具有与使用相似名称的字段相当的成本。</span>
<span>（与此方法不同，该字段不提供类型安全性。）</span>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 集合中的对象的类 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             空集 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/util/Collections.html#EMPTY_SET"><code>EMPTY_SET</code></a>
</dd>
</dl> </li>
</ul> <a name="emptySortedSet--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>emptySortedSet</h4> <pre>public static &lt;E&gt; <a href="../../java/util/SortedSet.html" title="interface in java.util">SortedSet</a>&lt;E&gt; emptySortedSet()</pre>
<div class="block">
<span>返回一个空的排序集（immutable）。</span>
<span>这个集是可序列化的。</span>
<p> <span>此示例说明了获取空排序集的类型安全方式：</span> </p>
<pre>  <span><code> SortedSet&lt;String&gt; s = Collections.emptySortedSet(); </code></span> </pre>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
             该方法的实现不需要为每个调用创建单独的 
            <code>SortedSet</code>对象。 
           </dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>E</code> - 元素的类型，如果有的话，在集合中 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             空排序集 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="emptyNavigableSet--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>emptyNavigableSet</h4> <pre>public static &lt;E&gt; <a href="../../java/util/NavigableSet.html" title="interface in java.util">NavigableSet</a>&lt;E&gt; emptyNavigableSet()</pre>
<div class="block">
<span>返回一个空导航集（immutable）。</span>
<span>这个集是可序列化的。</span>
<p> <span>此示例说明了获取空导航集的类型安全方式：</span> </p>
<pre>  <span><code> NavigableSet&lt;String&gt; s = Collections.emptyNavigableSet(); </code></span> </pre>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
             该方法的实现不需要为每个调用创建单独的 
            <code>NavigableSet</code>对象。 
           </dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>E</code> - 元素的类型，如果有的话，在集合中 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             空导航集 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="emptyList--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>emptyList</h4> <pre>public static final &lt;T&gt; <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt; emptyList()</pre>
<div class="block">
<span>返回空列表（immutable）。</span>
<span>此列表是可序列化的。</span>
<p> <span>此示例说明了获取空列表的类型安全方式：</span> </p>
<pre>  <span>List&lt;String&gt; s = Collections.emptyList();</span> </pre>
<span>实现说明：该方法的实现不需要为每个调用创建一个单独的<tt>List</tt>对象。</span>
<span>使用此方法可能具有与使用相似名称的字段相当的成本。</span>
<span>（与此方法不同，该字段不提供类型安全性。）</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 列表中的元素类型，如果有的话 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个空的不变名单 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/util/Collections.html#EMPTY_LIST"><code>EMPTY_LIST</code></a>
</dd>
</dl> </li>
</ul> <a name="emptyMap--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>emptyMap</h4> <pre>public static final &lt;K,V&gt; <a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,V&gt; emptyMap()</pre>
<div class="block">
<span>返回空的地图（不可变）。</span>
<span>这张地图是可序列化的。</span>
<p> <span>此示例说明了获取空地图的类型安全方式：</span> </p>
<pre>  <span>Map&lt;String, Date&gt; s = Collections.emptyMap();</span> </pre>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>该方法的实现不需要为每个调用创建单独的<code>Map</code>对象。</span>
<span>使用此方法可能具有与使用相似名称的字段相当的成本。</span>
<span>（与此方法不同，该字段不提供类型安全性。）</span>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>K</code> - 地图键的类 
           </dd>
<dd>
<code>V</code> - 地图值的类 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一张空地图 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/util/Collections.html#EMPTY_MAP"><code>EMPTY_MAP</code></a>
</dd>
</dl> </li>
</ul> <a name="emptySortedMap--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>emptySortedMap</h4> <pre>public static final &lt;K,V&gt; <a href="../../java/util/SortedMap.html" title="interface in java.util">SortedMap</a>&lt;K,V&gt; emptySortedMap()</pre>
<div class="block">
<span>返回空的排序映射（immutable）。</span>
<span>这张地图是可序列化的。</span>
<p> <span>此示例说明了获取空地图的类型安全方式：</span> </p>
<pre>  <span><code> SortedMap&lt;String, Date&gt; s = Collections.emptySortedMap(); </code></span> </pre>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
             该方法的实现不需要为每个调用创建单独的 
            <code>SortedMap</code>对象。 
           </dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>K</code> - 地图键的类 
           </dd>
<dd>
<code>V</code> - 地图值的类 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个空的排序地图 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="emptyNavigableMap--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>emptyNavigableMap</h4> <pre>public static final &lt;K,V&gt; <a href="../../java/util/NavigableMap.html" title="interface in java.util">NavigableMap</a>&lt;K,V&gt; emptyNavigableMap()</pre>
<div class="block">
<span>返回空导航地图（不可变）。</span>
<span>这张地图是可序列化的。</span>
<p> <span>此示例说明了获取空地图的类型安全方式：</span> </p>
<pre>  <span><code> NavigableMap&lt;String, Date&gt; s = Collections.emptyNavigableMap(); </code></span> </pre>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
             该方法的实现不需要为每个调用创建单独的 
            <code>NavigableMap</code>对象。 
           </dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>K</code> - 地图键的类 
           </dd>
<dd>
<code>V</code> - 地图值的类 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个空的导航地图 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="singleton-java.lang.Object-">
<!-- --> </a><a name="singleton-T-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>singleton</h4> <pre>public static &lt;T&gt; <a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;T&gt; singleton(T o)</pre>
<div class="block">
<span>返回一个只包含指定对象的不可变集。</span>
<span>返回的集合是可序列化的。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 集合中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>o</code> - 要存储在返回集合中的唯一对象。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个不可变的集合，只包含指定的对象。 
           </dd>
</dl> </li>
</ul> <a name="singletonList-java.lang.Object-">
<!-- --> </a><a name="singletonList-T-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>singletonList</h4> <pre>public static &lt;T&gt; <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt; singletonList(T o)</pre>
<div class="block">
<span>返回一个只包含指定对象的不可变列表。</span>
<span>返回的列表是可序列化的。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 列表中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>o</code> - 要存储在返回列表中的唯一对象。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个只包含指定对象的不可变列表。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.3 
           </dd>
</dl> </li>
</ul> <a name="singletonMap-java.lang.Object-java.lang.Object-">
<!-- --> </a><a name="singletonMap-K-V-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>singletonMap</h4> <pre>public static &lt;K,V&gt; <a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,V&gt; singletonMap(K key,
                                          V value)</pre>
<div class="block">
<span>返回一个不可变的地图，只将指定的键映射到指定的值。</span>
<span>返回的地图是可序列化的。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>K</code> - 地图键的类 
           </dd>
<dd>
<code>V</code> - 地图值的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>key</code> - 存储在返回地图中的唯一键。 
           </dd>
<dd>
<code>value</code> - 返回地图映射到的值 
            <tt>key</tt> 。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个不可变的映射，只包含指定的键值映射。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.3 
           </dd>
</dl> </li>
</ul> <a name="nCopies-int-java.lang.Object-">
<!-- --> </a><a name="nCopies-int-T-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>nCopies</h4> <pre>public static &lt;T&gt; <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt; nCopies(int n,
                                  T o)</pre>
<div class="block">
<span>返回由指定对象的<tt>n</tt>副本组成的不可变列表。</span>
<span>新分配的数据对象很小（它包含对数据对象的单个引用）。</span>
<span>此方法与<tt>List.addAll</tt>方法结合使用可以增长列表。</span>
<span>返回的列表是可序列化的。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 要复制的对象的类和返回列表中的对象的类。 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>n</code> - 返回列表中的元素数。 
           </dd>
<dd>
<code>o</code> - 在返回的列表中重复出现的元素。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个不可变的列表，由指定对象的 
            <tt>n</tt>副本组成。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>n &lt; 0</code>
</dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/util/List.html#addAll-java.util.Collection-"><code>List.addAll(Collection)</code></a> ， 
            <a href="../../java/util/List.html#addAll-int-java.util.Collection-"><code>List.addAll(int, Collection)</code></a>
</dd>
</dl> </li>
</ul> <a name="reverseOrder--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>reverseOrder</h4> <pre>public static &lt;T&gt; <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;T&gt; reverseOrder()</pre>
<div class="block">
<span>返回一个比较器，它对实现<code>Comparable</code>接口的对象集合施加与<em>自然排序</em>相反的比较。</span>
<span>（自然顺序是由物体本身的确定的顺序对<code>compareTo</code>方法）。这使得能够简单成语用于分拣（或维持）实现该对象的集合（或阵列） <code>Comparable</code>在反向自然顺序接口。</span>
<span>例如，假设<code>a</code>是字符串数组。</span>
<span>然后：</span>
<pre>  <span>Arrays.sort(a, Collections.reverseOrder());</span> </pre>
<span>以反字典（字母顺序）排列阵列。</span>
<p> <span>返回的比较器是可序列化的。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 比较对象比较对象的类 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             该规定于实现 
            <tt>Comparable</tt>接口的对象collection的 
            <i>自然顺序</i>相反的比较器。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a></span>
</dd>
</dl> </li>
</ul> <a name="reverseOrder-java.util.Comparator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>reverseOrder</h4> <pre>public static &lt;T&gt; <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;T&gt; reverseOrder(<a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;T&gt; cmp)</pre>
<div class="block">
<span>返回一个比较器，它强制指定比较器的反向排序。</span>
<span>如果指定的比较器是<code>null</code> ，则该方法相当于<a href="../../java/util/Collections.html#reverseOrder--"><code>reverseOrder()</code></a> （换句话说，它返回一个比较器，它对实现Comparable接口的对象集合施加了<em>自然排序</em>的相反）。</span>
<p> <span>返回的比较器是可串行化的（假设指定的比较器也可串行化或者<code>null</code> ）。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 比较类比较对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>cmp</code> - 比较者的排序将由返回的比较器或 
            <code>null</code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个比较器，它强制指定比较器的反向排序。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="enumeration-java.util.Collection-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>enumeration</h4> <pre>public static &lt;T&gt; <a href="../../java/util/Enumeration.html" title="interface in java.util">Enumeration</a>&lt;T&gt; enumeration(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;T&gt; c)</pre>
<div class="block">
<span>返回指定集合的枚举。</span>
<span>这提供了与需要枚举作为输入的传统API的互操作性。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 集合中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>c</code> - 要返回枚举的集合。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定集合的枚举。 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/util/Enumeration.html" title="java.util中的接口"><code>Enumeration</code></a></span>
</dd>
</dl> </li>
</ul> <a name="list-java.util.Enumeration-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>list</h4> <pre>public static &lt;T&gt; <a href="../../java/util/ArrayList.html" title="class in java.util">ArrayList</a>&lt;T&gt; list(<a href="../../java/util/Enumeration.html" title="interface in java.util">Enumeration</a>&lt;T&gt; e)</pre>
<div class="block">
<span>返回一个数组列表，其中包含由枚举返回的顺序由指定的枚举返回的元素。</span>
<span>这种方法提供返回枚举的传统API和需要集合的新API之间的互操作性。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 
            <code>T</code>返回的对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>e</code> - 枚举为返回的数组列表提供元素 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             包含指定枚举返回的元素的数组列表。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.4 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/util/Enumeration.html" title="java.util中的接口"><code>Enumeration</code></a> ， <a href="../../java/util/ArrayList.html" title="java.util中的类"><code>ArrayList</code></a></span>
</dd>
</dl> </li>
</ul> <a name="frequency-java.util.Collection-java.lang.Object-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>frequency</h4> <pre>public static int frequency(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;?&gt; c,
                            <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> o)</pre>
<div class="block">
<span>返回指定集合中与指定对象相等的元素数。</span>
<span>更正式地，返回<tt>集合</tt>中的元素数量e，使得<tt>(o == null ? e == null : o.equals(e))</tt> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>c</code> - 其中确定o的频率的 
            <tt>集合</tt>
</dd>
<dd>
<code>o</code> - 要确定其频率的对象 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>c</code>中元素的 
            <code>c</code>等于 
            <code>o</code>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>c</tt>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="disjoint-java.util.Collection-java.util.Collection-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>disjoint</h4> <pre>public static boolean disjoint(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;?&gt; c1,
                               <a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;?&gt; c2)</pre>
<div class="block">
<span>如果两个指定的集合没有共同的元素，则返回<code>true</code> 。</span>
<p> <span>如果这种方法用于不符合<code>Collection</code>的一般合同的<code>Collection</code> 。</span> <span>实施方案可以选择在任一集合中迭代并测试另一集合中的包含（或执行任何等效计算）。</span> <span>如果任何一个收集使用非标准平等的测试（如做了<a href="../../java/util/SortedSet.html" title="java.util中的接口"><code>SortedSet</code></a> ，其顺序是<em>不是等号</em> ，或者按键的<em>兼容</em> <a href="../../java/util/IdentityHashMap.html" title="java.util中的类"><code>IdentityHashMap</code></a> ），两个集合必须使用相同的非标准相等测试，或者这种方法的结果是不确定的。</span> </p>
<p> <span>当使用对它们可能包含的元素有限制的集合时，还必须小心。</span> <span>允许集合实现为涉及其认为不合格的元素的任何操作抛出异常。</span> <span>为了绝对安全，指定的集合只应包含两个集合的符合条件的元素。</span> </p>
<p> <span>请注意，允许在两个参数中传递相同的集合，在这种情况下，当且仅当集合为空时，该方法将返回<code>true</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>c1</code> - 一个集合 
           </dd>
<dd>
<code>c2</code> - 一个集合 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果两个指定的集合没有共同的元素。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一集合是 
            <code>null</code> 。 
           </dd>
<dd>
<span><code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果一个集合包含一个<code>null</code>元素，并且<code>null</code>不是其他集合的合格元素。</span>
<span>（ <a href="Collection.html#optional-restrictions">optional</a> ）</span>
</dd>
<dd>
<span><code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果一个集合包含一个不符合其他集合类型的元素。</span>
<span>（ <a href="Collection.html#optional-restrictions">optional</a> ）</span>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="addAll-java.util.Collection-java.lang.Object:A-">
<!-- --> </a><a name="addAll-java.util.Collection-T...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>addAll</h4> <pre><a href="../../java/lang/SafeVarargs.html" title="annotation in java.lang">@SafeVarargs</a>
public static &lt;T&gt; boolean addAll(<a href="../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;? super T&gt; c,
                                              T... elements)</pre>
<div class="block">
<span>将所有指定的元素添加到指定的集合。</span>
<span>要添加的元素可以单独指定或作为数组指定。</span>
<span>这种方便方法的行为与c.addAll(Arrays.asList(elements)) <tt>相同</tt> ，但是在大多数实现中，这种方法可能会显着加快。</span>
<p> <span>单独指定元素时，此方法为现有集合添加一些元素提供了一种便捷的方法：</span> </p>
<pre>  <span>Collections.addAll(flavors, "Peaches 'n Plutonium", "Rocky Racoon");</span> </pre>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 要添加和收集的元素的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>c</code> - 要插入 
            <tt>elements的集合</tt>
</dd>
<dd>
<code>elements</code> - 要插入到 
            <tt>c</tt>的元素 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<tt>true</tt>如果集合由于调用而更改 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果 
            <tt>c</tt>不支持 
            <tt>add</tt>操作 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>elements</tt>包含一个或多个空值，并且 
            <tt>c</tt>不允许空元素，或者如果 
            <tt>c</tt>或 
            <tt>elements</tt>为 
            <tt>null</tt>
</dd>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果在 
            <tt>elements</tt>一个值的某些属性不允许它添加到 
            <tt>c</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/util/Collection.html#addAll-java.util.Collection-"><code>Collection.addAll(Collection)</code></a>
</dd>
</dl> </li>
</ul> <a name="newSetFromMap-java.util.Map-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newSetFromMap</h4> <pre>public static &lt;E&gt; <a href="../../java/util/Set.html" title="interface in java.util">Set</a>&lt;E&gt; newSetFromMap(<a href="../../java/util/Map.html" title="interface in java.util">Map</a>&lt;E,<a href="../../java/lang/Boolean.html" title="class in java.lang">Boolean</a>&gt; map)</pre>
<div class="block">
<span>返回由指定地图支持的集合。</span>
<span>结果集显示与背景映射相同的排序，并发和性能特征。</span>
<span>在本质上，此工厂方法提供了一种<a href="../../java/util/Set.html" title="java.util中的接口"><code>Set</code></a>对应于任何执行<a href="../../java/util/Map.html" title="java.util中的接口"><code>Map</code></a>实现。</span>
<span>已经有<a href="../../java/util/Set.html" title="java.util中的接口"><code>Set</code></a>实现（例如<a href="../../java/util/HashMap.html" title="java.util中的类"><code>HashMap</code></a>或<a href="../../java/util/TreeMap.html" title="java.util中的类"><code>TreeMap</code></a> ）的<a href="../../java/util/Map.html" title="java.util中的接口"><code>Map</code></a>实现没有必要使用此方法。</span>
<p> <span>在该方法返回的集合上的每个方法调用都会在后台映射或其<tt>keySet</tt>视图上完成一个方法调用，但有一个例外。</span> <span><tt>addAll</tt>方法在辅助地图上以<tt>put</tt>调用的顺序实现。</span> </p>
<p> <span>在调用此方法时，指定的映射必须为空，并且在此方法返回后不能直接访问。</span> <span>如果映射创建为空，直接传递给此方法，并且不保留对映射的引用，则保证这些条件，如以下代码片段所示：</span> </p>
<pre>  <span>Set&lt;Object&gt; weakHashSet = Collections.newSetFromMap(
        new WeakHashMap&lt;Object, Boolean&gt;());</span> </pre>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>E</code> - 映射键和返回集中的对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>map</code> - 支持地图 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             该集合由地图支持 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <tt>map</tt>不为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="asLifoQueue-java.util.Deque-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>asLifoQueue</h4> <pre>public static &lt;T&gt; <a href="../../java/util/Queue.html" title="interface in java.util">Queue</a>&lt;T&gt; asLifoQueue(<a href="../../java/util/Deque.html" title="interface in java.util">Deque</a>&lt;T&gt; deque)</pre>
<div class="block">
<span>返回<a href="../../java/util/Deque.html" title="java.util中的接口"><code>Deque</code></a>作为先进先出（ <a href="../../java/util/Queue.html" title="java.util中的接口">Lifo</a> ） <a href="../../java/util/Queue.html" title="java.util中的接口"><code>Queue</code>的视图</a> 。</span>
<span>方法<tt>add</tt>被映射到<tt><tt>push，remove</tt></tt>映射到<tt>pop</tt>等。</span>
<span>当您想使用需要<tt>Queue</tt>但需要<tt>Lifo</tt>订购的方法时，此视图可能很有用。</span>
<p> <span>通过此方法返回的队列上的每个方法调用都将在支持deque上完成一个方法调用，但有一个例外。</span> <span><a href="../../java/util/Collection.html#addAll-java.util.Collection-"><code>addAll</code></a>方法被实现为一个<code>addFirst</code>对支持deque的<a href="../../java/util/Deque.html#addFirst-E-">调用</a>的序列。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 在deque中的对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>deque</code> - deque 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             队列 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>