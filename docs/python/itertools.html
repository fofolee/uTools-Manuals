<div class="body" role="main"><div class="section" id="module-itertools"><h1><span class="yiyi-st" id="yiyi-10">10.1. <a class="reference internal" href="#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal"><span class="pre">itertools</span></code></a> — 为高效循环创建迭代器的函数</span></h1><p><span class="yiyi-st" id="yiyi-11">这个模块实现了许多基于APL，Haskell和SML构造的<a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term"> iterator </span></a>构建块。</span><span class="yiyi-st" id="yiyi-12">每一个都已经以适合Python的形式进行了重铸。</span></p><p><span class="yiyi-st" id="yiyi-13">该模块标准化了一套快速，高效的内存工具，这些工具本身或其组合都是有用的。</span><span class="yiyi-st" id="yiyi-14">它们一起构成了一个“迭代器代数”，可以在纯Python中简洁高效地构建专门的工具。</span></p><p><span class="yiyi-st" id="yiyi-15">对于实例，SML提供了一个列表工具：<code class="docutils literal"><span class="pre">tabulate（f）</span></code>，它产生一个序列<code class="docutils literal"><span class="pre">f(0),</span> <span class="pre">f(1),</span> <span class="pre">...</span></code>。</span><span class="yiyi-st" id="yiyi-16">同样的效果可以通过 Python 中 <a class="reference internal" href="functions.html#map" title="map"><code class="xref py py-func docutils literal"><span class="pre">map()</span></code></a> 和 <a class="reference internal" href="#itertools.count" title="itertools.count"><code class="xref py py-func docutils literal"><span class="pre">count()</span></code></a> 实现 <code class="docutils literal"><span class="pre">map(f,</span> <span class="pre">count())</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-17">这些工具和它们的内建对象也可以很好地处理<a class="reference internal" href="operator.html#module-operator" title="operator: Functions corresponding to the standard operators."><code class="xref py py-mod docutils literal"><span class="pre"> operator </span></code></a>模块中的高速函数。</span><span class="yiyi-st" id="yiyi-18">例如，可以将乘法操作符映射到两个向量上，形成一个有效的点积：<code class="docutils literal"><span class="pre">sum(map(operator.mul,</span> <span class="pre">vector1,</span> <span class="pre">vector2))</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-19"><strong>无限迭代器︰</strong></span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-20">迭代器</span></th><th class="head"><span class="yiyi-st" id="yiyi-21">参数</span></th><th class="head"><span class="yiyi-st" id="yiyi-22">结果</span></th><th class="head"><span class="yiyi-st" id="yiyi-23">例</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-24"><a class="reference internal" href="#itertools.count" title="itertools.count"><code class="xref py py-func docutils literal"><span class="pre">count()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-25">start, [step]</span></td><td><span class="yiyi-st" id="yiyi-26">start, start+step, start+2*step, ...</span></td><td><span class="yiyi-st" id="yiyi-27"><code class="docutils literal"><span class="pre">count(10)</span> <span class="pre">--&gt;</span> <span class="pre">10</span> <span class="pre">11</span> <span class="pre">12</span> <span class="pre">13</span> <span class="pre">14</span> <span class="pre">...</span></code></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-28"><a class="reference internal" href="#itertools.cycle" title="itertools.cycle"><code class="xref py py-func docutils literal"><span class="pre">cycle()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-29">p</span></td><td><span class="yiyi-st" id="yiyi-30">p0, p1, ... plast, p0, p1, ...</span></td><td><span class="yiyi-st" id="yiyi-31"><code class="docutils literal"><span class="pre">cycle('ABCD')</span> <span class="pre">--&gt;</span> <span class="pre">A</span> <span class="pre">B</span> <span class="pre">C</span> <span class="pre">D</span> <span class="pre">A</span> <span class="pre">B</span> <span class="pre">C</span> <span class="pre">D</span> <span class="pre">...</span></code></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-32"><a class="reference internal" href="#itertools.repeat" title="itertools.repeat"><code class="xref py py-func docutils literal"><span class="pre">repeat()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-33">elem [,n]</span></td><td><span class="yiyi-st" id="yiyi-34">elem, elem, elem, ... endlessly or up to n times</span></td><td><span class="yiyi-st" id="yiyi-35"><code class="docutils literal"><span class="pre">repeat(10,</span> <span class="pre">3)</span> <span class="pre">--&gt;</span> <span class="pre">10</span> <span class="pre">10</span> <span class="pre">10</span></code></span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-36"><strong>在最短输入序列上终止的迭代器：</strong></span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-37">迭代器</span></th><th class="head"><span class="yiyi-st" id="yiyi-38">参数</span></th><th class="head"><span class="yiyi-st" id="yiyi-39">结果</span></th><th class="head"><span class="yiyi-st" id="yiyi-40">例</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-41"><a class="reference internal" href="#itertools.accumulate" title="itertools.accumulate"><code class="xref py py-func docutils literal"><span class="pre">accumulate()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-42">p [,func]</span></td><td><span class="yiyi-st" id="yiyi-43">p0，p0 + p1，p0 + p1 + p2，...</span></td><td><span class="yiyi-st" id="yiyi-44"><code class="docutils literal"><span class="pre">accumulate([1,2,3,4,5])</span> <span class="pre">--&gt;</span> <span class="pre">1</span> <span class="pre">3</span> <span class="pre">6</span> <span class="pre">10</span> <span class="pre">15</span></code></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-45"><a class="reference internal" href="#itertools.chain" title="itertools.chain"><code class="xref py py-func docutils literal"><span class="pre">chain()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-46">p, q, ...</span></td><td><span class="yiyi-st" id="yiyi-47">p0，p1，... plast，q0，q1，...</span></td><td><span class="yiyi-st" id="yiyi-48"><code class="docutils literal"><span class="pre">chain('ABC',</span> <span class="pre">'DEF')</span> <span class="pre">--&gt;</span> <span class="pre">A</span> <span class="pre">B</span> <span class="pre">C</span> <span class="pre">D</span> <span class="pre">E</span> <span class="pre">F</span></code></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-49"><a class="reference internal" href="#itertools.chain.from_iterable" title="itertools.chain.from_iterable"><code class="xref py py-func docutils literal"><span class="pre">chain.from_iterable()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-50">iterable</span></td><td><span class="yiyi-st" id="yiyi-51">p0，p1，... plast，q0，q1，...</span></td><td><span class="yiyi-st" id="yiyi-52"><code class="docutils literal"><span class="pre">chain.from_iterable(['ABC',</span> <span class="pre">'DEF'])</span> <span class="pre">--&gt;</span> <span class="pre">A</span> <span class="pre">B</span> <span class="pre">C</span> <span class="pre">D</span> <span class="pre">E</span> <span class="pre">F</span></code></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-53"><a class="reference internal" href="#itertools.compress" title="itertools.compress"><code class="xref py py-func docutils literal"><span class="pre">compress()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-54">data, selectors</span></td><td><span class="yiyi-st" id="yiyi-55">(d[0] if s[0]), (d[1] if s[1]), ...</span></td><td><span class="yiyi-st" id="yiyi-56"><code class="docutils literal"><span class="pre">compress('ABCDEF',</span> <span class="pre">[1,0,1,0,1,1])</span> <span class="pre">--&gt;</span> <span class="pre">A</span> <span class="pre">C</span> <span class="pre">E</span> <span class="pre">F</span></code></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-57"><a class="reference internal" href="#itertools.dropwhile" title="itertools.dropwhile"><code class="xref py py-func docutils literal"><span class="pre">dropwhile()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-58">pred, seq</span></td><td><span class="yiyi-st" id="yiyi-59">seq[n], seq[n+1], starting when pred fails</span></td><td><span class="yiyi-st" id="yiyi-60"><code class="docutils literal"><span class="pre">dropwhile(lambda</span> <span class="pre">x:</span> <span class="pre">x&lt;5,</span> <span class="pre">[1,4,6,4,1])</span> <span class="pre">--&gt;</span> <span class="pre">6</span> <span class="pre">4</span> <span class="pre">1</span></code></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-61"><a class="reference internal" href="#itertools.filterfalse" title="itertools.filterfalse"><code class="xref py py-func docutils literal"><span class="pre">filterfalse()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-62">pred, seq</span></td><td><span class="yiyi-st" id="yiyi-63">elements of seq where pred(elem) is false</span></td><td><span class="yiyi-st" id="yiyi-64"><code class="docutils literal"><span class="pre">filterfalse(lambda</span> <span class="pre">x:</span> <span class="pre">x%2,</span> <span class="pre">range(10))</span> <span class="pre">--&gt;</span> <span class="pre">0</span> <span class="pre">2</span> <span class="pre">4</span> <span class="pre">6</span> <span class="pre">8</span></code></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-65"><a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><code class="xref py py-func docutils literal"><span class="pre">groupby()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-66">iterable[, keyfunc]</span></td><td><span class="yiyi-st" id="yiyi-67">sub-iterators grouped by value of keyfunc(v)</span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-68"><a class="reference internal" href="#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal"><span class="pre">islice()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-69">seq, [start,] stop [, step]</span></td><td><span class="yiyi-st" id="yiyi-70">elements from seq[start:stop:step]</span></td><td><span class="yiyi-st" id="yiyi-71"><code class="docutils literal"><span class="pre">islice('ABCDEFG',</span> <span class="pre">2,</span> <span class="pre">None)</span> <span class="pre">--&gt;</span> <span class="pre">C</span> <span class="pre">D</span> <span class="pre">E</span> <span class="pre">F</span> <span class="pre">G</span></code></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-72"><a class="reference internal" href="#itertools.starmap" title="itertools.starmap"><code class="xref py py-func docutils literal"><span class="pre">starmap()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-73">func, seq</span></td><td><span class="yiyi-st" id="yiyi-74">func(*seq[0]), func(*seq[1]), ...</span></td><td><span class="yiyi-st" id="yiyi-75"><code class="docutils literal"><span class="pre">starmap(pow,</span> <span class="pre">[(2,5),</span> <span class="pre">(3,2),</span> <span class="pre">(10,3)])</span> <span class="pre">--&gt;</span> <span class="pre">32</span> <span class="pre">9</span> <span class="pre">1000</span></code></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-76"><a class="reference internal" href="#itertools.takewhile" title="itertools.takewhile"><code class="xref py py-func docutils literal"><span class="pre">takewhile()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-77">pred, seq</span></td><td><span class="yiyi-st" id="yiyi-78">seq[0], seq[1], until pred fails</span></td><td><span class="yiyi-st" id="yiyi-79"><code class="docutils literal"><span class="pre">takewhile(lambda</span> <span class="pre">x:</span> <span class="pre">x&lt;5,</span> <span class="pre">[1,4,6,4,1])</span> <span class="pre">--&gt;</span> <span class="pre">1</span> <span class="pre">4</span></code></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-80"><a class="reference internal" href="#itertools.tee" title="itertools.tee"><code class="xref py py-func docutils literal"><span class="pre">tee()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-81">it, n</span></td><td><span class="yiyi-st" id="yiyi-82">it1, it2, ... itn splits one iterator into n</span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-83"><a class="reference internal" href="#itertools.zip_longest" title="itertools.zip_longest"><code class="xref py py-func docutils literal"><span class="pre">zip_longest()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-84">p, q, ...</span></td><td><span class="yiyi-st" id="yiyi-85">(p[0], q[0]), (p[1], q[1]), ...</span></td><td><span class="yiyi-st" id="yiyi-86"><code class="docutils literal"><span class="pre">zip_longest('ABCD',</span> <span class="pre">'xy',</span> <span class="pre">fillvalue='-')</span> <span class="pre">--&gt;</span> <span class="pre">Ax</span> <span class="pre">By</span> <span class="pre">C-</span> <span class="pre">D-</span></code></span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-87"><strong>组合生成器：</strong></span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-88">迭代器</span></th><th class="head"><span class="yiyi-st" id="yiyi-89">参数</span></th><th class="head"><span class="yiyi-st" id="yiyi-90">结果</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-91"><a class="reference internal" href="#itertools.product" title="itertools.product"><code class="xref py py-func docutils literal"><span class="pre">product()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-92">p, q, ... [repeat=1]</span></td><td><span class="yiyi-st" id="yiyi-93">笛卡尔积，相当于嵌套for循环</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-94"><a class="reference internal" href="#itertools.permutations" title="itertools.permutations"><code class="xref py py-func docutils literal"><span class="pre">permutations()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-95">p[, r]</span></td><td><span class="yiyi-st" id="yiyi-96">r长度元组，所有可能的顺序，没有重复的元素</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-97"><a class="reference internal" href="#itertools.combinations" title="itertools.combinations"><code class="xref py py-func docutils literal"><span class="pre">combinations()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-98">p, r</span></td><td><span class="yiyi-st" id="yiyi-99">r长度元组，按排序顺序，没有重复的元素</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-100"><a class="reference internal" href="#itertools.combinations_with_replacement" title="itertools.combinations_with_replacement"><code class="xref py py-func docutils literal"><span class="pre">combinations_with_replacement()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-101">p, r</span></td><td><span class="yiyi-st" id="yiyi-102">r长度元组，按排序顺序，重复元素</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-103"><code class="docutils literal"><span class="pre">product('ABCD',</span> <span class="pre">repeat=2)</span></code></span></td><td></td><td><span class="yiyi-st" id="yiyi-104"><code class="docutils literal"><span class="pre">AA</span> <span class="pre">AB</span> <span class="pre">AC</span> <span class="pre">AD</span> <span class="pre">BA</span> <span class="pre">BB</span> <span class="pre">BC</span> <span class="pre">BD</span> <span class="pre">CA</span> <span class="pre">CB</span> <span class="pre">CC</span> <span class="pre">CD</span> <span class="pre">DA</span> <span class="pre">DB</span> <span class="pre">DC</span> <span class="pre">DD</span></code></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-105"><code class="docutils literal"><span class="pre">permutations('ABCD',</span> <span class="pre">2)</span></code></span></td><td></td><td><span class="yiyi-st" id="yiyi-106"><code class="docutils literal"><span class="pre">AB</span> <span class="pre">AC</span> <span class="pre">AD</span> <span class="pre">BA</span> <span class="pre">BC</span> <span class="pre">BD</span> <span class="pre">CA</span> <span class="pre">CB</span> <span class="pre">CD</span> <span class="pre">DA</span> <span class="pre">DB</span> <span class="pre">DC</span></code></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-107"><code class="docutils literal"><span class="pre">combinations('ABCD',</span> <span class="pre">2)</span></code></span></td><td></td><td><span class="yiyi-st" id="yiyi-108"><code class="docutils literal"><span class="pre">AB</span> <span class="pre">AC</span> <span class="pre">AD</span> <span class="pre">BC</span> <span class="pre">BD</span> <span class="pre">CD</span></code></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-109"><code class="docutils literal"><span class="pre">combinations_with_replacement('ABCD',</span> <span class="pre">2)</span></code></span></td><td></td><td><span class="yiyi-st" id="yiyi-110"><code class="docutils literal"><span class="pre">AA</span> <span class="pre">AB</span> <span class="pre">AC</span> <span class="pre">AD</span> <span class="pre">BB</span> <span class="pre">BC</span> <span class="pre">BD</span> <span class="pre">CC</span> <span class="pre">CD</span> <span class="pre">DD</span></code></span></td></tr></tbody></table><div class="section" id="itertool-functions"><h2><span class="yiyi-st" id="yiyi-111">10.1.1.</span><span class="yiyi-st" id="yiyi-112">Itertool函数</span></h2><p><span class="yiyi-st" id="yiyi-113">以下的模块级别函数都构造并返回一个迭代对象。</span><span class="yiyi-st" id="yiyi-114">有些对象提供无限长的流，所以它们只能通过函数或者循环来截断它们。</span></p><dl class="function"><dt id="itertools.accumulate"><span class="yiyi-st" id="yiyi-115"><code class="descclassname">itertools.</code><code class="descname">accumulate</code><span class="sig-paren">(</span><em>iterable</em><span class="optional">[</span>, <em>func</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-116">创建的迭代对象返回被计算的sums值或者其它二元函数的结果(通过指定<em>func</em>参数)。</span><span class="yiyi-st" id="yiyi-117"><em>func</em>应该是接收两个参数的函数。</span><span class="yiyi-st" id="yiyi-118">输入<em>iterable</em>的元素可以是可以作为<em>func</em>的参数接受的任何类型。</span><span class="yiyi-st" id="yiyi-119">（例如，使用默认的加法操作，元素可以是任何可添加类型，包括<a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>或<a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal"><span class="pre">Fraction</span></code></a>。）</span><span class="yiyi-st" id="yiyi-120">如果输入iterable为空，则输出iterable也将为空。</span></p><p><span class="yiyi-st" id="yiyi-121">大致相当于：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">accumulate</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">):</span>
    <span class="s1">'Return running totals'</span>
    <span class="c1"># accumulate([1,2,3,4,5]) --&gt; 1 3 6 10 15</span>
    <span class="c1"># accumulate([1,2,3,4,5], operator.mul) --&gt; 1 2 6 24 120</span>
    <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">yield</span> <span class="n">total</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">total</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-122">对于<em>func</em>参数有许多用途。</span><span class="yiyi-st" id="yiyi-123">It can be set to <a class="reference internal" href="functions.html#min" title="min"><code class="xref py py-func docutils literal"><span class="pre">min()</span></code></a> for a running minimum, <a class="reference internal" href="functions.html#max" title="max"><code class="xref py py-func docutils literal"><span class="pre">max()</span></code></a> for a running maximum, or <a class="reference internal" href="operator.html#operator.mul" title="operator.mul"><code class="xref py py-func docutils literal"><span class="pre">operator.mul()</span></code></a> for a running product. </span><span class="yiyi-st" id="yiyi-124">摊销表可以通过累积利息和应用付款来构建。</span><span class="yiyi-st" id="yiyi-125">一阶<a class="reference external" href="https://en.wikipedia.org/wiki/Recurrence_relation">递归关系</a>可以通过在迭代中提供初始值并仅使用<em>func</em>参数中的累加总数来建模：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">accumulate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">))</span>     <span class="c1"># running product</span>
<span class="go">[3, 12, 72, 144, 144, 1296, 0, 0, 0, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">accumulate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">max</span><span class="p">))</span>              <span class="c1"># running maximum</span>
<span class="go">[3, 4, 6, 6, 6, 9, 9, 9, 9, 9]</span>

<span class="go"># Amortize a 5% loan of 1000 with 4 annual payments of 90</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cashflows</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">accumulate</span><span class="p">(</span><span class="n">cashflows</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">bal</span><span class="p">,</span> <span class="n">pmt</span><span class="p">:</span> <span class="n">bal</span><span class="o">*</span><span class="mf">1.05</span> <span class="o">+</span> <span class="n">pmt</span><span class="p">))</span>
<span class="go">[1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001]</span>

<span class="go"># Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logistic_map</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span>  <span class="n">r</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="mf">3.8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="mf">0.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inputs</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="mi">36</span><span class="p">)</span>     <span class="c1"># only the initial value is used</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">'.2f'</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">logistic_map</span><span class="p">)]</span>
<span class="go">['0.40', '0.91', '0.30', '0.81', '0.60', '0.92', '0.29', '0.79', '0.63',</span>
<span class="go"> '0.88', '0.39', '0.90', '0.33', '0.84', '0.52', '0.95', '0.18', '0.57',</span>
<span class="go"> '0.93', '0.25', '0.71', '0.79', '0.63', '0.88', '0.39', '0.91', '0.32',</span>
<span class="go"> '0.83', '0.54', '0.95', '0.20', '0.60', '0.91', '0.30', '0.80', '0.60']</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-126">有关仅返回最终累加值的类似函数，请参见<a class="reference internal" href="functools.html#functools.reduce" title="functools.reduce"><code class="xref py py-func docutils literal"><span class="pre">functools.reduce()</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-127"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-128"><span class="versionmodified">在版本3.3中已更改：</span>添加了可选的<em>func</em>参数。</span></p></div></dd></dl><dl class="function"><dt id="itertools.chain"><span class="yiyi-st" id="yiyi-129"><code class="descclassname">itertools.</code><code class="descname">chain</code><span class="sig-paren">(</span><em>*iterables</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-130">创建一个迭代器，从第一个迭代器返回元素，直到它耗尽，然后继续下一个迭代器，直到所有的迭代器都用尽。</span><span class="yiyi-st" id="yiyi-131">用于将连续序列作为单个序列处理。</span><span class="yiyi-st" id="yiyi-132">大致相当于：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">chain</span><span class="p">(</span><span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
    <span class="c1"># chain('ABC', 'DEF') --&gt; A B C D E F</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">element</span>
</pre></div></div></dd></dl><dl class="classmethod"><dt id="itertools.chain.from_iterable"><span class="yiyi-st" id="yiyi-133"> <em class="property">classmethod </em><code class="descclassname">chain.</code><code class="descname">from_iterable</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-134"><a class="reference internal" href="#itertools.chain" title="itertools.chain"><code class="xref py py-func docutils literal"><span class="pre">chain()</span></code></a>的替代构造函数。</span><span class="yiyi-st" id="yiyi-135">从一个可计算延迟的可迭代参数获取链接的输入。</span><span class="yiyi-st" id="yiyi-136">大致相当于：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">from_iterable</span><span class="p">(</span><span class="n">iterables</span><span class="p">):</span>
    <span class="c1"># chain.from_iterable(['ABC', 'DEF']) --&gt; A B C D E F</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">element</span>
</pre></div></div></dd></dl><dl class="function"><dt id="itertools.combinations"><span class="yiyi-st" id="yiyi-137"><code class="descclassname">itertools.</code><code class="descname">combinations</code><span class="sig-paren">(</span><em>iterable</em>, <em>r</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-138">从输入<em>可迭代</em>返回<em>r</em>个元素的长度子序列。</span></p><p><span class="yiyi-st" id="yiyi-139">组合以词典排序顺序发出。</span><span class="yiyi-st" id="yiyi-140">因此，如果输入<em>可迭代</em>被排序，则组合元组将以排序顺序产生。</span></p><p><span class="yiyi-st" id="yiyi-141">元素根据它们的位置而不是它们的值被视为唯一的。</span><span class="yiyi-st" id="yiyi-142">因此，如果输入元素是唯一的，则在每个组合中将不存在重复值。</span></p><p><span class="yiyi-st" id="yiyi-143">大致相当于：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">combinations</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="c1"># combinations('ABCD', 2) --&gt; AB AC AD BC BD CD</span>
    <span class="c1"># combinations(range(4), 3) --&gt; 012 013 023 123</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
    <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="n">r</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-144"><a class="reference internal" href="#itertools.combinations" title="itertools.combinations"><code class="xref py py-func docutils literal"><span class="pre">combinations()</span></code></a>的代码还可以在过滤条目之后被表示为<a class="reference internal" href="#itertools.permutations" title="itertools.permutations"><code class="xref py py-func docutils literal"><span class="pre">permutations()</span></code></a>的子序列，其中元素不是按照排序顺序（根据它们在输入中的位置池）：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">combinations</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-145">返回的项目数为<code class="docutils literal"><span class="pre">n！</span> <span class="pre">/</span> <span class="pre">r！</span> <span class="pre">/</span> <span class="pre">（nr）！ </span></code></span><span class="yiyi-st" id="yiyi-146">当<code class="docutils literal"><span class="pre">0</span> <span class="pre"> <span class="pre">r</span> <span class="pre"> <span class="pre">n</span>当<code class="docutils literal"><span class="pre">r</span> <span class="pre">&gt;</span> <span class="pre">n</span></code>时，t0&gt;或零。</span></span></code></span></p></dd></dl><dl class="function"><dt id="itertools.combinations_with_replacement"><span class="yiyi-st" id="yiyi-147"><code class="descclassname">itertools.</code><code class="descname">combinations_with_replacement</code><span class="sig-paren">(</span><em>iterable</em>, <em>r</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-148">从输入<em>可迭代</em>返回元素的<em>r</em>长度子序列，允许单个元素重复一次以上。</span></p><p><span class="yiyi-st" id="yiyi-149">组合以词典排序顺序发出。</span><span class="yiyi-st" id="yiyi-150">因此，如果输入<em>可迭代</em>被排序，则组合元组将以排序顺序产生。</span></p><p><span class="yiyi-st" id="yiyi-151">元素根据它们的位置而不是它们的值被视为唯一的。</span><span class="yiyi-st" id="yiyi-152">因此，如果输入元素是唯一的，则生成的组合也将是唯一的。</span></p><p><span class="yiyi-st" id="yiyi-153">大致相当于：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">combinations_with_replacement</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="c1"># combinations_with_replacement('ABC', 2) --&gt; AA AB AC BB BC CC</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">r</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span>
    <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-154"><a class="reference internal" href="#itertools.combinations_with_replacement" title="itertools.combinations_with_replacement"><code class="xref py py-func docutils literal"><span class="pre">combinations_with_replacement()</span></code></a>的代码也可以在过滤条目之后被表示为<a class="reference internal" href="#itertools.product" title="itertools.product"><code class="xref py py-func docutils literal"><span class="pre">product()</span></code></a>的子序列，其中元素不是按照排序顺序（根据它们在输入中的位置池）：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">combinations_with_replacement</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-155">The number of items returned is <code class="docutils literal"><span class="pre">(n+r-1)!</span> <span class="pre">/</span> <span class="pre">r!</span> <span class="pre">/</span> <span class="pre">(n-1)!</span></code></span><span class="yiyi-st" id="yiyi-156">当<code class="docutils literal"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>时。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-157"><span class="versionmodified">版本3.1中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="itertools.compress"><span class="yiyi-st" id="yiyi-158"><code class="descclassname">itertools.</code><code class="descname">compress</code><span class="sig-paren">(</span><em>data</em>, <em>selectors</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-159">创建一个迭代器，用于过滤<em>数据</em>中的元素，只返回在<em>选择器</em>中具有对应元素的元素，其计算结果为<code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-160">当<em>数据</em>或<em>选择器</em>迭代可用时停止。</span><span class="yiyi-st" id="yiyi-161">大致相当于：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">selectors</span><span class="p">):</span>
    <span class="c1"># compress('ABCDEF', [1,0,1,0,1,1]) --&gt; A C E F</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">selectors</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span><span class="p">)</span>
</pre></div></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-162"><span class="versionmodified">版本3.1中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="itertools.count"><span class="yiyi-st" id="yiyi-163"><code class="descclassname">itertools.</code><code class="descname">count</code><span class="sig-paren">(</span><em>start=0</em>, <em>step=1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-164">使迭代器以数字<em>开始</em>开始返回均匀间隔的值。</span><span class="yiyi-st" id="yiyi-165">通常用作<a class="reference internal" href="functions.html#map" title="map"><code class="xref py py-func docutils literal"><span class="pre">map()</span></code></a>的参数以生成连续的数据点。</span><span class="yiyi-st" id="yiyi-166">此外，与<a class="reference internal" href="functions.html#zip" title="zip"><code class="xref py py-func docutils literal"><span class="pre">zip()</span></code></a>一起使用可添加序列号。</span><span class="yiyi-st" id="yiyi-167">大致相当于：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># count(10) --&gt; 10 11 12 13 14 ...</span>
    <span class="c1"># count(2.5, 0.5) -&gt; 2.5 3.0 3.5 ...</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">start</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">n</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="n">step</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-168">When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: <code class="docutils literal"><span class="pre">(start</span> <span class="pre">+</span> <span class="pre">step</span> <span class="pre">*</span> <span class="pre">i</span> <span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">count())</span></code>.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-169"><span class="versionmodified">在版本3.1中已更改：</span>添加了<em>步骤</em>参数，并允许使用非整数参数。</span></p></div></dd></dl><dl class="function"><dt id="itertools.cycle"><span class="yiyi-st" id="yiyi-170"><code class="descclassname">itertools.</code><code class="descname">cycle</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-171">使迭代器从可迭代器返回元素并保存每个元素的副本。</span><span class="yiyi-st" id="yiyi-172">当iterable耗尽时，从保存的副本返回元素。</span><span class="yiyi-st" id="yiyi-173">重复无限。</span><span class="yiyi-st" id="yiyi-174">大致相当于：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cycle</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="c1"># cycle('ABCD') --&gt; A B C D A B C D A B C D ...</span>
    <span class="n">saved</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">element</span>
        <span class="n">saved</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">saved</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">saved</span><span class="p">:</span>
              <span class="k">yield</span> <span class="n">element</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-175">注意，工具包的这个成员可能需要大量的辅助存储（取决于可迭代的长度）。</span></p></dd></dl><dl class="function"><dt id="itertools.dropwhile"><span class="yiyi-st" id="yiyi-176"><code class="descclassname">itertools.</code><code class="descname">dropwhile</code><span class="sig-paren">(</span><em>predicate</em>, <em>iterable</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-177">创建一个迭代器，只要谓词为真，就从迭代中删除元素；之后，返回每个元素。</span><span class="yiyi-st" id="yiyi-178">注意，迭代器不会产生<em>任何</em>输出，直到谓词首次变为假，因此它可能有一个冗长的启动时间。</span><span class="yiyi-st" id="yiyi-179">大致相当于：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dropwhile</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
    <span class="c1"># dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1</span>
    <span class="n">iterable</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
            <span class="k">break</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">x</span>
</pre></div></div></dd></dl><dl class="function"><dt id="itertools.filterfalse"><span class="yiyi-st" id="yiyi-180"><code class="descclassname">itertools.</code><code class="descname">filterfalse</code><span class="sig-paren">(</span><em>predicate</em>, <em>iterable</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-181">创建一个迭代器，过滤可迭代元素，只返回谓词为<code class="docutils literal"><span class="pre">False</span></code>的元素。</span><span class="yiyi-st" id="yiyi-182">如果<em>谓词</em>是<code class="docutils literal"><span class="pre">None</span></code>，则返回false的项目。</span><span class="yiyi-st" id="yiyi-183">大致相当于：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">filterfalse</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
    <span class="c1"># filterfalse(lambda x: x%2, range(10)) --&gt; 0 2 4 6 8</span>
    <span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">predicate</span> <span class="o">=</span> <span class="nb">bool</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
</pre></div></div></dd></dl><dl class="function"><dt id="itertools.groupby"><span class="yiyi-st" id="yiyi-184"><code class="descclassname">itertools.</code><code class="descname">groupby</code><span class="sig-paren">(</span><em>iterable</em>, <em>key=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-185">创建一个迭代器，从<em>可迭代</em>返回连续的键和组。</span><span class="yiyi-st" id="yiyi-186"><em>键</em>是计算每个元素的键值的函数。</span><span class="yiyi-st" id="yiyi-187">如果未指定或<code class="docutils literal"><span class="pre">None</span></code>，则<em>键</em>默认为标识函数，并且不更改元素。</span><span class="yiyi-st" id="yiyi-188">通常，迭代需要已经在相同的键函数上排序。</span></p><p><span class="yiyi-st" id="yiyi-189"><a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><code class="xref py py-func docutils literal"><span class="pre">groupby()</span></code></a>的操作类似于Unix中的<code class="docutils literal"><span class="pre">uniq</span></code>过滤器。</span><span class="yiyi-st" id="yiyi-190">每当键函数的值发生变化时（这就是为什么通常需要使用相同的键函数对数据进行排序），它会生成一个断点或新的组。</span><span class="yiyi-st" id="yiyi-191">这种行为不同于SQL的GROUP BY，它集合了公共元素，而不考虑它们的输入顺序。</span></p><p><span class="yiyi-st" id="yiyi-192">返回的组本身是一个迭代器，它与<a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><code class="xref py py-func docutils literal"><span class="pre">groupby()</span></code></a>共享底层的可迭代器。</span><span class="yiyi-st" id="yiyi-193">因为源是共享的，所以当<a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><code class="xref py py-func docutils literal"><span class="pre">groupby()</span></code></a>对象高级时，先前的组不再可见。</span><span class="yiyi-st" id="yiyi-194">因此，如果以后需要该数据，则应将其存储为列表：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">uniquekeys</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">data</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">keyfunc</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">keyfunc</span><span class="p">):</span>
    <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>      <span class="c1"># Store group iterator as a list</span>
    <span class="n">uniquekeys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-195"><a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><code class="xref py py-func docutils literal"><span class="pre">groupby()</span></code></a>大致相当于：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">groupby</span><span class="p">:</span>
    <span class="c1"># [k for k, g in groupby('AAAABBBCCDAABBB')] --&gt; A B C D A B</span>
    <span class="c1"># [list(g) for k, g in groupby('AAAABBBCCD')] --&gt; AAAA BBB CC D</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyfunc</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tgtkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currvalue</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">currkey</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">tgtkey</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">currvalue</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">it</span><span class="p">)</span>    <span class="c1"># Exit on StopIteration</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">currkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyfunc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currvalue</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tgtkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currkey</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currkey</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grouper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tgtkey</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">_grouper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tgtkey</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">currkey</span> <span class="o">==</span> <span class="n">tgtkey</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">currvalue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">currvalue</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">it</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">currkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyfunc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currvalue</span><span class="p">)</span>
</pre></div></div></dd></dl><dl class="function"><dt id="itertools.islice"><span class="yiyi-st" id="yiyi-196"><code class="descclassname">itertools.</code><code class="descname">islice</code><span class="sig-paren">(</span><em>iterable</em>, <em>stop</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-197"><code class="descclassname">itertools.</code><code class="descname">islice</code><span class="sig-paren">(</span><em>iterable</em>, <em>start</em>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-198">让一个迭代器从它返回选定的元素。</span><span class="yiyi-st" id="yiyi-199">如果<em>start</em>不为零，则跳过来自可迭代的元素，直到达到开始。</span><span class="yiyi-st" id="yiyi-200">之后，连续返回元素，除非<em>步骤</em>设置为高于导致项目被跳过的元素。</span><span class="yiyi-st" id="yiyi-201">如果<em>停止</em>是<code class="docutils literal"><span class="pre">None</span></code>，则迭代继续，直到迭代器耗尽，如果有的话；否则，它停在指定位置。</span><span class="yiyi-st" id="yiyi-202">不像常规切片，<a class="reference internal" href="#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal"><span class="pre">islice()</span></code></a>不支持<em>开始</em>，<em>停止</em>或<em>步骤</em>的负值。</span><span class="yiyi-st" id="yiyi-203">可用于从内部结构已展平的数据中提取相关字段（例如，多行报告可在每第三行列出名称字段）。</span><span class="yiyi-st" id="yiyi-204">大致相当于：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">islice</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="c1"># islice('ABCDEFG', 2) --&gt; A B</span>
    <span class="c1"># islice('ABCDEFG', 2, 4) --&gt; C D</span>
    <span class="c1"># islice('ABCDEFG', 2, None) --&gt; C D E F G</span>
    <span class="c1"># islice('ABCDEFG', 0, None, 2) --&gt; A C E G</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">start</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">stop</span> <span class="ow">or</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">step</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">nexti</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">nexti</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">element</span>
            <span class="n">nexti</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-205">如果<em>开始</em>为<code class="docutils literal"><span class="pre">None</span></code>，则迭代从零开始。</span><span class="yiyi-st" id="yiyi-206">如果<em>步骤</em>为<code class="docutils literal"><span class="pre">None</span></code>，则步骤默认为一。</span></p></dd></dl><dl class="function"><dt id="itertools.permutations"><span class="yiyi-st" id="yiyi-207"><code class="descclassname">itertools.</code><code class="descname">permutations</code><span class="sig-paren">(</span><em>iterable</em>, <em>r=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-208">返回<em>可迭代</em>中的元素的连续<em>r</em>长度排列。</span></p><p><span class="yiyi-st" id="yiyi-209">如果<em>r</em>未指定或<code class="docutils literal"><span class="pre">None</span></code>，则<em>r</em>默认为<em>可迭代</em>的长度，长度排列。</span></p><p><span class="yiyi-st" id="yiyi-210">排列按照字典排序顺序排列。</span><span class="yiyi-st" id="yiyi-211">因此，如果输入<em>iterable</em>被排序，则排列元组将以排序顺序产生。</span></p><p><span class="yiyi-st" id="yiyi-212">元素根据它们的位置而不是它们的值被视为唯一的。</span><span class="yiyi-st" id="yiyi-213">因此，如果输入元素是唯一的，则在每个排列中将不存在重复值。</span></p><p><span class="yiyi-st" id="yiyi-214">大致相当于：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">permutations</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># permutations('ABCD', 2) --&gt; AB AC AD BA BC BD CA CB CD DA DB DC</span>
    <span class="c1"># permutations(range(3)) --&gt; 012 021 102 120 201 210</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">n</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">r</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">cycles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">r</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[:</span><span class="n">r</span><span class="p">])</span>
    <span class="k">while</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
            <span class="n">cycles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">cycles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">cycles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">cycles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="o">-</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="o">-</span><span class="n">j</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[:</span><span class="n">r</span><span class="p">])</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-215"><a class="reference internal" href="#itertools.permutations" title="itertools.permutations"><code class="xref py py-func docutils literal"><span class="pre">permutations()</span></code></a>的代码也可以表示为<a class="reference internal" href="#itertools.product" title="itertools.product"><code class="xref py py-func docutils literal"><span class="pre">product()</span></code></a>的子序列，被过滤以排除具有重复元素的条目（来自输入池中相同位置的条目） ：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">permutations</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">n</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">r</span>
    <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span> <span class="o">==</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-216">返回的项目数为<code class="docutils literal"><span class="pre">n！</span> <span class="pre">/</span> <span class="pre">（n-r）！</span></code></span><span class="yiyi-st" id="yiyi-217">当<code class="docutils literal"><span class="pre">0</span> <span class="pre"> <span class="pre">r</span> <span class="pre"> <span class="pre">n</span>当<code class="docutils literal"><span class="pre">r</span> <span class="pre">&gt;</span> <span class="pre">n</span></code>时，t0&gt;或零。</span></span></code></span></p></dd></dl><dl class="function"><dt id="itertools.product"><span class="yiyi-st" id="yiyi-218"><code class="descclassname">itertools.</code><code class="descname">product</code><span class="sig-paren">(</span><em>*iterables</em>, <em>repeat=1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-219">输入迭代的笛卡尔乘积。</span></p><p><span class="yiyi-st" id="yiyi-220">大致等同于生成器表达式中的嵌套for循环。</span><span class="yiyi-st" id="yiyi-221">例如，<code class="docutils literal"><span class="pre">乘积（A，</span> <span class="pre">B）</span></code>返回与<code class="docutils literal"><span class="pre">（（x，y）</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">A</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre"> in</span> <span class="pre">B）</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-222">嵌套循环像一个里程表，最右边的元素在每次迭代前进。</span><span class="yiyi-st" id="yiyi-223">此模式创建词典顺序，以便如果输入的iterable被排序，则产品元组按排序顺序发出。</span></p><p><span class="yiyi-st" id="yiyi-224">要计算迭代值与自身的乘积，请使用可选的<em>repeat</em>关键字参数指定重复次数。</span><span class="yiyi-st" id="yiyi-225">例如，<code class="docutils literal"><span class="pre">产品（A，</span> <span class="pre">repeat = 4）</span></code>表示与<code class="docutils literal"><span class="pre"><span class="pre">A，</span> <span class="pre">A，</span> <span class="pre">A）</span></span></code>。</span></p><p><span class="yiyi-st" id="yiyi-226">这个函数大致相当于下面的代码，除了实际的实现不会在内存中建立中间结果：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># product('ABCD', 'xy') --&gt; Ax Ay Bx By Cx Cy Dx Dy</span>
    <span class="c1"># product(range(2), repeat=3) --&gt; 000 001 010 011 100 101 110 111</span>
    <span class="n">pools</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span> <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span> <span class="o">*</span> <span class="n">repeat</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[[]]</span>
    <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="n">pools</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">pool</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span>
</pre></div></div></dd></dl><dl class="function"><dt id="itertools.repeat"><span class="yiyi-st" id="yiyi-227"><code class="descclassname">itertools.</code><code class="descname">repeat</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>times</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-228">创建一个反复返回<em>对象</em>的迭代器。</span><span class="yiyi-st" id="yiyi-229">除非指定<em>次</em>参数，否则无限期运行。</span><span class="yiyi-st" id="yiyi-230">用作<a class="reference internal" href="functions.html#map" title="map"><code class="xref py py-func docutils literal"><span class="pre">map()</span></code></a>的参数，用于调用函数的不变参数。</span><span class="yiyi-st" id="yiyi-231">还与<a class="reference internal" href="functions.html#zip" title="zip"><code class="xref py py-func docutils literal"><span class="pre">zip()</span></code></a>一起使用以创建元组记录的不变部分。</span></p><p><span class="yiyi-st" id="yiyi-232">大致相当于：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># repeat(10, 3) --&gt; 10 10 10</span>
    <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="nb">object</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
            <span class="k">yield</span> <span class="nb">object</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-233"><em>repeat</em>的常见用法是向<em>map</em>或<em>zip</em>提供常量值流：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">pow</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
<span class="go">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span>
</pre></div></div></dd></dl><dl class="function"><dt id="itertools.starmap"><span class="yiyi-st" id="yiyi-234"><code class="descclassname">itertools.</code><code class="descname">starmap</code><span class="sig-paren">(</span><em>function</em>, <em>iterable</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-235">创建一个迭代器，使用从可迭代获得的参数计算函数。</span><span class="yiyi-st" id="yiyi-236">当参数参数已经被分组到来自单个可迭代的元组（数据已经被“预压缩”）时，使用<a class="reference internal" href="functions.html#map" title="map"><code class="xref py py-func docutils literal"><span class="pre">map()</span></code></a>。</span><span class="yiyi-st" id="yiyi-237"><a class="reference internal" href="functions.html#map" title="map"><code class="xref py py-func docutils literal"><span class="pre">map()</span></code></a>和<a class="reference internal" href="#itertools.starmap" title="itertools.starmap"><code class="xref py py-func docutils literal"><span class="pre">starmap()</span></code></a>之间的区别与<code class="docutils literal"><span class="pre">function(a,b)</span></code>和<code class="docutils literal"><span class="pre">function(*c)</span></code>。</span><span class="yiyi-st" id="yiyi-238">大致相当于：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">starmap</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
    <span class="c1"># starmap(pow, [(2,5), (3,2), (10,3)]) --&gt; 32 9 1000</span>
    <span class="k">for</span> <span class="n">args</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div></div></dd></dl><dl class="function"><dt id="itertools.takewhile"><span class="yiyi-st" id="yiyi-239"><code class="descclassname">itertools.</code><code class="descname">takewhile</code><span class="sig-paren">(</span><em>predicate</em>, <em>iterable</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-240">创建一个迭代器，只要谓词为真，它就返回可迭代的元素。</span><span class="yiyi-st" id="yiyi-241">大致相当于：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">takewhile</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
    <span class="c1"># takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 1 4</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>
</pre></div></div></dd></dl><dl class="function"><dt id="itertools.tee"><span class="yiyi-st" id="yiyi-242"><code class="descclassname">itertools.</code><code class="descname">tee</code><span class="sig-paren">(</span><em>iterable</em>, <em>n=2</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-243">从单个可迭代中返回<em>n</em>独立迭代器。</span><span class="yiyi-st" id="yiyi-244">大致相当于：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">tee</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">deques</span> <span class="o">=</span> <span class="p">[</span><span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="n">mydeque</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mydeque</span><span class="p">:</span>             <span class="c1"># when the local deque is empty</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">newval</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>   <span class="c1"># fetch a new value and</span>
                <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">deques</span><span class="p">:</span>        <span class="c1"># load it to all the deques</span>
                    <span class="n">d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newval</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">mydeque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">gen</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">deques</span><span class="p">)</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-245">一旦<a class="reference internal" href="#itertools.tee" title="itertools.tee"><code class="xref py py-func docutils literal"><span class="pre">tee()</span></code></a>进行拆分，原始<em>可迭代</em>不应在任何其他地方使用；否则，<em>可迭代</em>可以获得高级，而无需通知三通对象。</span></p><p><span class="yiyi-st" id="yiyi-246">此itertool可能需要大量的辅助存储（取决于需要存储多少临时数据）。</span><span class="yiyi-st" id="yiyi-247">通常，如果一个迭代器在另一个迭代器开始之前使用大多数或所有数据，则使用<a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-func docutils literal"><span class="pre">list()</span></code></a>而不是<a class="reference internal" href="#itertools.tee" title="itertools.tee"><code class="xref py py-func docutils literal"><span class="pre">tee()</span></code></a>更快。</span></p></dd></dl><dl class="function"><dt id="itertools.zip_longest"><span class="yiyi-st" id="yiyi-248"><code class="descclassname">itertools.</code><code class="descname">zip_longest</code><span class="sig-paren">(</span><em>*iterables</em>, <em>fillvalue=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-249">创建一个迭代器，聚合来自每个迭代器的元素。</span><span class="yiyi-st" id="yiyi-250">如果迭代的长度不均匀，则缺少的值将被填充<em>fillvalue</em>。</span><span class="yiyi-st" id="yiyi-251">迭代继续，直到最长可迭代被耗尽。</span><span class="yiyi-st" id="yiyi-252">大致相当于：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ZipExhausted</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">zip_longest</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
    <span class="c1"># zip_longest('ABCD', 'xy', fillvalue='-') --&gt; Ax By C- D-</span>
    <span class="n">fillvalue</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'fillvalue'</span><span class="p">)</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">def</span> <span class="nf">sentinel</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">counter</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">counter</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ZipExhausted</span>
        <span class="n">counter</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">yield</span> <span class="n">fillvalue</span>
    <span class="n">fillers</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">fillvalue</span><span class="p">)</span>
    <span class="n">iterators</span> <span class="o">=</span> <span class="p">[</span><span class="n">chain</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">sentinel</span><span class="p">(),</span> <span class="n">fillers</span><span class="p">)</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">iterators</span><span class="p">:</span>
            <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">next</span><span class="p">,</span> <span class="n">iterators</span><span class="p">))</span>
    <span class="k">except</span> <span class="n">ZipExhausted</span><span class="p">:</span>
        <span class="k">pass</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-253">如果一个迭代可能是无限的，那么<a class="reference internal" href="#itertools.zip_longest" title="itertools.zip_longest"><code class="xref py py-func docutils literal"><span class="pre">zip_longest()</span></code></a>函数应该包含限制调用次数的东西（例如<a class="reference internal" href="#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal"><span class="pre">islice()</span></code></a>或<a class="reference internal" href="#itertools.takewhile" title="itertools.takewhile"><code class="xref py py-func docutils literal"><span class="pre">takewhile()</span></code></a>）。</span><span class="yiyi-st" id="yiyi-254">如果未指定，<em>fillvalue</em>默认为<code class="docutils literal"><span class="pre">None</span></code>。</span></p></dd></dl></div><div class="section" id="itertools-recipes"><h2><span class="yiyi-st" id="yiyi-255">10.1.2.</span><span class="yiyi-st" id="yiyi-256">Itertools食谱</span></h2><p><span class="yiyi-st" id="yiyi-257">此部分显示了使用现有itertools作为构造块创建扩展工具集的配方。</span></p><p><span class="yiyi-st" id="yiyi-258">扩展工具提供与底层工具集相同的高性能。</span><span class="yiyi-st" id="yiyi-259">优越的存储器性能通过一次一个处理元件来保持，而不是一次性地将整个可迭代器带入存储器。</span><span class="yiyi-st" id="yiyi-260">通过以有助于消除临时变量的功能样式将工具链接在一起，使代码量保持较小。</span><span class="yiyi-st" id="yiyi-261">在使用for循环和<a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>的情况下，通过优选“向量化”构造块来保持高速，这引起解释器开销。</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
    <span class="s2">"Return first n items of the iterable as a list"</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">tabulate</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="s2">"Return function(0), function(1), ..."</span>
    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">count</span><span class="p">(</span><span class="n">start</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">tail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
    <span class="s2">"Return an iterator over the last n items"</span>
    <span class="c1"># tail(3, 'ABCDEFG') --&gt; E F G</span>
    <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="n">n</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">consume</span><span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="s2">"Advance the iterator n-steps ahead. If n is none, consume entirely."</span>
    <span class="c1"># Use functions that consume iterators at C speed.</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># feed the entire iterator into a zero-length deque</span>
        <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># advance to the empty slice starting at position n</span>
        <span class="nb">next</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">nth</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="s2">"Returns the nth item or a default value"</span>
    <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">default</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">all_equal</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="s2">"Returns True if all the elements are equal to each other"</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">groupby</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">quantify</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">pred</span><span class="o">=</span><span class="nb">bool</span><span class="p">):</span>
    <span class="s2">"Count how many times the predicate is true"</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">iterable</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">padnone</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="sd">"""Returns the sequence elements and then returns None indefinitely.</span>

<span class="sd">    Useful for emulating the behavior of the built-in map() function.</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">chain</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">repeat</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">ncycles</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="s2">"Returns the sequence elements n times"</span>
    <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">),</span> <span class="n">n</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">dotproduct</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">listOfLists</span><span class="p">):</span>
    <span class="s2">"Flatten one level of nesting"</span>
    <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">listOfLists</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">repeatfunc</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">"""Repeat calls to func with specified arguments.</span>

<span class="sd">    Example:  repeatfunc(random.random)</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">starmap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">repeat</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">starmap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">repeat</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">times</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">pairwise</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="s2">"s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">tee</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="nb">next</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">grouper</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">fillvalue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="s2">"Collect data into fixed-length chunks or blocks"</span>
    <span class="c1"># grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">zip_longest</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">fillvalue</span><span class="o">=</span><span class="n">fillvalue</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">roundrobin</span><span class="p">(</span><span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
    <span class="s2">"roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"</span>
    <span class="c1"># Recipe credited to George Sakkis</span>
    <span class="n">pending</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">iterables</span><span class="p">)</span>
    <span class="n">nexts</span> <span class="o">=</span> <span class="n">cycle</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">it</span><span class="p">)</span><span class="o">.</span><span class="n">__next__</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">pending</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="nb">next</span> <span class="ow">in</span> <span class="n">nexts</span><span class="p">:</span>
                <span class="k">yield</span> <span class="nb">next</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="n">pending</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">nexts</span> <span class="o">=</span> <span class="n">cycle</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">nexts</span><span class="p">,</span> <span class="n">pending</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
    <span class="s1">'Use a predicate to partition entries into false entries and true entries'</span>
    <span class="c1"># partition(is_odd, range(10)) --&gt; 0 2 4 6 8   and  1 3 5 7 9</span>
    <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">tee</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">filterfalse</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">t1</span><span class="p">),</span> <span class="nb">filter</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">powerset</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="s2">"powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">unique_everseen</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="s2">"List unique elements, preserving order. Remember all elements ever seen."</span>
    <span class="c1"># unique_everseen('AAAABBBCCDAABBB') --&gt; A B C D</span>
    <span class="c1"># unique_everseen('ABBCcAD', str.lower) --&gt; A B C D</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">seen_add</span> <span class="o">=</span> <span class="n">seen</span><span class="o">.</span><span class="n">add</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">filterfalse</span><span class="p">(</span><span class="n">seen</span><span class="o">.</span><span class="n">__contains__</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
            <span class="n">seen_add</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">element</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">key</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="n">seen_add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">element</span>

<span class="k">def</span> <span class="nf">unique_justseen</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="s2">"List unique elements, preserving order. Remember only the element just seen."</span>
    <span class="c1"># unique_justseen('AAAABBBCCDAABBB') --&gt; A B C D A B</span>
    <span class="c1"># unique_justseen('ABBCcAD', str.lower) --&gt; A B C A D</span>
    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="nb">next</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">groupby</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">key</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">iter_except</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">exception</span><span class="p">,</span> <span class="n">first</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">""" Call a function repeatedly until an exception is raised.</span>

<span class="sd">    Converts a call-until-exception interface to an iterator interface.</span>
<span class="sd">    Like builtins.iter(func, sentinel) but uses an exception instead</span>
<span class="sd">    of a sentinel to end the loop.</span>

<span class="sd">    Examples:</span>
<span class="sd">        iter_except(functools.partial(heappop, h), IndexError)   # priority queue iterator</span>
<span class="sd">        iter_except(d.popitem, KeyError)                         # non-blocking dict iterator</span>
<span class="sd">        iter_except(d.popleft, IndexError)                       # non-blocking deque iterator</span>
<span class="sd">        iter_except(q.get_nowait, Queue.Empty)                   # loop over a producer Queue</span>
<span class="sd">        iter_except(s.pop, KeyError)                             # non-blocking set iterator</span>

<span class="sd">    """</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">first</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">first</span><span class="p">()</span>            <span class="c1"># For database APIs needing an initial cast to db.first()</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">func</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">exception</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="k">def</span> <span class="nf">first_true</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pred</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""Returns the first true value in the iterable.</span>

<span class="sd">    If no true value is found, returns *default*</span>

<span class="sd">    If *pred* is not None, returns the first item</span>
<span class="sd">    for which pred(item) is true.</span>

<span class="sd">    """</span>
    <span class="c1"># first_true([a,b,c], x) --&gt; a or b or c or x</span>
    <span class="c1"># first_true([a,b], x, f) --&gt; a if f(a) else b if f(b) else x</span>
    <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">iterable</span><span class="p">),</span> <span class="n">default</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">random_product</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="s2">"Random selection from itertools.product(*args, **kwds)"</span>
    <span class="n">pools</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span> <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span> <span class="o">*</span> <span class="n">repeat</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span> <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="n">pools</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">random_permutation</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="s2">"Random selection from itertools.permutations(iterable, r)"</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">r</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">random_combination</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="s2">"Random selection from itertools.combinations(iterable, r)"</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">r</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">random_combination_with_replacement</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="s2">"Random selection from itertools.combinations_with_replacement(iterable, r)"</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-262">注意，许多上述配方可以通过用定义为默认值的局部变量替换全局查找来优化。</span><span class="yiyi-st" id="yiyi-263">例如，<em>dotproduct</em>配方可以写为：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dotproduct</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">,</span> <span class="nb">sum</span><span class="o">=</span><span class="nb">sum</span><span class="p">,</span> <span class="nb">map</span><span class="o">=</span><span class="nb">map</span><span class="p">,</span> <span class="n">mul</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">))</span>
</pre></div></div></div></div></div>