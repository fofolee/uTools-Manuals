<div class="body" role="main"><div class="section" id="module-base64"><h1><span class="yiyi-st" id="yiyi-10">19.6. <a class="reference internal" href="#module-base64" title="base64: RFC 3548: Base16, Base32, Base64 Data Encodings; Base85 and Ascii85"><code class="xref py py-mod docutils literal"><span class="pre">base64</span></code></a>  -  Base16，Base32，Base64，Base85数据编码</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/base64.py">Lib/base64.py</a></span></p><p><span class="yiyi-st" id="yiyi-12">此模块提供将二进制数据编码为可打印ASCII字符并将此类编码解码回二进制数据的功能。</span><span class="yiyi-st" id="yiyi-13">它为在<span class="target" id="index-1"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc3548.html"><strong>RFC 3548</strong></a>中指定的编码提供编码和解码功能，该编码定义了Base16，Base32和Base64算法，以及事实上的标准Ascii85和Base85编码。</span></p><p><span class="yiyi-st" id="yiyi-14"><span class="target" id="index-2"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc3548.html"><strong>RFC 3548</strong></a>编码适用于编码二进制数据，以便它可以安全地通过电子邮件发送，用作URL的一部分，或作为HTTP POST请求的一部分。</span><span class="yiyi-st" id="yiyi-15">其编码算法与<strong class="program">uuencode</strong>程序不同。</span></p><p><span class="yiyi-st" id="yiyi-16">此模块提供两个接口。</span><span class="yiyi-st" id="yiyi-17">现代接口支持将<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">类字节对象</span></a>编码为ASCII<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">字节</span></code></a>，以及将<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">类字节对象</span></a>或包含ASCII的字符串解码为<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">字节</span></code></a>。</span><span class="yiyi-st" id="yiyi-18"><span class="target" id="index-3"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3548.html"><strong>RFC 3548</strong></a>中定义的两个基本64字母表（普通字母表，和URL及文件系统安全的字母表）都支持。</span></p><p><span class="yiyi-st" id="yiyi-19">传统接口不支持从字符串进行解码，但它提供从<a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">文件对象</span></a>编码和解码的功能。</span><span class="yiyi-st" id="yiyi-20">它仅支持Base64标准字母表，并根据<span class="target" id="index-4"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2045.html"><strong>RFC 2045</strong></a>每76个字符添加换行符。</span><span class="yiyi-st" id="yiyi-21">请注意，如果你要查找<span class="target" id="index-5"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2045.html"><strong>RFC 2045</strong></a>支持，你可能希望查看<a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages, including MIME documents."><code class="xref py py-mod docutils literal"><span class="pre">email</span></code></a>包。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-22"><span class="versionmodified">在版本3.3中更改：</span>现代接口的解码函数现在接受ASCII-only的Unicode字符串。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-23"><span class="versionmodified">在版本3.4中更改：</span>现在此模块中的所有编码和解码函数接受任何<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">类字节对象</span></a>。</span><span class="yiyi-st" id="yiyi-24">添加对Ascii85/Base85的支持。</span></p></div><p><span class="yiyi-st" id="yiyi-25">现代接口提供：</span></p><dl class="function"><dt id="base64.b64encode"><span class="yiyi-st" id="yiyi-26"><code class="descclassname">base64.</code><code class="descname">b64encode</code><span class="sig-paren">(</span><em>s</em>, <em>altchars=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-27">使用Base64编码<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">类字节对象</span></a><em>s</em>，并返回编码后的<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">字节</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-28">可选的<em>altchars</em>必须是一个<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">类字节对象</span></a>，长度至少为2（忽略其他字符），它指定<code class="docutils literal"><span class="pre">+</span></code>和<code class="docutils literal"><span class="pre">/</span></code>字符的替代字母。</span><span class="yiyi-st" id="yiyi-29">这允许应用</span><span class="yiyi-st" id="yiyi-30">生成URL或文件系统安全的Base64字符串。</span><span class="yiyi-st" id="yiyi-31">默认值为<code class="docutils literal"><span class="pre">None</span></code>，使用标准的Base64字母表。</span></p></dd></dl><dl class="function"><dt id="base64.b64decode"><span class="yiyi-st" id="yiyi-32"><code class="descclassname">base64.</code><code class="descname">b64decode</code><span class="sig-paren">(</span><em>s</em>, <em>altchars=None</em>, <em>validate=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-33">解码Base64编码的<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">类字节对象</span></a>或ASCII字符串<em>s</em>并返回解码的<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">字节</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-34">可选的<em>altchars</em>必须是一个<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">类字节对象</span></a>，长度至少为2（忽略其他字符），它指定<code class="docutils literal"><span class="pre">+</span></code>和<code class="docutils literal"><span class="pre">/</span></code>字符的替代字母。</span></p><p><span class="yiyi-st" id="yiyi-35">如果<em>s</em>未正确填充，则引发<a class="reference internal" href="binascii.html#binascii.Error" title="binascii.Error"><code class="xref py py-exc docutils literal"><span class="pre">binascii.Error</span></code></a>异常。</span></p><p><span class="yiyi-st" id="yiyi-36">如果<em>validate</em>是<code class="docutils literal"><span class="pre">False</span></code>（默认值），则在填充检查之前，将不在正常base-64字母表中或替代字母表中的字符丢弃。</span><span class="yiyi-st" id="yiyi-37">如果<em>validate</em>是<code class="docutils literal"><span class="pre">True</span></code>，则输入中的这些非字母字符会导致<a class="reference internal" href="binascii.html#binascii.Error" title="binascii.Error"><code class="xref py py-exc docutils literal"><span class="pre">binascii.Error</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="base64.standard_b64encode"><span class="yiyi-st" id="yiyi-38"><code class="descclassname">base64.</code><code class="descname">standard_b64encode</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-39">使用标准的Base64字母表编码<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">类字节对象</span></a> <em>s</em>并返回编码的<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">字节</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="base64.standard_b64decode"><span class="yiyi-st" id="yiyi-40"><code class="descclassname">base64.</code><code class="descname">standard_b64decode</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-41">使用标准的Base64字母表解码<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">类字节对象</span></a>或ASCII字符串<em>s</em>并返回解码的<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">字节</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="base64.urlsafe_b64encode"><span class="yiyi-st" id="yiyi-42"><code class="descclassname">base64.</code><code class="descname">urlsafe_b64encode</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-43">使用URL和文件系统安全的字母表编码<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">类字节对象</span></a><em>s</em>，它用<code class="docutils literal"><span class="pre">-</span></code>和<code class="docutils literal"><span class="pre">_</span></code>分别替换标准的Base64字母表中的<code class="docutils literal"><span class="pre">+</span></code>和<code class="docutils literal"><span class="pre">/</span></code>，并返回编码的<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">字节</span></code></a>。</span><span class="yiyi-st" id="yiyi-44">结果仍可包含<code class="docutils literal"><span class="pre">=</span></code>。</span></p></dd></dl><dl class="function"><dt id="base64.urlsafe_b64decode"><span class="yiyi-st" id="yiyi-45"><code class="descclassname">base64.</code><code class="descname">urlsafe_b64decode</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-46">使用URL及文件系统安全的字母表解码<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">类字节对象</span></a>或ASCII字符串<em>s</em>，它将标准Base64字母表中的<code class="docutils literal"><span class="pre">+</span></code>替换为<code class="docutils literal"><span class="pre">-</span></code>、<code class="docutils literal"><span class="pre">/</span></code>替换为<code class="docutils literal"><span class="pre">_</span></code>，并返回解码后的<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">字节</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="base64.b32encode"><span class="yiyi-st" id="yiyi-47"><code class="descclassname">base64.</code><code class="descname">b32encode</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-48">使用Base32编码<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">类字节对象</span></a><em>s</em>并返回编码后的<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">字节</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="base64.b32decode"><span class="yiyi-st" id="yiyi-49"><code class="descclassname">base64.</code><code class="descname">b32decode</code><span class="sig-paren">(</span><em>s</em>, <em>casefold=False</em>, <em>map01=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-50">解码Base32编码的<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>或ASCII字符串<em>s</em>并返回解码的<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-51">可选<em>casefold</em>是指定是否可接受小写字母作为输入的标志。</span><span class="yiyi-st" id="yiyi-52">出于安全考虑，默认值为<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-53"><span class="target" id="index-6"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc3548.html"><strong>RFC 3548</strong></a>允许将数字0（零）可选地映射到字母O（oh），并且可选地将数字1（一）映射到字母I（eye）或字母L（el）。</span><span class="yiyi-st" id="yiyi-54">可选参数<em>map01</em>不为<code class="docutils literal"><span class="pre">None</span></code>时，指定数字1应映射到哪个字母（当<em>map01</em>不为<code class="docutils literal"><span class="pre">None</span></code>时，数字0始终映射到字母O）。</span><span class="yiyi-st" id="yiyi-55">为了安全起见，默认值为<code class="docutils literal"><span class="pre">None</span></code>，因此输入中不允许0和1。</span></p><p><span class="yiyi-st" id="yiyi-56">如果<em>s</em>未正确填充或输入中存在非字母字符，则会引发<a class="reference internal" href="binascii.html#binascii.Error" title="binascii.Error"><code class="xref py py-exc docutils literal"><span class="pre">binascii.Error</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="base64.b16encode"><span class="yiyi-st" id="yiyi-57"><code class="descclassname">base64.</code><code class="descname">b16encode</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-58">使用Base16编码<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> <em>s</em>并返回编码的<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="base64.b16decode"><span class="yiyi-st" id="yiyi-59"><code class="descclassname">base64.</code><code class="descname">b16decode</code><span class="sig-paren">(</span><em>s</em>, <em>casefold=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-60">解码Base16编码的<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>或ASCII字符串<em>s</em>并返回解码的<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-61">可选<em>casefold</em>是指定是否可接受小写字母作为输入的标志。</span><span class="yiyi-st" id="yiyi-62">出于安全考虑，默认值为<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-63">如果<em>s</em>未正确填充或输入中存在非字母字符，则会引发<a class="reference internal" href="binascii.html#binascii.Error" title="binascii.Error"><code class="xref py py-exc docutils literal"><span class="pre">binascii.Error</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="base64.a85encode"><span class="yiyi-st" id="yiyi-64"><code class="descclassname">base64.</code><code class="descname">a85encode</code><span class="sig-paren">(</span><em>b</em>, <em>*</em>, <em>foldspaces=False</em>, <em>wrapcol=0</em>, <em>pad=False</em>, <em>adobe=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-65">使用Ascii85编码<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> <em>b</em>并返回编码的<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-66"><em>折叠空间</em>是一个可选标志，使用特殊短序列“y”，而不是“btoa”支持的4个连续空格（ASCII 0x20）。</span><span class="yiyi-st" id="yiyi-67">“标准”Ascii85编码不支持此功能。</span></p><p><span class="yiyi-st" id="yiyi-68"><em>wrapcol</em>控制输出是否应该添加换行符（<code class="docutils literal"><span class="pre">b'\n'</span></code>）。</span><span class="yiyi-st" id="yiyi-69">如果这是非零，每个输出行将最多这个许多字符长。</span></p><p><span class="yiyi-st" id="yiyi-70"><em>pad</em>控制输入在编码之前是否填充为4的倍数。</span><span class="yiyi-st" id="yiyi-71">注意，<code class="docutils literal"><span class="pre">btoa</span></code>实现总是垫。</span></p><p><span class="yiyi-st" id="yiyi-72"><em>adobe</em>控制编码后的字节序列是否用<code class="docutils literal"><span class="pre">&lt;~</span></code> and <code class="docutils literal"><span class="pre">~&gt;</span></code>包围，用于Adobe实现。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-73"><span class="versionmodified">新版本3.4。</span></span></p></div></dd></dl><dl class="function"><dt id="base64.a85decode"><span class="yiyi-st" id="yiyi-74"><code class="descclassname">base64.</code><code class="descname">a85decode</code><span class="sig-paren">(</span><em>b</em>, <em>*</em>, <em>foldspaces=False</em>, <em>adobe=False</em>, <em>ignorechars=b' \t\n\r\v'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-75">解码Ascii85编码的<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>或ASCII字符串<em>b</em>并返回解码的<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-76"><em>折叠空间</em>是指定是否应接受“y”短序列作为4个连续空格（ASCII 0x20）的缩写的标志。</span><span class="yiyi-st" id="yiyi-77">“标准”Ascii85编码不支持此功能。</span></p><p><span class="yiyi-st" id="yiyi-78"><em>adobe</em>控制输入序列是否为Adobe Ascii85格式（即</span><span class="yiyi-st" id="yiyi-79">框架）。</span></p><p><span class="yiyi-st" id="yiyi-80"><em>ignorechars</em>应为<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>或包含要从输入忽略的字符的ASCII字符串。</span><span class="yiyi-st" id="yiyi-81">这应该只包含空格字符，并且默认包含ASCII中的所有空格字符。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-82"><span class="versionmodified">新版本3.4。</span></span></p></div></dd></dl><dl class="function"><dt id="base64.b85encode"><span class="yiyi-st" id="yiyi-83"><code class="descclassname">base64.</code><code class="descname">b85encode</code><span class="sig-paren">(</span><em>b</em>, <em>pad=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-84">使用base85编码<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> <em>b</em>（如</span><span class="yiyi-st" id="yiyi-85">git-style binary diffs）并返回编码的<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-86">如果<em>pad</em>为真，则输入用<code class="docutils literal"><span class="pre">b'\0'</span></code>填充，因此其长度是编码前的4个字节的倍数。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-87"><span class="versionmodified">新版本3.4。</span></span></p></div></dd></dl><dl class="function"><dt id="base64.b85decode"><span class="yiyi-st" id="yiyi-88"><code class="descclassname">base64.</code><code class="descname">b85decode</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-89">解码base85编码的<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>或ASCII字符串<em>b</em>并返回解码的<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>。</span><span class="yiyi-st" id="yiyi-90">如果需要，隐含地删除填充。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-91"><span class="versionmodified">新版本3.4。</span></span></p></div></dd></dl><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-92">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-93">Base85和Ascii85都有5到4的扩展因子（5个Base85或Ascii85字符可以编码4个二进制字节），而更好的Base64扩展因子为6到4。</span><span class="yiyi-st" id="yiyi-94">因此，当空间昂贵时，它们更有效。</span><span class="yiyi-st" id="yiyi-95">它们因细节（例如用于编码的字符映射）而不同。</span></p></div><p><span class="yiyi-st" id="yiyi-96">传统接口：</span></p><dl class="function"><dt id="base64.decode"><span class="yiyi-st" id="yiyi-97"><code class="descclassname">base64.</code><code class="descname">decode</code><span class="sig-paren">(</span><em>input</em>, <em>output</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-98">解码二进制<em>输入</em>文件的内容，并将生成的二进制数据写入<em>输出</em>文件。</span><span class="yiyi-st" id="yiyi-99"><em>输入</em>和<em>输出</em>必须是<a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file objects</span></a>。</span><span class="yiyi-st" id="yiyi-100"><em>输入</em>将被读取，直到<code class="docutils literal"><span class="pre">input.readline()</span></code>返回一个空字节对象。</span></p></dd></dl><dl class="function"><dt id="base64.decodebytes"><span class="yiyi-st" id="yiyi-101"><code class="descclassname">base64.</code><code class="descname">decodebytes</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span></span></dt><dt id="base64.decodestring"><span class="yiyi-st" id="yiyi-102"><code class="descclassname">base64.</code><code class="descname">decodestring</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-103">解码<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> <em>s</em>，其中必须包含一行或多行base64编码数据，并返回解码的<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>。</span><span class="yiyi-st" id="yiyi-104"><code class="docutils literal"><span class="pre">decodestring</span></code>是一个已弃用的别名。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-105"><span class="versionmodified">版本3.1中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="base64.encode"><span class="yiyi-st" id="yiyi-106"><code class="descclassname">base64.</code><code class="descname">encode</code><span class="sig-paren">(</span><em>input</em>, <em>output</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-107">编码二进制<em>输入</em>文件的内容，并将生成的base64编码数据写入<em>输出</em>文件。</span><span class="yiyi-st" id="yiyi-108"><em>输入</em>和<em>输出</em>必须是<a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file objects</span></a>。</span><span class="yiyi-st" id="yiyi-109"><em>输入</em>将被读取，直到<code class="docutils literal"><span class="pre">input.read()</span></code>返回一个空字节对象。</span><span class="yiyi-st" id="yiyi-110"><a class="reference internal" href="#base64.encode" title="base64.encode"><code class="xref py py-func docutils literal"><span class="pre">encode()</span></code></a>在输出的每76个字节后插入一个换行符（<code class="docutils literal"><span class="pre">b'\n'</span></code>），以及确保输出总是以换行符结束每<span class="target" id="index-7"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2045.html"><strong>RFC 2045</strong></a>（MIME）。</span></p></dd></dl><dl class="function"><dt id="base64.encodebytes"><span class="yiyi-st" id="yiyi-111"><code class="descclassname">base64.</code><code class="descname">encodebytes</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span></span></dt><dt id="base64.encodestring"><span class="yiyi-st" id="yiyi-112"><code class="descclassname">base64.</code><code class="descname">encodestring</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-113">编码<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">类字节对象</span></a><em>s</em>，它可以包含任意二进制数据，并返回base64编码数据的<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">字节</span></code></a>，根据<span class="target" id="index-8"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2045.html"><strong>RFC 2045</strong></a> （MIME），在输出的每76个字节之后插入换行符（<code class="docutils literal"><span class="pre">b'\n'</span></code>），并确保末尾有一个换行符。</span></p><p><span class="yiyi-st" id="yiyi-114"><code class="docutils literal"><span class="pre">encodestring</span></code>是已弃用的别名。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-115">模块的示例用法：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">base64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoded</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64encode</span><span class="p">(</span><span class="n">b</span><span class="s1">'data to be encoded'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoded</span>
<span class="go">b'ZGF0YSB0byBiZSBlbmNvZGVk'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">b'data to be encoded'</span>
</pre></div></div><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-116">也可以看看</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-117">模块<a class="reference internal" href="binascii.html#module-binascii" title="binascii: Tools for converting between binary and various ASCII-encoded binary representations."><code class="xref py py-mod docutils literal"><span class="pre">binascii</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-118">支持模块包含ASCII到二进制和二进制到ASCII转换。</span></dd><dt><span class="yiyi-st" id="yiyi-119"><span class="target" id="index-9"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc1521.html"><strong>RFC 1521</strong></a>  -  MIME（多用途互联网邮件扩展）第一部分：指定和描述互联网消息机构格式的机制</span></dt><dd><span class="yiyi-st" id="yiyi-120">第5.2节“Base64内容传输编码”提供了base64编码的定义。</span></dd></dl></div></div></div>