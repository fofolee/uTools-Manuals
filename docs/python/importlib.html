<div class="body" role="main"><div class="section" id="module-importlib"><h1><span class="yiyi-st" id="yiyi-10">31.5. <a class="reference internal" href="#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal"><span class="pre">importlib</span></code></a> —— <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 的实现 </span></h1><div class="versionadded"><p><span class="yiyi-st" id="yiyi-11"><span class="versionmodified">版本3.1中的新功能。</span></span></p></div><p><span class="yiyi-st" id="yiyi-12"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/importlib/__init__.py">Lib/importlib/__init__.py</a></span></p><div class="section" id="introduction"><h2><span class="yiyi-st" id="yiyi-13">31.5.1. </span><span class="yiyi-st" id="yiyi-14">引言</span></h2><p><span class="yiyi-st" id="yiyi-15"><a class="reference internal" href="#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal"><span class="pre">importlib</span></code></a> 包有两种目的。</span><span class="yiyi-st" id="yiyi-16">一是提供Python源代码中<a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a>语句（和扩展，如 <a class="reference internal" href="functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> 函数）的实现。</span><span class="yiyi-st" id="yiyi-17">这里提供的 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 的实现可以移植到任何 Python 解释器。</span><span class="yiyi-st" id="yiyi-18">这里提供的实现比非 Python 编程语言的实现更容易理解。</span></p><p><span class="yiyi-st" id="yiyi-19">二是实现<a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a>的组件在此包中公开，使用户更容易创建自己的自定义对象（通常称为<a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>）以参与导入过程。</span></p><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-20">另见</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-21"><a class="reference internal" href="../reference/simple_stmts.html#import"><span>The import statement</span></a></span></dt><dd><span class="yiyi-st" id="yiyi-22"><a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a>语句的语言参考。</span></dd><dt><span class="yiyi-st" id="yiyi-23"><a class="reference external" href="http://legacy.python.org/doc/essays/packages.html">包规范</a></span></dt><dd><span class="yiyi-st" id="yiyi-24">包装的原始规格。</span><span class="yiyi-st" id="yiyi-25">自此文档编写以来，一些语义已发生变化（例如，</span><span class="yiyi-st" id="yiyi-26">基于<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a>中<code class="docutils literal"><span class="pre">None</span></code>的重定向）。</span></dd><dt><span class="yiyi-st" id="yiyi-27"><a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a>函数</span></dt><dd><span class="yiyi-st" id="yiyi-28"><a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a>语句是该函数的语法糖。</span></dd><dt><span class="yiyi-st" id="yiyi-29"><span class="target" id="index-0"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0235"><strong>PEP 235</strong></a></span></dt><dd><span class="yiyi-st" id="yiyi-30">在不区分大小写的平台上导入</span></dd><dt><span class="yiyi-st" id="yiyi-31"><span class="target" id="index-1"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0263"><strong>PEP 263</strong></a></span></dt><dd><span class="yiyi-st" id="yiyi-32">定义Python源代码编码</span></dd><dt><span class="yiyi-st" id="yiyi-33"><span class="target" id="index-2"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a></span></dt><dd><span class="yiyi-st" id="yiyi-34">新的导入钩子</span></dd><dt><span class="yiyi-st" id="yiyi-35"><span class="target" id="index-3"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a></span></dt><dd><span class="yiyi-st" id="yiyi-36">进口：多线和绝对/相对</span></dd><dt><span class="yiyi-st" id="yiyi-37"><span class="target" id="index-4"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a></span></dt><dd><span class="yiyi-st" id="yiyi-38">主模块显式相对导入</span></dd><dt><span class="yiyi-st" id="yiyi-39"><span class="target" id="index-5"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a></span></dt><dd><span class="yiyi-st" id="yiyi-40">隐式名称空间包</span></dd><dt><span class="yiyi-st" id="yiyi-41"><span class="target" id="index-6"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0451"><strong>PEP 451</strong></a></span></dt><dd><span class="yiyi-st" id="yiyi-42">导入系统的ModuleSpec类型</span></dd><dt><span class="yiyi-st" id="yiyi-43"><span class="target" id="index-7"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a></span></dt><dd><span class="yiyi-st" id="yiyi-44">消除PYO文件</span></dd><dt><span class="yiyi-st" id="yiyi-45"><span class="target" id="index-8"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a></span></dt><dd><span class="yiyi-st" id="yiyi-46">多相扩展模块初始化</span></dd><dt><span class="yiyi-st" id="yiyi-47"><span class="target" id="index-9"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3120"><strong>PEP 3120</strong></a></span></dt><dd><span class="yiyi-st" id="yiyi-48">使用UTF-8作为默认源编码</span></dd><dt><span class="yiyi-st" id="yiyi-49"><span class="target" id="index-10"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a></span></dt><dd><span class="yiyi-st" id="yiyi-50">PYC存储库目录</span></dd></dl></div></div><div class="section" id="functions"><h2><span class="yiyi-st" id="yiyi-51">31.5.2. </span><span class="yiyi-st" id="yiyi-52">函数 </span></h2><dl class="function"><dt id="importlib.__import__"><span class="yiyi-st" id="yiyi-53"> <code class="descclassname">importlib.</code><code class="descname">__import__</code><span class="sig-paren">(</span><em>name</em>, <em>globals=None</em>, <em>locals=None</em>, <em>fromlist=()</em>, <em>level=0</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-54">内置<a class="reference internal" href="functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a>函数的实现。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-55">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-56">程序中的模块导入应该使用 <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal"><span class="pre">import_module()</span></code></a> 而不是这个函数。</span></p></div></dd></dl><dl class="function"><dt id="importlib.import_module"><span class="yiyi-st" id="yiyi-57"> <code class="descclassname">importlib.</code><code class="descname">import_module</code><span class="sig-paren">(</span><em>name</em>, <em>package=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-58">导入一个模块。</span><span class="yiyi-st" id="yiyi-59"><em>name</em> 参数指定要导入的模块，可以是绝对路径或相对路径（比如：</span><span class="yiyi-st" id="yiyi-60"><code class="docutils literal"><span class="pre">pkg.mod</span></code> 或 <code class="docutils literal"><span class="pre">..mod</span></code>）。</span><span class="yiyi-st" id="yiyi-61">如果 name 是以相对路径，则 <em>package</em> 参数必须设置为包的名称，该名称将作为解析包名称的锚点（比如：</span><span class="yiyi-st" id="yiyi-62"><code class="docutils literal"><span class="pre">import_module('..mod',</span> <span class="pre">'pkg.subpkg')</span></code> 将导入 <code class="docutils literal"><span class="pre">pkg.mod</span></code>）。</span></p><p><span class="yiyi-st" id="yiyi-63"><a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal"><span class="pre">import_module()</span></code></a> 函数是 <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal"><span class="pre">importlib.__import__()</span></code></a> 的简单化封装。</span><span class="yiyi-st" id="yiyi-64">这意味着该函数的所有语义都来自 <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal"><span class="pre">importlib.__import__()</span></code></a>。</span><span class="yiyi-st" id="yiyi-65">这两个函数最重要的区别在于 <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal"><span class="pre">import_module()</span></code></a> 返回指定的包或模块（例如，</span><span class="yiyi-st" id="yiyi-66"><code class="docutils literal"><span class="pre">pkg.mod</span></code>），而 <a class="reference internal" href="functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> 返回顶级的包或模块（例如，</span><span class="yiyi-st" id="yiyi-67"><code class="docutils literal"><span class="pre">pkg</span></code>）。</span></p><p><span class="yiyi-st" id="yiyi-68">如果你正在动态导入的模块是在解释器执行以后创建的（例如创建的 Python 源文件），则可能需要调用 <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal"><span class="pre">invalidate_caches()</span></code></a> 以使新模块被 import 系统觉察到。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-69"><span class="versionmodified">在版本3.3中更改：</span>父包会自动导入。</span></p></div></dd></dl><dl class="function"><dt id="importlib.find_loader"><span class="yiyi-st" id="yiyi-70"> <code class="descclassname">importlib.</code><code class="descname">find_loader</code><span class="sig-paren">(</span><em>name</em>, <em>path=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-71">查找模块的加载程序，可选地在指定的<em>路径</em>中。</span><span class="yiyi-st" id="yiyi-72">If the module is in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal"><span class="pre">sys.modules</span></code></a>, then <code class="docutils literal"><span class="pre">sys.modules[name].__loader__</span></code> is returned (unless the loader would be <code class="docutils literal"><span class="pre">None</span></code> or is not set, in which case <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> is raised). </span><span class="yiyi-st" id="yiyi-73">否则，使用<a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal"><span class="pre">sys.meta_path</span></code></a>完成搜索。</span><span class="yiyi-st" id="yiyi-74"><code class="docutils literal"><span class="pre">None</span></code> is returned if no loader is found.</span></p><p><span class="yiyi-st" id="yiyi-75">虚线名称没有父项的隐式导入，因为需要加载它们，这可能不是所期望的。</span><span class="yiyi-st" id="yiyi-76">要正确导入子模块，您需要导入子模块的所有父包，并将正确的参数用于<em>路径</em>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-77"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-78"><span class="versionmodified">在版本3.4中更改：</span>如果未设置<code class="docutils literal"><span class="pre">__loader__</span></code>，则引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>，就像属性设置为<code class="docutils literal"><span class="pre">None</span></code></span></p></div><div class="deprecated"><p><span class="yiyi-st" id="yiyi-79"><span class="versionmodified">从版本3.4开始弃用：</span>改为使用<a class="reference internal" href="#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal"><span class="pre">importlib.util.find_spec()</span></code></a>。</span></p></div></dd></dl><dl class="function"><dt id="importlib.invalidate_caches"><span class="yiyi-st" id="yiyi-80"> <code class="descclassname">importlib.</code><code class="descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-81">使存储在<a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></code></a>中的finders的内部缓存失效。</span><span class="yiyi-st" id="yiyi-82">如果查找程序实现<code class="docutils literal"><span class="pre">invalidate_caches()</span></code>，那么它将被调用来执行无效操作。</span><span class="yiyi-st" id="yiyi-83">如果在程序运行时创建/安装了任何模块以确保所有查找程序都会注意到新模块的存在，则应该调用此函数。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-84"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="importlib.reload"><span class="yiyi-st" id="yiyi-85"> <code class="descclassname">importlib.</code><code class="descname">reload</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-86">重新载入先前导入的 <em>module</em>。</span><span class="yiyi-st" id="yiyi-87">参数必须是一个模块对象，因此必须先被成功导入。</span><span class="yiyi-st" id="yiyi-88">如果你使用外部编辑器编辑了模块源文件，并希望在不离开 Python 解释器的情况下尝试新版本，这将非常有用。</span><span class="yiyi-st" id="yiyi-89">返回值是模块对象（如果重新导入会导致将不同的对象放置在<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a>中，则返回值可能不同）。</span></p><p><span class="yiyi-st" id="yiyi-90">当执行<a class="reference internal" href="#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal"><span class="pre">reload()</span></code></a>时：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-91">重新编译Python模块的代码并重新执行模块级代码，通过重新使用最初加载模块的<a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>来定义一组新的对象，这些对象绑定到模块字典中的名称。</span><span class="yiyi-st" id="yiyi-92">扩展模块的 <code class="docutils literal"><span class="pre">init</span></code> 函数不再第二次调用。</span></li><li><span class="yiyi-st" id="yiyi-93">与Python中的所有其他对象一样，旧对象只有在引用计数下降到零后才被回收。</span></li><li><span class="yiyi-st" id="yiyi-94">模块命名空间中的名称将更新为指向任何新的或已更改的对象。</span></li><li><span class="yiyi-st" id="yiyi-95">对旧对象的其他引用（例如模块外部的名称）不会重新引用来引用新对象，如果需要，必须在每个命名空间中对其进行更新。</span></li></ul><p><span class="yiyi-st" id="yiyi-96">还有一些其他警告：</span></p><p><span class="yiyi-st" id="yiyi-97">重新加载模块时，将保留其字典（包含模块的全局变量）。</span><span class="yiyi-st" id="yiyi-98">名称的重定义将覆盖旧的定义，因此这通常不是问题。</span><span class="yiyi-st" id="yiyi-99">如果模块的新版本未定义由旧版本定义的名称，则旧定义将保留。</span><span class="yiyi-st" id="yiyi-100">如果它维护一个全局表或对象缓存，使用<a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a>语句可以测试表的存在并跳过其初始化，如果需要，这个特性可以用于模块的优势：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">cache</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-101">重新加载内置或动态加载的模块通常不是很有用。</span><span class="yiyi-st" id="yiyi-102">不推荐重新加载<a class="reference internal" href="sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal"><span class="pre">sys</span></code></a>，<a class="reference internal" href="__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal"><span class="pre">__main__</span></code></a>，<a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal"><span class="pre">builtins</span></code></a>和其他关键模块。</span><span class="yiyi-st" id="yiyi-103">在许多情况下，扩展模块并不是设计成多次初始化的，并且在重新加载时可能会以任意方式失败。</span></p><p><span class="yiyi-st" id="yiyi-104">If a module imports objects from another module using <a class="reference internal" href="../reference/simple_stmts.html#from"><code class="xref std std-keyword docutils literal"><span class="pre">from</span></code></a> ... <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> ..., calling <a class="reference internal" href="#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal"><span class="pre">reload()</span></code></a> for the other module does not redefine the objects imported from it — one way around this is to re-execute the <a class="reference internal" href="../reference/simple_stmts.html#from"><code class="xref std std-keyword docutils literal"><span class="pre">from</span></code></a> statement, another is to use <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> and qualified names (<em>module.name</em>) instead.</span></p><p><span class="yiyi-st" id="yiyi-105">如果一个模块实例化一个类的实例，重新加载定义该类的模块不会影响实例的方法定义 - 它们继续使用旧的类定义。</span><span class="yiyi-st" id="yiyi-106">对于派生类同样如此。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-107"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl></div><div class="section" id="module-importlib.abc"><h2><span class="yiyi-st" id="yiyi-108">31.5.3.  <a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal"><span class="pre">importlib.abc</span></code></a>  - 与导入相关的抽象基类</span></h2><p><span class="yiyi-st" id="yiyi-109"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/importlib/abc.py">Lib/importlib/abc.py</a></span></p><p><span class="yiyi-st" id="yiyi-110"><a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal"><span class="pre">importlib.abc</span></code></a>模块包含<a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a>使用的所有核心抽象基类。</span><span class="yiyi-st" id="yiyi-111">核心抽象基类的一些子类也被提供来帮助实现核心ABCs。</span></p><p><span class="yiyi-st" id="yiyi-112">ABC层次结构：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="nb">object</span>
 <span class="o">+--</span> <span class="n">Finder</span> <span class="p">(</span><span class="n">deprecated</span><span class="p">)</span>
 <span class="o">|</span>    <span class="o">+--</span> <span class="n">MetaPathFinder</span>
 <span class="o">|</span>    <span class="o">+--</span> <span class="n">PathEntryFinder</span>
 <span class="o">+--</span> <span class="n">Loader</span>
      <span class="o">+--</span> <span class="n">ResourceLoader</span> <span class="o">--------+</span>
      <span class="o">+--</span> <span class="n">InspectLoader</span>          <span class="o">|</span>
           <span class="o">+--</span> <span class="n">ExecutionLoader</span> <span class="o">--+</span>
                                 <span class="o">+--</span> <span class="n">FileLoader</span>
                                 <span class="o">+--</span> <span class="n">SourceLoader</span>
</pre></div></div><dl class="class"><dt id="importlib.abc.Finder"><span class="yiyi-st" id="yiyi-113"> <em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">Finder</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-114">表示<a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a>的抽象基类。</span></p><div class="deprecated"><p><span class="yiyi-st" id="yiyi-115"><span class="versionmodified">从版本3.3开始弃用：</span>改为使用<a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal"><span class="pre">MetaPathFinder</span></code></a>或<a class="reference internal" href="#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal"><span class="pre">PathEntryFinder</span></code></a>。</span></p></div><dl class="method"><dt id="importlib.abc.Finder.find_module"><span class="yiyi-st" id="yiyi-116"> <em class="property">abstractmethod </em><code class="descname">find_module</code><span class="sig-paren">(</span><em>fullname</em>, <em>path=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-117">用于查找指定模块的<a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>的抽象方法。</span><span class="yiyi-st" id="yiyi-118">该方法最初在<span class="target" id="index-11"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>中指定，用于<a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></code></a>和基于路径的导入子系统中。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-119"><span class="versionmodified">在版本3.4中更改：</span>调用时不返回<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>时返回<code class="docutils literal"><span class="pre">None</span></code>。</span></p></div></dd></dl></dd></dl><dl class="class"><dt id="importlib.abc.MetaPathFinder"><span class="yiyi-st" id="yiyi-120"> <em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">MetaPathFinder</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-121">表示<a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a>的抽象基类。</span><span class="yiyi-st" id="yiyi-122">为了兼容性，这是<a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><code class="xref py py-class docutils literal"><span class="pre">Finder</span></code></a>的一个子类。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-123"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><dl class="method"><dt id="importlib.abc.MetaPathFinder.find_spec"><span class="yiyi-st" id="yiyi-124"> <code class="descname">find_spec</code><span class="sig-paren">(</span><em>fullname</em>, <em>path</em>, <em>target=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-125">为指定模块查找<a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a>的抽象方法。</span><span class="yiyi-st" id="yiyi-126">如果这是顶级导入，则<em>路径</em>将为<code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-127">否则，这是对子包或模块的搜索，并且<em>path</em>将是父包中的<a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal"><span class="pre">__path__</span></code></a>的值。</span><span class="yiyi-st" id="yiyi-128">如果找不到规格，则返回<code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-129">传入时，<code class="docutils literal"><span class="pre">target</span></code>是一个模块对象，取景器可以使用它来更好地了解要返回的规范。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-130"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="importlib.abc.MetaPathFinder.find_module"><span class="yiyi-st" id="yiyi-131"> <code class="descname">find_module</code><span class="sig-paren">(</span><em>fullname</em>, <em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-132">用于查找指定模块的<a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>的传统方法。</span><span class="yiyi-st" id="yiyi-133">如果这是顶级导入，则<em>路径</em>将为<code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-134">否则，这是对子包或模块的搜索，并且<em>path</em>将是父包中的<a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal"><span class="pre">__path__</span></code></a>的值。</span><span class="yiyi-st" id="yiyi-135">如果找不到加载程序，则返回<code class="docutils literal"><span class="pre">None</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-136">如果定义了<a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a>，则提供了向后兼容的功能。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-137"><span class="versionmodified">在版本3.4中更改：</span>调用时不返回<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>时返回<code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-138">可以使用<a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a>来提供功能。</span></p></div><div class="deprecated"><p><span class="yiyi-st" id="yiyi-139"><span class="versionmodified">从版本3.4开始弃用：</span>改为使用<a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a>。</span></p></div></dd></dl><dl class="method"><dt id="importlib.abc.MetaPathFinder.invalidate_caches"><span class="yiyi-st" id="yiyi-140"> <code class="descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-141">一个可选的方法，被调用时应该使查找器使用的任何内部缓存失效。</span><span class="yiyi-st" id="yiyi-142">当<a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></code></a>中的所有查找器的缓存失效时，由<a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal"><span class="pre">importlib.invalidate_caches()</span></code></a>使用。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-143"><span class="versionmodified">在版本3.4中更改：</span>在调用而不是<code class="docutils literal"><span class="pre">NotImplemented</span></code>时返回<code class="docutils literal"><span class="pre">None</span></code>。</span></p></div></dd></dl></dd></dl><dl class="class"><dt id="importlib.abc.PathEntryFinder"><span class="yiyi-st" id="yiyi-144"> <em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">PathEntryFinder</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-145">表示<a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a>的抽象基类。</span><span class="yiyi-st" id="yiyi-146">虽然它与<a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal"><span class="pre">MetaPathFinder</span></code></a>有一些相似之处，但<code class="docutils literal"><span class="pre">PathEntryFinder</span></code>仅适用于<code class="xref py py-class docutils literal"><span class="pre">PathFinder</span></code>提供的基于路径的导入子系统内。</span><span class="yiyi-st" id="yiyi-147">由于兼容性原因，此ABC是<a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><code class="xref py py-class docutils literal"><span class="pre">Finder</span></code></a>的子类。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-148"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><dl class="method"><dt id="importlib.abc.PathEntryFinder.find_spec"><span class="yiyi-st" id="yiyi-149"> <code class="descname">find_spec</code><span class="sig-paren">(</span><em>fullname</em>, <em>target=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-150">为指定模块查找<a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a>的抽象方法。</span><span class="yiyi-st" id="yiyi-151">取景器将只在分配给它的<a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">path entry</span></a>内搜索模块。</span><span class="yiyi-st" id="yiyi-152">如果找不到规格，则返回<code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-153">传入时，<code class="docutils literal"><span class="pre">target</span></code>是一个模块对象，取景器可以使用它来更好地了解要返回的规范。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-154"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="importlib.abc.PathEntryFinder.find_loader"><span class="yiyi-st" id="yiyi-155"> <code class="descname">find_loader</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-156">用于查找指定模块的<a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>的传统方法。</span><span class="yiyi-st" id="yiyi-157">返回<code class="docutils literal"><span class="pre">（loader，</span> <span class="pre">部分）的2元组，其中<code class="docutils literal"><span class="pre">portion</span></code>是一系列文件系统位置，命名空间包的一部分。</span></code></span><span class="yiyi-st" id="yiyi-158">当指定<code class="docutils literal"><span class="pre">portion</span></code>来表示文件系统位置对名称空间包的贡献时，加载器可以是<code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-159">一个空的列表可以用于<code class="docutils literal"><span class="pre">portion</span></code>来表示加载器不是名称空间包的一部分。</span><span class="yiyi-st" id="yiyi-160">如果<code class="docutils literal"><span class="pre">loader</span></code>是<code class="docutils literal"><span class="pre">None</span></code>且<code class="docutils literal"><span class="pre">portion</span></code>是空列表，则不会找到名称空间包的加载器或位置。</span><span class="yiyi-st" id="yiyi-161">未能找到任何模块）。</span></p><p><span class="yiyi-st" id="yiyi-162">如果定义了<a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a>，则提供向后兼容的功能。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-163"><span class="versionmodified">版本3.4中改变：</span>返回<code class="docutils literal"><span class="pre">（None，</span> <span class="pre">[]）</span></code>，而不是引发<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a></span><span class="yiyi-st" id="yiyi-164">在可用时使用<a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a>来提供功能。</span></p></div><div class="deprecated"><p><span class="yiyi-st" id="yiyi-165"><span class="versionmodified">从版本3.4开始弃用：</span>改为使用<a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a>。</span></p></div></dd></dl><dl class="method"><dt id="importlib.abc.PathEntryFinder.find_module"><span class="yiyi-st" id="yiyi-166"> <code class="descname">find_module</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-167"><a class="reference internal" href="#importlib.abc.Finder.find_module" title="importlib.abc.Finder.find_module"><code class="xref py py-meth docutils literal"><span class="pre">Finder.find_module()</span></code></a>的具体实现等同于<code class="docutils literal"><span class="pre">self.find_loader(fullname)[0]</span></code>。</span></p><div class="deprecated"><p><span class="yiyi-st" id="yiyi-168"><span class="versionmodified">从版本3.4开始弃用：</span>改为使用<a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a>。</span></p></div></dd></dl><dl class="method"><dt id="importlib.abc.PathEntryFinder.invalidate_caches"><span class="yiyi-st" id="yiyi-169"> <code class="descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-170">一个可选的方法，被调用时应该使查找器使用的任何内部缓存失效。</span><span class="yiyi-st" id="yiyi-171">在使所有缓存查找器的缓存无效时，由<code class="xref py py-meth docutils literal"><span class="pre">PathFinder.invalidate_caches()</span></code>使用。</span></p></dd></dl></dd></dl><dl class="class"><dt id="importlib.abc.Loader"><span class="yiyi-st" id="yiyi-172"> <em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">Loader</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-173">一个<a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>。</span><span class="yiyi-st" id="yiyi-174">有关加载程序的确切定义，请参阅<span class="target" id="index-12"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>。</span></p><dl class="method"><dt id="importlib.abc.Loader.create_module"><span class="yiyi-st" id="yiyi-175"> <code class="descname">create_module</code><span class="sig-paren">(</span><em>spec</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-176">导入模块时返回要使用的模块对象的方法。</span><span class="yiyi-st" id="yiyi-177">此方法可能会返回<code class="docutils literal"><span class="pre">None</span></code>，表示应该发生默认的模块创建语义。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-178"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-179"><span class="versionmodified">在版本3.5中更改：</span>从Python 3.6开始，当定义<a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">exec_module()</span></code></a>时，此方法将不可选。</span></p></div></dd></dl><dl class="method"><dt id="importlib.abc.Loader.exec_module"><span class="yiyi-st" id="yiyi-180"> <code class="descname">exec_module</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-181">抽象方法，用于在导入或重新加载模块时在其自己的名称空间中执行模块。</span><span class="yiyi-st" id="yiyi-182">当调用exec_module()时，模块应该已经被初始化。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-183"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="importlib.abc.Loader.load_module"><span class="yiyi-st" id="yiyi-184"> <code class="descname">load_module</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-185">加载模块的传统方法。</span><span class="yiyi-st" id="yiyi-186">如果模块无法加载，则引发<a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a>，否则返回加载的模块。</span></p><p><span class="yiyi-st" id="yiyi-187">如果请求的模块已经存在于<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a>中，则应该使用并重新加载该模块。</span><span class="yiyi-st" id="yiyi-188">否则，加载程序应该在任何加载开始之前创建一个新模块并将其插入到<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a>中，以防止导入引发递归。</span><span class="yiyi-st" id="yiyi-189">如果加载程序插入了一个模块并且加载失败，则它必须由加载程序从<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a>中删除。已经在<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a>中的模块应该放在一起（参见<a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal"><span class="pre">importlib.util.module_for_loader()</span></code></a>）。</span></p><p><span class="yiyi-st" id="yiyi-190">加载器应该在模块上设置几个属性。</span><span class="yiyi-st" id="yiyi-191">（请注意，某些模块重新加载时，这些属性可能会发生变化）：</span></p><ul><li><dl class="first docutils"><dt><span class="yiyi-st" id="yiyi-192"><a class="reference internal" href="../reference/import.html#__name__" title="__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a></span></dt><dd><p class="first last"><span class="yiyi-st" id="yiyi-193">模块的名称。</span></p></dd></dl></li><li><dl class="first docutils"><dt><span class="yiyi-st" id="yiyi-194"><a class="reference internal" href="../reference/import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal"><span class="pre">__file__</span></code></a></span></dt><dd><p class="first last"><span class="yiyi-st" id="yiyi-195">模块数据存储位置的路径（未为内置模块设置）。</span></p></dd></dl></li><li><dl class="first docutils"><dt><span class="yiyi-st" id="yiyi-196"><a class="reference internal" href="../reference/import.html#__cached__" title="__cached__"><code class="xref py py-attr docutils literal"><span class="pre">__cached__</span></code></a></span></dt><dd><p class="first last"><span class="yiyi-st" id="yiyi-197">应该存储模块的已编译版本的路径（当属性不合适时不会设置）。</span></p></dd></dl></li><li><dl class="first docutils"><dt><span class="yiyi-st" id="yiyi-198"><a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal"><span class="pre">__path__</span></code></a></span></dt><dd><p class="first last"><span class="yiyi-st" id="yiyi-199">指定包内搜索路径的字符串列表。</span><span class="yiyi-st" id="yiyi-200">该属性未在模块上设置。</span></p></dd></dl></li><li><dl class="first docutils"><dt><span class="yiyi-st" id="yiyi-201"><a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a></span></dt><dd><p class="first last"><span class="yiyi-st" id="yiyi-202">模块/包的父包。</span><span class="yiyi-st" id="yiyi-203">如果模块是顶层的，那么它有一个空字符串的值。</span><span class="yiyi-st" id="yiyi-204"><a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal"><span class="pre">importlib.util.module_for_loader()</span></code></a>修饰器可以处理<a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a>的细节。</span></p></dd></dl></li><li><dl class="first docutils"><dt><span class="yiyi-st" id="yiyi-205"><a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal"><span class="pre">__loader__</span></code></a></span></dt><dd><p class="first last"><span class="yiyi-st" id="yiyi-206">加载器用于加载模块。</span><span class="yiyi-st" id="yiyi-207"><a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal"><span class="pre">importlib.util.module_for_loader()</span></code></a>修饰器可以处理<a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a>的细节。</span></p></dd></dl></li></ul><p><span class="yiyi-st" id="yiyi-208">当<a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">exec_module()</span></code></a>可用时，提供向后兼容的功能。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-209"><span class="versionmodified">在版本3.4中更改：</span>在调用<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>时调用<a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a>。</span><span class="yiyi-st" id="yiyi-210">当<a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">exec_module()</span></code></a>可用时提供的功能。</span></p></div><div class="deprecated"><p><span class="yiyi-st" id="yiyi-211"><span class="versionmodified">从版本3.4开始不推荐使用：</span>用于加载模块的推荐API是<a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">exec_module()</span></code></a>（和<a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal"><span class="pre">create_module()</span></code></a>）。</span><span class="yiyi-st" id="yiyi-212">加载器应该实现它而不是load_module()。</span><span class="yiyi-st" id="yiyi-213">当执行exec_module()时，导入机器负责load_module()的所有其他职责。</span></p></div></dd></dl><dl class="method"><dt id="importlib.abc.Loader.module_repr"><span class="yiyi-st" id="yiyi-214"> <code class="descname">module_repr</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-215">传统方法，在实现时计算并返回给定模块的repr，作为字符串。</span><span class="yiyi-st" id="yiyi-216">模块类型的默认repr()将根据需要使用此方法的结果。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-217"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-218"><span class="versionmodified">在3.4版本中更改：</span>制作可选，而不是抽象方法。</span></p></div><div class="deprecated"><p><span class="yiyi-st" id="yiyi-219"><span class="versionmodified">从版本3.4开始不推荐使用：</span>导入机器现在自动处理。</span></p></div></dd></dl></dd></dl><dl class="class"><dt id="importlib.abc.ResourceLoader"><span class="yiyi-st" id="yiyi-220"> <em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">ResourceLoader</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-221">一个<a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>的抽象基类，它实现了用于从存储后端加载任意资源的可选的<span class="target" id="index-13"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a></span></p><dl class="method"><dt id="importlib.abc.ResourceLoader.get_data"><span class="yiyi-st" id="yiyi-222"> <em class="property">abstractmethod </em><code class="descname">get_data</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-223">返回位于<em>路径</em>的数据的字节的抽象方法。</span><span class="yiyi-st" id="yiyi-224">具有允许存储任意数据的文件类存储后端的加载器可以实现这种抽象方法，以直接访问存储的数据。</span><span class="yiyi-st" id="yiyi-225"><a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> is to be raised if the <em>path</em> cannot be found. </span><span class="yiyi-st" id="yiyi-226">预计<em>路径</em>将使用模块的<a class="reference internal" href="../reference/import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal"><span class="pre">__file__</span></code></a>属性或来自包的<a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal"><span class="pre">__path__</span></code></a>的项目构建。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-227"><span class="versionmodified">版本3.4中改变：</span>引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>而不是<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>。</span></p></div></dd></dl></dd></dl><dl class="class"><dt id="importlib.abc.InspectLoader"><span class="yiyi-st" id="yiyi-228"> <em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">InspectLoader</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-229">一个<a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>的抽象基类，它为检查模块的加载器实现可选的<span class="target" id="index-14"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>协议。</span></p><dl class="method"><dt id="importlib.abc.InspectLoader.get_code"><span class="yiyi-st" id="yiyi-230"> <code class="descname">get_code</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-231">返回模块的代码对象，如果模块没有代码对象，则返回<code class="docutils literal"><span class="pre">None</span></code>（例如，对于内置模块就是这种情况）。</span><span class="yiyi-st" id="yiyi-232">如果加载程序无法找到请求的模块，请引发<a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-233">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-234">虽然该方法有一个默认的实现，但是如果可能的话，建议它被覆盖。</span></p></div><div class="versionchanged" id="index-15"><p><span class="yiyi-st" id="yiyi-235"><span class="versionmodified">在版本3.4中更改：</span>不再提供抽象和具体实现。</span></p></div></dd></dl><dl class="method"><dt id="importlib.abc.InspectLoader.get_source"><span class="yiyi-st" id="yiyi-236"> <em class="property">abstractmethod </em><code class="descname">get_source</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-237">一种抽象方法来返回模块的来源。</span><span class="yiyi-st" id="yiyi-238">它使用<a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a>作为文本字符串返回，将所有已识别的行分隔符转换为<code class="docutils literal"><span class="pre">'\n'</span></code>个字符。</span><span class="yiyi-st" id="yiyi-239">如果没有可用的来源（例如，来源），则返回<code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-240">一个内置模块）。</span><span class="yiyi-st" id="yiyi-241">如果加载程序找不到指定的模块，则引发<a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-242"><span class="versionmodified">在版本3.4中更改：</span>引发<a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a>而不是<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>。</span></p></div></dd></dl><dl class="method"><dt id="importlib.abc.InspectLoader.is_package"><span class="yiyi-st" id="yiyi-243"> <code class="descname">is_package</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-244">如果模块是包，则返回true值的抽象方法，否则返回false值。</span><span class="yiyi-st" id="yiyi-245"><a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> is raised if the <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> cannot find the module.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-246"><span class="versionmodified">在版本3.4中更改：</span>引发<a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a>而不是<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>。</span></p></div></dd></dl><dl class="staticmethod"><dt id="importlib.abc.InspectLoader.source_to_code"><span class="yiyi-st" id="yiyi-247"> <em class="property">static </em><code class="descname">source_to_code</code><span class="sig-paren">(</span><em>data</em>, <em>path='&lt;string&gt;'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-248">从Python源代码创建一个代码对象。</span></p><p><span class="yiyi-st" id="yiyi-249"><em>data</em>参数可以是<a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a>函数支持的任何内容（即，</span><span class="yiyi-st" id="yiyi-250">字符串或字节）。</span><span class="yiyi-st" id="yiyi-251"><em>path</em>参数应该是源代码来源的“路径”，它可以是一个抽象概念（例如，</span><span class="yiyi-st" id="yiyi-252">位置在一个zip文件中）。</span></p><p><span class="yiyi-st" id="yiyi-253">通过运行<code class="docutils literal"><span class="pre">exec（code，</span> <span class="pre">module .__ dict __）</span></code>，随后的代码对象可以在模块中执行它。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-254"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-255"><span class="versionmodified">在版本3.5中更改：</span>使方法变为静态。</span></p></div></dd></dl><dl class="method"><dt id="importlib.abc.InspectLoader.exec_module"><span class="yiyi-st" id="yiyi-256"> <code class="descname">exec_module</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-257"><a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">Loader.exec_module()</span></code></a>的实现。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-258"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="importlib.abc.InspectLoader.load_module"><span class="yiyi-st" id="yiyi-259"> <code class="descname">load_module</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-260"><a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal"><span class="pre">Loader.load_module()</span></code></a>的实现。</span></p><div class="deprecated"><p><span class="yiyi-st" id="yiyi-261"><span class="versionmodified">从版本3.4开始弃用：</span>改为使用<a class="reference internal" href="#importlib.abc.InspectLoader.exec_module" title="importlib.abc.InspectLoader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">exec_module()</span></code></a>。</span></p></div></dd></dl></dd></dl><dl class="class"><dt id="importlib.abc.ExecutionLoader"><span class="yiyi-st" id="yiyi-262"> <em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">ExecutionLoader</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-263">一个从<a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal"><span class="pre">InspectLoader</span></code></a>继承的抽象基类，它在实现时帮助模块作为脚本执行。</span><span class="yiyi-st" id="yiyi-264">ABC表示可选的<span class="target" id="index-16"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>协议。</span></p><dl class="method"><dt id="importlib.abc.ExecutionLoader.get_filename"><span class="yiyi-st" id="yiyi-265"> <em class="property">abstractmethod </em><code class="descname">get_filename</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-266">一个抽象方法，用于返回指定模块的<a class="reference internal" href="../reference/import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal"><span class="pre">__file__</span></code></a>的值。</span><span class="yiyi-st" id="yiyi-267">如果没有路径可用，则引发<a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-268">如果源代码可用，那么该方法应该返回源文件的路径，而不管是否使用字节码来加载模块。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-269"><span class="versionmodified">在版本3.4中更改：</span>引发<a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a>而不是<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>。</span></p></div></dd></dl></dd></dl><dl class="class"><dt id="importlib.abc.FileLoader"><span class="yiyi-st" id="yiyi-270"> <em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">FileLoader</code><span class="sig-paren">(</span><em>fullname</em>, <em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-271">一个从<a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal"><span class="pre">ResourceLoader</span></code></a>和<a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal"><span class="pre">ExecutionLoader</span></code></a>继承的抽象基类，提供了<a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal"><span class="pre">ResourceLoader.get_data()</span></code></a>和<a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal"><span class="pre">ExecutionLoader.get_filename()</span></code></a></span></p><p><span class="yiyi-st" id="yiyi-272"><em>fullname</em>参数是加载程序要处理的模块的完全解析名称。</span><span class="yiyi-st" id="yiyi-273"><em>path</em>参数是模块文件的路径。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-274"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><dl class="attribute"><dt id="importlib.abc.FileLoader.name"><span class="yiyi-st" id="yiyi-275"> <code class="descname">name</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-276">加载器可以处理的模块的名称。</span></p></dd></dl><dl class="attribute"><dt id="importlib.abc.FileLoader.path"><span class="yiyi-st" id="yiyi-277"> <code class="descname">path</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-278">模块文件的路径。</span></p></dd></dl><dl class="method"><dt id="importlib.abc.FileLoader.load_module"><span class="yiyi-st" id="yiyi-279"> <code class="descname">load_module</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-280">调用super的<code class="docutils literal"><span class="pre">load_module()</span></code>。</span></p><div class="deprecated"><p><span class="yiyi-st" id="yiyi-281"><span class="versionmodified">从版本3.4开始弃用：</span>改为使用<a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">Loader.exec_module()</span></code></a>。</span></p></div></dd></dl><dl class="method"><dt id="importlib.abc.FileLoader.get_filename"><span class="yiyi-st" id="yiyi-282"> <em class="property">abstractmethod </em><code class="descname">get_filename</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-283">返回<a class="reference internal" href="#importlib.abc.FileLoader.path" title="importlib.abc.FileLoader.path"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="importlib.abc.FileLoader.get_data"><span class="yiyi-st" id="yiyi-284"> <em class="property">abstractmethod </em><code class="descname">get_data</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-285">将<em>路径</em>读取为二进制文件并从中返回字节。</span></p></dd></dl></dd></dl><dl class="class"><dt id="importlib.abc.SourceLoader"><span class="yiyi-st" id="yiyi-286"> <em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">SourceLoader</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-287">用于实现源文件（可选）和字节码文件加载的抽象基类。</span><span class="yiyi-st" id="yiyi-288">该类继承于<a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal"><span class="pre">ResourceLoader</span></code></a>和<a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal"><span class="pre">ExecutionLoader</span></code></a>，需要执行：</span></p><ul><li><p class="first"><span class="yiyi-st" id="yiyi-289"><a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal"><span class="pre">ResourceLoader.get_data()</span></code></a></span></p></li><li><dl class="first docutils"><dt><span class="yiyi-st" id="yiyi-290"><a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal"><span class="pre">ExecutionLoader.get_filename()</span></code></a></span></dt><dd><p class="first last"><span class="yiyi-st" id="yiyi-291">只应该返回源文件的路径；不支持无源加载。</span></p></dd></dl></li></ul><p><span class="yiyi-st" id="yiyi-292">这个类定义的抽象方法是添加可选的字节码文件支持。</span><span class="yiyi-st" id="yiyi-293">不执行这些可选方法（或导致它们引发<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>）会导致加载器只能使用源代码。</span><span class="yiyi-st" id="yiyi-294">实现这些方法允许加载器使用source <em>和</em>字节码文件；它不允许仅提供字节码的<em>无源</em>加载。</span><span class="yiyi-st" id="yiyi-295">字节码文件是一种优化，可以通过删除Python编译器的解析步骤来加速加载，因此不会暴露字节码特定的API。</span></p><dl class="method"><dt id="importlib.abc.SourceLoader.path_stats"><span class="yiyi-st" id="yiyi-296"> <code class="descname">path_stats</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-297">可选的抽象方法，它返回包含关于指定路径的元数据的<a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>。</span><span class="yiyi-st" id="yiyi-298">支持的字典键是：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-299"><code class="docutils literal"><span class="pre">'mtime'</span></code>（强制）：表示源代码修改时间的整数或浮点数；</span></li><li><span class="yiyi-st" id="yiyi-300"><code class="docutils literal"><span class="pre">'size'</span></code>（可选）：源代码的字节大小。</span></li></ul><p><span class="yiyi-st" id="yiyi-301">字典中的任何其他键都将被忽略，以允许将来的扩展。</span><span class="yiyi-st" id="yiyi-302">如果路径无法处理，则引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-303"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-304"><span class="versionmodified">版本3.4中改变：</span>引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>而不是<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>。</span></p></div></dd></dl><dl class="method"><dt id="importlib.abc.SourceLoader.path_mtime"><span class="yiyi-st" id="yiyi-305"> <code class="descname">path_mtime</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-306">可选抽象方法，返回指定路径的修改时间。</span></p><div class="deprecated"><p><span class="yiyi-st" id="yiyi-307"><span class="versionmodified">从版本3.3开始不推荐使用：</span>此方法已弃用，以支持<a class="reference internal" href="#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal"><span class="pre">path_stats()</span></code></a>。</span><span class="yiyi-st" id="yiyi-308">您不必实现它，但它仍然可用于兼容性目的。</span><span class="yiyi-st" id="yiyi-309">如果路径无法处理，请引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-310"><span class="versionmodified">版本3.4中改变：</span>引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>而不是<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>。</span></p></div></dd></dl><dl class="method"><dt id="importlib.abc.SourceLoader.set_data"><span class="yiyi-st" id="yiyi-311"> <code class="descname">set_data</code><span class="sig-paren">(</span><em>path</em>, <em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-312">将指定字节写入文件路径的可选抽象方法。</span><span class="yiyi-st" id="yiyi-313">任何不存在的中间目录都将被自动创建。</span></p><p><span class="yiyi-st" id="yiyi-314">由于路径是只读的（<a class="reference internal" href="errno.html#errno.EACCES" title="errno.EACCES"><code class="xref py py-attr docutils literal"><span class="pre">errno.EACCES</span></code></a> / <a class="reference internal" href="exceptions.html#PermissionError" title="PermissionError"><code class="xref py py-exc docutils literal"><span class="pre">PermissionError</span></code></a>），因此写入路径失败时，请勿传播异常。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-315"><span class="versionmodified">在版本3.4中更改：</span>调用时不再引发<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>。</span></p></div></dd></dl><dl class="method"><dt id="importlib.abc.SourceLoader.get_code"><span class="yiyi-st" id="yiyi-316"> <code class="descname">get_code</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-317"><a class="reference internal" href="#importlib.abc.InspectLoader.get_code" title="importlib.abc.InspectLoader.get_code"><code class="xref py py-meth docutils literal"><span class="pre">InspectLoader.get_code()</span></code></a>的具体实现。</span></p></dd></dl><dl class="method"><dt id="importlib.abc.SourceLoader.exec_module"><span class="yiyi-st" id="yiyi-318"> <code class="descname">exec_module</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span></span></dt><dd><span class="yiyi-st" id="yiyi-320"><blockquote> <div>Concrete implementation of <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">Loader.exec_module()</span></code></a>.</div></blockquote></span><div class="versionadded"><p><span class="yiyi-st" id="yiyi-319"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="importlib.abc.SourceLoader.load_module"><span class="yiyi-st" id="yiyi-321"> <code class="descname">load_module</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-322"><a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal"><span class="pre">Loader.load_module()</span></code></a>的具体实现。</span></p><div class="deprecated"><p><span class="yiyi-st" id="yiyi-323"><span class="versionmodified">从版本3.4开始弃用：</span>改为使用<a class="reference internal" href="#importlib.abc.SourceLoader.exec_module" title="importlib.abc.SourceLoader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">exec_module()</span></code></a>。</span></p></div></dd></dl><dl class="method"><dt id="importlib.abc.SourceLoader.get_source"><span class="yiyi-st" id="yiyi-324"> <code class="descname">get_source</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-325"><a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal"><span class="pre">InspectLoader.get_source()</span></code></a>的具体实现。</span></p></dd></dl><dl class="method"><dt id="importlib.abc.SourceLoader.is_package"><span class="yiyi-st" id="yiyi-326"> <code class="descname">is_package</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-327"><a class="reference internal" href="#importlib.abc.InspectLoader.is_package" title="importlib.abc.InspectLoader.is_package"><code class="xref py py-meth docutils literal"><span class="pre">InspectLoader.is_package()</span></code></a>的具体实现。</span><span class="yiyi-st" id="yiyi-328">如果一个模块的文件路径（如<a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal"><span class="pre">ExecutionLoader.get_filename()</span></code></a>）提供的文件路径是一个名为<code class="docutils literal"><span class="pre">__init__</span></code>的文件，则当文件扩展名被删除时，该模块将被确定为一个包<strong>和</strong>模块名称本身不会以<code class="docutils literal"><span class="pre">__init__</span></code>结尾。</span></p></dd></dl></dd></dl></div><div class="section" id="module-importlib.machinery"><h2><span class="yiyi-st" id="yiyi-329">31.5.4.  <a class="reference internal" href="#module-importlib.machinery" title="importlib.machinery: Importers and path hooks"><code class="xref py py-mod docutils literal"><span class="pre">importlib.machinery</span></code></a>  - 进口商和路径挂钩</span></h2><p><span class="yiyi-st" id="yiyi-330"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/importlib/machinery.py">Lib/importlib/machinery.py</a></span></p><p><span class="yiyi-st" id="yiyi-331">该模块包含帮助<a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a>查找和加载模块的各种对象。</span></p><dl class="attribute"><dt id="importlib.machinery.SOURCE_SUFFIXES"><span class="yiyi-st" id="yiyi-332"> <code class="descclassname">importlib.machinery.</code><code class="descname">SOURCE_SUFFIXES</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-333">表示源模块的识别文件后缀的字符串列表。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-334"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="attribute"><dt id="importlib.machinery.DEBUG_BYTECODE_SUFFIXES"><span class="yiyi-st" id="yiyi-335"> <code class="descclassname">importlib.machinery.</code><code class="descname">DEBUG_BYTECODE_SUFFIXES</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-336">表示非优化字节码模块的文件后缀的字符串列表。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-337"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><div class="deprecated"><p><span class="yiyi-st" id="yiyi-338"><span class="versionmodified">从版本3.5开始弃用：</span>改为使用<a class="reference internal" href="#importlib.machinery.BYTECODE_SUFFIXES" title="importlib.machinery.BYTECODE_SUFFIXES"><code class="xref py py-attr docutils literal"><span class="pre">BYTECODE_SUFFIXES</span></code></a>。</span></p></div></dd></dl><dl class="attribute"><dt id="importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES"><span class="yiyi-st" id="yiyi-339"> <code class="descclassname">importlib.machinery.</code><code class="descname">OPTIMIZED_BYTECODE_SUFFIXES</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-340">代表优化字节码模块的文件后缀的字符串列表。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-341"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><div class="deprecated"><p><span class="yiyi-st" id="yiyi-342"><span class="versionmodified">从版本3.5开始弃用：</span>改为使用<a class="reference internal" href="#importlib.machinery.BYTECODE_SUFFIXES" title="importlib.machinery.BYTECODE_SUFFIXES"><code class="xref py py-attr docutils literal"><span class="pre">BYTECODE_SUFFIXES</span></code></a>。</span></p></div></dd></dl><dl class="attribute"><dt id="importlib.machinery.BYTECODE_SUFFIXES"><span class="yiyi-st" id="yiyi-343"> <code class="descclassname">importlib.machinery.</code><code class="descname">BYTECODE_SUFFIXES</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-344">代表字节码模块（包括前导点）的识别文件后缀的字符串列表。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-345"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-346"><span class="versionmodified">在版本3.5中更改：</span>该值不再依赖于<code class="docutils literal"><span class="pre">__debug__</span></code>。</span></p></div></dd></dl><dl class="attribute"><dt id="importlib.machinery.EXTENSION_SUFFIXES"><span class="yiyi-st" id="yiyi-347"> <code class="descclassname">importlib.machinery.</code><code class="descname">EXTENSION_SUFFIXES</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-348">表示扩展模块的识别文件后缀的字符串列表。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-349"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="importlib.machinery.all_suffixes"><span class="yiyi-st" id="yiyi-350"> <code class="descclassname">importlib.machinery.</code><code class="descname">all_suffixes</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-351">返回表示由标准导入机制识别的模块的所有文件后缀的字符串组合列表。</span><span class="yiyi-st" id="yiyi-352">这是代码的帮助器，它只需知道文件系统路径是否可能引用模块而不需要有关模块种类的任何细节（例如，<a class="reference internal" href="inspect.html#inspect.getmodulename" title="inspect.getmodulename"><code class="xref py py-func docutils literal"><span class="pre">inspect.getmodulename()</span></code></a>）。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-353"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="class"><dt id="importlib.machinery.BuiltinImporter"><span class="yiyi-st" id="yiyi-354"> <em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">BuiltinImporter</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-355">内置模块的<a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>。</span><span class="yiyi-st" id="yiyi-356">所有已知的内置模块都列在<a class="reference internal" href="sys.html#sys.builtin_module_names" title="sys.builtin_module_names"><code class="xref py py-data docutils literal"><span class="pre">sys.builtin_module_names</span></code></a>中。</span><span class="yiyi-st" id="yiyi-357">该类实现<a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.MetaPathFinder</span></code></a>和<a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.InspectLoader</span></code></a> ABC。</span></p><p><span class="yiyi-st" id="yiyi-358">只有类方法是由这个类定义的，以减轻实例化的需要。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-359"><span class="versionmodified">版本3.5中改变：</span>作为<span class="target" id="index-17"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a>的一部分，内建导入器现在实现<code class="xref py py-meth docutils literal"><span class="pre">Loader.create_module()</span></code> <code class="xref py py-meth docutils literal"><span class="pre">Loader.exec_module()</span></code></span></p></div></dd></dl><dl class="class"><dt id="importlib.machinery.FrozenImporter"><span class="yiyi-st" id="yiyi-360"> <em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">FrozenImporter</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-361">冻结模块的<a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>。</span><span class="yiyi-st" id="yiyi-362">该类实现<a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.MetaPathFinder</span></code></a>和<a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.InspectLoader</span></code></a> ABC。</span></p><p><span class="yiyi-st" id="yiyi-363">只有类方法是由这个类定义的，以减轻实例化的需要。</span></p></dd></dl><dl class="class"><dt id="importlib.machinery.WindowsRegistryFinder"><span class="yiyi-st" id="yiyi-364"> <em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">WindowsRegistryFinder</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-365"><a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Finder</span></a> for modules declared in the Windows registry. </span><span class="yiyi-st" id="yiyi-366">这个类实现了<a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.Finder</span></code></a> ABC。</span></p><p><span class="yiyi-st" id="yiyi-367">只有类方法是由这个类定义的，以减轻实例化的需要。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-368"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="class"><dt id="importlib.machinery.PathFinder"><span class="yiyi-st" id="yiyi-369"> <em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">PathFinder</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-370">A <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Finder</span></a>用于<a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a>和程序包<code class="docutils literal"><span class="pre">__path__</span></code>属性。</span><span class="yiyi-st" id="yiyi-371">这个类实现了<a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> ABC。</span></p><p><span class="yiyi-st" id="yiyi-372">只有类方法是由这个类定义的，以减轻实例化的需要。</span></p><dl class="classmethod"><dt id="importlib.machinery.PathFinder.find_spec"><span class="yiyi-st" id="yiyi-373"> <em class="property">classmethod </em><code class="descname">find_spec</code><span class="sig-paren">(</span><em>fullname</em>, <em>path=None</em>, <em>target=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-374">尝试为<a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a>上由<em>全名</em>指定的模块或<em>路径中定义的模块找到<a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> / T6&gt;。</em></span><span class="yiyi-st" id="yiyi-375">对于搜索到的每个路径条目，检查<a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></code></a>。</span><span class="yiyi-st" id="yiyi-376">如果找到一个非错误的对象，那么它将用作<a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a>来查找正在搜索的模块。</span><span class="yiyi-st" id="yiyi-377">如果在<a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></code></a>中找不到任何条目，那么将搜索<a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></code></a>中的路径条目的查找器，并且如果找到，则存储在<a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></code></a>以及正在查询的模块。</span><span class="yiyi-st" id="yiyi-378">如果没有找到finder，则<code class="docutils literal"><span class="pre">None</span></code>都存储在缓存中并返回。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-379"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-380"><span class="versionmodified">Changed in version 3.5: </span>If the current working directory – represented by an empty string – is no longer valid then <code class="docutils literal"><span class="pre">None</span></code> is returned but no value is cached in <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></code></a>.</span></p></div></dd></dl><dl class="classmethod"><dt id="importlib.machinery.PathFinder.find_module"><span class="yiyi-st" id="yiyi-381"> <em class="property">classmethod </em><code class="descname">find_module</code><span class="sig-paren">(</span><em>fullname</em>, <em>path=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-382">一个围绕<a class="reference internal" href="#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a>的传统封装。</span></p><div class="deprecated"><p><span class="yiyi-st" id="yiyi-383"><span class="versionmodified">从版本3.4开始弃用：</span>改为使用<a class="reference internal" href="#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a>。</span></p></div></dd></dl><dl class="classmethod"><dt id="importlib.machinery.PathFinder.invalidate_caches"><span class="yiyi-st" id="yiyi-384"> <em class="property">classmethod </em><code class="descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-385">在存储在<a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-attr docutils literal"><span class="pre">sys.path_importer_cache</span></code></a>中的所有查找器中调用<a class="reference internal" href="#importlib.abc.PathEntryFinder.invalidate_caches" title="importlib.abc.PathEntryFinder.invalidate_caches"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.PathEntryFinder.invalidate_caches()</span></code></a>。</span></p></dd></dl><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-386"><span class="versionmodified">在版本3.4中更改：</span>使用当前工作目录<code class="docutils literal"><span class="pre">''</span></code>调用<a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></code></a>中的对象。</span><span class="yiyi-st" id="yiyi-387">空字符串）。</span></p></div></dd></dl><dl class="class"><dt id="importlib.machinery.FileFinder"><span class="yiyi-st" id="yiyi-388"> <em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">FileFinder</code><span class="sig-paren">(</span><em>path</em>, <em>*loader_details</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-389"><a class="reference internal" href="#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.PathEntryFinder</span></code></a>的具体实现，它缓存文件系统的结果。</span></p><p><span class="yiyi-st" id="yiyi-390"><em>path</em>参数是查找器负责搜索的目录。</span></p><p><span class="yiyi-st" id="yiyi-391"><em>loader_details</em>参数是可变数量的2项元组，每个元组包含加载程序和加载程序识别的一系列文件后缀。</span><span class="yiyi-st" id="yiyi-392">预计装入程序是可接受的，它接受模块名称的两个参数和找到的文件的路径。</span></p><p><span class="yiyi-st" id="yiyi-393">取景器将根据需要缓存目录内容，为每个模块搜索进行统计调用以验证缓存未过期。</span><span class="yiyi-st" id="yiyi-394">因为缓存过期依赖于操作系统的文件系统状态信息的粒度，所以存在潜在的争用条件：搜索模块，创建新文件，然后搜索新文件所代表的模块。</span><span class="yiyi-st" id="yiyi-395">如果操作发生的速度足以满足stat调用的粒度，那么模块搜索将失败。</span><span class="yiyi-st" id="yiyi-396">为防止这种情况发生，当您动态创建模块时，请务必调用<a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal"><span class="pre">importlib.invalidate_caches()</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-397"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><dl class="attribute"><dt id="importlib.machinery.FileFinder.path"><span class="yiyi-st" id="yiyi-398"> <code class="descname">path</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-399">查找器将搜索的路径。</span></p></dd></dl><dl class="method"><dt id="importlib.machinery.FileFinder.find_spec"><span class="yiyi-st" id="yiyi-400"> <code class="descname">find_spec</code><span class="sig-paren">(</span><em>fullname</em>, <em>target=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-401">尝试在<a class="reference internal" href="#importlib.machinery.FileFinder.path" title="importlib.machinery.FileFinder.path"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a>内找到处理<em>fullname</em>的规范。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-402"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="importlib.machinery.FileFinder.find_loader"><span class="yiyi-st" id="yiyi-403"> <code class="descname">find_loader</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-404">试图在<a class="reference internal" href="#importlib.machinery.FileFinder.path" title="importlib.machinery.FileFinder.path"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a>中找到加载器来处理<em>fullname</em>。</span></p></dd></dl><dl class="method"><dt id="importlib.machinery.FileFinder.invalidate_caches"><span class="yiyi-st" id="yiyi-405"> <code class="descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-406">清除内部缓存。</span></p></dd></dl><dl class="classmethod"><dt id="importlib.machinery.FileFinder.path_hook"><span class="yiyi-st" id="yiyi-407"> <em class="property">classmethod </em><code class="descname">path_hook</code><span class="sig-paren">(</span><em>*loader_details</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-408">返回闭包以在<a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-attr docutils literal"><span class="pre">sys.path_hooks</span></code></a>上使用的类方法。</span><span class="yiyi-st" id="yiyi-409">一个<a class="reference internal" href="#importlib.machinery.FileFinder" title="importlib.machinery.FileFinder"><code class="xref py py-class docutils literal"><span class="pre">FileFinder</span></code></a>的实例由闭包使用直接给闭包的路径参数和<em>loader_details</em>间接返回。</span></p><p><span class="yiyi-st" id="yiyi-410">如果闭包的参数不是现有目录，则引发<a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a>。</span></p></dd></dl></dd></dl><dl class="class"><dt id="importlib.machinery.SourceFileLoader"><span class="yiyi-st" id="yiyi-411"> <em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">SourceFileLoader</code><span class="sig-paren">(</span><em>fullname</em>, <em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-412">通过继承<a class="reference internal" href="#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.FileLoader</span></code></a>来具体实现<a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.SourceLoader</span></code></a>，并提供其他方法的一些具体实现。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-413"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><dl class="attribute"><dt id="importlib.machinery.SourceFileLoader.name"><span class="yiyi-st" id="yiyi-414"> <code class="descname">name</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-415">该加载器将处理的模块的名称。</span></p></dd></dl><dl class="attribute"><dt id="importlib.machinery.SourceFileLoader.path"><span class="yiyi-st" id="yiyi-416"> <code class="descname">path</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-417">源文件的路径。</span></p></dd></dl><dl class="method"><dt id="importlib.machinery.SourceFileLoader.is_package"><span class="yiyi-st" id="yiyi-418"> <code class="descname">is_package</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-419">如果<a class="reference internal" href="#importlib.machinery.SourceFileLoader.path" title="importlib.machinery.SourceFileLoader.path"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a>显示为包，则返回true。</span></p></dd></dl><dl class="method"><dt id="importlib.machinery.SourceFileLoader.path_stats"><span class="yiyi-st" id="yiyi-420"> <code class="descname">path_stats</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-421"><a class="reference internal" href="#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.SourceLoader.path_stats()</span></code></a>的具体实现。</span></p></dd></dl><dl class="method"><dt id="importlib.machinery.SourceFileLoader.set_data"><span class="yiyi-st" id="yiyi-422"> <code class="descname">set_data</code><span class="sig-paren">(</span><em>path</em>, <em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-423"><a class="reference internal" href="#importlib.abc.SourceLoader.set_data" title="importlib.abc.SourceLoader.set_data"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.SourceLoader.set_data()</span></code></a>的具体实现。</span></p></dd></dl><dl class="method"><dt id="importlib.machinery.SourceFileLoader.load_module"><span class="yiyi-st" id="yiyi-424"> <code class="descname">load_module</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-425"><a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.Loader.load_module()</span></code></a>的具体实现，其中指定要加载的模块的名称是可选的。</span></p></dd></dl></dd></dl><dl class="class"><dt id="importlib.machinery.SourcelessFileLoader"><span class="yiyi-st" id="yiyi-426"> <em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">SourcelessFileLoader</code><span class="sig-paren">(</span><em>fullname</em>, <em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-427"><a class="reference internal" href="#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.FileLoader</span></code></a>的具体实现可以导入字节码文件（即</span><span class="yiyi-st" id="yiyi-428">没有源代码文件存在）。</span></p><p><span class="yiyi-st" id="yiyi-429">请注意，直接使用字节码文件（从而不是源代码文件）会禁止所有Python实现或更改字节码格式的Python新版本使用您的模块。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-430"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><dl class="attribute"><dt id="importlib.machinery.SourcelessFileLoader.name"><span class="yiyi-st" id="yiyi-431"> <code class="descname">name</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-432">加载器将处理的模块的名称。</span></p></dd></dl><dl class="attribute"><dt id="importlib.machinery.SourcelessFileLoader.path"><span class="yiyi-st" id="yiyi-433"> <code class="descname">path</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-434">字节码文件的路径。</span></p></dd></dl><dl class="method"><dt id="importlib.machinery.SourcelessFileLoader.is_package"><span class="yiyi-st" id="yiyi-435"> <code class="descname">is_package</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-436">根据<a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a>确定模块是否为包。</span></p></dd></dl><dl class="method"><dt id="importlib.machinery.SourcelessFileLoader.get_code"><span class="yiyi-st" id="yiyi-437"> <code class="descname">get_code</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-438">返回从<a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a>创建的<a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.name" title="importlib.machinery.SourcelessFileLoader.name"><code class="xref py py-attr docutils literal"><span class="pre">name</span></code></a>的代码对象。</span></p></dd></dl><dl class="method"><dt id="importlib.machinery.SourcelessFileLoader.get_source"><span class="yiyi-st" id="yiyi-439"> <code class="descname">get_source</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-440">返回<code class="docutils literal"><span class="pre">None</span></code>，因为使用此加载程序时，字节码文件没有源代码。</span></p></dd></dl><dl class="method"><dt id="importlib.machinery.SourcelessFileLoader.load_module"><span class="yiyi-st" id="yiyi-441"> <code class="descname">load_module</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span></span></dt><dd></dd></dl><p><span class="yiyi-st" id="yiyi-442"><a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.Loader.load_module()</span></code></a>的具体实现，其中指定要加载的模块的名称是可选的。</span></p></dd></dl><dl class="class"><dt id="importlib.machinery.ExtensionFileLoader"><span class="yiyi-st" id="yiyi-443"> <em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">ExtensionFileLoader</code><span class="sig-paren">(</span><em>fullname</em>, <em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-444">扩展模块的<a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.ExecutionLoader</span></code></a>的具体实现。</span></p><p><span class="yiyi-st" id="yiyi-445"><em>fullname</em>参数指定加载程序要支持的模块的名称。</span><span class="yiyi-st" id="yiyi-446"><em>path</em>参数是扩展模块文件的路径。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-447"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><dl class="attribute"><dt id="importlib.machinery.ExtensionFileLoader.name"><span class="yiyi-st" id="yiyi-448"> <code class="descname">name</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-449">加载程序支持的模块的名称。</span></p></dd></dl><dl class="attribute"><dt id="importlib.machinery.ExtensionFileLoader.path"><span class="yiyi-st" id="yiyi-450"> <code class="descname">path</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-451">扩展模块的路径。</span></p></dd></dl><dl class="method"><dt id="importlib.machinery.ExtensionFileLoader.create_module"><span class="yiyi-st" id="yiyi-452"> <code class="descname">create_module</code><span class="sig-paren">(</span><em>spec</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-453">按照<span class="target" id="index-18"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a>从给定规范创建模块对象。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-454"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="importlib.machinery.ExtensionFileLoader.exec_module"><span class="yiyi-st" id="yiyi-455"> <code class="descname">exec_module</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-456">根据<span class="target" id="index-19"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a>初始化给定的模块对象。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-457"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="importlib.machinery.ExtensionFileLoader.is_package"><span class="yiyi-st" id="yiyi-458"> <code class="descname">is_package</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-459">如果文件路径基于<a class="reference internal" href="#importlib.machinery.EXTENSION_SUFFIXES" title="importlib.machinery.EXTENSION_SUFFIXES"><code class="xref py py-attr docutils literal"><span class="pre">EXTENSION_SUFFIXES</span></code></a>指向程序包的<code class="docutils literal"><span class="pre">__init__</span></code>模块，则返回<code class="docutils literal"><span class="pre">True</span></code>。</span></p></dd></dl><dl class="method"><dt id="importlib.machinery.ExtensionFileLoader.get_code"><span class="yiyi-st" id="yiyi-460"> <code class="descname">get_code</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-461">返回<code class="docutils literal"><span class="pre">None</span></code>，因为扩展模块缺少代码对象。</span></p></dd></dl><dl class="method"><dt id="importlib.machinery.ExtensionFileLoader.get_source"><span class="yiyi-st" id="yiyi-462"> <code class="descname">get_source</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-463">返回<code class="docutils literal"><span class="pre">None</span></code>，因为扩展模块没有源代码。</span></p></dd></dl><dl class="method"><dt id="importlib.machinery.ExtensionFileLoader.get_filename"><span class="yiyi-st" id="yiyi-464"> <code class="descname">get_filename</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-465">返回<a class="reference internal" href="#importlib.machinery.ExtensionFileLoader.path" title="importlib.machinery.ExtensionFileLoader.path"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-466"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl></dd></dl><dl class="class"><dt id="importlib.machinery.ModuleSpec"><span class="yiyi-st" id="yiyi-467"> <em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">ModuleSpec</code><span class="sig-paren">(</span><em>name</em>, <em>loader</em>, <em>*</em>, <em>origin=None</em>, <em>loader_state=None</em>, <em>is_package=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-468">模块的导入系统相关状态的规范。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-469"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div><dl class="attribute"><dt id="importlib.machinery.ModuleSpec.name"><span class="yiyi-st" id="yiyi-470"> <code class="descname">name</code></span></dt><dd></dd></dl><p><span class="yiyi-st" id="yiyi-471">(<code class="docutils literal"><span class="pre">__name__</span></code>)</span></p><p><span class="yiyi-st" id="yiyi-472">一个字符串，用于模块的完全限定名称。</span></p><dl class="attribute"><dt id="importlib.machinery.ModuleSpec.loader"><span class="yiyi-st" id="yiyi-473"> <code class="descname">loader</code></span></dt><dd></dd></dl><p><span class="yiyi-st" id="yiyi-474">(<code class="docutils literal"><span class="pre">__loader__</span></code>)</span></p><p><span class="yiyi-st" id="yiyi-475">用于加载的加载器。</span><span class="yiyi-st" id="yiyi-476">对于命名空间包，应将其设置为None。</span></p><dl class="attribute"><dt id="importlib.machinery.ModuleSpec.origin"><span class="yiyi-st" id="yiyi-477"> <code class="descname">origin</code></span></dt><dd></dd></dl><p><span class="yiyi-st" id="yiyi-478">(<code class="docutils literal"><span class="pre">__file__</span></code>)</span></p><p><span class="yiyi-st" id="yiyi-479">装载模块的地点的名称，例如</span><span class="yiyi-st" id="yiyi-480">内置模块的“builtin”和从源加载的模块的文件名。</span><span class="yiyi-st" id="yiyi-481">通常应该设置“origin”，但可能是None（默认值），表示它是未指定的。</span></p><dl class="attribute"><dt id="importlib.machinery.ModuleSpec.submodule_search_locations"><span class="yiyi-st" id="yiyi-482"> <code class="descname">submodule_search_locations</code></span></dt><dd></dd></dl><p><span class="yiyi-st" id="yiyi-483">(<code class="docutils literal"><span class="pre">__path__</span></code>)</span></p><p><span class="yiyi-st" id="yiyi-484">如果是包（否则无），可以在哪里找到子模块的字符串列表。</span></p><dl class="attribute"><dt id="importlib.machinery.ModuleSpec.loader_state"><span class="yiyi-st" id="yiyi-485"> <code class="descname">loader_state</code></span></dt><dd></dd></dl><p><span class="yiyi-st" id="yiyi-486">装载期间使用的额外模块特定数据的容器（或无）。</span></p><dl class="attribute"><dt id="importlib.machinery.ModuleSpec.cached"><span class="yiyi-st" id="yiyi-487"> <code class="descname">cached</code></span></dt><dd></dd></dl><p><span class="yiyi-st" id="yiyi-488">(<code class="docutils literal"><span class="pre">__cached__</span></code>)</span></p><p><span class="yiyi-st" id="yiyi-489">字符串，用于编译模块应存储的位置（或无）。</span></p><dl class="attribute"><dt id="importlib.machinery.ModuleSpec.parent"><span class="yiyi-st" id="yiyi-490"> <code class="descname">parent</code></span></dt><dd></dd></dl><p><span class="yiyi-st" id="yiyi-491">(<code class="docutils literal"><span class="pre">__package__</span></code>)</span></p><p><span class="yiyi-st" id="yiyi-492">（只读）模块作为子模块所属的软件包的完全限定名称（或无）。</span></p><dl class="attribute"><dt id="importlib.machinery.ModuleSpec.has_location"><span class="yiyi-st" id="yiyi-493"> <code class="descname">has_location</code></span></dt><dd></dd></dl><p><span class="yiyi-st" id="yiyi-494">指示模块的“origin”属性是否指向可加载位置的布尔值。</span></p></dd></dl></div><div class="section" id="module-importlib.util"><h2><span class="yiyi-st" id="yiyi-495">31.5.5. <a class="reference internal" href="#module-importlib.util" title="importlib.util: Utility code for importers"><code class="xref py py-mod docutils literal"><span class="pre">importlib.util</span></code></a> — importer的实用程序代码</span></h2><p><span class="yiyi-st" id="yiyi-496"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/importlib/util.py">Lib/importlib/util.py</a></span></p><p><span class="yiyi-st" id="yiyi-497">该模块包含帮助构建<a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>的各种对象。</span></p><dl class="attribute"><dt id="importlib.util.MAGIC_NUMBER"><span class="yiyi-st" id="yiyi-498"> <code class="descclassname">importlib.util.</code><code class="descname">MAGIC_NUMBER</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-499">代表字节码版本号的字节。</span><span class="yiyi-st" id="yiyi-500">如果您需要加载/写入字节码的帮助，请考虑<a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.SourceLoader</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-501"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="importlib.util.cache_from_source"><span class="yiyi-st" id="yiyi-502"> <code class="descclassname">importlib.util.</code><code class="descname">cache_from_source</code><span class="sig-paren">(</span><em>path</em>, <em>debug_override=None</em>, <em>*</em>, <em>optimization=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-503">Return the <span class="target" id="index-20"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a>/<span class="target" id="index-21"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a> path to the byte-compiled file associated with the source <em>path</em>. </span><span class="yiyi-st" id="yiyi-504">例如，如果<em>path</em>是<code class="docutils literal"><span class="pre">/foo/bar/baz.py</span></code>，则返回值为<code class="docutils literal"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code> for Python 3.2。</span><span class="yiyi-st" id="yiyi-505"><code class="docutils literal"><span class="pre">cpython-32</span></code>字符串来自当前的魔术标签（参见<code class="xref py py-func docutils literal"><span class="pre">get_tag()</span></code>；如果没有定义<code class="xref py py-attr docutils literal"><span class="pre">sys.implementation.cache_tag</span></code>，则<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>会被提出）。</span></p><p><span class="yiyi-st" id="yiyi-506"><em>optimization</em>参数用于指定字节码文件的优化级别。</span><span class="yiyi-st" id="yiyi-507">一个空字符串表示没有优化，所以<code class="docutils literal"><span class="pre">/foo/bar/baz.py</span></code>与<em>优化</em> <code class="docutils literal"><span class="pre">''</span></code>将导致字节码路径为<code class="docutils literal"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code></span><span class="yiyi-st" id="yiyi-508"><code class="docutils literal"><span class="pre">None</span></code>会导致使用interpter的优化级别。</span><span class="yiyi-st" id="yiyi-509">使用任何其他值的字符串表示形式，所以<code class="docutils literal"><span class="pre">/foo/bar/baz.py</span></code>与<em>优化</em> <code class="docutils literal"><span class="pre">2</span></code>将导致字节码路径为<code class="docutils literal"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc</span></code></span><span class="yiyi-st" id="yiyi-510">The string representation of <em>optimization</em> can only be alphanumeric, else <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> is raised.</span></p><p><span class="yiyi-st" id="yiyi-511"><em>debug_override</em>参数已弃用，可用于覆盖<code class="docutils literal"><span class="pre">__debug__</span></code>的系统值。</span><span class="yiyi-st" id="yiyi-512">一个<code class="docutils literal"><span class="pre">True</span></code>值相当于将<em>优化</em>设置为空字符串。</span><span class="yiyi-st" id="yiyi-513">A <code class="docutils literal"><span class="pre">False</span></code>的值与<em>优化</em>至<code class="docutils literal"><span class="pre">1</span></code>的设置相同。</span><span class="yiyi-st" id="yiyi-514">如果<em>debug_override</em>和<em>优化</em>都不是<code class="docutils literal"><span class="pre">None</span></code>，则引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-515"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-516"><span class="versionmodified">在版本3.5中更改：</span>添加了<em>优化</em>参数，并且不推荐使用<em>debug_override</em>参数。</span></p></div></dd></dl><dl class="function"><dt id="importlib.util.source_from_cache"><span class="yiyi-st" id="yiyi-517"> <code class="descclassname">importlib.util.</code><code class="descname">source_from_cache</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-518">将<em>路径</em>指定给<span class="target" id="index-22"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a>文件名，返回关联的源代码文件路径。</span><span class="yiyi-st" id="yiyi-519">例如，如果<em>路径</em>为<code class="docutils literal"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code>，则返回的路径为<code class="docutils literal"><span class="pre">/foo/bar/baz.py</span></code>。</span><span class="yiyi-st" id="yiyi-520"><em>path</em> need not exist, however if it does not conform to <span class="target" id="index-23"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a> or <span class="target" id="index-24"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a> format, a <code class="docutils literal"><span class="pre">ValueError</span></code> is raised. </span><span class="yiyi-st" id="yiyi-521">如果未定义<code class="xref py py-attr docutils literal"><span class="pre">sys.implementation.cache_tag</span></code>，则会引发<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-522"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="importlib.util.decode_source"><span class="yiyi-st" id="yiyi-523"> <code class="descclassname">importlib.util.</code><code class="descname">decode_source</code><span class="sig-paren">(</span><em>source_bytes</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-524">解码表示源代码的给定字节，并将其作为带有通用换行符的字符串返回（如<a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.InspectLoader.get_source()</span></code></a>所要求的）。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-525"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="importlib.util.resolve_name"><span class="yiyi-st" id="yiyi-526"> <code class="descclassname">importlib.util.</code><code class="descname">resolve_name</code><span class="sig-paren">(</span><em>name</em>, <em>package</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-527">将相对模块名称解析为绝对模块名称。</span></p><p><span class="yiyi-st" id="yiyi-528">如果<strong>name</strong>没有前导点，则简单地返回<strong>name</strong>。</span><span class="yiyi-st" id="yiyi-529">这允许使用诸如<code class="docutils literal"><span class="pre">importlib.util.resolve_name（'sys'，</span> <span class="pre">__ package __）</span></code>，而不检查<strong>package</strong>参数是必需的。</span></p><p><span class="yiyi-st" id="yiyi-530"><a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> is raised if <strong>name</strong> is a relative module name but package is a false value (e.g. </span><span class="yiyi-st" id="yiyi-531"><code class="docutils literal"><span class="pre">None</span></code>或空字符串）。</span><span class="yiyi-st" id="yiyi-532"><a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> is also raised a relative name would escape its containing package (e.g. </span><span class="yiyi-st" id="yiyi-533">请求<code class="docutils literal"><span class="pre">spam</span></code>包中的<code class="docutils literal"><span class="pre">..bacon</span></code>）。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-534"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="importlib.util.find_spec"><span class="yiyi-st" id="yiyi-535"> <code class="descclassname">importlib.util.</code><code class="descname">find_spec</code><span class="sig-paren">(</span><em>name</em>, <em>package=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-536">查找模块的<a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a>，可选地相对于指定的<strong>包</strong>名称。</span><span class="yiyi-st" id="yiyi-537">If the module is in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal"><span class="pre">sys.modules</span></code></a>, then <code class="docutils literal"><span class="pre">sys.modules[name].__spec__</span></code> is returned (unless the spec would be <code class="docutils literal"><span class="pre">None</span></code> or is not set, in which case <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> is raised). </span><span class="yiyi-st" id="yiyi-538">否则，使用<a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal"><span class="pre">sys.meta_path</span></code></a>完成搜索。</span><span class="yiyi-st" id="yiyi-539"><code class="docutils literal"><span class="pre">None</span></code> is returned if no spec is found.</span></p><p><span class="yiyi-st" id="yiyi-540">如果<strong>name</strong>用于子模块（包含点），则会自动导入父模块。</span></p><p><span class="yiyi-st" id="yiyi-541"><strong>name</strong>和<strong>package</strong>与<code class="xref py py-func docutils literal"><span class="pre">import_module()</span></code>的工作方式相同。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-542"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="importlib.util.module_from_spec"><span class="yiyi-st" id="yiyi-543"> <code class="descclassname">importlib.util.</code><code class="descname">module_from_spec</code><span class="sig-paren">(</span><em>spec</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-544">根据<strong>spec</strong>和<code class="docutils literal"><span class="pre">spec.loader.create_module()</span></code>创建一个新模块。</span></p><p><span class="yiyi-st" id="yiyi-545">如果<code class="docutils literal"><span class="pre">spec.loader.create_module()</span></code>没有返回<code class="docutils literal"><span class="pre">None</span></code>，那么任何预先存在的属性都不会被重置。</span><span class="yiyi-st" id="yiyi-546">另外，如果在访问<strong>spec</strong>时触发，或者在模块上设置属性，则不会引发<a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-547">此功能优于使用<a class="reference internal" href="types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal"><span class="pre">types.ModuleType</span></code></a>创建新模块，因为<strong>spec</strong>用于在模块上设置尽可能多的导入控制属性。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-548"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="importlib.util.module_for_loader"><span class="yiyi-st" id="yiyi-549"> <code class="descclassname">@</code><code class="descclassname">importlib.util.</code><code class="descname">module_for_loader</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-550">用于<a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.Loader.load_module()</span></code></a>的<a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a>来处理选择要加载的适当模块对象。</span><span class="yiyi-st" id="yiyi-551">期望装饰方法具有带有两个位置参数（例如，</span><span class="yiyi-st" id="yiyi-552"><code class="docutils literal"><span class="pre">load_module(self,</span> <span class="pre">module)</span></code>) for which the second argument will be the module <strong>object</strong> to be used by the loader. </span><span class="yiyi-st" id="yiyi-553">请注意，由于假设有两个参数，装饰器不能用于静态方法。</span></p><p><span class="yiyi-st" id="yiyi-554">装饰好的方法将按照<a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>的预期加载模块的<strong>名称</strong>。</span><span class="yiyi-st" id="yiyi-555">如果在<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a>中找不到该模块，则会构建一个新模块。</span><span class="yiyi-st" id="yiyi-556">无论模块来自何处，设置为<strong>self</strong>和<a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a>的<a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal"><span class="pre">__loader__</span></code></a>都根据<a class="reference internal" href="#importlib.abc.InspectLoader.is_package" title="importlib.abc.InspectLoader.is_package"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.InspectLoader.is_package()</span></code></a>返回（如果可用）。</span><span class="yiyi-st" id="yiyi-557">这些属性被无条件设置为支持重新加载。</span></p><p><span class="yiyi-st" id="yiyi-558">如果装饰方法引发异常，并且将模块添加到<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a>中，则模块将被删除，以防止部分初始化的模块留在<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a></span><span class="yiyi-st" id="yiyi-559">如果该模块已经在<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a>中，那么它就被单独保留。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-560"><span class="versionmodified">Changed in version 3.3: </span><a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal"><span class="pre">__loader__</span></code></a> and <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a> are automatically set (when possible).</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-561"><span class="versionmodified">版本3.4中改变：</span>设置<a class="reference internal" href="../reference/import.html#__name__" title="__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a>，<a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal"><span class="pre">__loader__</span></code></a> <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a>无条件支持重新加载。</span></p></div><div class="deprecated"><p><span class="yiyi-st" id="yiyi-562"><span class="versionmodified">从版本3.4开始弃用：</span>现在，导入机器直接执行此功能提供的所有功能。</span></p></div></dd></dl><dl class="function"><dt id="importlib.util.set_loader"><span class="yiyi-st" id="yiyi-563"> <code class="descclassname">@</code><code class="descclassname">importlib.util.</code><code class="descname">set_loader</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-564">用于<a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.Loader.load_module()</span></code></a>的<a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a>在返回的模块上设置<a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal"><span class="pre">__loader__</span></code></a>属性。</span><span class="yiyi-st" id="yiyi-565">如果该属性已经设置，装饰器不做任何事情。</span><span class="yiyi-st" id="yiyi-566">假定包装方法的第一个位置参数（即，</span><span class="yiyi-st" id="yiyi-567"><code class="docutils literal"><span class="pre">self</span></code>）是<a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal"><span class="pre">__loader__</span></code></a>应该设置的值。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-568"><span class="versionmodified">Changed in version 3.4: </span>Set <code class="docutils literal"><span class="pre">__loader__</span></code> if set to <code class="docutils literal"><span class="pre">None</span></code>, as if the attribute does not exist.</span></p></div><div class="deprecated"><p><span class="yiyi-st" id="yiyi-569"><span class="versionmodified">从版本3.4开始弃用：</span>进口机械自动处理。</span></p></div></dd></dl><dl class="function"><dt id="importlib.util.set_package"><span class="yiyi-st" id="yiyi-570"> <code class="descclassname">@</code><code class="descclassname">importlib.util.</code><code class="descname">set_package</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-571">用于<a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.Loader.load_module()</span></code></a>的<a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a>在返回的模块上设置<a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a>属性。</span><span class="yiyi-st" id="yiyi-572">如果<a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a>被设置并且其值不是<code class="docutils literal"><span class="pre">None</span></code>，它将不会被更改。</span></p><div class="deprecated"><p><span class="yiyi-st" id="yiyi-573"><span class="versionmodified">从版本3.4开始弃用：</span>进口机械自动处理。</span></p></div></dd></dl><dl class="function"><dt id="importlib.util.spec_from_loader"><span class="yiyi-st" id="yiyi-574"> <code class="descclassname">importlib.util.</code><code class="descname">spec_from_loader</code><span class="sig-paren">(</span><em>name</em>, <em>loader</em>, <em>*</em>, <em>origin=None</em>, <em>is_package=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-575">基于加载程序创建<code class="xref py py-class docutils literal"><span class="pre">ModuleSpec</span></code>实例的工厂函数。</span><span class="yiyi-st" id="yiyi-576">这些参数与ModuleSpec具有相同的含义。</span><span class="yiyi-st" id="yiyi-577">该函数使用可用的<a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> API（例如<code class="xref py py-meth docutils literal"><span class="pre">InspectLoader.is_package()</span></code>）来填写规范中缺少的任何信息。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-578"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="importlib.util.spec_from_file_location"><span class="yiyi-st" id="yiyi-579"> <code class="descclassname">importlib.util.</code><code class="descname">spec_from_file_location</code><span class="sig-paren">(</span><em>name</em>, <em>location</em>, <em>*</em>, <em>loader=None</em>, <em>submodule_search_locations=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-580">基于文件路径创建<code class="xref py py-class docutils literal"><span class="pre">ModuleSpec</span></code>实例的工厂函数。</span><span class="yiyi-st" id="yiyi-581">缺少的信息将通过使用加载器API以及模块将基于文件的含义填充到规范中。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-582"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl><dl class="class"><dt id="importlib.util.LazyLoader"><span class="yiyi-st" id="yiyi-583"> <em class="property">class </em><code class="descclassname">importlib.util.</code><code class="descname">LazyLoader</code><span class="sig-paren">(</span><em>loader</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-584">推迟模块加载程序执行的类，直到模块具有访问的属性为止。</span></p><p><span class="yiyi-st" id="yiyi-585">该类仅<strong></strong>与定义<a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">exec_module()</span></code></a>的加载程序一起使用，以控制需要使用哪个模块类型的模块。</span><span class="yiyi-st" id="yiyi-586">出于同样的原因，加载程序的<a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal"><span class="pre">create_module()</span></code></a>方法将被忽略（即加载程序的方法应该只返回<code class="docutils literal"><span class="pre">None</span></code>；这不包括<code class="xref py py-class docutils literal"><span class="pre">BuiltinImporter</span></code>和<code class="xref py py-class docutils literal"><span class="pre">ExtensionFileLoader</span></code></span><span class="yiyi-st" id="yiyi-587">Finally, modules which substitute the object placed into <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal"><span class="pre">sys.modules</span></code></a> will not work as there is no way to properly replace the module references throughout the interpreter safely; <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> is raised if such a substitution is detected.</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-588">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-589">对于启动时间很关键的项目，如果从未使用模块，该类可以潜在地降低加载模块的成本。</span><span class="yiyi-st" id="yiyi-590">For projects where startup time is not essential then use of this class is <strong>heavily</strong> discouraged due to error messages created during loading being postponed and thus occurring out of context.</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-591"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div><dl class="classmethod"><dt id="importlib.util.LazyLoader.factory"><span class="yiyi-st" id="yiyi-592"> <em class="property">classmethod </em><code class="descname">factory</code><span class="sig-paren">(</span><em>loader</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-593">一个静态方法，它返回一个可创建懒惰加载器的可调用对象。</span><span class="yiyi-st" id="yiyi-594">这是为了在加载器按类而不是按实例传递的情况下使用。</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">suffixes</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SOURCE_SUFFIXES</span>
<span class="n">loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SourceFileLoader</span>
<span class="n">lazy_loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">LazyLoader</span><span class="o">.</span><span class="n">factory</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
<span class="n">finder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">FileFinder</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="p">(</span><span class="n">lazy_loader</span><span class="p">,</span> <span class="n">suffixes</span><span class="p">))</span>
</pre></div></div></dd></dl></dd></dl></div></div></div>