<div class="body" role="main"><div class="section" id="module-xdrlib"><h1><span class="yiyi-st" id="yiyi-10">14.4. <a class="reference internal" href="#module-xdrlib" title="xdrlib: Encoders and decoders for the External Data Representation (XDR)."><code class="xref py py-mod docutils literal"><span class="pre">xdrlib</span></code></a>  - 对XDR数据进行编码和解码</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/xdrlib.py">Lib / xdrlib.py</a></span></p><p><span class="yiyi-st" id="yiyi-12"><a class="reference internal" href="#module-xdrlib" title="xdrlib: Encoders and decoders for the External Data Representation (XDR)."><code class="xref py py-mod docutils literal"><span class="pre">xdrlib</span></code></a>模块支持由Sun Microsystems，Inc.于1987年6月编写的<span class="target" id="index-1"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc1014.html"><strong>RFC 1014</strong></a>中描述的外部数据表示标准。</span><span class="yiyi-st" id="yiyi-13">它支持RFC中描述的大多数数据类型。</span></p><p><span class="yiyi-st" id="yiyi-14"><a class="reference internal" href="#module-xdrlib" title="xdrlib: Encoders and decoders for the External Data Representation (XDR)."><code class="xref py py-mod docutils literal"><span class="pre">xdrlib</span></code></a>模块定义了两个类，一个用于封装变量为XDR表示，另一个用于XDR表示的分拆。</span><span class="yiyi-st" id="yiyi-15">还有两个异常类。</span></p><dl class="class"><dt id="xdrlib.Packer"><span class="yiyi-st" id="yiyi-16"> <em class="property">class </em><code class="descclassname">xdrlib.</code><code class="descname">Packer</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-17"><a class="reference internal" href="#xdrlib.Packer" title="xdrlib.Packer"><code class="xref py py-class docutils literal"><span class="pre">Packer</span></code></a>是封装数据到XDR表示形式的类。</span><span class="yiyi-st" id="yiyi-18"><a class="reference internal" href="#xdrlib.Packer" title="xdrlib.Packer"><code class="xref py py-class docutils literal"><span class="pre">Packer</span></code></a>类实例化时没有参数。</span></p></dd></dl><dl class="class"><dt id="xdrlib.Unpacker"><span class="yiyi-st" id="yiyi-19"> <em class="property">class </em><code class="descclassname">xdrlib.</code><code class="descname">Unpacker</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-20"><code class="docutils literal"><span class="pre">Unpacker</span></code>是从字符串缓冲区解包XDR数据值的互补类。</span><span class="yiyi-st" id="yiyi-21">输入缓冲区为<em>data</em>。</span></p></dd></dl><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-22">也可以看看</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-23"><span class="target" id="index-2"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc1014.html"><strong>RFC 1014</strong></a>  -  XDR：外部数据表示标准</span></dt><dd><span class="yiyi-st" id="yiyi-24">此RFC定义了在最初写入此模块时为XDR的数据的编码。</span><span class="yiyi-st" id="yiyi-25">它显然已被<span class="target" id="index-3"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc1832.html"><strong>RFC 1832</strong></a>废弃。</span></dd><dt><span class="yiyi-st" id="yiyi-26"><span class="target" id="index-4"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc1832.html"><strong>RFC 1832</strong></a>  -  XDR：外部数据表示标准</span></dt><dd><span class="yiyi-st" id="yiyi-27">较新的RFC，提供了XDR的修订定义。</span></dd></dl></div><div class="section" id="packer-objects"><h2><span class="yiyi-st" id="yiyi-28">14.4.1. </span><span class="yiyi-st" id="yiyi-29">Packer Objects</span></h2><p><span class="yiyi-st" id="yiyi-30"><a class="reference internal" href="#xdrlib.Packer" title="xdrlib.Packer"><code class="xref py py-class docutils literal"><span class="pre">Packer</span></code></a>实例具有以下方法：</span></p><dl class="method"><dt id="xdrlib.Packer.get_buffer"><span class="yiyi-st" id="yiyi-31"> <code class="descclassname">Packer.</code><code class="descname">get_buffer</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-32">以字符串形式返回当前封装缓冲区。</span></p></dd></dl><dl class="method"><dt id="xdrlib.Packer.reset"><span class="yiyi-st" id="yiyi-33"> <code class="descclassname">Packer.</code><code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-34">将封装缓冲区重置为空字符串。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-35">通常，您可以通过调用相应的<code class="docutils literal"><span class="pre">pack_type()</span></code>方法封装任何最常见的XDR数据类型。</span><span class="yiyi-st" id="yiyi-36">每个方法接受一个参数，值为封装。</span><span class="yiyi-st" id="yiyi-37">The following simple data type packing methods are supported: <code class="xref py py-meth docutils literal"><span class="pre">pack_uint()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">pack_int()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">pack_enum()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">pack_bool()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">pack_uhyper()</span></code>, and <code class="xref py py-meth docutils literal"><span class="pre">pack_hyper()</span></code>.</span></p><dl class="method"><dt id="xdrlib.Packer.pack_float"><span class="yiyi-st" id="yiyi-38"> <code class="descclassname">Packer.</code><code class="descname">pack_float</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-39">打包单精度浮点数<em>值</em>。</span></p></dd></dl><dl class="method"><dt id="xdrlib.Packer.pack_double"><span class="yiyi-st" id="yiyi-40"> <code class="descclassname">Packer.</code><code class="descname">pack_double</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-41">打包双精度浮点数<em>值</em>。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-42">以下方法支持封装字符串，字节和不透明数据：</span></p><dl class="method"><dt id="xdrlib.Packer.pack_fstring"><span class="yiyi-st" id="yiyi-43"> <code class="descclassname">Packer.</code><code class="descname">pack_fstring</code><span class="sig-paren">(</span><em>n</em>, <em>s</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-44">打包固定长度的字符串<em>s</em>。 <em>n</em>是字符串的长度，但它<em>不</em>打包到数据缓冲区。</span><span class="yiyi-st" id="yiyi-45">如果需要，字符串用空字节填充以保证4字节对齐。</span></p></dd></dl><dl class="method"><dt id="xdrlib.Packer.pack_fopaque"><span class="yiyi-st" id="yiyi-46"> <code class="descclassname">Packer.</code><code class="descname">pack_fopaque</code><span class="sig-paren">(</span><em>n</em>, <em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-47">类似于<a class="reference internal" href="#xdrlib.Packer.pack_fstring" title="xdrlib.Packer.pack_fstring"><code class="xref py py-meth docutils literal"><span class="pre">pack_fstring()</span></code></a>，包装固定长度的不透明数据流。</span></p></dd></dl><dl class="method"><dt id="xdrlib.Packer.pack_string"><span class="yiyi-st" id="yiyi-48"> <code class="descclassname">Packer.</code><code class="descname">pack_string</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-49">打包可变长度字符串<em>s</em>。字符串的长度首先作为无符号整数打包，然后用<a class="reference internal" href="#xdrlib.Packer.pack_fstring" title="xdrlib.Packer.pack_fstring"><code class="xref py py-meth docutils literal"><span class="pre">pack_fstring()</span></code></a>打包该字符串数据。</span></p></dd></dl><dl class="method"><dt id="xdrlib.Packer.pack_opaque"><span class="yiyi-st" id="yiyi-50"> <code class="descclassname">Packer.</code><code class="descname">pack_opaque</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-51">类似于<a class="reference internal" href="#xdrlib.Packer.pack_string" title="xdrlib.Packer.pack_string"><code class="xref py py-meth docutils literal"><span class="pre">pack_string()</span></code></a>包装一个可变长度的不透明数据字符串。</span></p></dd></dl><dl class="method"><dt id="xdrlib.Packer.pack_bytes"><span class="yiyi-st" id="yiyi-52"> <code class="descclassname">Packer.</code><code class="descname">pack_bytes</code><span class="sig-paren">(</span><em>bytes</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-53">类似于<a class="reference internal" href="#xdrlib.Packer.pack_string" title="xdrlib.Packer.pack_string"><code class="xref py py-meth docutils literal"><span class="pre">pack_string()</span></code></a>包装一个可变长度的字节流。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-54">以下方法支持封装数组和列表：</span></p><dl class="method"><dt id="xdrlib.Packer.pack_list"><span class="yiyi-st" id="yiyi-55"> <code class="descclassname">Packer.</code><code class="descname">pack_list</code><span class="sig-paren">(</span><em>list</em>, <em>pack_item</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-56">包装同质物品的<em>列表</em>。</span><span class="yiyi-st" id="yiyi-57">此方法对于具有不确定大小的列表很有用；即：</span><span class="yiyi-st" id="yiyi-58">在整个列表已经遍历之前，该大小不可用。</span><span class="yiyi-st" id="yiyi-59">对于列表中的每个项目，首先打包无符号整数<code class="docutils literal"><span class="pre">1</span></code>，后跟数组值。</span><span class="yiyi-st" id="yiyi-60"><em>pack_item</em>是用于封装单个项目的函数。</span><span class="yiyi-st" id="yiyi-61">在列表的末尾，打包无符号整数<code class="docutils literal"><span class="pre">0</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-62">例如，要封装整数列表，代码可能如下所示：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xdrlib</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">xdrlib</span><span class="o">.</span><span class="n">Packer</span><span class="p">()</span>
<span class="n">p</span><span class="o">.</span><span class="n">pack_list</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">p</span><span class="o">.</span><span class="n">pack_int</span><span class="p">)</span>
</pre></div></div></dd></dl><dl class="method"><dt id="xdrlib.Packer.pack_farray"><span class="yiyi-st" id="yiyi-63"> <code class="descclassname">Packer.</code><code class="descname">pack_farray</code><span class="sig-paren">(</span><em>n</em>, <em>array</em>, <em>pack_item</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-64">打包均匀项的固定长度列表（<em>数组</em>）。</span><span class="yiyi-st" id="yiyi-65"><em>n</em> is the length of the list; it is <em>not</em> packed into the buffer, but a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> exception is raised if <code class="docutils literal"><span class="pre">len(array)</span></code> is not equal to <em>n</em>. As above, <em>pack_item</em> is the function used to pack each element.</span></p></dd></dl><dl class="method"><dt id="xdrlib.Packer.pack_array"><span class="yiyi-st" id="yiyi-66"> <code class="descclassname">Packer.</code><code class="descname">pack_array</code><span class="sig-paren">(</span><em>list</em>, <em>pack_item</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-67">包含均匀项目的变长<em>列表</em>。</span><span class="yiyi-st" id="yiyi-68">首先，列表的长度打包为无符号整数，然后每个元素被打包为<a class="reference internal" href="#xdrlib.Packer.pack_farray" title="xdrlib.Packer.pack_farray"><code class="xref py py-meth docutils literal"><span class="pre">pack_farray()</span></code></a>。</span></p></dd></dl></div><div class="section" id="unpacker-objects"><h2><span class="yiyi-st" id="yiyi-69">14.4.2. </span><span class="yiyi-st" id="yiyi-70">Unpacker Objects</span></h2><p><span class="yiyi-st" id="yiyi-71"><a class="reference internal" href="#xdrlib.Unpacker" title="xdrlib.Unpacker"><code class="xref py py-class docutils literal"><span class="pre">Unpacker</span></code></a>类提供以下方法：</span></p><dl class="method"><dt id="xdrlib.Unpacker.reset"><span class="yiyi-st" id="yiyi-72"> <code class="descclassname">Unpacker.</code><code class="descname">reset</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-73">使用给定的<em>数据</em>重置字符串缓冲区。</span></p></dd></dl><dl class="method"><dt id="xdrlib.Unpacker.get_position"><span class="yiyi-st" id="yiyi-74"> <code class="descclassname">Unpacker.</code><code class="descname">get_position</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-75">返回数据缓冲区中的当前分离位置。</span></p></dd></dl><dl class="method"><dt id="xdrlib.Unpacker.set_position"><span class="yiyi-st" id="yiyi-76"> <code class="descclassname">Unpacker.</code><code class="descname">set_position</code><span class="sig-paren">(</span><em>position</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-77">将数据缓冲区分离位置设置为<em>位置</em>。</span><span class="yiyi-st" id="yiyi-78">您应该小心使用<a class="reference internal" href="#xdrlib.Unpacker.get_position" title="xdrlib.Unpacker.get_position"><code class="xref py py-meth docutils literal"><span class="pre">get_position()</span></code></a>和<a class="reference internal" href="#xdrlib.Unpacker.set_position" title="xdrlib.Unpacker.set_position"><code class="xref py py-meth docutils literal"><span class="pre">set_position()</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="xdrlib.Unpacker.get_buffer"><span class="yiyi-st" id="yiyi-79"> <code class="descclassname">Unpacker.</code><code class="descname">get_buffer</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-80">以字符串形式返回当前分拆数据缓冲区。</span></p></dd></dl><dl class="method"><dt id="xdrlib.Unpacker.done"><span class="yiyi-st" id="yiyi-81"> <code class="descclassname">Unpacker.</code><code class="descname">done</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-82">表示分拆完成。</span><span class="yiyi-st" id="yiyi-83">如果所有数据未解压缩，则引发<a class="reference internal" href="#xdrlib.Error" title="xdrlib.Error"><code class="xref py py-exc docutils literal"><span class="pre">Error</span></code></a>异常。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-84">此外，可以使用<a class="reference internal" href="#xdrlib.Packer" title="xdrlib.Packer"><code class="xref py py-class docutils literal"><span class="pre">Packer</span></code></a>打包的每种数据类型都可以使用<a class="reference internal" href="#xdrlib.Unpacker" title="xdrlib.Unpacker"><code class="xref py py-class docutils literal"><span class="pre">Unpacker</span></code></a>解压缩。</span><span class="yiyi-st" id="yiyi-85">分拆方法的形式是<code class="docutils literal"><span class="pre">unpack_type()</span></code>，并且不带参数。</span><span class="yiyi-st" id="yiyi-86">它们返回未打包的对象。</span></p><dl class="method"><dt id="xdrlib.Unpacker.unpack_float"><span class="yiyi-st" id="yiyi-87"> <code class="descclassname">Unpacker.</code><code class="descname">unpack_float</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-88">解包单精度浮点数。</span></p></dd></dl><dl class="method"><dt id="xdrlib.Unpacker.unpack_double"><span class="yiyi-st" id="yiyi-89"> <code class="descclassname">Unpacker.</code><code class="descname">unpack_double</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-90">类似于<a class="reference internal" href="#xdrlib.Unpacker.unpack_float" title="xdrlib.Unpacker.unpack_float"><code class="xref py py-meth docutils literal"><span class="pre">unpack_float()</span></code></a>，打开双精度浮点数。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-91">另外，以下方法分拆字符串，字节和不透明数据：</span></p><dl class="method"><dt id="xdrlib.Unpacker.unpack_fstring"><span class="yiyi-st" id="yiyi-92"> <code class="descclassname">Unpacker.</code><code class="descname">unpack_fstring</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-93">解包并返回固定长度的字符串。</span><span class="yiyi-st" id="yiyi-94"><em>n</em>是预期的字符数。</span><span class="yiyi-st" id="yiyi-95">假设填充空字节以保证4字节对齐。</span></p></dd></dl><dl class="method"><dt id="xdrlib.Unpacker.unpack_fopaque"><span class="yiyi-st" id="yiyi-96"> <code class="descclassname">Unpacker.</code><code class="descname">unpack_fopaque</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-97">与<a class="reference internal" href="#xdrlib.Unpacker.unpack_fstring" title="xdrlib.Unpacker.unpack_fstring"><code class="xref py py-meth docutils literal"><span class="pre">unpack_fstring()</span></code></a>类似，解包并返回固定长度的不透明数据流。</span></p></dd></dl><dl class="method"><dt id="xdrlib.Unpacker.unpack_string"><span class="yiyi-st" id="yiyi-98"> <code class="descclassname">Unpacker.</code><code class="descname">unpack_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-99">解包并返回可变长度的字符串。</span><span class="yiyi-st" id="yiyi-100">字符串的长度首先作为无符号整数解包，然后使用<a class="reference internal" href="#xdrlib.Unpacker.unpack_fstring" title="xdrlib.Unpacker.unpack_fstring"><code class="xref py py-meth docutils literal"><span class="pre">unpack_fstring()</span></code></a>解压缩字符串数据。</span></p></dd></dl><dl class="method"><dt id="xdrlib.Unpacker.unpack_opaque"><span class="yiyi-st" id="yiyi-101"> <code class="descclassname">Unpacker.</code><code class="descname">unpack_opaque</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-102">与<a class="reference internal" href="#xdrlib.Unpacker.unpack_string" title="xdrlib.Unpacker.unpack_string"><code class="xref py py-meth docutils literal"><span class="pre">unpack_string()</span></code></a>类似，解包并返回可变长度的不透明数据字符串。</span></p></dd></dl><dl class="method"><dt id="xdrlib.Unpacker.unpack_bytes"><span class="yiyi-st" id="yiyi-103"> <code class="descclassname">Unpacker.</code><code class="descname">unpack_bytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-104">与<a class="reference internal" href="#xdrlib.Unpacker.unpack_string" title="xdrlib.Unpacker.unpack_string"><code class="xref py py-meth docutils literal"><span class="pre">unpack_string()</span></code></a>类似，解压缩并返回可变长度的字节流。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-105">以下方法支持分拆数组和列表：</span></p><dl class="method"><dt id="xdrlib.Unpacker.unpack_list"><span class="yiyi-st" id="yiyi-106"> <code class="descclassname">Unpacker.</code><code class="descname">unpack_list</code><span class="sig-paren">(</span><em>unpack_item</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-107">解包并返回均匀项目的列表。</span><span class="yiyi-st" id="yiyi-108">该列表通过首先拆分无符号整数标志来一次解包一个元素。</span><span class="yiyi-st" id="yiyi-109">如果该标志为<code class="docutils literal"><span class="pre">1</span></code>，则该项目被解包并附加到列表。</span><span class="yiyi-st" id="yiyi-110"><code class="docutils literal"><span class="pre">0</span></code>的标志表示列表的结尾。</span><span class="yiyi-st" id="yiyi-111"><em>unpack_item</em>是调用以拆分项目的函数。</span></p></dd></dl><dl class="method"><dt id="xdrlib.Unpacker.unpack_farray"><span class="yiyi-st" id="yiyi-112"> <code class="descclassname">Unpacker.</code><code class="descname">unpack_farray</code><span class="sig-paren">(</span><em>n</em>, <em>unpack_item</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-113">解包并返回（作为列表）一个固定长度的同质项目数组。</span><span class="yiyi-st" id="yiyi-114"><em>n</em>是在缓冲区中期望的列表元素的数量。</span><span class="yiyi-st" id="yiyi-115">如上，<em>unpack_item</em>是用于分拆每个元素的函数。</span></p></dd></dl><dl class="method"><dt id="xdrlib.Unpacker.unpack_array"><span class="yiyi-st" id="yiyi-116"> <code class="descclassname">Unpacker.</code><code class="descname">unpack_array</code><span class="sig-paren">(</span><em>unpack_item</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-117">解包并返回均匀项的可变长度<em>列表</em>。</span><span class="yiyi-st" id="yiyi-118">首先，列表的长度被解包为无符号整数，则每个元素被解包，如在上面的<a class="reference internal" href="#xdrlib.Unpacker.unpack_farray" title="xdrlib.Unpacker.unpack_farray"><code class="xref py py-meth docutils literal"><span class="pre">unpack_farray()</span></code></a>中。</span></p></dd></dl></div><div class="section" id="exceptions"><h2><span class="yiyi-st" id="yiyi-119">14.4.3. </span><span class="yiyi-st" id="yiyi-120">Exceptions</span></h2><p><span class="yiyi-st" id="yiyi-121">此模块中的异常被编码为类实例：</span></p><dl class="exception"><dt id="xdrlib.Error"><span class="yiyi-st" id="yiyi-122"> <em class="property">exception </em><code class="descclassname">xdrlib.</code><code class="descname">Error</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-123">基本异常类。</span><span class="yiyi-st" id="yiyi-124"><a class="reference internal" href="#xdrlib.Error" title="xdrlib.Error"><code class="xref py py-exc docutils literal"><span class="pre">Error</span></code></a>具有包含错误描述的单个公共属性<code class="xref py py-attr docutils literal"><span class="pre">msg</span></code>。</span></p></dd></dl><dl class="exception"><dt id="xdrlib.ConversionError"><span class="yiyi-st" id="yiyi-125"> <em class="property">exception </em><code class="descclassname">xdrlib.</code><code class="descname">ConversionError</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-126">源自<a class="reference internal" href="#xdrlib.Error" title="xdrlib.Error"><code class="xref py py-exc docutils literal"><span class="pre">Error</span></code></a>的类。</span><span class="yiyi-st" id="yiyi-127">不包含其他实例变量。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-128">这里是一个例子，你将如何捕获这些异常之一：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xdrlib</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">xdrlib</span><span class="o">.</span><span class="n">Packer</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">p</span><span class="o">.</span><span class="n">pack_double</span><span class="p">(</span><span class="mf">8.01</span><span class="p">)</span>
<span class="k">except</span> <span class="n">xdrlib</span><span class="o">.</span><span class="n">ConversionError</span> <span class="k">as</span> <span class="n">instance</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'packing the double failed:'</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="n">msg</span><span class="p">)</span>
</pre></div></div></div></div></div>