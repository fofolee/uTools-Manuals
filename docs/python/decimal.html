<div class="body" role="main"><div class="section" id="module-decimal"><h1><span class="yiyi-st" id="yiyi-10">9.4.  <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a>  - 十进制定点和浮点运算</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/decimal.py">Lib / decimal.py</a></span></p><p><span class="yiyi-st" id="yiyi-12"><a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a>模块支持快速正确舍入的十进制浮点运算。</span><span class="yiyi-st" id="yiyi-13">它比<a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>数据类型提供了几个优点：</span></p><ul><li><p class="first"><span class="yiyi-st" id="yiyi-14">十进制“是基于一个浮点模型，该模型是以人为本设计的，并且必须有一个最重要的指导原则 - 计算机必须提供一种与人们在学校学习的算术相同的算法。” - 摘自十进制算术规范。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-15">十进制数字可以精确表示。</span><span class="yiyi-st" id="yiyi-16">相比之下，像<code class="xref py py-const docutils literal"><span class="pre">1.1</span></code>和<code class="xref py py-const docutils literal"><span class="pre">2.2</span></code>这样的数字在二进制浮点中没有精确的表示。</span><span class="yiyi-st" id="yiyi-17">End users typically would not expect <code class="docutils literal"><span class="pre">1.1</span> <span class="pre">+</span> <span class="pre">2.2</span></code> to display as <code class="xref py py-const docutils literal"><span class="pre">3.3000000000000003</span></code> as it does with binary floating point.</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-18">精确性被转化为算术。</span><span class="yiyi-st" id="yiyi-19">在十进制浮点数中，<code class="docutils literal"><span class="pre">0.1</span> + <span class="pre"></span> <span class="pre">0.1</span> <span class="pre"></span> + <span class="pre">0.1</span> <span class="pre"> - </span> <span class="pre">0.3</span></code>正好等于零。</span><span class="yiyi-st" id="yiyi-20">在二进制浮点中，结果是<code class="xref py py-const docutils literal"><span class="pre">5.5511151231257827e-017</span></code>。</span><span class="yiyi-st" id="yiyi-21">尽管接近于零，但差异阻止了可靠的平等测试，并且可能会积累差异。</span><span class="yiyi-st" id="yiyi-22">由于这个原因，在具有严格的等式不变量的会计应用中，小数是优选的。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-23">The decimal module incorporates a notion of significant places so that <code class="docutils literal"><span class="pre">1.30</span> <span class="pre">+</span> <span class="pre">1.20</span></code> is <code class="xref py py-const docutils literal"><span class="pre">2.50</span></code>. </span><span class="yiyi-st" id="yiyi-24">尾随零保持显示重要性。</span><span class="yiyi-st" id="yiyi-25">这是货币应用的惯例。</span><span class="yiyi-st" id="yiyi-26">对于乘法，“教科书”方法使用被乘数中的所有数字。</span><span class="yiyi-st" id="yiyi-27">For instance, <code class="docutils literal"><span class="pre">1.3</span> <span class="pre">*</span> <span class="pre">1.2</span></code> gives <code class="xref py py-const docutils literal"><span class="pre">1.56</span></code> while <code class="docutils literal"><span class="pre">1.30</span> <span class="pre">*</span> <span class="pre">1.20</span></code> gives <code class="xref py py-const docutils literal"><span class="pre">1.5600</span></code>.</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-28">与基于硬件的二进制浮点不同，十进制模块具有用户可更改的精度（默认为28个位置），对于给定的问题，该精度可以与需要的一样大：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal('0.142857')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal('0.1428571428571428571428571429')</span>
</pre></div></div></li><li><p class="first"><span class="yiyi-st" id="yiyi-29">二进制和十进制浮点都是按照已发布的标准实现的。</span><span class="yiyi-st" id="yiyi-30">尽管内置的float类型只展示了它的功能中的一小部分，但十进制模块公开了标准的所有必需部分。</span><span class="yiyi-st" id="yiyi-31">在需要时，程序员可以完全控制舍入和信号处理。</span><span class="yiyi-st" id="yiyi-32">这包括通过使用例外来阻止任何不精确操作来强制执行精确算术的选项。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-33">十进制模块被设计为支持“没有偏见，精确的未被占用的十进制算术（有时称为定点算术）和四舍五入的浮点算术。” - 摘自十进制算术规范。</span></p></li></ul><p><span class="yiyi-st" id="yiyi-34">模块设计以三个概念为中心：十进制数，算术环境和信号。</span></p><p><span class="yiyi-st" id="yiyi-35">十进制数是不可变的。</span><span class="yiyi-st" id="yiyi-36">它有一个符号，系数数字和一个指数。</span><span class="yiyi-st" id="yiyi-37">为了保留重要性，系数数字不会截断尾随零。</span><span class="yiyi-st" id="yiyi-38">Decimals also include special values such as <code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code>, <code class="xref py py-const docutils literal"><span class="pre">-Infinity</span></code>, and <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code>. </span><span class="yiyi-st" id="yiyi-39">该标准还将<code class="xref py py-const docutils literal"><span class="pre">-0</span></code>与<code class="xref py py-const docutils literal"><span class="pre">+0</span></code>区分开来。</span></p><p><span class="yiyi-st" id="yiyi-40">算术环境是指定精度的环境，舍入规则，指数限制，指示操作结果的标志，以及确定信号是否被视为例外的陷阱启动器。</span><span class="yiyi-st" id="yiyi-41">Rounding options include <a class="reference internal" href="#decimal.ROUND_CEILING" title="decimal.ROUND_CEILING"><code class="xref py py-const docutils literal"><span class="pre">ROUND_CEILING</span></code></a>, <a class="reference internal" href="#decimal.ROUND_DOWN" title="decimal.ROUND_DOWN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_DOWN</span></code></a>, <a class="reference internal" href="#decimal.ROUND_FLOOR" title="decimal.ROUND_FLOOR"><code class="xref py py-const docutils literal"><span class="pre">ROUND_FLOOR</span></code></a>, <a class="reference internal" href="#decimal.ROUND_HALF_DOWN" title="decimal.ROUND_HALF_DOWN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_DOWN</span></code></a>, <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_EVEN</span></code></a>, <a class="reference internal" href="#decimal.ROUND_HALF_UP" title="decimal.ROUND_HALF_UP"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_UP</span></code></a>, <a class="reference internal" href="#decimal.ROUND_UP" title="decimal.ROUND_UP"><code class="xref py py-const docutils literal"><span class="pre">ROUND_UP</span></code></a>, and <a class="reference internal" href="#decimal.ROUND_05UP" title="decimal.ROUND_05UP"><code class="xref py py-const docutils literal"><span class="pre">ROUND_05UP</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-42">信号是在计算过程中出现的一组特殊情况。</span><span class="yiyi-st" id="yiyi-43">根据应用的需要，信号可能被忽略，被视为信息性的，或被视为例外。</span><span class="yiyi-st" id="yiyi-44">The signals in the decimal module are: <a class="reference internal" href="#decimal.Clamped" title="decimal.Clamped"><code class="xref py py-const docutils literal"><span class="pre">Clamped</span></code></a>, <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal"><span class="pre">InvalidOperation</span></code></a>, <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-const docutils literal"><span class="pre">DivisionByZero</span></code></a>, <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal"><span class="pre">Inexact</span></code></a>, <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal"><span class="pre">Rounded</span></code></a>, <a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-const docutils literal"><span class="pre">Subnormal</span></code></a>, <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-const docutils literal"><span class="pre">Overflow</span></code></a>, <a class="reference internal" href="#decimal.Underflow" title="decimal.Underflow"><code class="xref py py-const docutils literal"><span class="pre">Underflow</span></code></a> and <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-const docutils literal"><span class="pre">FloatOperation</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-45">每个信号都有一个标志和一个陷阱启动器。</span><span class="yiyi-st" id="yiyi-46">遇到信号时，其标志被设置为1，然后，如果陷阱启用码设置为1，则会引发异常。</span><span class="yiyi-st" id="yiyi-47">标志是粘性的，所以用户在监控计算之前需要重置它们。</span></p><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-48">也可以看看</span></p><ul class="last simple"><li><span class="yiyi-st" id="yiyi-49">IBM’s General Decimal Arithmetic Specification, <a class="reference external" href="http://speleotrove.com/decimal/decarith.html">The General Decimal Arithmetic Specification</a>.</span></li></ul></div><div class="section" id="quick-start-tutorial"><h2><span class="yiyi-st" id="yiyi-50">9.4.1.</span><span class="yiyi-st" id="yiyi-51">快速入门教程</span></h2><p><span class="yiyi-st" id="yiyi-52">通常开始使用小数是导入模块，使用<a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a>查看当前上下文，并在必要时为精度，舍入或启用的陷阱设置新值：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span>
<span class="go">Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[], traps=[Overflow, DivisionByZero,</span>
<span class="go">        InvalidOperation])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">7</span>       <span class="c1"># Set a new precision</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-53">十进制实例可以用整数，字符串，浮点数或元组构造。</span><span class="yiyi-st" id="yiyi-54">从整数或浮点构造执行该整数或浮点的值的精确转换。</span><span class="yiyi-st" id="yiyi-55">Decimal numbers include special values such as <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> which stands for “Not a number”, positive and negative <code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code>, and <code class="xref py py-const docutils literal"><span class="pre">-0</span></code>:</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">Decimal('10')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'3.14'</span><span class="p">)</span>
<span class="go">Decimal('3.14')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="go">Decimal('3.140000000000000124344978758017532527446746826171875')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
<span class="go">Decimal('3.14')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">))</span>
<span class="go">Decimal('1.4142135623730951')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'0.5'</span><span class="p">)</span>
<span class="go">Decimal('1.414213562373095048801688724')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'NaN'</span><span class="p">)</span>
<span class="go">Decimal('NaN')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'-Infinity'</span><span class="p">)</span>
<span class="go">Decimal('-Infinity')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-56">如果<a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal"><span class="pre">FloatOperation</span></code></a>信号被捕获，则在构造函数中意外混合小数点和浮点数或进行排序比较会引发异常：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">getcontext</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">FloatOperation</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.FloatOperation</span>: <span class="n">[&lt;class 'decimal.FloatOperation'&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'3.5'</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">3.7</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.FloatOperation</span>: <span class="n">[&lt;class 'decimal.FloatOperation'&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'3.5'</span><span class="p">)</span> <span class="o">==</span> <span class="mf">3.5</span>
<span class="go">True</span>
</pre></div></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-57"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><p><span class="yiyi-st" id="yiyi-58">新Decimal的意义仅由输入的位数决定。</span><span class="yiyi-st" id="yiyi-59">上下文精度和舍入仅在算术运算中发挥作用。</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'3.0'</span><span class="p">)</span>
<span class="go">Decimal('3.0')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'3.1415926535'</span><span class="p">)</span>
<span class="go">Decimal('3.1415926535')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'3.1415926535'</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'2.7182818285'</span><span class="p">)</span>
<span class="go">Decimal('5.85987')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">rounding</span> <span class="o">=</span> <span class="n">ROUND_UP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'3.1415926535'</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'2.7182818285'</span><span class="p">)</span>
<span class="go">Decimal('5.85988')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-60">如果C版本的内部限制被超过，构造一个小数将引发<a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-class docutils literal"><span class="pre">InvalidOperation</span></code></a>：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s2">"1e9999999999999999999"</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.InvalidOperation</span>: <span class="n">[&lt;class 'decimal.InvalidOperation'&gt;]</span>
</pre></div></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-61"><span class="versionmodified">在版本3.3中更改</span></span></p></div><p><span class="yiyi-st" id="yiyi-62">小数与Python的其余部分很好地交互。</span><span class="yiyi-st" id="yiyi-63">这里有一个小小数浮点飞行马戏团：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="s1">'1.34 1.87 3.45 2.35 1.00 0.03 9.25'</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal('9.25')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal('0.03')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">[Decimal('0.03'), Decimal('1.00'), Decimal('1.34'), Decimal('1.87'),</span>
<span class="go"> Decimal('2.35'), Decimal('3.45'), Decimal('9.25')]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal('19.29')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">'1.34'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.34</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Decimal('1.3')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="mi">5</span>
<span class="go">Decimal('6.70')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="go">Decimal('2.5058')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">%</span> <span class="n">a</span>
<span class="go">Decimal('0.77')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-64">还有一些数学函数也可用于Decimal：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
<span class="go">Decimal('1.414213562373095048801688724')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal('2.718281828459045235360287471')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'10'</span><span class="p">)</span><span class="o">.</span><span class="n">ln</span><span class="p">()</span>
<span class="go">Decimal('2.302585092994045684017991455')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'10'</span><span class="p">)</span><span class="o">.</span><span class="n">log10</span><span class="p">()</span>
<span class="go">Decimal('1')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-65"><code class="xref py py-meth docutils literal"><span class="pre">quantize()</span></code>方法将数字四舍五入为固定的指数。</span><span class="yiyi-st" id="yiyi-66">这种方法对于货币应用程序非常有用，这些应用程序通常会将结果转换为固定数量的地方</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'7.325'</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'.01'</span><span class="p">),</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span>
<span class="go">Decimal('7.32')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'7.325'</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'1.'</span><span class="p">),</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_UP</span><span class="p">)</span>
<span class="go">Decimal('8')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-67">如上所示，<a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a>函数访问当前上下文并允许更改设置。</span><span class="yiyi-st" id="yiyi-68">这种方法可以满足大多数应用的需求。</span></p><p><span class="yiyi-st" id="yiyi-69">对于更高级的工作，使用Context()构造函数创建备用上下文可能很有用。</span><span class="yiyi-st" id="yiyi-70">要使备用活动起作用，请使用<a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal"><span class="pre">setcontext()</span></code></a>函数。</span></p><p><span class="yiyi-st" id="yiyi-71">根据标准，<a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a>模块提供了两个准备使用的标准上下文：<a class="reference internal" href="#decimal.BasicContext" title="decimal.BasicContext"><code class="xref py py-const docutils literal"><span class="pre">BasicContext</span></code></a>和<a class="reference internal" href="#decimal.ExtendedContext" title="decimal.ExtendedContext"><code class="xref py py-const docutils literal"><span class="pre">ExtendedContext</span></code></a>。</span><span class="yiyi-st" id="yiyi-72">前者对于调试特别有用，因为许多陷阱都已启用：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">myothercontext</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_HALF_DOWN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">myothercontext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal('0.142857142857142857142857142857142857142857142857142857142857')</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ExtendedContext</span>
<span class="go">Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[], traps=[])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal('0.142857143')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Decimal('Infinity')</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">BasicContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;pyshell#143&gt;"</span>, line <span class="m">1</span>, in <span class="n">-toplevel-</span>
    <span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gr">DivisionByZero</span>: <span class="n">x / 0</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-73">上下文还有信号标志用于监控计算过程中遇到的异常情况。</span><span class="yiyi-st" id="yiyi-74">这些标志保持设置直到明确清除，因此最好在每组监视计算之前使用<code class="xref py py-meth docutils literal"><span class="pre">clear_flags()</span></code>方法清除标志。</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">clear_flags</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">355</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">113</span><span class="p">)</span>
<span class="go">Decimal('3.14159292')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span>
<span class="go">Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[])</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-75"><em>flags</em>条目显示对<code class="xref py py-const docutils literal"><span class="pre">Pi</span></code>的有理逼近进行了舍入（超出上下文精度的数字被丢弃），并且结果不准确（某些丢弃的数字不是-零）。</span></p><p><span class="yiyi-st" id="yiyi-76">单个陷阱是使用上下文的<code class="xref py py-attr docutils literal"><span class="pre">traps</span></code>字段中的字典设置的：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Decimal('Infinity')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">DivisionByZero</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;pyshell#112&gt;"</span>, line <span class="m">1</span>, in <span class="n">-toplevel-</span>
    <span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gr">DivisionByZero</span>: <span class="n">x / 0</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-77">大多数程序只在程序开始时调整当前上下文一次。</span><span class="yiyi-st" id="yiyi-78">而且，在许多应用程序中，数据被转换为<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>，并在循环内部进行单次转换。</span><span class="yiyi-st" id="yiyi-79">通过创建上下文集和小数点，程序的大部分操作数据的方式与其他Python数字类型无异。</span></p></div><div class="section" id="decimal-objects"><h2><span class="yiyi-st" id="yiyi-80">9.4.2.</span><span class="yiyi-st" id="yiyi-81">小数点对象</span></h2><dl class="class"><dt id="decimal.Decimal"><span class="yiyi-st" id="yiyi-82"> <em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Decimal</code><span class="sig-paren">(</span><em>value="0"</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-83">根据<em>值</em>构造一个新的<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>对象。</span></p><p><span class="yiyi-st" id="yiyi-84"><em>值</em>可以是整数，字符串，元组，<a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>或其他<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>对象。</span><span class="yiyi-st" id="yiyi-85">如果未给出<em>值</em>，则返回<code class="docutils literal"><span class="pre">Decimal('0')</span></code>。</span><span class="yiyi-st" id="yiyi-86">如果<em>值</em>是一个字符串，则在删除前导和尾随空白字符后，它应符合十进制数字字符串语法：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">sign</span>           <span class="p">::</span><span class="o">=</span>  <span class="s1">'+'</span> <span class="o">|</span> <span class="s1">'-'</span>
<span class="n">digit</span>          <span class="p">::</span><span class="o">=</span>  <span class="s1">'0'</span> <span class="o">|</span> <span class="s1">'1'</span> <span class="o">|</span> <span class="s1">'2'</span> <span class="o">|</span> <span class="s1">'3'</span> <span class="o">|</span> <span class="s1">'4'</span> <span class="o">|</span> <span class="s1">'5'</span> <span class="o">|</span> <span class="s1">'6'</span> <span class="o">|</span> <span class="s1">'7'</span> <span class="o">|</span> <span class="s1">'8'</span> <span class="o">|</span> <span class="s1">'9'</span>
<span class="n">indicator</span>      <span class="p">::</span><span class="o">=</span>  <span class="s1">'e'</span> <span class="o">|</span> <span class="s1">'E'</span>
<span class="n">digits</span>         <span class="p">::</span><span class="o">=</span>  <span class="n">digit</span> <span class="p">[</span><span class="n">digit</span><span class="p">]</span><span class="o">...</span>
<span class="n">decimal</span><span class="o">-</span><span class="n">part</span>   <span class="p">::</span><span class="o">=</span>  <span class="n">digits</span> <span class="s1">'.'</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span> <span class="o">|</span> <span class="p">[</span><span class="s1">'.'</span><span class="p">]</span> <span class="n">digits</span>
<span class="n">exponent</span><span class="o">-</span><span class="n">part</span>  <span class="p">::</span><span class="o">=</span>  <span class="n">indicator</span> <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">digits</span>
<span class="n">infinity</span>       <span class="p">::</span><span class="o">=</span>  <span class="s1">'Infinity'</span> <span class="o">|</span> <span class="s1">'Inf'</span>
<span class="n">nan</span>            <span class="p">::</span><span class="o">=</span>  <span class="s1">'NaN'</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span> <span class="o">|</span> <span class="s1">'sNaN'</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span>
<span class="n">numeric</span><span class="o">-</span><span class="n">value</span>  <span class="p">::</span><span class="o">=</span>  <span class="n">decimal</span><span class="o">-</span><span class="n">part</span> <span class="p">[</span><span class="n">exponent</span><span class="o">-</span><span class="n">part</span><span class="p">]</span> <span class="o">|</span> <span class="n">infinity</span>
<span class="n">numeric</span><span class="o">-</span><span class="n">string</span> <span class="p">::</span><span class="o">=</span>  <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">numeric</span><span class="o">-</span><span class="n">value</span> <span class="o">|</span> <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">nan</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-87">其他Unicode十进制数字也可以在<code class="docutils literal"><span class="pre">digit</span></code>出现在上面。</span><span class="yiyi-st" id="yiyi-88">这些包括来自各种其他字母（例如，阿拉伯 - 印度和德瓦加尔加数字）的十进制数字以及全角数字<code class="docutils literal"><span class="pre">'\uff10'</span></code>到<code class="docutils literal"><span class="pre">'\uff19'</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-89">If <em>value</em> is a <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>, it should have three components, a sign (<code class="xref py py-const docutils literal"><span class="pre">0</span></code> for positive or <code class="xref py py-const docutils literal"><span class="pre">1</span></code> for negative), a <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> of digits, and an integer exponent. </span><span class="yiyi-st" id="yiyi-90">For example, <code class="docutils literal"><span class="pre">Decimal((0,</span> <span class="pre">(1,</span> <span class="pre">4,</span> <span class="pre">1,</span> <span class="pre">4),</span> <span class="pre">-3))</span></code> returns <code class="docutils literal"><span class="pre">Decimal('1.414')</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-91">如果<em>值</em>是<a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>，则二进制浮点值将无损地转换为精确的十进制等值。</span><span class="yiyi-st" id="yiyi-92">这种转换通常需要53位或更多的精度。</span><span class="yiyi-st" id="yiyi-93">例如，<code class="docutils literal"><span class="pre">Decimal(float('1.1'))</span></code>转换为<code class="docutils literal"><span class="pre">Decimal('1.100000000000000088817841970012523233890533447265625')</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-94"><em>上下文</em>精度不影响存储多少位数。</span><span class="yiyi-st" id="yiyi-95">这完全取决于<em>值</em>中的位数。</span><span class="yiyi-st" id="yiyi-96">For example, <code class="docutils literal"><span class="pre">Decimal('3.00000')</span></code> records all five zeros even if the context precision is only three.</span></p><p><span class="yiyi-st" id="yiyi-97"><em>context</em>参数的用途是确定如果<em>值</em>是格式错误的字符串该怎么做。</span><span class="yiyi-st" id="yiyi-98">如果上下文陷阱<a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal"><span class="pre">InvalidOperation</span></code></a>，则会引发异常；否则，构造函数返回一个新的Decimal，其值为<code class="xref py py-const docutils literal"><span class="pre">NaN</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-99">Once constructed, <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> objects are immutable.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-100"><span class="versionmodified">在版本3.2中更改：</span>现在允许构造函数的参数为​​<a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>实例。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-101"><span class="versionmodified">在版本3.3中更改：如果设置了<a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal"><span class="pre">FloatOperation</span></code></a>陷阱，则</span> <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>参数会引发异常。</span><span class="yiyi-st" id="yiyi-102">默认情况下，陷阱关闭。</span></p></div><p><span class="yiyi-st" id="yiyi-103">十进制浮点对象与其他内置数值类型（如<a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>和<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>）共享许多属性。</span><span class="yiyi-st" id="yiyi-104">所有常用的数学运算和特殊方法都适用。</span><span class="yiyi-st" id="yiyi-105">同样，小数对象可以被复制，腌制，打印，用作字典键，用作设置元素，比较，排序和强制到另一种类型（例如<a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>或<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a></span></p><p><span class="yiyi-st" id="yiyi-106">在小数对象上的算术和整数和浮点数上的算术之间有一些小的差异。</span><span class="yiyi-st" id="yiyi-107">当余数运算符<code class="docutils literal"><span class="pre">%</span></code>应用于小数对象时，结果的符号是<em>除数</em>的符号而不是除数的符号：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">%</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Decimal('-3')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-108">The integer division operator <code class="docutils literal"><span class="pre">//</span></code> behaves analogously, returning the integer part of the true quotient (truncating towards zero) rather than its floor, so as to preserve the usual identity <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">(x</span> <span class="pre">//</span> <span class="pre">y)</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code>:</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="mi">7</span> <span class="o">//</span> <span class="mi">4</span>
<span class="go">-2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">//</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Decimal('-1')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-109"><code class="docutils literal"><span class="pre">%</span></code>和<code class="docutils literal"><span class="pre">//</span></code>运算符分别实现了<code class="docutils literal"><span class="pre">remainder</span></code>和<code class="docutils literal"><span class="pre">divide-integer</span></code>运算。</span></p><p><span class="yiyi-st" id="yiyi-110">Decimal objects cannot generally be combined with floats or instances of <a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal"><span class="pre">fractions.Fraction</span></code></a> in arithmetic operations: an attempt to add a <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> to a <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>, for example, will raise a <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>. </span><span class="yiyi-st" id="yiyi-111">但是，可以使用Python的比较运算符将<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>实例<code class="docutils literal"><span class="pre">x</span></code>与另一个数字<code class="docutils literal"><span class="pre">y</span></code>进行比较。</span><span class="yiyi-st" id="yiyi-112">这样可以避免在不同类型的数字之间进行相等比较时出现令人困惑的结果。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-113"><span class="versionmodified">在版本3.2中更改：</span>现在完全支持<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>实例和其他数字类型之间的混合类型比较。</span></p></div><p><span class="yiyi-st" id="yiyi-114">除了标准的数字属性外，十进制浮点对象还有许多特殊的方法：</span></p><dl class="method"><dt id="decimal.Decimal.adjusted"><span class="yiyi-st" id="yiyi-115"><code class="descname">adjusted</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-116">移出系数最右边的数字后，返回调整后的指数，直到只剩下前导数字：<code class="docutils literal"><span class="pre">Decimal('321e+5').adjusted()</span></code>返回7。</span><span class="yiyi-st" id="yiyi-117">用于确定最重要数字相对于小数点的位置。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.as_tuple"><span class="yiyi-st" id="yiyi-118"><code class="descname">as_tuple</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-119">Return a <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a> representation of the number: <code class="docutils literal"><span class="pre">DecimalTuple(sign,</span> <span class="pre">digits,</span> <span class="pre">exponent)</span></code>.</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.canonical"><span class="yiyi-st" id="yiyi-120"><code class="descname">canonical</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-121">返回参数的规范编码。</span><span class="yiyi-st" id="yiyi-122">目前，<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>实例的编码总是规范的，所以此操作返回其参数不变。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.compare"><span class="yiyi-st" id="yiyi-123"><code class="descname">compare</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-124">比较两个Decimal实例的值。</span><span class="yiyi-st" id="yiyi-125"><a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal"><span class="pre">compare()</span></code></a>返回一个Decimal实例，如果其中一个操作数是NaN，那么结果是NaN：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="ow">or</span> <span class="n">b</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">NaN</span>  <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'NaN'</span><span class="p">)</span>
<span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>            <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'-1'</span><span class="p">)</span>
<span class="n">a</span> <span class="o">==</span> <span class="n">b</span>           <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'0'</span><span class="p">)</span>
<span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span>            <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'1'</span><span class="p">)</span>
</pre></div></div></dd></dl><dl class="method"><dt id="decimal.Decimal.compare_signal"><span class="yiyi-st" id="yiyi-126"><code class="descname">compare_signal</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-127">该操作与<a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal"><span class="pre">compare()</span></code></a>方法相同，不同之处在于所有的NaN信号。</span><span class="yiyi-st" id="yiyi-128">也就是说，如果两个操作数都不是一个NaN信号，那么任何安静的NaN操作数都被视为一个信号NaN。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.compare_total"><span class="yiyi-st" id="yiyi-129"><code class="descname">compare_total</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-130">使用它们的抽象表示比较两个操作数，而不是它们的数值。</span><span class="yiyi-st" id="yiyi-131">类似于<a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal"><span class="pre">compare()</span></code></a>方法，但结果给出了<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>实例的总体排序。</span><span class="yiyi-st" id="yiyi-132">具有相同数值但不同表示的<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>实例在此排序中比较不等：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'12.0'</span><span class="p">)</span><span class="o">.</span><span class="n">compare_total</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'12'</span><span class="p">))</span>
<span class="go">Decimal('-1')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-133">安全和信令NaNs也包括在总的顺序中。</span><span class="yiyi-st" id="yiyi-134">The result of this function is <code class="docutils literal"><span class="pre">Decimal('0')</span></code> if both operands have the same representation, <code class="docutils literal"><span class="pre">Decimal('-1')</span></code> if the first operand is lower in the total order than the second, and <code class="docutils literal"><span class="pre">Decimal('1')</span></code> if the first operand is higher in the total order than the second operand. </span><span class="yiyi-st" id="yiyi-135">有关总订单的详细信息，请参阅规格。</span></p><p><span class="yiyi-st" id="yiyi-136">该操作不受上下文影响，并且安静：没有标志被改变，也没有执行舍入。</span><span class="yiyi-st" id="yiyi-137">作为例外，如果第二个操作数无法完全转换，则C版本可能会引发InvalidOperation。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.compare_total_mag"><span class="yiyi-st" id="yiyi-138"><code class="descname">compare_total_mag</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-139">使用它们的抽象表示而不是它们的值比较两个操作数，如<a class="reference internal" href="#decimal.Decimal.compare_total" title="decimal.Decimal.compare_total"><code class="xref py py-meth docutils literal"><span class="pre">compare_total()</span></code></a>，但忽略每个操作数的符号。</span><span class="yiyi-st" id="yiyi-140"><code class="docutils literal"><span class="pre">x.compare_total_mag(y)</span></code>等同于<code class="docutils literal"><span class="pre">x.copy_abs().compare_total(y.copy_abs())</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-141">该操作不受上下文影响，并且安静：没有标志被改变，也没有执行舍入。</span><span class="yiyi-st" id="yiyi-142">作为例外，如果第二个操作数无法完全转换，则C版本可能会引发InvalidOperation。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.conjugate"><span class="yiyi-st" id="yiyi-143"><code class="descname">conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-144">只是返回自我，这种方法只符合十进制规范。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.copy_abs"><span class="yiyi-st" id="yiyi-145"><code class="descname">copy_abs</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-146">返回参数的绝对值。</span><span class="yiyi-st" id="yiyi-147">此操作不受上下文影响，并且很安静：没有标志被更改，也没有执行舍入。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.copy_negate"><span class="yiyi-st" id="yiyi-148"><code class="descname">copy_negate</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-149">返回参数的否定。</span><span class="yiyi-st" id="yiyi-150">此操作不受上下文影响，并且很安静：没有标志被更改，也没有执行舍入。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.copy_sign"><span class="yiyi-st" id="yiyi-151"><code class="descname">copy_sign</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-152">返回第一个操作数的副本，并将符号设置为与第二个操作数的符号相同。</span><span class="yiyi-st" id="yiyi-153">例如：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'2.3'</span><span class="p">)</span><span class="o">.</span><span class="n">copy_sign</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'-1.5'</span><span class="p">))</span>
<span class="go">Decimal('-2.3')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-154">该操作不受上下文影响，并且安静：没有标志被改变，也没有执行舍入。</span><span class="yiyi-st" id="yiyi-155">作为例外，如果第二个操作数无法完全转换，则C版本可能会引发InvalidOperation。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.exp"><span class="yiyi-st" id="yiyi-156"><code class="descname">exp</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-157">返回给定数字处的（自然）指数函数<code class="docutils literal"><span class="pre">e**x</span></code>的值。</span><span class="yiyi-st" id="yiyi-158">使用<a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_EVEN</span></code></a>舍入模式正确舍入结果。</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal('2.718281828459045235360287471')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">321</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal('2.561702493119680037517373933E+139')</span>
</pre></div></div></dd></dl><dl class="method"><dt id="decimal.Decimal.from_float"><span class="yiyi-st" id="yiyi-159"><code class="descname">from_float</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-160">精确地将float转换为十进制数的Classmethod。</span></p><p><span class="yiyi-st" id="yiyi-161">注意<cite>Decimal.from_float（0.1）</cite>不同于<cite>Decimal（'0.1'）</cite>。</span><span class="yiyi-st" id="yiyi-162">由于0.1在二进制浮点中不能完全表示，因此该值将存储为最接近的可表示值，即<cite>0x1.999999999999ap-4</cite>。</span><span class="yiyi-st" id="yiyi-163">That equivalent value in decimal is <cite>0.1000000000000000055511151231257827021181583404541015625</cite>.</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-164">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-165">从Python 3.2开始，一个<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>实例也可以直接从<a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>构建。</span></p></div><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="go">Decimal('0.1000000000000000055511151231257827021181583404541015625')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">'nan'</span><span class="p">))</span>
<span class="go">Decimal('NaN')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">'inf'</span><span class="p">))</span>
<span class="go">Decimal('Infinity')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">'-inf'</span><span class="p">))</span>
<span class="go">Decimal('-Infinity')</span>
</pre></div></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-166"><span class="versionmodified">版本3.1中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="decimal.Decimal.fma"><span class="yiyi-st" id="yiyi-167"><code class="descname">fma</code><span class="sig-paren">(</span><em>other</em>, <em>third</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-168">融合乘加。</span><span class="yiyi-st" id="yiyi-169">返回自己*其他+第三没有舍去中间产品自己*其他。</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">fma</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">Decimal('11')</span>
</pre></div></div></dd></dl><dl class="method"><dt id="decimal.Decimal.is_canonical"><span class="yiyi-st" id="yiyi-170"><code class="descname">is_canonical</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-171">如果参数是规范的，则返回<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>，否则返回<a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>。</span><span class="yiyi-st" id="yiyi-172">目前，<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>实例始终是规范的，因此此操作始终返回<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.is_finite"><span class="yiyi-st" id="yiyi-173"><code class="descname">is_finite</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-174">如果参数是有限数字，则返回<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>；如果参数是无穷大或NaN，则返回<a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.is_infinite"><span class="yiyi-st" id="yiyi-175"><code class="descname">is_infinite</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-176">如果参数是正的或负的无穷大，则返回<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>，否则返回<a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.is_nan"><span class="yiyi-st" id="yiyi-177"><code class="descname">is_nan</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-178">如果参数是（安静或信号）NaN和<a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>，则返回<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a></span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.is_normal"><span class="yiyi-st" id="yiyi-179"><code class="descname">is_normal</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-180">如果参数是<em>正常</em>有限数字，则返回<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>。</span><span class="yiyi-st" id="yiyi-181">如果参数是零，subnormal，无限或NaN，则返回<a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.is_qnan"><span class="yiyi-st" id="yiyi-182"><code class="descname">is_qnan</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-183">如果参数是安静的NaN，则返回<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>，否则返回<a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.is_signed"><span class="yiyi-st" id="yiyi-184"><code class="descname">is_signed</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-185">如果参数具有负号，则返回<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>，否则返回<a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>。</span><span class="yiyi-st" id="yiyi-186">请注意，零和NaN都可以携带符号。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.is_snan"><span class="yiyi-st" id="yiyi-187"><code class="descname">is_snan</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-188">如果参数是一个信号NaN和<a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>，则返回<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a></span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.is_subnormal"><span class="yiyi-st" id="yiyi-189"><code class="descname">is_subnormal</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-190">如果参数为低于正常值，则返回<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>，否则返回<a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.is_zero"><span class="yiyi-st" id="yiyi-191"><code class="descname">is_zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-192">如果参数是（正或负）零，则返回<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>，否则返回<a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.ln"><span class="yiyi-st" id="yiyi-193"><code class="descname">ln</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-194">返回操作数的自然对数（基数e）。</span><span class="yiyi-st" id="yiyi-195">使用<a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_EVEN</span></code></a>舍入模式正确舍入结果。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.log10"><span class="yiyi-st" id="yiyi-196"><code class="descname">log10</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-197">返回操作数的十进制对数。</span><span class="yiyi-st" id="yiyi-198">使用<a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_EVEN</span></code></a>舍入模式正确舍入结果。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.logb"><span class="yiyi-st" id="yiyi-199"><code class="descname">logb</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-200">对于非零数字，将其操作数的调整指数作为<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>实例返回。</span><span class="yiyi-st" id="yiyi-201">如果操作数为零，则返回<code class="docutils literal"><span class="pre">Decimal('-Infinity')</span></code>，并引发<a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-const docutils literal"><span class="pre">DivisionByZero</span></code></a>标志。</span><span class="yiyi-st" id="yiyi-202">如果操作数是无穷大，则返回<code class="docutils literal"><span class="pre">Decimal('Infinity')</span></code>。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.logical_and"><span class="yiyi-st" id="yiyi-203"><code class="descname">logical_and</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-204"><a class="reference internal" href="#decimal.Decimal.logical_and" title="decimal.Decimal.logical_and"><code class="xref py py-meth docutils literal"><span class="pre">logical_and()</span></code></a> is a logical operation which takes two <em>logical operands</em> (see <a class="reference internal" href="#logical-operands-label"><span>Logical operands</span></a>). </span><span class="yiyi-st" id="yiyi-205">结果是两个操作数的数字方式<code class="docutils literal"><span class="pre">and</span></code>。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.logical_invert"><span class="yiyi-st" id="yiyi-206"><code class="descname">logical_invert</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-207"><a class="reference internal" href="#decimal.Decimal.logical_invert" title="decimal.Decimal.logical_invert"><code class="xref py py-meth docutils literal"><span class="pre">logical_invert()</span></code></a> is a logical operation. </span><span class="yiyi-st" id="yiyi-208">结果是操作数的数字反转。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.logical_or"><span class="yiyi-st" id="yiyi-209"><code class="descname">logical_or</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-210"><a class="reference internal" href="#decimal.Decimal.logical_or" title="decimal.Decimal.logical_or"><code class="xref py py-meth docutils literal"><span class="pre">logical_or()</span></code></a> is a logical operation which takes two <em>logical operands</em> (see <a class="reference internal" href="#logical-operands-label"><span>Logical operands</span></a>). </span><span class="yiyi-st" id="yiyi-211">结果是两个操作数的数字方式<code class="docutils literal"><span class="pre">or</span></code>。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.logical_xor"><span class="yiyi-st" id="yiyi-212"><code class="descname">logical_xor</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-213"><a class="reference internal" href="#decimal.Decimal.logical_xor" title="decimal.Decimal.logical_xor"><code class="xref py py-meth docutils literal"><span class="pre">logical_xor()</span></code></a> is a logical operation which takes two <em>logical operands</em> (see <a class="reference internal" href="#logical-operands-label"><span>Logical operands</span></a>). </span><span class="yiyi-st" id="yiyi-214">结果是数字独占或两个操作数。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.max"><span class="yiyi-st" id="yiyi-215"><code class="descname">max</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-216">Like <code class="docutils literal"><span class="pre">max(self,</span> <span class="pre">other)</span></code> except that the context rounding rule is applied before returning and that <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> values are either signaled or ignored (depending on the context and whether they are signaling or quiet).</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.max_mag"><span class="yiyi-st" id="yiyi-217"><code class="descname">max_mag</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-218">类似于<a class="reference internal" href="#decimal.Decimal.max" title="decimal.Decimal.max"><code class="xref py py-meth docutils literal"><span class="pre">max()</span></code></a>方法，但使用操作数的绝对值进行比较。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.min"><span class="yiyi-st" id="yiyi-219"><code class="descname">min</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-220">Like <code class="docutils literal"><span class="pre">min(self,</span> <span class="pre">other)</span></code> except that the context rounding rule is applied before returning and that <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> values are either signaled or ignored (depending on the context and whether they are signaling or quiet).</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.min_mag"><span class="yiyi-st" id="yiyi-221"><code class="descname">min_mag</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-222">类似于<a class="reference internal" href="#decimal.Decimal.min" title="decimal.Decimal.min"><code class="xref py py-meth docutils literal"><span class="pre">min()</span></code></a>方法，但是使用操作数的绝对值进行比较。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.next_minus"><span class="yiyi-st" id="yiyi-223"><code class="descname">next_minus</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-224">返回给定上下文中的最大数字（或者在当前线程的上下文中，如果没有给出上下文），该数字小于给定的操作数。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.next_plus"><span class="yiyi-st" id="yiyi-225"><code class="descname">next_plus</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-226">返回大于给定操作数的给定上下文（或者在当前线程的上下文中，如果没有给出上下文）中可表示的最小数字。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.next_toward"><span class="yiyi-st" id="yiyi-227"><code class="descname">next_toward</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-228">如果两个操作数不相等，则在第二个操作数的方向上返回最接近第一个操作数的数字。</span><span class="yiyi-st" id="yiyi-229">如果两个操作数在数值上相等，则返回第一个操作数的副本，并将符号设置为与第二个操作数的符号相同。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.normalize"><span class="yiyi-st" id="yiyi-230"> <code class="descname">normalize</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-231">通过去除最右边的尾部零并将任何结果等于<code class="xref py py-const docutils literal"><span class="pre">Decimal('0')</span></code>转换为<code class="xref py py-const docutils literal"><span class="pre">Decimal('0e0')</span></code>来归一化数字。</span><span class="yiyi-st" id="yiyi-232">用于为等价类的属性生成规范值。</span><span class="yiyi-st" id="yiyi-233">例如，<code class="docutils literal"><span class="pre">Decimal('32.100')</span></code>和<code class="docutils literal"><span class="pre">Decimal('0.321000e+2')</span></code>均归一化为等价值<code class="docutils literal"><span class="pre">Decimal('32.1')</span></code></span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.number_class"><span class="yiyi-st" id="yiyi-234"><code class="descname">number_class</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-235">返回描述操作数的<em>类</em>的字符串。</span><span class="yiyi-st" id="yiyi-236">返回的值是以下十个字符串之一。</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-237"><code class="docutils literal"><span class="pre">"-Infinity"</span></code>，表示操作数为负无穷。</span></li><li><span class="yiyi-st" id="yiyi-238"><code class="docutils literal"><span class="pre">"-Normal"</span></code>，表示操作数是一个负的正常数。</span></li><li><span class="yiyi-st" id="yiyi-239"><code class="docutils literal"><span class="pre">"-Subnormal"</span></code>，表示操作数是负数和低于正常值。</span></li><li><span class="yiyi-st" id="yiyi-240"><code class="docutils literal"><span class="pre">"-Zero"</span></code>，表示操作数为负零。</span></li><li><span class="yiyi-st" id="yiyi-241"><code class="docutils literal"><span class="pre">"+Zero"</span></code>，表示操作数为正零。</span></li><li><span class="yiyi-st" id="yiyi-242"><code class="docutils literal"><span class="pre">"+Subnormal"</span></code>，表示操作数为正数和低于正常数。</span></li><li><span class="yiyi-st" id="yiyi-243"><code class="docutils literal"><span class="pre">"+Normal"</span></code>，表示操作数是正数。</span></li><li><span class="yiyi-st" id="yiyi-244"><code class="docutils literal"><span class="pre">"+Infinity"</span></code>，表示操作数为正无穷。</span></li><li><span class="yiyi-st" id="yiyi-245"><code class="docutils literal"><span class="pre">"NaN"</span></code>，表示操作数是一个安静的NaN（不是数字）。</span></li><li><span class="yiyi-st" id="yiyi-246"><code class="docutils literal"><span class="pre">"sNaN"</span></code>，表示操作数是一个信令NaN。</span></li></ul></dd></dl><dl class="method"><dt id="decimal.Decimal.quantize"><span class="yiyi-st" id="yiyi-247"><code class="descname">quantize</code><span class="sig-paren">(</span><em>exp</em>, <em>rounding=None</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-248">在舍入后返回一个等于第一个操作数并具有第二个操作数的指数的值。</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'1.41421356'</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'1.000'</span><span class="p">))</span>
<span class="go">Decimal('1.414')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-249">与其他操作不同，如果量化操作之后的系数长度大于精度，则发送<a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal"><span class="pre">InvalidOperation</span></code></a>。</span><span class="yiyi-st" id="yiyi-250">这保证了，除非有错误条件，否则量化指数总是等于右侧操作数的指数。</span></p><p><span class="yiyi-st" id="yiyi-251">与其他操作不同，即使结果是次正常且不精确，量化也不会发出下溢信号。</span></p><p><span class="yiyi-st" id="yiyi-252">如果第二个操作数的指数大于第一个操作数的指数，则可能需要舍入。</span><span class="yiyi-st" id="yiyi-253">在这种情况下，舍入模式由给定的<code class="docutils literal"><span class="pre">rounding</span></code>参数确定，否则由给定的<code class="docutils literal"><span class="pre">context</span></code>参数确定；如果没有给出参数，则使用当前线程上下文的舍入模式。</span></p><p><span class="yiyi-st" id="yiyi-254">只要结果指数大于<code class="xref py py-attr docutils literal"><span class="pre">Emax</span></code>或小于<code class="xref py py-attr docutils literal"><span class="pre">Etiny</span></code>，就会返回错误。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.radix"><span class="yiyi-st" id="yiyi-255"><code class="descname">radix</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-256">返回<code class="docutils literal"><span class="pre">Decimal(10)</span></code>，<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>类完成所有算术运算的基数（基数）。</span><span class="yiyi-st" id="yiyi-257">包括与规范的兼容性。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.remainder_near"><span class="yiyi-st" id="yiyi-258"><code class="descname">remainder_near</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-259">将<em>self</em>除以<em>other</em>得到的余数。</span><span class="yiyi-st" id="yiyi-260">这与<code class="docutils literal"><span class="pre">self</span> <span class="pre">％</span> <span class="pre">其他</span></code>的不同之处在于，余数的符号被选择为使其绝对值最小化。</span><span class="yiyi-st" id="yiyi-261">More precisely, the return value is <code class="docutils literal"><span class="pre">self</span> <span class="pre">-</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">other</span></code> where <code class="docutils literal"><span class="pre">n</span></code> is the integer nearest to the exact value of <code class="docutils literal"><span class="pre">self</span> <span class="pre">/</span> <span class="pre">other</span></code>, and if two integers are equally near then the even one is chosen.</span></p><p><span class="yiyi-st" id="yiyi-262">如果结果为零，那么它的符号将是<em>self</em>的符号。</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal('-2')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal('5')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal('-5')</span>
</pre></div></div></dd></dl><dl class="method"><dt id="decimal.Decimal.rotate"><span class="yiyi-st" id="yiyi-263"><code class="descname">rotate</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-264">将第一个操作数的数字旋转一个由第二个操作数指定的量的结果。</span><span class="yiyi-st" id="yiyi-265">第二个操作数必须是精度范围-precision中的整数。</span><span class="yiyi-st" id="yiyi-266">第二个操作数的绝对值给出了要旋转的地方的数量。</span><span class="yiyi-st" id="yiyi-267">如果第二个操作数是正的，那么旋转是在左边；否则旋转是正确的。</span><span class="yiyi-st" id="yiyi-268">如有必要，第一个操作数的系数在左侧填充为零以达到长度精度。</span><span class="yiyi-st" id="yiyi-269">第一个操作数的符号和指数保持不变。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.same_quantum"><span class="yiyi-st" id="yiyi-270"><code class="descname">same_quantum</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-271">Test whether self and other have the same exponent or whether both are <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-272">该操作不受上下文影响，并且安静：没有标志被改变，也没有执行舍入。</span><span class="yiyi-st" id="yiyi-273">作为例外，如果第二个操作数无法完全转换，则C版本可能会引发InvalidOperation。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.scaleb"><span class="yiyi-st" id="yiyi-274"><code class="descname">scaleb</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-275">返回第一个操作数，指数由第二个调整。</span><span class="yiyi-st" id="yiyi-276">等价地，返回第一个操作数乘以<code class="docutils literal"><span class="pre">10**other</span></code>。</span><span class="yiyi-st" id="yiyi-277">第二个操作数必须是整数。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.shift"><span class="yiyi-st" id="yiyi-278"><code class="descname">shift</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-279">返回将第一个操作数的数位移位第二个操作数指定的数值的结果。</span><span class="yiyi-st" id="yiyi-280">第二个操作数必须是精度范围-precision中的整数。</span><span class="yiyi-st" id="yiyi-281">第二个操作数的绝对值给出了要移位的位数。</span><span class="yiyi-st" id="yiyi-282">如果第二个操作数是正的，那么这个移位是在左边；否则这个转变是在右边。</span><span class="yiyi-st" id="yiyi-283">移入系数的数字是零。</span><span class="yiyi-st" id="yiyi-284">第一个操作数的符号和指数保持不变。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.sqrt"><span class="yiyi-st" id="yiyi-285"><code class="descname">sqrt</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-286">将参数的平方根返回到完全精度。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.to_eng_string"><span class="yiyi-st" id="yiyi-287"><code class="descname">to_eng_string</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-288">如果需要指数，则转换为字符串，使用工程符号。</span></p><p><span class="yiyi-st" id="yiyi-289">工程表示法的指数是3的倍数。</span><span class="yiyi-st" id="yiyi-290">这可能会在小数点左边留下最多3位数字，并且可能需要添加一个或两个尾随零。</span></p><p><span class="yiyi-st" id="yiyi-291">例如，这将<code class="docutils literal"><span class="pre">Decimal('123E+1')</span></code>转换为<code class="docutils literal"><span class="pre">Decimal('1.23E+3')</span></code>。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.to_integral"><span class="yiyi-st" id="yiyi-292"><code class="descname">to_integral</code><span class="sig-paren">(</span><em>rounding=None</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-293">与<a class="reference internal" href="#decimal.Decimal.to_integral_value" title="decimal.Decimal.to_integral_value"><code class="xref py py-meth docutils literal"><span class="pre">to_integral_value()</span></code></a>方法相同。</span><span class="yiyi-st" id="yiyi-294"><code class="docutils literal"><span class="pre">to_integral</span></code>名称与旧版本保持兼容。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.to_integral_exact"><span class="yiyi-st" id="yiyi-295"><code class="descname">to_integral_exact</code><span class="sig-paren">(</span><em>rounding=None</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-296">如果发生舍入，则舍入为最接近的整数，发出信号<a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal"><span class="pre">Inexact</span></code></a>或<a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal"><span class="pre">Rounded</span></code></a>。</span><span class="yiyi-st" id="yiyi-297">舍入模式由给定的<code class="docutils literal"><span class="pre">rounding</span></code>参数确定，否则由给定的<code class="docutils literal"><span class="pre">context</span></code>确定。</span><span class="yiyi-st" id="yiyi-298">如果没有给出参数，则使用当前上下文的舍入模式。</span></p></dd></dl><dl class="method"><dt id="decimal.Decimal.to_integral_value"><span class="yiyi-st" id="yiyi-299"><code class="descname">to_integral_value</code><span class="sig-paren">(</span><em>rounding=None</em>, <em>context=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-300">四舍五入到最接近的整数，无信号<a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal"><span class="pre">Inexact</span></code></a>或<a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal"><span class="pre">Rounded</span></code></a>。</span><span class="yiyi-st" id="yiyi-301">如果给出，则适用<em>四舍五入</em>；否则，在提供的<em>上下文</em>或当前上下文中使用舍入方法。</span></p></dd></dl></dd></dl><div class="section" id="logical-operands"><h3><span class="yiyi-st" id="yiyi-302">9.4.2.1.</span><span class="yiyi-st" id="yiyi-303">逻辑操作数</span></h3><p><span class="yiyi-st" id="yiyi-304">The <code class="xref py py-meth docutils literal"><span class="pre">logical_and()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">logical_invert()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">logical_or()</span></code>, and <code class="xref py py-meth docutils literal"><span class="pre">logical_xor()</span></code> methods expect their arguments to be <em>logical operands</em>. </span><span class="yiyi-st" id="yiyi-305">A <em>logical operand</em> is a <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> instance whose exponent and sign are both zero, and whose digits are all either <code class="xref py py-const docutils literal"><span class="pre">0</span></code> or <code class="xref py py-const docutils literal"><span class="pre">1</span></code>.</span></p></div></div><div class="section" id="context-objects"><h2><span class="yiyi-st" id="yiyi-306">9.4.3.</span><span class="yiyi-st" id="yiyi-307">上下文对象</span></h2><p><span class="yiyi-st" id="yiyi-308">上下文是算术运算的环境。</span><span class="yiyi-st" id="yiyi-309">它们控制精度，设置舍入规则，确定哪些信号被视为例外，并限制指数的范围。</span></p><p><span class="yiyi-st" id="yiyi-310">每个线程都有自己的当前上下文，它可以使用<a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a>和<a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal"><span class="pre">setcontext()</span></code></a>函数进行访问或更改：</span></p><dl class="function"><dt id="decimal.getcontext"><span class="yiyi-st" id="yiyi-311"><code class="descclassname">decimal.</code><code class="descname">getcontext</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-312">返回活动线程的当前上下文。</span></p></dd></dl><dl class="function"><dt id="decimal.setcontext"><span class="yiyi-st" id="yiyi-313"><code class="descclassname">decimal.</code><code class="descname">setcontext</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-314">将活动线程的当前上下文设置为<em>c</em>。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-315">您还可以使用<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>语句和<a class="reference internal" href="#decimal.localcontext" title="decimal.localcontext"><code class="xref py py-func docutils literal"><span class="pre">localcontext()</span></code></a>函数临时更改活动上下文。</span></p><dl class="function"><dt id="decimal.localcontext"><span class="yiyi-st" id="yiyi-316"><code class="descclassname">decimal.</code><code class="descname">localcontext</code><span class="sig-paren">(</span><em>ctx=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-317">返回一个上下文管理器，它将活动线程的当前上下文设置为<em>ctx</em>的副本，并在退出with-statement时恢复前一个上下文。</span><span class="yiyi-st" id="yiyi-318">如果没有指定上下文，则使用当前上下文的副本。</span></p><p><span class="yiyi-st" id="yiyi-319">例如，以下代码将当前小数精度设置为42位，执行计算，然后自动恢复以前的上下文：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="n">localcontext</span>

<span class="k">with</span> <span class="n">localcontext</span><span class="p">()</span> <span class="k">as</span> <span class="n">ctx</span><span class="p">:</span>
    <span class="n">ctx</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">42</span>   <span class="c1"># Perform a high precision calculation</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">calculate_something</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="o">+</span><span class="n">s</span>  <span class="c1"># Round the final result back to the default precision</span>
</pre></div></div></dd></dl><p><span class="yiyi-st" id="yiyi-320">新的上下文也可以使用下面描述的<a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a>构造函数创建。</span><span class="yiyi-st" id="yiyi-321">另外，该模块提供了三个预先制定的上下文：</span></p><dl class="class"><dt id="decimal.BasicContext"><span class="yiyi-st" id="yiyi-322"><em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">BasicContext</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-323">这是通用十进制算术规范定义的标准上下文。</span><span class="yiyi-st" id="yiyi-324">精度设置为9。</span><span class="yiyi-st" id="yiyi-325">舍入设置为<a class="reference internal" href="#decimal.ROUND_HALF_UP" title="decimal.ROUND_HALF_UP"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_UP</span></code></a>。</span><span class="yiyi-st" id="yiyi-326">所有标志都被清除。</span><span class="yiyi-st" id="yiyi-327">除<a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal"><span class="pre">Inexact</span></code></a>，<a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal"><span class="pre">Rounded</span></code></a>和<a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-const docutils literal"><span class="pre">Subnormal</span></code></a>之外，所有陷阱均被启用（作为例外处理）。</span></p><p><span class="yiyi-st" id="yiyi-328">由于许多陷阱都已启用，因此此上下文对调试很有用。</span></p></dd></dl><dl class="class"><dt id="decimal.ExtendedContext"><span class="yiyi-st" id="yiyi-329"><em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">ExtendedContext</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-330">这是通用十进制算术规范定义的标准上下文。</span><span class="yiyi-st" id="yiyi-331">精度设置为9。</span><span class="yiyi-st" id="yiyi-332">舍入设置为<a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_EVEN</span></code></a>。</span><span class="yiyi-st" id="yiyi-333">所有标志都被清除。</span><span class="yiyi-st" id="yiyi-334">没有陷阱被启用（以便在计算期间不会引发异常）。</span></p><p><span class="yiyi-st" id="yiyi-335">因为陷阱是禁用的，所以这个上下文对于喜欢<code class="xref py py-const docutils literal"><span class="pre">NaN</span></code>或<code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code>的结果值而不是引发异常的应用程序非常有用。</span><span class="yiyi-st" id="yiyi-336">这允许应用程序在存在条件的情况下完成运行，否则该条件会暂停程序。</span></p></dd></dl><dl class="class"><dt id="decimal.DefaultContext"><span class="yiyi-st" id="yiyi-337"><em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">DefaultContext</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-338">该上下文被<a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a>构造函数用作新上下文的原型。</span><span class="yiyi-st" id="yiyi-339">更改一个字段（如精度）会改变由<a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a>构造函数创建的新上下文的默认值。</span></p><p><span class="yiyi-st" id="yiyi-340">这个上下文在多线程环境中非常有用。</span><span class="yiyi-st" id="yiyi-341">在启动线程之前更改其中一个字段具有设置系统范围内默认值的效果。</span><span class="yiyi-st" id="yiyi-342">不建议在线程启动后更改字段，因为它需要线程同步来防止竞争条件。</span></p><p><span class="yiyi-st" id="yiyi-343">在单线程环境中，最好不要使用这个上下文。</span><span class="yiyi-st" id="yiyi-344">相反，只需按照下面的描述直接创建上下文。</span></p><p><span class="yiyi-st" id="yiyi-345">The default values are <code class="xref py py-attr docutils literal"><span class="pre">prec</span></code>=<code class="xref py py-const docutils literal"><span class="pre">28</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">rounding</span></code>=<a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_EVEN</span></code></a>, and enabled traps for <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-class docutils literal"><span class="pre">Overflow</span></code></a>, <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-class docutils literal"><span class="pre">InvalidOperation</span></code></a>, and <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-class docutils literal"><span class="pre">DivisionByZero</span></code></a>.</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-346">除了三个提供的上下文之外，还可以使用<a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a>构造函数创建新的上下文。</span></p><dl class="class"><dt id="decimal.Context"><span class="yiyi-st" id="yiyi-347"> <em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Context</code><span class="sig-paren">(</span><em>prec=None</em>, <em>rounding=None</em>, <em>Emin=None</em>, <em>Emax=None</em>, <em>capitals=None</em>, <em>clamp=None</em>, <em>flags=None</em>, <em>traps=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-348">创建一个新的上下文。</span><span class="yiyi-st" id="yiyi-349">如果未指定字段或<a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>，则默认值将从<a class="reference internal" href="#decimal.DefaultContext" title="decimal.DefaultContext"><code class="xref py py-const docutils literal"><span class="pre">DefaultContext</span></code></a>中复制。</span><span class="yiyi-st" id="yiyi-350">如果未指定<em>标志</em>字段或者<a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>，则清除所有标志。</span></p><p><span class="yiyi-st" id="yiyi-351"><em>prec</em>是一个范围为[<code class="xref py py-const docutils literal"><span class="pre">1</span></code>，<a class="reference internal" href="#decimal.MAX_PREC" title="decimal.MAX_PREC"><code class="xref py py-const docutils literal"><span class="pre">MAX_PREC</span></code></a>]的整数，用于设置上下文中算术运算的精度。</span></p><p><span class="yiyi-st" id="yiyi-352"><em>舍入</em>选项是<a class="reference internal" href="#rounding-modes">舍入模式</a>部分中列出的常量之一。</span></p><p><span class="yiyi-st" id="yiyi-353"><em>陷阱</em>和<em>标记</em>字段列出了要设置的任何信号。</span><span class="yiyi-st" id="yiyi-354">通常情况下，新的上下文应该只设置陷阱并且清除标志。</span></p><p><span class="yiyi-st" id="yiyi-355"><em>Emin</em>和<em>Emax</em>字段是指定允许指数的外部限制的整数。</span><span class="yiyi-st" id="yiyi-356"><em>Emin</em> must be in the range [<a class="reference internal" href="#decimal.MIN_EMIN" title="decimal.MIN_EMIN"><code class="xref py py-const docutils literal"><span class="pre">MIN_EMIN</span></code></a>, <code class="xref py py-const docutils literal"><span class="pre">0</span></code>], <em>Emax</em> in the range [<code class="xref py py-const docutils literal"><span class="pre">0</span></code>, <a class="reference internal" href="#decimal.MAX_EMAX" title="decimal.MAX_EMAX"><code class="xref py py-const docutils literal"><span class="pre">MAX_EMAX</span></code></a>].</span></p><p><span class="yiyi-st" id="yiyi-357"><em>首字母</em>字段是<code class="xref py py-const docutils literal"><span class="pre">0</span></code>或<code class="xref py py-const docutils literal"><span class="pre">1</span></code>（默认值）。</span><span class="yiyi-st" id="yiyi-358">如果设置为<code class="xref py py-const docutils literal"><span class="pre">1</span></code>，指数将用大写字母<code class="xref py py-const docutils literal"><span class="pre">E</span></code>打印；否则，使用小写字母<code class="xref py py-const docutils literal"><span class="pre">e</span></code>：<code class="xref py py-const docutils literal"><span class="pre">Decimal('6.02e+23')</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-359"><em>clamp</em>字段是<code class="xref py py-const docutils literal"><span class="pre">0</span></code>（默认）或<code class="xref py py-const docutils literal"><span class="pre">1</span></code>。</span><span class="yiyi-st" id="yiyi-360">If set to <code class="xref py py-const docutils literal"><span class="pre">1</span></code>, the exponent <code class="docutils literal"><span class="pre">e</span></code> of a <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> instance representable in this context is strictly limited to the range <code class="docutils literal"><span class="pre">Emin</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">e</span> <span class="pre">&lt;=</span> <span class="pre">Emax</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code>. </span><span class="yiyi-st" id="yiyi-361">If <em>clamp</em> is <code class="xref py py-const docutils literal"><span class="pre">0</span></code> then a weaker condition holds: the adjusted exponent of the <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> instance is at most <code class="docutils literal"><span class="pre">Emax</span></code>. </span><span class="yiyi-st" id="yiyi-362">当<em>clamp</em>是<code class="xref py py-const docutils literal"><span class="pre">1</span></code>时，一个大的正常数将在可能的情况下减小其指数并将相应数量的零加到其系数上，以便适合指数约束；这保留了数字的值，但丢失了关于重要尾随零的信息。</span><span class="yiyi-st" id="yiyi-363">例如：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">clamp</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">create_decimal</span><span class="p">(</span><span class="s1">'1.23e999'</span><span class="p">)</span>
<span class="go">Decimal('1.23000E+999')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-364"><code class="xref py py-const docutils literal"><span class="pre">1</span></code>的<em>clamp</em>值允许与IEEE 754中指定的固定宽度十进制交换格式兼容。</span></p><p><span class="yiyi-st" id="yiyi-365"><a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a>类定义了几种通用的方法，以及大量用于在给定上下文中直接进行算术的方法。</span><span class="yiyi-st" id="yiyi-366">另外，对于上述每个<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>方法（除<code class="xref py py-meth docutils literal"><span class="pre">adjusted()</span></code>和<code class="xref py py-meth docutils literal"><span class="pre">as_tuple()</span></code>方法外）都有一个对应的<a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a>方法。</span><span class="yiyi-st" id="yiyi-367">For example, for a <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> instance <code class="docutils literal"><span class="pre">C</span></code> and <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> instance <code class="docutils literal"><span class="pre">x</span></code>, <code class="docutils literal"><span class="pre">C.exp(x)</span></code> is equivalent to <code class="docutils literal"><span class="pre">x.exp(context=C)</span></code>. </span><span class="yiyi-st" id="yiyi-368">每个<a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a>方法接受一个Python整数（<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>的一个实例），接受Decimal实例的任何地方。</span></p><dl class="method"><dt id="decimal.Context.clear_flags"><span class="yiyi-st" id="yiyi-369"><code class="descname">clear_flags</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-370">将所有标志重置为<code class="xref py py-const docutils literal"><span class="pre">0</span></code>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.clear_traps"><span class="yiyi-st" id="yiyi-371"><code class="descname">clear_traps</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-372">将所有陷阱重置为<code class="xref py py-const docutils literal"><span class="pre">0</span></code>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-373"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="decimal.Context.copy"><span class="yiyi-st" id="yiyi-374"><code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-375">返回上下文的副本。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.copy_decimal"><span class="yiyi-st" id="yiyi-376"><code class="descname">copy_decimal</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-377">返回Decimal实例num的副本。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.create_decimal"><span class="yiyi-st" id="yiyi-378"><code class="descname">create_decimal</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-379">从<em>num</em>创建一个新的Decimal实例，但使用<em>self</em>作为上下文。</span><span class="yiyi-st" id="yiyi-380">与<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>构造函数不同，上下文精度，舍入方法，标志和陷阱应用于转换。</span></p><p><span class="yiyi-st" id="yiyi-381">这很有用，因为常量的精度通常比应用程序所需要的要高。</span><span class="yiyi-st" id="yiyi-382">另一个好处是，四舍五入可以消除超出当前精度的数字的意外影响。</span><span class="yiyi-st" id="yiyi-383">在以下示例中，使用未接地输入意味着将零加到和可以改变结果：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'3.4445'</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'1.0023'</span><span class="p">)</span>
<span class="go">Decimal('4.45')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'3.4445'</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'1.0023'</span><span class="p">)</span>
<span class="go">Decimal('4.44')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-384">此方法实现了IBM规范的定数操作。</span><span class="yiyi-st" id="yiyi-385">如果参数是一个字符串，则不允许前导或尾随空格。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.create_decimal_from_float"><span class="yiyi-st" id="yiyi-386"><code class="descname">create_decimal_from_float</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-387">从float <em>f</em>创建新的Decimal实例，但使用<em>self</em>作为上下文进行舍入。</span><span class="yiyi-st" id="yiyi-388">与<a class="reference internal" href="#decimal.Decimal.from_float" title="decimal.Decimal.from_float"><code class="xref py py-meth docutils literal"><span class="pre">Decimal.from_float()</span></code></a>类方法不同，上下文精度，舍入方法，标志和陷阱应用于转换。</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">create_decimal_from_float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">Decimal('3.1415')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">create_decimal_from_float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">decimal.Inexact</span>: <span class="n">None</span>
</pre></div></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-389"><span class="versionmodified">版本3.1中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="decimal.Context.Etiny"><span class="yiyi-st" id="yiyi-390"><code class="descname">Etiny</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-391">返回值等于<code class="docutils literal"><span class="pre">Emin</span> <span class="pre"> - </span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">t0&gt;，它是次正常结果的最小指数值。</span></code></span><span class="yiyi-st" id="yiyi-392">发生下溢时，指数设置为<a class="reference internal" href="#decimal.Context.Etiny" title="decimal.Context.Etiny"><code class="xref py py-const docutils literal"><span class="pre">Etiny</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.Etop"><span class="yiyi-st" id="yiyi-393"><code class="descname">Etop</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-394">返回值等于<code class="docutils literal"><span class="pre">Emax</span> <span class="pre"> - </span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">T0&gt;。</span></code></span></p></dd></dl><p><span class="yiyi-st" id="yiyi-395">处理小数的常用方法是创建<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>实例，然后应用在活动线程的当前上下文中进行的算术运算。</span><span class="yiyi-st" id="yiyi-396">另一种方法是在上下文中使用上下文方法进行计算。</span><span class="yiyi-st" id="yiyi-397">这些方法与<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>类的方法类似，在此仅作简要介绍。</span></p><dl class="method"><dt id="decimal.Context.abs"><span class="yiyi-st" id="yiyi-398"><code class="descname">abs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-399">返回<em>x</em>的绝对值。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.add"><span class="yiyi-st" id="yiyi-400"><code class="descname">add</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-401">返回<em>x</em>和<em>y</em>的总和。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.canonical"><span class="yiyi-st" id="yiyi-402"><code class="descname">canonical</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-403">返回相同的十进制对象<em>x</em>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.compare"><span class="yiyi-st" id="yiyi-404"><code class="descname">compare</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-405">以数字方式比较<em>x</em>和<em>y</em>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.compare_signal"><span class="yiyi-st" id="yiyi-406"><code class="descname">compare_signal</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-407">以数字方式比较两个操作数的值。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.compare_total"><span class="yiyi-st" id="yiyi-408"><code class="descname">compare_total</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-409">使用抽象表示法比较两个操作数。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.compare_total_mag"><span class="yiyi-st" id="yiyi-410"><code class="descname">compare_total_mag</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-411">使用它们的抽象表示比较两个操作数，忽略符号。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.copy_abs"><span class="yiyi-st" id="yiyi-412"><code class="descname">copy_abs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-413">返回符号设置为0的<em>x</em>的副本。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.copy_negate"><span class="yiyi-st" id="yiyi-414"><code class="descname">copy_negate</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-415">返回符号反转的<em>x</em>的副本。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.copy_sign"><span class="yiyi-st" id="yiyi-416"><code class="descname">copy_sign</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-417">将符号从<em>y</em>复制到<em>x</em>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.divide"><span class="yiyi-st" id="yiyi-418"><code class="descname">divide</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-419">返回<em>x</em>除以<em>y</em>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.divide_int"><span class="yiyi-st" id="yiyi-420"><code class="descname">divide_int</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-421">返回<em>x</em>除以<em>y</em>，截断为整数。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.divmod"><span class="yiyi-st" id="yiyi-422"><code class="descname">divmod</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-423">将两个数字相除并返回结果的整数部分。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.exp"><span class="yiyi-st" id="yiyi-424"><code class="descname">exp</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-425">返回<cite>e ** x</cite>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.fma"><span class="yiyi-st" id="yiyi-426"><code class="descname">fma</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-427">返回<em>x</em>乘以<em>y</em>，再加上<em>z</em>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.is_canonical"><span class="yiyi-st" id="yiyi-428"><code class="descname">is_canonical</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-429">如果<em>x</em>是规范的，则返回<code class="docutils literal"><span class="pre">True</span></code>；否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.is_finite"><span class="yiyi-st" id="yiyi-430"><code class="descname">is_finite</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-431">如果<em>x</em>是有限的，则返回<code class="docutils literal"><span class="pre">True</span></code>；否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.is_infinite"><span class="yiyi-st" id="yiyi-432"><code class="descname">is_infinite</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-433">如果<em>x</em>是无限的，则返回<code class="docutils literal"><span class="pre">True</span></code>；否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.is_nan"><span class="yiyi-st" id="yiyi-434"><code class="descname">is_nan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-435">如果<em>x</em>是qNaN或sNaN，则返回<code class="docutils literal"><span class="pre">True</span></code>否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.is_normal"><span class="yiyi-st" id="yiyi-436"><code class="descname">is_normal</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-437">如果<em>x</em>是一个正常数字，则返回<code class="docutils literal"><span class="pre">True</span></code>；否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.is_qnan"><span class="yiyi-st" id="yiyi-438"><code class="descname">is_qnan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-439">如果<em>x</em>是安静的NaN，则返回<code class="docutils literal"><span class="pre">True</span></code>；否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.is_signed"><span class="yiyi-st" id="yiyi-440"><code class="descname">is_signed</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-441">如果<em>x</em>为负，则返回<code class="docutils literal"><span class="pre">True</span></code>；否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.is_snan"><span class="yiyi-st" id="yiyi-442"><code class="descname">is_snan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-443">如果<em>x</em>是一个信号NaN，则返回<code class="docutils literal"><span class="pre">True</span></code>；否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.is_subnormal"><span class="yiyi-st" id="yiyi-444"><code class="descname">is_subnormal</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-445">如果<em>x</em>是低于正常的，则返回<code class="docutils literal"><span class="pre">True</span></code>；否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.is_zero"><span class="yiyi-st" id="yiyi-446"><code class="descname">is_zero</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-447">如果<em>x</em>是零，则返回<code class="docutils literal"><span class="pre">True</span></code>；否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.ln"><span class="yiyi-st" id="yiyi-448"><code class="descname">ln</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-449">返回<em>x</em>的自然对数（基数e）。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.log10"><span class="yiyi-st" id="yiyi-450"><code class="descname">log10</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-451">返回<em>x</em>的以10为底的对数。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.logb"><span class="yiyi-st" id="yiyi-452"><code class="descname">logb</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-453">返回操作数MSD大小的指数。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.logical_and"><span class="yiyi-st" id="yiyi-454"><code class="descname">logical_and</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-455">在每个操作数的数字之间应用逻辑运算<em>和</em>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.logical_invert"><span class="yiyi-st" id="yiyi-456"><code class="descname">logical_invert</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-457">反转<em>x</em>中的所有数字。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.logical_or"><span class="yiyi-st" id="yiyi-458"><code class="descname">logical_or</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-459">在每个操作数的数字之间应用逻辑操作<em>或</em>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.logical_xor"><span class="yiyi-st" id="yiyi-460"><code class="descname">logical_xor</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-461">在每个操作数的数字之间应用逻辑操作<em>xor</em>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.max"><span class="yiyi-st" id="yiyi-462"><code class="descname">max</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-463">数字比较两个值并返回最大值。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.max_mag"><span class="yiyi-st" id="yiyi-464"><code class="descname">max_mag</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-465">将数值与它们的符号忽略进行比较。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.min"><span class="yiyi-st" id="yiyi-466"><code class="descname">min</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-467">数字比较两个值并返回最小值。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.min_mag"><span class="yiyi-st" id="yiyi-468"><code class="descname">min_mag</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-469">将数值与它们的符号忽略进行比较。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.minus"><span class="yiyi-st" id="yiyi-470"><code class="descname">minus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-471">减号对应于Python中的一元前缀减运算符。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.multiply"><span class="yiyi-st" id="yiyi-472"><code class="descname">multiply</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-473">返回<em>x</em>和<em>y</em>的乘积。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.next_minus"><span class="yiyi-st" id="yiyi-474"><code class="descname">next_minus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-475">返回小于<em>x</em>的最大可表示数。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.next_plus"><span class="yiyi-st" id="yiyi-476"><code class="descname">next_plus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-477">返回大于<em>x</em>的最小可表示数。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.next_toward"><span class="yiyi-st" id="yiyi-478"><code class="descname">next_toward</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-479">返回最接近<em>x</em>的方向，朝<em>y</em>的方向。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.normalize"><span class="yiyi-st" id="yiyi-480"><code class="descname">normalize</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-481">将<em>x</em>减少到最简单的形式。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.number_class"><span class="yiyi-st" id="yiyi-482"><code class="descname">number_class</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-483">返回<em>x</em>类的指示。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.plus"><span class="yiyi-st" id="yiyi-484"><code class="descname">plus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-485">Plus对应于Python中的一元前缀加运算符。</span><span class="yiyi-st" id="yiyi-486">This operation applies the context precision and rounding, so it is <em>not</em> an identity operation.</span></p></dd></dl><dl class="method"><dt id="decimal.Context.power"><span class="yiyi-st" id="yiyi-487"><code class="descname">power</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>modulo=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-488">Return <code class="docutils literal"><span class="pre">x</span></code> to the power of <code class="docutils literal"><span class="pre">y</span></code>, reduced modulo <code class="docutils literal"><span class="pre">modulo</span></code> if given.</span></p><p><span class="yiyi-st" id="yiyi-489">有两个参数，计算<code class="docutils literal"><span class="pre">x**y</span></code>。</span><span class="yiyi-st" id="yiyi-490">如果<code class="docutils literal"><span class="pre">x</span></code>是负数，那么<code class="docutils literal"><span class="pre">y</span></code>必须是整数。</span><span class="yiyi-st" id="yiyi-491">除非<code class="docutils literal"><span class="pre">y</span></code>是积分并且结果是有限的，并且可以精确地用'精度'数字表示，结果将是不精确的。</span><span class="yiyi-st" id="yiyi-492">使用上下文的舍入模式。</span><span class="yiyi-st" id="yiyi-493">结果总是在Python版本中正确舍入。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-494"><span class="versionmodified">Changed in version 3.3: </span>The C module computes <a class="reference internal" href="#decimal.Context.power" title="decimal.Context.power"><code class="xref py py-meth docutils literal"><span class="pre">power()</span></code></a> in terms of the correctly-rounded <a class="reference internal" href="#decimal.Context.exp" title="decimal.Context.exp"><code class="xref py py-meth docutils literal"><span class="pre">exp()</span></code></a> and <a class="reference internal" href="#decimal.Context.ln" title="decimal.Context.ln"><code class="xref py py-meth docutils literal"><span class="pre">ln()</span></code></a> functions. </span><span class="yiyi-st" id="yiyi-495">结果是明确的，但只有“几乎总是正确的圆整”。</span></p></div><p><span class="yiyi-st" id="yiyi-496">有三个参数，计算<code class="docutils literal"><span class="pre">（x ** y）</span> <span class="pre">％</span> <span class="pre">modulo</span></code>。</span><span class="yiyi-st" id="yiyi-497">对于三个参数表单，参数的以下限制保留：</span></p><span class="yiyi-st" id="yiyi-501"> <blockquote> <div><ul class="simple"> <li>all three arguments must be integral</li> <li><code class="docutils literal"><span class="pre">y</span></code> must be nonnegative</li> <li>at least one of <code class="docutils literal"><span class="pre">x</span></code> or <code class="docutils literal"><span class="pre">y</span></code> must be nonzero</li> <li><code class="docutils literal"><span class="pre">modulo</span></code> must be nonzero and have at most ‘precision’ digits</li> </ul> </div></blockquote></span><p><span class="yiyi-st" id="yiyi-498">The value resulting from <code class="docutils literal"><span class="pre">Context.power(x,</span> <span class="pre">y,</span> <span class="pre">modulo)</span></code> is equal to the value that would be obtained by computing <code class="docutils literal"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">modulo</span></code> with unbounded precision, but is computed more efficiently. </span><span class="yiyi-st" id="yiyi-499">无论<code class="docutils literal"><span class="pre">x</span></code>，<code class="docutils literal"><span class="pre">y</span></code>和<code class="docutils literal"><span class="pre">modulo</span></code>的指数如何，结果的指数均为零。</span><span class="yiyi-st" id="yiyi-500">结果总是确切的。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.quantize"><span class="yiyi-st" id="yiyi-502"><code class="descname">quantize</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-503">返回一个等于<em>x</em>（四舍五入）的值，指数为<em>y</em>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.radix"><span class="yiyi-st" id="yiyi-504"><code class="descname">radix</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-505">只需返回10，因为这是Decimal，:)</span></p></dd></dl><dl class="method"><dt id="decimal.Context.remainder"><span class="yiyi-st" id="yiyi-506"><code class="descname">remainder</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-507">返回整数除法的余数。</span></p><p><span class="yiyi-st" id="yiyi-508">结果的符号（如果非零）与原始股息的符号相同。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.remainder_near"><span class="yiyi-st" id="yiyi-509"><code class="descname">remainder_near</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-510">Returns <code class="docutils literal"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">n</span></code>, where <em>n</em> is the integer nearest the exact value of <code class="docutils literal"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code> (if the result is 0 then its sign will be the sign of <em>x</em>).</span></p></dd></dl><dl class="method"><dt id="decimal.Context.rotate"><span class="yiyi-st" id="yiyi-511"><code class="descname">rotate</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-512">返回<em>x</em>，<em>y</em>次的旋转副本。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.same_quantum"><span class="yiyi-st" id="yiyi-513"><code class="descname">same_quantum</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-514">如果两个操作数具有相同的指数，则返回<code class="docutils literal"><span class="pre">True</span></code>。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.scaleb"><span class="yiyi-st" id="yiyi-515"><code class="descname">scaleb</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-516">在添加exp的第二个值后返回第一个操作数。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.shift"><span class="yiyi-st" id="yiyi-517"><code class="descname">shift</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-518">返回<em>x</em>，<em>y</em>次的移位副本。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.sqrt"><span class="yiyi-st" id="yiyi-519"><code class="descname">sqrt</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-520">上下文精度的非负数的平方根。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.subtract"><span class="yiyi-st" id="yiyi-521"><code class="descname">subtract</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-522">返回<em>x</em>和<em>y</em>之间的差异。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.to_eng_string"><span class="yiyi-st" id="yiyi-523"><code class="descname">to_eng_string</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-524">如果需要指数，则转换为字符串，使用工程符号。</span></p><p><span class="yiyi-st" id="yiyi-525">工程表示法的指数是3的倍数。</span><span class="yiyi-st" id="yiyi-526">这可能会在小数点左边留下最多3位数字，并且可能需要添加一个或两个尾随零。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.to_integral_exact"><span class="yiyi-st" id="yiyi-527"><code class="descname">to_integral_exact</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-528">舍入为整数。</span></p></dd></dl><dl class="method"><dt id="decimal.Context.to_sci_string"><span class="yiyi-st" id="yiyi-529"><code class="descname">to_sci_string</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-530">使用科学记数法将数字转换为字符串。</span></p></dd></dl></dd></dl></div><div class="section" id="constants"><h2><span class="yiyi-st" id="yiyi-531">9.4.4.</span><span class="yiyi-st" id="yiyi-532">常量</span></h2><p><span class="yiyi-st" id="yiyi-533">本节中的常量仅与C模块相关。</span><span class="yiyi-st" id="yiyi-534">它们也包含在纯Python版本中以兼容。</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"></th><th class="head"><span class="yiyi-st" id="yiyi-535">32位</span></th><th class="head"><span class="yiyi-st" id="yiyi-536">64位</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><dl class="first last data"><dt id="decimal.MAX_PREC"><span class="yiyi-st" id="yiyi-537"><code class="descclassname">decimal.</code><code class="descname">MAX_PREC</code></span></dt><dd></dd></dl></td><td><span class="yiyi-st" id="yiyi-538"><code class="xref py py-const docutils literal"><span class="pre">425000000</span></code></span></td><td><span class="yiyi-st" id="yiyi-539"><code class="xref py py-const docutils literal"><span class="pre">999999999999999999</span></code></span></td></tr><tr class="row-odd"><td><dl class="first last data"><dt id="decimal.MAX_EMAX"><span class="yiyi-st" id="yiyi-540"><code class="descclassname">decimal.</code><code class="descname">MAX_EMAX</code></span></dt><dd></dd></dl></td><td><span class="yiyi-st" id="yiyi-541"><code class="xref py py-const docutils literal"><span class="pre">425000000</span></code></span></td><td><span class="yiyi-st" id="yiyi-542"><code class="xref py py-const docutils literal"><span class="pre">999999999999999999</span></code></span></td></tr><tr class="row-even"><td><dl class="first last data"><dt id="decimal.MIN_EMIN"><span class="yiyi-st" id="yiyi-543"><code class="descclassname">decimal.</code><code class="descname">MIN_EMIN</code></span></dt><dd></dd></dl></td><td><span class="yiyi-st" id="yiyi-544"><code class="xref py py-const docutils literal"><span class="pre">-425000000</span></code></span></td><td><span class="yiyi-st" id="yiyi-545"><code class="xref py py-const docutils literal"><span class="pre">-999999999999999999</span></code></span></td></tr><tr class="row-odd"><td><dl class="first last data"><dt id="decimal.MIN_ETINY"><span class="yiyi-st" id="yiyi-546"><code class="descclassname">decimal.</code><code class="descname">MIN_ETINY</code></span></dt><dd></dd></dl></td><td><span class="yiyi-st" id="yiyi-547"><code class="xref py py-const docutils literal"><span class="pre">-849999999</span></code></span></td><td><span class="yiyi-st" id="yiyi-548"><code class="xref py py-const docutils literal"><span class="pre">-1999999999999999997</span></code></span></td></tr></tbody></table><dl class="data"><dt id="decimal.HAVE_THREADS"><span class="yiyi-st" id="yiyi-549"><code class="descclassname">decimal.</code><code class="descname">HAVE_THREADS</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-550">默认值是<code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-551">如果Python编译时没有线程，C版本会自动禁用昂贵的线程本地上下文机制。</span><span class="yiyi-st" id="yiyi-552">在这种情况下，值为<code class="docutils literal"><span class="pre">False</span></code>。</span></p></dd></dl></div><div class="section" id="rounding-modes"><h2><span class="yiyi-st" id="yiyi-553">9.4.5.</span><span class="yiyi-st" id="yiyi-554">舍入模式</span></h2><dl class="data"><dt id="decimal.ROUND_CEILING"><span class="yiyi-st" id="yiyi-555"><code class="descclassname">decimal.</code><code class="descname">ROUND_CEILING</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-556">向<code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code>展开。</span></p></dd></dl><dl class="data"><dt id="decimal.ROUND_DOWN"><span class="yiyi-st" id="yiyi-557"><code class="descclassname">decimal.</code><code class="descname">ROUND_DOWN</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-558">向零回合。</span></p></dd></dl><dl class="data"><dt id="decimal.ROUND_FLOOR"><span class="yiyi-st" id="yiyi-559"><code class="descclassname">decimal.</code><code class="descname">ROUND_FLOOR</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-560">向<code class="xref py py-const docutils literal"><span class="pre">-Infinity</span></code>回合。</span></p></dd></dl><dl class="data"><dt id="decimal.ROUND_HALF_DOWN"><span class="yiyi-st" id="yiyi-561"><code class="descclassname">decimal.</code><code class="descname">ROUND_HALF_DOWN</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-562">将关系向最接近零的方向调整。</span></p></dd></dl><dl class="data"><dt id="decimal.ROUND_HALF_EVEN"><span class="yiyi-st" id="yiyi-563"><code class="descclassname">decimal.</code><code class="descname">ROUND_HALF_EVEN</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-564">以最接近的偶数整数将关系舍入到最近。</span></p></dd></dl><dl class="data"><dt id="decimal.ROUND_HALF_UP"><span class="yiyi-st" id="yiyi-565"><code class="descclassname">decimal.</code><code class="descname">ROUND_HALF_UP</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-566">离领带最近的距离为零。</span></p></dd></dl><dl class="data"><dt id="decimal.ROUND_UP"><span class="yiyi-st" id="yiyi-567"><code class="descclassname">decimal.</code><code class="descname">ROUND_UP</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-568">从零开始回合。</span></p></dd></dl><dl class="data"><dt id="decimal.ROUND_05UP"><span class="yiyi-st" id="yiyi-569"><code class="descclassname">decimal.</code><code class="descname">ROUND_05UP</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-570">如果舍入到零后的最后一位数字为0或5，则从零开始舍去；否则向零回合。</span></p></dd></dl></div><div class="section" id="signals"><h2><span class="yiyi-st" id="yiyi-571">9.4.6.</span><span class="yiyi-st" id="yiyi-572">信号</span></h2><p><span class="yiyi-st" id="yiyi-573">信号代表计算过程中出现的条件。</span><span class="yiyi-st" id="yiyi-574">每个对应于一个上下文标志和一个上下文陷阱启用器。</span></p><p><span class="yiyi-st" id="yiyi-575">上下文标志在遇到条件时设置。</span><span class="yiyi-st" id="yiyi-576">在计算之后，可以检查标志以用于信息目的（例如，以确定计算是否准确）。</span><span class="yiyi-st" id="yiyi-577">检查标志后，确保在开始下一次计算之前清除所有标志。</span></p><p><span class="yiyi-st" id="yiyi-578">如果为信号设置了上下文的陷阱启用码，则该条件会引发Python异常。</span><span class="yiyi-st" id="yiyi-579">例如，如果设置了<a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-class docutils literal"><span class="pre">DivisionByZero</span></code></a>陷阱，则遇到条件时会引发<a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-exc docutils literal"><span class="pre">DivisionByZero</span></code></a>异常。</span></p><dl class="class"><dt id="decimal.Clamped"><span class="yiyi-st" id="yiyi-580"><em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Clamped</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-581">改变了指数以适应表示限制。</span></p><p><span class="yiyi-st" id="yiyi-582">Typically, clamping occurs when an exponent falls outside the context’s <code class="xref py py-attr docutils literal"><span class="pre">Emin</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">Emax</span></code> limits. </span><span class="yiyi-st" id="yiyi-583">如果可能的话，通过给系数加零来使指数减小到合适的值。</span></p></dd></dl><dl class="class"><dt id="decimal.DecimalException"><span class="yiyi-st" id="yiyi-584"><em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">DecimalException</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-585">其他信号的基类和<a class="reference internal" href="exceptions.html#ArithmeticError" title="ArithmeticError"><code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code></a>的子类。</span></p></dd></dl><dl class="class"><dt id="decimal.DivisionByZero"><span class="yiyi-st" id="yiyi-586"><em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">DivisionByZero</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-587">用零表示非无限数的划分。</span></p><p><span class="yiyi-st" id="yiyi-588">可能发生在划分，模块划分或将某个数字提升至负值时。</span><span class="yiyi-st" id="yiyi-589">如果此信号未被捕获，则返回<code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code>或<code class="xref py py-const docutils literal"><span class="pre">-Infinity</span></code>，其符号由计算输入确定。</span></p></dd></dl><dl class="class"><dt id="decimal.Inexact"><span class="yiyi-st" id="yiyi-590"><em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Inexact</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-591">表示发生舍入且结果不准确。</span></p><p><span class="yiyi-st" id="yiyi-592">舍入时丢弃非零数字的信号。</span><span class="yiyi-st" id="yiyi-593">四舍五入的结果被返回。</span><span class="yiyi-st" id="yiyi-594">信号标志或陷阱用于检测结果是否不准确。</span></p></dd></dl><dl class="class"><dt id="decimal.InvalidOperation"><span class="yiyi-st" id="yiyi-595"><em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">InvalidOperation</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-596">执行了无效的操作。</span></p><p><span class="yiyi-st" id="yiyi-597">表示请求的操作没有意义。</span><span class="yiyi-st" id="yiyi-598">如果没有陷入，返回<code class="xref py py-const docutils literal"><span class="pre">NaN</span></code>。</span><span class="yiyi-st" id="yiyi-599">可能的原因包括：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">Infinity</span> <span class="o">-</span> <span class="n">Infinity</span>
<span class="mi">0</span> <span class="o">*</span> <span class="n">Infinity</span>
<span class="n">Infinity</span> <span class="o">/</span> <span class="n">Infinity</span>
<span class="n">x</span> <span class="o">%</span> <span class="mi">0</span>
<span class="n">Infinity</span> <span class="o">%</span> <span class="n">x</span>
<span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="mi">0</span> <span class="o">**</span> <span class="mi">0</span>
<span class="n">x</span> <span class="o">**</span> <span class="p">(</span><span class="n">non</span><span class="o">-</span><span class="n">integer</span><span class="p">)</span>
<span class="n">x</span> <span class="o">**</span> <span class="n">Infinity</span>
</pre></div></div></dd></dl><dl class="class"><dt id="decimal.Overflow"><span class="yiyi-st" id="yiyi-600"><em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Overflow</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-601">数值溢出。</span></p><p><span class="yiyi-st" id="yiyi-602">指出在舍入发生后指数大于<code class="xref py py-attr docutils literal"><span class="pre">Emax</span></code>。</span><span class="yiyi-st" id="yiyi-603">If not trapped, the result depends on the rounding mode, either pulling inward to the largest representable finite number or rounding outward to <code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code>. </span><span class="yiyi-st" id="yiyi-604">在任何一种情况下，<a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-class docutils literal"><span class="pre">Inexact</span></code></a>和<a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-class docutils literal"><span class="pre">Rounded</span></code></a>也会发出信号。</span></p></dd></dl><dl class="class"><dt id="decimal.Rounded"><span class="yiyi-st" id="yiyi-605"><em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Rounded</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-606">尽管可能没有信息丢失，但发生了舍入。</span></p><p><span class="yiyi-st" id="yiyi-607">每当四舍五入舍弃数字时发信号通知；即使这些数字是零（例如舍入<code class="xref py py-const docutils literal"><span class="pre">5.00</span></code>到<code class="xref py py-const docutils literal"><span class="pre">5.0</span></code>）。</span><span class="yiyi-st" id="yiyi-608">如果未被捕获，则返回结果不变。</span><span class="yiyi-st" id="yiyi-609">该信号用于检测有效数字的丢失。</span></p></dd></dl><dl class="class"><dt id="decimal.Subnormal"><span class="yiyi-st" id="yiyi-610"><em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Subnormal</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-611">Exponent was lower than <code class="xref py py-attr docutils literal"><span class="pre">Emin</span></code> prior to rounding.</span></p><p><span class="yiyi-st" id="yiyi-612">当运算结果不正常时（指数太小）发生。</span><span class="yiyi-st" id="yiyi-613">如果未被捕获，则返回结果不变。</span></p></dd></dl><dl class="class"><dt id="decimal.Underflow"><span class="yiyi-st" id="yiyi-614"><em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Underflow</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-615">数值下溢，结果舍入为零。</span></p><p><span class="yiyi-st" id="yiyi-616">通过舍入将低于正常值的结果推到零时发生。</span><span class="yiyi-st" id="yiyi-617"><a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-class docutils literal"><span class="pre">Inexact</span></code></a>和<a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-class docutils literal"><span class="pre">Subnormal</span></code></a>也会发出信号。</span></p></dd></dl><dl class="class"><dt id="decimal.FloatOperation"><span class="yiyi-st" id="yiyi-618"><em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">FloatOperation</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-619">为混合浮点数和小数点启用更严格的语义。</span></p><p><span class="yiyi-st" id="yiyi-620">如果信号未被捕获（默认），则在<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>构造函数，<a class="reference internal" href="#decimal.Context.create_decimal" title="decimal.Context.create_decimal"><code class="xref py py-meth docutils literal"><span class="pre">create_decimal()</span></code></a>和所有比较运算符中允许混合浮点数和小数点。</span><span class="yiyi-st" id="yiyi-621">转换和比较都是确切的。</span><span class="yiyi-st" id="yiyi-622">通过在上下文标志中设置<a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal"><span class="pre">FloatOperation</span></code></a>，可以静默记录任何混合操作的发生。</span><span class="yiyi-st" id="yiyi-623">使用<a class="reference internal" href="#decimal.Decimal.from_float" title="decimal.Decimal.from_float"><code class="xref py py-meth docutils literal"><span class="pre">from_float()</span></code></a>或<a class="reference internal" href="#decimal.Context.create_decimal_from_float" title="decimal.Context.create_decimal_from_float"><code class="xref py py-meth docutils literal"><span class="pre">create_decimal_from_float()</span></code></a>的显式转换不会设置标志。</span></p><p><span class="yiyi-st" id="yiyi-624">否则（信号被捕获），只有平等比较和显式转换是无声的。</span><span class="yiyi-st" id="yiyi-625">All other mixed operations raise <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal"><span class="pre">FloatOperation</span></code></a>.</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-626">下表总结了信号的层次结构：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">exceptions</span><span class="o">.</span><span class="n">ArithmeticError</span><span class="p">(</span><span class="n">exceptions</span><span class="o">.</span><span class="n">Exception</span><span class="p">)</span>
    <span class="n">DecimalException</span>
        <span class="n">Clamped</span>
        <span class="n">DivisionByZero</span><span class="p">(</span><span class="n">DecimalException</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ZeroDivisionError</span><span class="p">)</span>
        <span class="n">Inexact</span>
            <span class="n">Overflow</span><span class="p">(</span><span class="n">Inexact</span><span class="p">,</span> <span class="n">Rounded</span><span class="p">)</span>
            <span class="n">Underflow</span><span class="p">(</span><span class="n">Inexact</span><span class="p">,</span> <span class="n">Rounded</span><span class="p">,</span> <span class="n">Subnormal</span><span class="p">)</span>
        <span class="n">InvalidOperation</span>
        <span class="n">Rounded</span>
        <span class="n">Subnormal</span>
        <span class="n">FloatOperation</span><span class="p">(</span><span class="n">DecimalException</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">TypeError</span><span class="p">)</span>
</pre></div></div></div><div class="section" id="floating-point-notes"><h2><span class="yiyi-st" id="yiyi-627">9.4.7.</span><span class="yiyi-st" id="yiyi-628">浮点数注意事项</span></h2><div class="section" id="mitigating-round-off-error-with-increased-precision"><h3><span class="yiyi-st" id="yiyi-629">9.4.7.1.</span><span class="yiyi-st" id="yiyi-630">以更高的精度减轻舍入误差</span></h3><p><span class="yiyi-st" id="yiyi-631">使用十进制浮点消除了十进制表示错误（可以精确地表示<code class="xref py py-const docutils literal"><span class="pre">0.1</span></code>）；但是，当非零数字超过固定精度时，某些操作仍然会产生舍入误差。</span></p><p><span class="yiyi-st" id="yiyi-632">舍入误差的影响可以通过增加或减少近似偏移量来放大，从而导致显着性的损失。</span><span class="yiyi-st" id="yiyi-633">Knuth提供了两个有启发意义的例子，其中精度不足的四舍五入浮点运算导致加法的关联和分布性质的崩溃：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># Examples from Seminumerical Algorithms, Section 4.2.2.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">getcontext</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">8</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">11111113</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">11111111</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'7.51111111'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span>
<span class="n">Decimal</span><span class="p">(</span><span class="s1">'9.5111111'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>
<span class="n">Decimal</span><span class="p">(</span><span class="s1">'10'</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">20000</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'6.0000003'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="n">Decimal</span><span class="p">(</span><span class="s1">'0.01'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">w</span><span class="p">)</span>
<span class="n">Decimal</span><span class="p">(</span><span class="s1">'0.0060000'</span><span class="p">)</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-634"><a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a>模块可以通过充分扩展精度来恢复身份，以避免失去重要性：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">11111113</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">11111111</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'7.51111111'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span>
<span class="go">Decimal('9.51111111')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>
<span class="go">Decimal('9.51111111')</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">20000</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'6.0000003'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal('0.0060000')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal('0.0060000')</span>
</pre></div></div></div><div class="section" id="special-values"><h3><span class="yiyi-st" id="yiyi-635">9.4.7.2.</span><span class="yiyi-st" id="yiyi-636">特殊值</span></h3><p><span class="yiyi-st" id="yiyi-637">The number system for the <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> module provides special values including <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code>, <code class="xref py py-const docutils literal"><span class="pre">sNaN</span></code>, <code class="xref py py-const docutils literal"><span class="pre">-Infinity</span></code>, <code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code>, and two zeros, <code class="xref py py-const docutils literal"><span class="pre">+0</span></code> and <code class="xref py py-const docutils literal"><span class="pre">-0</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-638">无穷可以直接使用：<code class="docutils literal"><span class="pre">Decimal('Infinity')</span></code>。</span><span class="yiyi-st" id="yiyi-639">此外，当<a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-exc docutils literal"><span class="pre">DivisionByZero</span></code></a>信号未被捕获时，它们可能会因除以零而产生。</span><span class="yiyi-st" id="yiyi-640">同样，当<a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-exc docutils literal"><span class="pre">Overflow</span></code></a>信号未被捕获时，无限大可能因四舍五入超出最大可表示数的限制而产生。</span></p><p><span class="yiyi-st" id="yiyi-641">无穷大被签名（仿射），可用于算术运算中，它们被视为非常大，不确定的数字。</span><span class="yiyi-st" id="yiyi-642">例如，将一个常数加到无穷大给出了另一个无限的结果。</span></p><p><span class="yiyi-st" id="yiyi-643">某些操作不确定并返回<code class="xref py py-const docutils literal"><span class="pre">NaN</span></code>，或者如果<a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-exc docutils literal"><span class="pre">InvalidOperation</span></code></a>信号被捕获，则引发异常。</span><span class="yiyi-st" id="yiyi-644">例如，<code class="docutils literal"><span class="pre">0/0</span></code>返回<code class="xref py py-const docutils literal"><span class="pre">NaN</span></code>，这意味着“不是一个数字”。</span><span class="yiyi-st" id="yiyi-645">This variety of <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> is quiet and, once created, will flow through other computations always resulting in another <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code>. </span><span class="yiyi-st" id="yiyi-646">这种行为对于偶尔缺少输入的一系列计算很有用 - 它允许在将特定结果标记为无效时继续进行计算。</span></p><p><span class="yiyi-st" id="yiyi-647">A variant is <code class="xref py py-const docutils literal"><span class="pre">sNaN</span></code> which signals rather than remaining quiet after every operation. </span><span class="yiyi-st" id="yiyi-648">当无效结果需要中断特殊处理的计算时，这是一个有用的返回值。</span></p><p><span class="yiyi-st" id="yiyi-649">涉及<code class="xref py py-const docutils literal"><span class="pre">NaN</span></code>时，Python的比较运算符的行为可能有点令人惊讶。</span><span class="yiyi-st" id="yiyi-650">A test for equality where one of the operands is a quiet or signaling <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> always returns <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> (even when doing <code class="docutils literal"><span class="pre">Decimal('NaN')==Decimal('NaN')</span></code>), while a test for inequality always returns <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>. </span><span class="yiyi-st" id="yiyi-651">An attempt to compare two Decimals using any of the <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code> or <code class="docutils literal"><span class="pre">&gt;=</span></code> operators will raise the <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-exc docutils literal"><span class="pre">InvalidOperation</span></code></a> signal if either operand is a <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code>, and return <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> if this signal is not trapped. </span><span class="yiyi-st" id="yiyi-652">Note that the General Decimal Arithmetic specification does not specify the behavior of direct comparisons; these rules for comparisons involving a <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> were taken from the IEEE 854 standard (see Table 3 in section 5.7). </span><span class="yiyi-st" id="yiyi-653">为确保遵守严格的标准，请使用<code class="xref py py-meth docutils literal"><span class="pre">compare()</span></code>和<code class="xref py py-meth docutils literal"><span class="pre">compare-signal()</span></code>方法。</span></p><p><span class="yiyi-st" id="yiyi-654">有符号的零可能源自下溢的计算结果。</span><span class="yiyi-st" id="yiyi-655">如果计算过程更加精确，它们会保留原来的符号。</span><span class="yiyi-st" id="yiyi-656">由于它们的大小为零，所以正和负零都被视为相等并且它们的符号是信息性的。</span></p><p><span class="yiyi-st" id="yiyi-657">除了两个不同而又相等的有符号零点之外，零点的各种表示还有不同的精度，但其价值相同。</span><span class="yiyi-st" id="yiyi-658">这需要一些习惯。</span><span class="yiyi-st" id="yiyi-659">对于习惯于归一化浮点表示的眼睛来说，下面的计算返回等于零的值并不明显：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'Infinity'</span><span class="p">)</span>
<span class="go">Decimal('0E-1000026')</span>
</pre></div></div></div></div><div class="section" id="working-with-threads"><h2><span class="yiyi-st" id="yiyi-660">9.4.8.</span><span class="yiyi-st" id="yiyi-661">使用线程</span></h2><p><span class="yiyi-st" id="yiyi-662"><a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a>函数为每个线程访问不同的<a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a>对象。</span><span class="yiyi-st" id="yiyi-663">分离线程上下文意味着线程可以在不干扰其他线程的情况下进行更改（如<code class="docutils literal"><span class="pre">getcontext().prec=10</span></code>）。</span></p><p><span class="yiyi-st" id="yiyi-664">同样，<a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal"><span class="pre">setcontext()</span></code></a>函数自动将其目标分配给当前线程。</span></p><p><span class="yiyi-st" id="yiyi-665">如果<a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal"><span class="pre">setcontext()</span></code></a>尚未在<a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a>之前调用，那么<a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a>会自动创建一个新的上下文以供当前线程使用。</span></p><p><span class="yiyi-st" id="yiyi-666">新的上下文是从称为<em>DefaultContext</em>的原型上下文中复制的。</span><span class="yiyi-st" id="yiyi-667">要控制默认值，以便每个线程在整个应用程序中使用相同的值，请直接修改<em>DefaultContext</em>对象。</span><span class="yiyi-st" id="yiyi-668">这应该在开始之前<em>完成，以便在调用<a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a>的线程之间不存在争用条件。</em></span><span class="yiyi-st" id="yiyi-669">例如：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># Set applicationwide defaults for all threads about to be launched</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">rounding</span> <span class="o">=</span> <span class="n">ROUND_DOWN</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">traps</span> <span class="o">=</span> <span class="n">ExtendedContext</span><span class="o">.</span><span class="n">traps</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">InvalidOperation</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">setcontext</span><span class="p">(</span><span class="n">DefaultContext</span><span class="p">)</span>

<span class="c1"># Afterwards, the threads can be started</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t3</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
 <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
</pre></div></div></div><div class="section" id="recipes"><h2><span class="yiyi-st" id="yiyi-670">9.4.9.</span><span class="yiyi-st" id="yiyi-671">配方</span></h2><p><span class="yiyi-st" id="yiyi-672">下面是一些作为实用功能的食谱，并演示了如何使用<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>类：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">moneyfmt</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">curr</span><span class="o">=</span><span class="s1">''</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">','</span><span class="p">,</span> <span class="n">dp</span><span class="o">=</span><span class="s1">'.'</span><span class="p">,</span>
             <span class="n">pos</span><span class="o">=</span><span class="s1">''</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="s1">'-'</span><span class="p">,</span> <span class="n">trailneg</span><span class="o">=</span><span class="s1">''</span><span class="p">):</span>
    <span class="sd">"""Convert Decimal to a money formatted string.</span>

<span class="sd">    places:  required number of places after the decimal point</span>
<span class="sd">    curr:    optional currency symbol before the sign (may be blank)</span>
<span class="sd">    sep:     optional grouping separator (comma, period, space, or blank)</span>
<span class="sd">    dp:      decimal point indicator (comma or period)</span>
<span class="sd">             only specify as blank when places is zero</span>
<span class="sd">    pos:     optional sign for positive numbers: '+', space or blank</span>
<span class="sd">    neg:     optional sign for negative numbers: '-', '(', space or blank</span>
<span class="sd">    trailneg:optional trailing minus indicator:  '-', ')', space or blank</span>

<span class="sd">    &gt;&gt;&gt; d = Decimal('-1234567.8901')</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, curr='$')</span>
<span class="sd">    '-$1,234,567.89'</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, places=0, sep='.', dp='', neg='', trailneg='-')</span>
<span class="sd">    '1.234.568-'</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, curr='$', neg='(', trailneg=')')</span>
<span class="sd">    '($1,234,567.89)'</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(Decimal(123456789), sep=' ')</span>
<span class="sd">    '123 456 789.00'</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(Decimal('-0.02'), neg='&lt;', trailneg='&gt;')</span>
<span class="sd">    '&lt;0.02&gt;'</span>

<span class="sd">    """</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="n">places</span>      <span class="c1"># 2 places --&gt; '0.01'</span>
    <span class="n">sign</span><span class="p">,</span> <span class="n">digits</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">as_tuple</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">digits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">digits</span><span class="p">))</span>
    <span class="n">build</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">pop</span>
    <span class="k">if</span> <span class="n">sign</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="n">trailneg</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">places</span><span class="p">):</span>
        <span class="n">build</span><span class="p">(</span><span class="nb">next</span><span class="p">()</span> <span class="k">if</span> <span class="n">digits</span> <span class="k">else</span> <span class="s1">'0'</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">places</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">digits</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="s1">'0'</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">digits</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="nb">next</span><span class="p">())</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">digits</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">build</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">build</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
    <span class="n">build</span><span class="p">(</span><span class="n">neg</span> <span class="k">if</span> <span class="n">sign</span> <span class="k">else</span> <span class="n">pos</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">pi</span><span class="p">():</span>
    <span class="sd">"""Compute Pi to the current precision.</span>

<span class="sd">    &gt;&gt;&gt; print(pi())</span>
<span class="sd">    3.141592653589793238462643383</span>

<span class="sd">    """</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># extra digits for intermediate steps</span>
    <span class="n">three</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>      <span class="c1"># substitute "three=3.0" for regular floats</span>
    <span class="n">lasts</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">da</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">three</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">24</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">na</span> <span class="o">=</span> <span class="n">n</span><span class="o">+</span><span class="n">na</span><span class="p">,</span> <span class="n">na</span><span class="o">+</span><span class="mi">8</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">da</span> <span class="o">=</span> <span class="n">d</span><span class="o">+</span><span class="n">da</span><span class="p">,</span> <span class="n">da</span><span class="o">+</span><span class="mi">32</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>               <span class="c1"># unary plus applies the new precision</span>

<span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">"""Return e raised to the power of x.  Result type matches input type.</span>

<span class="sd">    &gt;&gt;&gt; print(exp(Decimal(1)))</span>
<span class="sd">    2.718281828459045235360287471</span>
<span class="sd">    &gt;&gt;&gt; print(exp(Decimal(2)))</span>
<span class="sd">    7.389056098930650227230427461</span>
<span class="sd">    &gt;&gt;&gt; print(exp(2.0))</span>
<span class="sd">    7.38905609893</span>
<span class="sd">    &gt;&gt;&gt; print(exp(2+0j))</span>
<span class="sd">    (7.38905609893+0j)</span>

<span class="sd">    """</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>

<span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">"""Return the cosine of x as measured in radians.</span>

<span class="sd">    The Taylor series approximation works best for a small value of x.</span>
<span class="sd">    For larger values, first compute x = x % (2 * pi).</span>

<span class="sd">    &gt;&gt;&gt; print(cos(Decimal('0.5')))</span>
<span class="sd">    0.8775825618903727161162815826</span>
<span class="sd">    &gt;&gt;&gt; print(cos(0.5))</span>
<span class="sd">    0.87758256189</span>
<span class="sd">    &gt;&gt;&gt; print(cos(0.5+0j))</span>
<span class="sd">    (0.87758256189+0j)</span>

<span class="sd">    """</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">sign</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>

<span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">"""Return the sine of x as measured in radians.</span>

<span class="sd">    The Taylor series approximation works best for a small value of x.</span>
<span class="sd">    For larger values, first compute x = x % (2 * pi).</span>

<span class="sd">    &gt;&gt;&gt; print(sin(Decimal('0.5')))</span>
<span class="sd">    0.4794255386042030002732879352</span>
<span class="sd">    &gt;&gt;&gt; print(sin(0.5))</span>
<span class="sd">    0.479425538604</span>
<span class="sd">    &gt;&gt;&gt; print(sin(0.5+0j))</span>
<span class="sd">    (0.479425538604+0j)</span>

<span class="sd">    """</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">sign</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>
</pre></div></div></div><div class="section" id="decimal-faq"><h2><span class="yiyi-st" id="yiyi-673">9.4.10.</span><span class="yiyi-st" id="yiyi-674">十进制常见问题</span></h2><p><span class="yiyi-st" id="yiyi-675">Q.</span><span class="yiyi-st" id="yiyi-676">输入<code class="docutils literal"><span class="pre">decimal.Decimal('1234.5')</span></code>很麻烦。</span><span class="yiyi-st" id="yiyi-677">在使用交互式解释器时，是否有办法减少键入？</span></p><p><span class="yiyi-st" id="yiyi-678">一个。</span><span class="yiyi-st" id="yiyi-679">一些用户将构造函数缩写为一个字母：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">(</span><span class="s1">'1.23'</span><span class="p">)</span> <span class="o">+</span> <span class="n">D</span><span class="p">(</span><span class="s1">'3.45'</span><span class="p">)</span>
<span class="go">Decimal('4.68')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-680">Q.</span><span class="yiyi-st" id="yiyi-681">在有两位小数的定点应用程序中，某些输入有许多地方，需要四舍五入。</span><span class="yiyi-st" id="yiyi-682">其他人不应该有过多的数字，需要验证。</span><span class="yiyi-st" id="yiyi-683">应该使用什么方法？</span></p><p><span class="yiyi-st" id="yiyi-684">一个。</span><span class="yiyi-st" id="yiyi-685"><code class="xref py py-meth docutils literal"><span class="pre">quantize()</span></code>方法舍入到固定的小数位数。</span><span class="yiyi-st" id="yiyi-686">如果设置了<a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal"><span class="pre">Inexact</span></code></a>陷阱，它对于验证也很有用：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">TWOPLACES</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span>       <span class="c1"># same as Decimal('0.01')</span>
</pre></div></div><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Round to two places</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'3.214'</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>
<span class="go">Decimal('3.21')</span>
</pre></div></div><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Validate that a number does not exceed two places</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'3.21'</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">Context</span><span class="p">(</span><span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]))</span>
<span class="go">Decimal('3.21')</span>
</pre></div></div><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'3.214'</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">Context</span><span class="p">(</span><span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]))</span>
<span class="gt">Traceback (most recent call last):</span>
   <span class="c">...</span>
<span class="gr">Inexact</span>: <span class="n">None</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-687">Q.</span><span class="yiyi-st" id="yiyi-688">一旦我有有效的两个位置输入，我如何在整个应用程序中保持不变？</span></p><p><span class="yiyi-st" id="yiyi-689">一个。</span><span class="yiyi-st" id="yiyi-690">像加法，减法和乘以整数等操作将自动保留固定点。</span><span class="yiyi-st" id="yiyi-691">其他操作（如分割和非整数乘法）将更改小数位数，并需要使用<code class="xref py py-meth docutils literal"><span class="pre">quantize()</span></code>步骤进行后续操作：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'102.72'</span><span class="p">)</span>           <span class="c1"># Initial fixed-point values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'3.17'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>                           <span class="c1"># Addition preserves fixed-point</span>
<span class="go">Decimal('105.89')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
<span class="go">Decimal('99.55')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="mi">42</span>                          <span class="c1"># So does integer multiplication</span>
<span class="go">Decimal('4314.24')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>     <span class="c1"># Must quantize non-integer multiplication</span>
<span class="go">Decimal('325.62')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">b</span> <span class="o">/</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>     <span class="c1"># And quantize division</span>
<span class="go">Decimal('0.03')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-692">在开发定点应用程序时，定义处理<code class="xref py py-meth docutils literal"><span class="pre">quantize()</span></code>步骤的函数是很方便的：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">TWOPLACES</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">TWOPLACES</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
</pre></div></div><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>                       <span class="c1"># Automatically preserve fixed-point</span>
<span class="go">Decimal('325.62')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">div</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">Decimal('0.03')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-693">Q.</span><span class="yiyi-st" id="yiyi-694">有很多方法来表达相同的价值。</span><span class="yiyi-st" id="yiyi-695">The numbers <code class="xref py py-const docutils literal"><span class="pre">200</span></code>, <code class="xref py py-const docutils literal"><span class="pre">200.000</span></code>, <code class="xref py py-const docutils literal"><span class="pre">2E2</span></code>, and <code class="xref py py-const docutils literal"><span class="pre">02E+4</span></code> all have the same value at various precisions. </span><span class="yiyi-st" id="yiyi-696">有没有办法将它们转换为单一可识别的规范值？</span></p><p><span class="yiyi-st" id="yiyi-697">一个。</span><span class="yiyi-st" id="yiyi-698"><code class="xref py py-meth docutils literal"><span class="pre">normalize()</span></code>方法将所有等价值映射到单个代表：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="s1">'200 200.000 2E2 .02E+4'</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
<span class="go">[Decimal('2E+2'), Decimal('2E+2'), Decimal('2E+2'), Decimal('2E+2')]</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-699">Q.</span><span class="yiyi-st" id="yiyi-700">一些小数值总是以指数表示法打印。</span><span class="yiyi-st" id="yiyi-701">有没有办法获得非指数表示？</span></p><p><span class="yiyi-st" id="yiyi-702">一个。</span><span class="yiyi-st" id="yiyi-703">对于某些值，指数符号是表示系数中重要位置数的唯一方式。</span><span class="yiyi-st" id="yiyi-704">例如，将<code class="xref py py-const docutils literal"><span class="pre">5.0E+3</span></code>表示为<code class="xref py py-const docutils literal"><span class="pre">5000</span></code>可使该值保持不变，但不能显示原始的双位意义。</span></p><p><span class="yiyi-st" id="yiyi-705">如果应用程序不关心跟踪重要性，则很容易去除指数和尾随零，失去重要性，但保持值不变：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">remove_exponent</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">d</span><span class="o">.</span><span class="n">to_integral</span><span class="p">()</span> <span class="k">else</span> <span class="n">d</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
</pre></div></div><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">remove_exponent</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'5E+3'</span><span class="p">))</span>
<span class="go">Decimal('5000')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-706">Q.</span><span class="yiyi-st" id="yiyi-707">有没有办法将常规浮点数转换为<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>？</span></p><p><span class="yiyi-st" id="yiyi-708">一个。</span><span class="yiyi-st" id="yiyi-709">是的，任何二进制浮点数都可以精确地表示为十进制，但精确转换可能比直觉所建议的要精确得多：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">Decimal('3.141592653589793115997963468544185161590576171875')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-710">Q.</span><span class="yiyi-st" id="yiyi-711">在一个复杂的计算中，我怎么能确保我没有得到一个虚假的结果，因为精度不足或舍入异常。</span></p><p><span class="yiyi-st" id="yiyi-712">一个。</span><span class="yiyi-st" id="yiyi-713">十进制模块可以很容易地测试结果。</span><span class="yiyi-st" id="yiyi-714">最佳做法是使用更高精度和各种舍入模式重新运行计算。</span><span class="yiyi-st" id="yiyi-715">广泛不同的结果表明精度不足，舍入模式问题，病态输入或数字不稳定算法。</span></p><p><span class="yiyi-st" id="yiyi-716">问：我注意到上下文的精确度适用于操作的结果，但不适用于输入。</span><span class="yiyi-st" id="yiyi-717">混合不同精度值时有什么需要注意的吗？</span></p><p><span class="yiyi-st" id="yiyi-718">一个。</span><span class="yiyi-st" id="yiyi-719">是。</span><span class="yiyi-st" id="yiyi-720">原则是所有的值都被认为是精确的，这些值的算术也是如此。</span><span class="yiyi-st" id="yiyi-721">只有结果四舍五入。</span><span class="yiyi-st" id="yiyi-722">投入的优点是“你输入的是你所得到的”。</span><span class="yiyi-st" id="yiyi-723">缺点是，如果忘记输入未被舍入，结果可能会显得很奇怪：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'3.104'</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'2.104'</span><span class="p">)</span>
<span class="go">Decimal('5.21')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'3.104'</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'0.000'</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'2.104'</span><span class="p">)</span>
<span class="go">Decimal('5.20')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-724">解决方法是提高精度或强制使用一元加运算对输入进行四舍五入：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">+</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'1.23456789'</span><span class="p">)</span>      <span class="c1"># unary plus triggers rounding</span>
<span class="go">Decimal('1.23')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-725">或者，输入可以在创建时使用<a class="reference internal" href="#decimal.Context.create_decimal" title="decimal.Context.create_decimal"><code class="xref py py-meth docutils literal"><span class="pre">Context.create_decimal()</span></code></a>方法进行舍入：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span><span class="o">.</span><span class="n">create_decimal</span><span class="p">(</span><span class="s1">'1.2345678'</span><span class="p">)</span>
<span class="go">Decimal('1.2345')</span>
</pre></div></div></div></div></div>