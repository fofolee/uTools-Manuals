<div class="body" role="main"><div class="section" id="module-types"><h1><span class="yiyi-st" id="yiyi-10">8.9. <a class="reference internal" href="#module-types" title="types: Names for built-in types."><code class="xref py py-mod docutils literal"><span class="pre">types</span></code></a>  - 内建类型的动态类型创建和名称</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/types.py">Lib / types.py</a></span></p><p><span class="yiyi-st" id="yiyi-12">该模块定义了效用函数以帮助动态创建新类型。</span></p><p><span class="yiyi-st" id="yiyi-13">它还定义了标准Python解释器使用的某些对象类型的名称，但不作为<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>或<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>的内置码公开。</span></p><p><span class="yiyi-st" id="yiyi-14">最后，它提供了一些额外的类型相关的实用程序类和函数，这些类和函数对于内置函数不够重要。</span></p><div class="section" id="dynamic-type-creation"><h2><span class="yiyi-st" id="yiyi-15">8.9.1。</span><span class="yiyi-st" id="yiyi-16">动态类型创建</span></h2><dl class="function"><dt id="types.new_class"><span class="yiyi-st" id="yiyi-17"><code class="descclassname">types.</code><code class="descname">new_class</code><span class="sig-paren">(</span><em>name</em>, <em>bases=()</em>, <em>kwds=None</em>, <em>exec_body=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-18">使用适当的元类动态创建类对象。</span></p><p><span class="yiyi-st" id="yiyi-19">前三个参数是组成类定义头的组件：类名，基类（按顺序），关键字参数（例如<code class="docutils literal"><span class="pre">metaclass</span></code>）。</span></p><p><span class="yiyi-st" id="yiyi-20"><em>exec_body</em>参数是一个回调，用于填充新创建的类命名空间。</span><span class="yiyi-st" id="yiyi-21">它应该接受类命名空间作为其唯一的参数，并直接用类内容更新命名空间。</span><span class="yiyi-st" id="yiyi-22">如果未提供回调，则与传递<code class="docutils literal"><span class="pre">lambda</span> <span class="pre">ns：</span> <span class="pre">ns</span></code>具有相同的效果。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-23"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="types.prepare_class"><span class="yiyi-st" id="yiyi-24"><code class="descclassname">types.</code><code class="descname">prepare_class</code><span class="sig-paren">(</span><em>name</em>, <em>bases=()</em>, <em>kwds=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-25">计算适当的元类并创建类命名空间。</span></p><p><span class="yiyi-st" id="yiyi-26">参数是构成类定义头的组件：类名，基类（按顺序）和关键字参数（例如<code class="docutils literal"><span class="pre">metaclass</span></code>）。</span></p><p><span class="yiyi-st" id="yiyi-27">返回值是一个三元组：<code class="docutils literal"><span class="pre">元类，</span> <span class="pre">命名空间，</span> <span class="pre">kwds</span></code></span></p><p><span class="yiyi-st" id="yiyi-28"><em>元类</em>是适当的元类，<em>命名空间</em>是准备的类命名空间，<em>kwds</em>是<em>kwds  t3 &gt;任何<code class="docutils literal"><span class="pre">'metaclass'</span></code>条目的参数。</em></span><span class="yiyi-st" id="yiyi-29">如果没有传递<em>kwds</em>参数，这将是一个空的dict。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-30"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-31">也可以看看</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-32"><a class="reference internal" href="../reference/datamodel.html#metaclasses"><span>Customizing class creation</span></a></span></dt><dd><span class="yiyi-st" id="yiyi-33">这些函数支持的类创建过程的完整详细信息</span></dd><dt><span class="yiyi-st" id="yiyi-34"><span class="target" id="index-0"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3115"><strong>PEP 3115</strong></a>  -  Python 3000中的元类</span></dt><dd><span class="yiyi-st" id="yiyi-35">引入了<code class="docutils literal"><span class="pre">__prepare__</span></code>命名空间钩子</span></dd></dl></div></div><div class="section" id="standard-interpreter-types"><h2><span class="yiyi-st" id="yiyi-36">8.9.2.</span><span class="yiyi-st" id="yiyi-37">标准解释器类型</span></h2><p><span class="yiyi-st" id="yiyi-38">此模块提供了实现Python解释器所需的许多类型的名称。</span><span class="yiyi-st" id="yiyi-39">它有意避免包括在处理期间偶然出现的一些类型，例如<code class="docutils literal"><span class="pre">listiterator</span></code>类型。</span></p><p><span class="yiyi-st" id="yiyi-40">这些名称的典型用法是<a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a>或<a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal"><span class="pre">issubclass()</span></code></a>检查。</span></p><p><span class="yiyi-st" id="yiyi-41">标准名称为以下类型定义：</span></p><dl class="data"><dt id="types.FunctionType"><span class="yiyi-st" id="yiyi-42"><code class="descclassname">types.</code><code class="descname">FunctionType</code></span></dt><dt id="types.LambdaType"><span class="yiyi-st" id="yiyi-43"><code class="descclassname">types.</code><code class="descname">LambdaType</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-44">由<a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal"><span class="pre">lambda</span></code></a>表达式创建的用户定义函数和函数的类型。</span></p></dd></dl><dl class="data"><dt id="types.GeneratorType"><span class="yiyi-st" id="yiyi-45"><code class="descclassname">types.</code><code class="descname">GeneratorType</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-46">由生成器函数创建的<a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>  - 类型对象。</span></p></dd></dl><dl class="data"><dt id="types.CoroutineType"><span class="yiyi-st" id="yiyi-47"><code class="descclassname">types.</code><code class="descname">CoroutineType</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-48">由<a class="reference internal" href="../reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">def</span></code></a>函数创建的<a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a>对象的类型。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-49"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="types.CodeType"><span class="yiyi-st" id="yiyi-50"><code class="descclassname">types.</code><code class="descname">CodeType</code></span></dt><dd><p id="index-1"><span class="yiyi-st" id="yiyi-51">由<a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a>返回的代码对象的类型。</span></p></dd></dl><dl class="data"><dt id="types.MethodType"><span class="yiyi-st" id="yiyi-52"><code class="descclassname">types.</code><code class="descname">MethodType</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-53">methodtype</span></p></dd></dl><dl class="data"><dt id="types.BuiltinFunctionType"><span class="yiyi-st" id="yiyi-54"><code class="descclassname">types.</code><code class="descname">BuiltinFunctionType</code></span></dt><dt id="types.BuiltinMethodType"><span class="yiyi-st" id="yiyi-55"><code class="descclassname">types.</code><code class="descname">BuiltinMethodType</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-56">内建函数的类型如<a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a>或<a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal"><span class="pre">sys.exit()</span></code></a>，以及内建类的方法。</span><span class="yiyi-st" id="yiyi-57">（这里，“内建”的意思是“用C写的”。）</span></p></dd></dl><dl class="class"><dt id="types.ModuleType"><span class="yiyi-st" id="yiyi-58"><em class="property">class </em><code class="descclassname">types.</code><code class="descname">ModuleType</code><span class="sig-paren">(</span><em>name</em>, <em>doc=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-59"><a class="reference internal" href="../glossary.html#term-module"><span class="xref std std-term">modules</span></a>。</span><span class="yiyi-st" id="yiyi-60">构造函数采用要创建的模块的名称，并且可选择其<a class="reference internal" href="../glossary.html#term-docstring"><span class="xref std std-term">docstring</span></a>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-61">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-62">如果要设置各种导入控制的属性，请使用<a class="reference internal" href="importlib.html#importlib.util.module_from_spec" title="importlib.util.module_from_spec"><code class="xref py py-func docutils literal"><span class="pre">importlib.util.module_from_spec()</span></code></a>创建一个新模块。</span></p></div><dl class="attribute"><dt id="types.ModuleType.__doc__"><span class="yiyi-st" id="yiyi-63"><code class="descname">__doc__</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-64">模块的<a class="reference internal" href="../glossary.html#term-docstring"><span class="xref std std-term">docstring</span></a>。</span><span class="yiyi-st" id="yiyi-65">默认为<code class="docutils literal"><span class="pre">None</span></code>。</span></p></dd></dl><dl class="attribute"><dt id="types.ModuleType.__loader__"><span class="yiyi-st" id="yiyi-66"><code class="descname">__loader__</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-67">加载模块的<a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>。</span><span class="yiyi-st" id="yiyi-68">默认为<code class="docutils literal"><span class="pre">None</span></code>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-69"><span class="versionmodified">在版本3.4中更改：</span>默认为<code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-70">以前的属性是可选的。</span></p></div></dd></dl><dl class="attribute"><dt id="types.ModuleType.__name__"><span class="yiyi-st" id="yiyi-71"><code class="descname">__name__</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-72">模块的名称。</span></p></dd></dl><dl class="attribute"><dt id="types.ModuleType.__package__"><span class="yiyi-st" id="yiyi-73"><code class="descname">__package__</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-74">模块所属的<a class="reference internal" href="../glossary.html#term-package"><span class="xref std std-term">package</span></a>。</span><span class="yiyi-st" id="yiyi-75">如果模块是顶级（即，</span><span class="yiyi-st" id="yiyi-76">不是任何特定包的一部分），那么该属性应设置为<code class="docutils literal"><span class="pre">''</span></code>，否则应设置为包的名称（如果<a class="reference internal" href="../reference/import.html#__name__" title="__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a>模块是一个包本身）。</span><span class="yiyi-st" id="yiyi-77">默认为<code class="docutils literal"><span class="pre">None</span></code>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-78"><span class="versionmodified">在版本3.4中更改：</span>默认为<code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-79">以前的属性是可选的。</span></p></div></dd></dl></dd></dl><dl class="data"><dt id="types.TracebackType"><span class="yiyi-st" id="yiyi-80"><code class="descclassname">types.</code><code class="descname">TracebackType</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-81">跟踪对象的类型，例如在<code class="docutils literal"><span class="pre">sys.exc_info()[2]</span></code>中找到。</span></p></dd></dl><dl class="data"><dt id="types.FrameType"><span class="yiyi-st" id="yiyi-82"><code class="descclassname">types.</code><code class="descname">FrameType</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-83">如<code class="docutils literal"><span class="pre">tb.tb_frame</span></code>如果<code class="docutils literal"><span class="pre">tb</span></code>中找到的帧对象类型是跟踪对象。</span></p></dd></dl><dl class="data"><dt id="types.GetSetDescriptorType"><span class="yiyi-st" id="yiyi-84"><code class="descclassname">types.</code><code class="descname">GetSetDescriptorType</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-85">在扩展模块中使用<code class="docutils literal"><span class="pre">PyGetSetDef</span></code>定义的对象类型，例如<code class="docutils literal"><span class="pre">FrameType.f_locals</span></code>或<code class="docutils literal"><span class="pre">array.array.typecode</span></code>。</span><span class="yiyi-st" id="yiyi-86">此类型用作对象属性的描述器；它具有与<a class="reference internal" href="functions.html#property" title="property"><code class="xref py py-class docutils literal"><span class="pre">property</span></code></a>类型相同的目的，但是对于在扩展模块中定义的类。</span></p></dd></dl><dl class="data"><dt id="types.MemberDescriptorType"><span class="yiyi-st" id="yiyi-87"><code class="descclassname">types.</code><code class="descname">MemberDescriptorType</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-88">在扩展模块中使用<code class="docutils literal"><span class="pre">PyMemberDef</span></code>定义的对象类型，例如<code class="docutils literal"><span class="pre">datetime.timedelta.days</span></code>。</span><span class="yiyi-st" id="yiyi-89">此类型用作描述器，用于使用标准转换函数的简单C数据成员；它具有与<a class="reference internal" href="functions.html#property" title="property"><code class="xref py py-class docutils literal"><span class="pre">property</span></code></a>类型相同的目的，但是对于在扩展模块中定义的类。</span></p><div class="impl-detail compound"><p><span class="yiyi-st" id="yiyi-90"><strong>CPython实现细节：</strong>在Python的其他实现中，此类型可能与<code class="docutils literal"><span class="pre">GetSetDescriptorType</span></code>相同。</span></p></div></dd></dl><dl class="class"><dt id="types.MappingProxyType"><span class="yiyi-st" id="yiyi-91"> <em class="property">class </em><code class="descclassname">types.</code><code class="descname">MappingProxyType</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-92">只读代理映射。</span><span class="yiyi-st" id="yiyi-93">它提供了对映射条目的动态视图，这意味着当映射更改时，视图反映这些更改。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-94"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><dl class="describe"><dt><span class="yiyi-st" id="yiyi-95"><code class="descname">key in proxy</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-96">如果底层映射具有键<em>键</em>，则返回<code class="docutils literal"><span class="pre">True</span></code>，否则<code class="docutils literal"><span class="pre">False</span></code>。</span></p></dd></dl><dl class="describe"><dt><span class="yiyi-st" id="yiyi-97"><code class="descname">proxy[key]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-98">使用键<em>键</em>返回底层映射的项。</span><span class="yiyi-st" id="yiyi-99">引发<a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a>如果<em>键</em>不在底层映射中。</span></p></dd></dl><dl class="describe"><dt><span class="yiyi-st" id="yiyi-100"><code class="descname">iter(proxy)</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-101">在底层映射的键上返回一个迭代器。</span><span class="yiyi-st" id="yiyi-102">这是<code class="docutils literal"><span class="pre">iter(proxy.keys())</span></code>的快捷方式。</span></p></dd></dl><dl class="describe"><dt><span class="yiyi-st" id="yiyi-103"><code class="descname">len(proxy)</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-104">返回底层映射中的项目数。</span></p></dd></dl><dl class="method"><dt id="types.MappingProxyType.copy"><span class="yiyi-st" id="yiyi-105"><code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-106">返回底层映射的浅层副本。</span></p></dd></dl><dl class="method"><dt id="types.MappingProxyType.get"><span class="yiyi-st" id="yiyi-107"> <code class="descname">get</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-108">如果<em>键</em>在底层映射中，则返回<em>键</em>的值，否则<em>默认</em>。</span><span class="yiyi-st" id="yiyi-109">如果未指定<em>默认</em>，则默认为<code class="docutils literal"><span class="pre">None</span></code>，因此此方法从不引用<a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="types.MappingProxyType.items"><span class="yiyi-st" id="yiyi-110"><code class="descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-111">返回底层映射项目的新视图（<code class="docutils literal"><span class="pre">（键，</span> <span class="pre">值）</span></code>对）。</span></p></dd></dl><dl class="method"><dt id="types.MappingProxyType.keys"><span class="yiyi-st" id="yiyi-112"><code class="descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-113">返回底层映射键的新视图。</span></p></dd></dl><dl class="method"><dt id="types.MappingProxyType.values"><span class="yiyi-st" id="yiyi-114"><code class="descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-115">返回底层映射值的新视图。</span></p></dd></dl></dd></dl></div><div class="section" id="additional-utility-classes-and-functions"><h2><span class="yiyi-st" id="yiyi-116">8.9.3.</span><span class="yiyi-st" id="yiyi-117">附加实用程序类和函数</span></h2><dl class="class"><dt id="types.SimpleNamespace"><span class="yiyi-st" id="yiyi-118"><em class="property">class </em><code class="descclassname">types.</code><code class="descname">SimpleNamespace</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-119">一个简单的<a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a>子类，提供对其命名空间的属性访问，以及一个有意义的repr。</span></p><p><span class="yiyi-st" id="yiyi-120">与<a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a>不同，使用<code class="docutils literal"><span class="pre">SimpleNamespace</span></code>可以添加和删除属性。</span><span class="yiyi-st" id="yiyi-121">如果使用关键字参数初始化一个<code class="docutils literal"><span class="pre">SimpleNamespace</span></code>对象，那么它们将直接添加到底层命名空间。</span></p><p><span class="yiyi-st" id="yiyi-122">类型大致相当于以下代码：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SimpleNamespace</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
        <span class="n">items</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2">=</span><span class="si">{!r}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">"</span><span class="si">{}</span><span class="s2">(</span><span class="si">{}</span><span class="s2">)"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="s2">", "</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">items</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__dict__</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-123"><code class="docutils literal"><span class="pre">SimpleNamespace</span></code>可能有助于替代<code class="docutils literal"><span class="pre">类</span> <span class="pre">NS：</span> <span class="pre">pass</span></code>。</span><span class="yiyi-st" id="yiyi-124">但是，对于结构化记录类型，请改用<a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal"><span class="pre">namedtuple()</span></code></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-125"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="types.DynamicClassAttribute"><span class="yiyi-st" id="yiyi-126"><code class="descclassname">types.</code><code class="descname">DynamicClassAttribute</code><span class="sig-paren">(</span><em>fget=None</em>, <em>fset=None</em>, <em>fdel=None</em>, <em>doc=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-127">将类的路由属性访问权限授予__getattr__。</span></p><p><span class="yiyi-st" id="yiyi-128">这是一个描述器，用于定义通过实例和类访问时不同行为的属性。</span><span class="yiyi-st" id="yiyi-129">实例访问保持正常，但通过类访问属性将被路由到类的__getattr__方法；这是通过提高AttributeError来完成的。</span></p><p><span class="yiyi-st" id="yiyi-130">这允许在实例上具有活动的属性，并且在类上具有相同名称的虚拟属性（参见示例的枚举）。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-131"><span class="versionmodified">版本3.4中的新功能。</span></span></p></div></dd></dl></div><div class="section" id="coroutine-utility-functions"><h2><span class="yiyi-st" id="yiyi-132">8.9.4.</span><span class="yiyi-st" id="yiyi-133">协程效用函数</span></h2><dl class="function"><dt id="types.coroutine"><span class="yiyi-st" id="yiyi-134"><code class="descclassname">types.</code><code class="descname">coroutine</code><span class="sig-paren">(</span><em>gen_func</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-135">此函数将<a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>函数转换为<a class="reference internal" href="../glossary.html#term-coroutine-function"><span class="xref std std-term">coroutine function</span></a>，返回基于生成器的协程。</span><span class="yiyi-st" id="yiyi-136">基于生成器的协程仍然是<a class="reference internal" href="../glossary.html#term-generator-iterator"><span class="xref std std-term">generator iterator</span></a>，但也被认为是<a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a>对象并且<a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a>。</span><span class="yiyi-st" id="yiyi-137">但是，它可能不一定实现<a class="reference internal" href="../reference/datamodel.html#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal"><span class="pre">__await__()</span></code></a>方法。</span></p><p><span class="yiyi-st" id="yiyi-138">如果<em>gen_func</em>是生成器函数，它将被原地修改。</span></p><p><span class="yiyi-st" id="yiyi-139">如果<em>gen_func</em>不是生成器函数，它将被包装。</span><span class="yiyi-st" id="yiyi-140">如果它返回一个实例<a class="reference internal" href="collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Generator</span></code></a>，实例将被包装在一个<em>等待</em>代理对象中。</span><span class="yiyi-st" id="yiyi-141">所有其他类型的对象将按原样返回。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-142"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl></div></div></div>