<div class="body" role="main"><div class="section" id="module-urllib.parse"><h1><span class="yiyi-st" id="yiyi-10">21.8. <a class="reference internal" href="#module-urllib.parse" title="urllib.parse: Parse URLs into or assemble them from components."><code class="xref py py-mod docutils literal"><span class="pre">urllib.parse</span></code></a> — 分解URL</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong><a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/urllib/parse.py">Lib/urllib/parse.py</a></span></p><p><span class="yiyi-st" id="yiyi-12">该模块定义了一个标准接口，用于分解统一资源定位符（URL）字符串为各个组成部分（寻址方案、网络位置、路径等</span><span class="yiyi-st" id="yiyi-13">），以及将各个组成部分组合回URL字符串，并将“相对URL”转换为给定“基本URL”的绝对URL。</span></p><p><span class="yiyi-st" id="yiyi-14">该模块的设计符合相对统一资源定位符的因特网RFC。</span><span class="yiyi-st" id="yiyi-15">它支持以下网址格式: <code class="docutils literal"><span class="pre">file</span></code>, <code class="docutils literal"><span class="pre">ftp</span></code>, <code class="docutils literal"><span class="pre">gopher</span></code>, <code class="docutils literal"><span class="pre">hdl</span></code>, <code class="docutils literal"><span class="pre">http</span></code>, <code class="docutils literal"><span class="pre">https</span></code>, <code class="docutils literal"><span class="pre">imap</span></code>, <code class="docutils literal"><span class="pre">mailto</span></code>, <code class="docutils literal"><span class="pre">mms</span></code>, <code class="docutils literal"><span class="pre">news</span></code>, <code class="docutils literal"><span class="pre">nntp</span></code>, <code class="docutils literal"><span class="pre">prospero</span></code>, <code class="docutils literal"><span class="pre">rsync</span></code>, <code class="docutils literal"><span class="pre">rtsp</span></code>, <code class="docutils literal"><span class="pre">rtspu</span></code>, <code class="docutils literal"><span class="pre">sftp</span></code>, <code class="docutils literal"><span class="pre">shttp</span></code>, <code class="docutils literal"><span class="pre">sip</span></code>, <code class="docutils literal"><span class="pre">sips</span></code>, <code class="docutils literal"><span class="pre">snews</span></code>, <code class="docutils literal"><span class="pre">svn</span></code>, <code class="docutils literal"><span class="pre">svn+ssh</span></code>, <code class="docutils literal"><span class="pre">telnet</span></code>, <code class="docutils literal"><span class="pre">wais</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-16"><a class="reference internal" href="#module-urllib.parse" title="urllib.parse: Parse URLs into or assemble them from components."><code class="xref py py-mod docutils literal"><span class="pre">urllib.parse</span></code></a>模块定义的函数分为两大类：URL解析和URL转义。</span><span class="yiyi-st" id="yiyi-17">它们将在以下章节详细阐述。</span></p><div class="section" id="url-parsing"><h2><span class="yiyi-st" id="yiyi-18">21.8.1. </span><span class="yiyi-st" id="yiyi-19">URL解析</span></h2><p><span class="yiyi-st" id="yiyi-20">URL解析函数专注于将URL字符串拆分为各个部分，或者将URL各个部分组合到一个URL字符串中。</span></p><dl class="function"><dt id="urllib.parse.urlparse"><span class="yiyi-st" id="yiyi-21"> <code class="descclassname">urllib.parse.</code><code class="descname">urlparse</code><span class="sig-paren">(</span><em>urlstring</em>, <em>scheme=''</em>, <em>allow_fragments=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-22">将URL解析为六个部分，返回一个6元组。</span><span class="yiyi-st" id="yiyi-23">这对应于URL的一般结构：<code class="docutils literal"><span class="pre">scheme://netloc/path;parameters?query#fragment</span></code>。</span><span class="yiyi-st" id="yiyi-24">每个元组项都是一个字符串，可能为空。</span><span class="yiyi-st" id="yiyi-25">各个组成部分不会再分解为更小的部分（例如，网络位置是单个字符串），并且不扩展％转义。</span><span class="yiyi-st" id="yiyi-26">上面所示的分隔符不会成为结果的一部分，除了<em>path</em>组件中的前导斜杠，如果它存在则保留。</span><span class="yiyi-st" id="yiyi-27">例如：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="k">import</span> <span class="n">urlparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="s1">'http://www.cwi.nl:80/</span><span class="si">%7E</span><span class="s1">guido/Python.html'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span>   
<span class="go">ParseResult(scheme='http', netloc='www.cwi.nl:80', path='/%7Eguido/Python.html',</span>
<span class="go">            params='', query='', fragment='')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">scheme</span>
<span class="go">'http'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">port</span>
<span class="go">80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">geturl</span><span class="p">()</span>
<span class="go">'http://www.cwi.nl:80/%7Eguido/Python.html'</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-28">遵循<span class="target" id="index-1"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc1808.html"><strong>RFC 1808</strong></a>中的语法规范，urlparse仅在由“//”正确引入时识别netloc。</span><span class="yiyi-st" id="yiyi-29">否则，输入被假定为相对URL，并且因此以路径分量开始。</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="k">import</span> <span class="n">urlparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlparse</span><span class="p">(</span><span class="s1">'//www.cwi.nl:80/</span><span class="si">%7E</span><span class="s1">guido/Python.html'</span><span class="p">)</span>
<span class="go">ParseResult(scheme='', netloc='www.cwi.nl:80', path='/%7Eguido/Python.html',</span>
<span class="go">           params='', query='', fragment='')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlparse</span><span class="p">(</span><span class="s1">'www.cwi.nl/</span><span class="si">%7E</span><span class="s1">guido/Python.html'</span><span class="p">)</span>
<span class="go">ParseResult(scheme='', netloc='', path='www.cwi.nl/%7Eguido/Python.html',</span>
<span class="go">           params='', query='', fragment='')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlparse</span><span class="p">(</span><span class="s1">'help/Python.html'</span><span class="p">)</span>
<span class="go">ParseResult(scheme='', netloc='', path='help/Python.html', params='',</span>
<span class="go">           query='', fragment='')</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-30"><em>scheme </em>参数提供默认寻址方案，仅当URL不指定时使用。</span><span class="yiyi-st" id="yiyi-31">它应该是与<em>urlstring</em>相同的类型（文本或字节），除了始终允许默认值<code class="docutils literal"><span class="pre">''</span></code>，并自动转换为<code class="docutils literal"><span class="pre">b''</span></code>（如果适用）。</span></p><p><span class="yiyi-st" id="yiyi-32">如果<em>allow_fragments</em>参数为false，则无法识别片段标识符。</span><span class="yiyi-st" id="yiyi-33">而是将它们作为路径，参数或查询组件的一部分进行解析，并将<code class="xref py py-attr docutils literal"><span class="pre">fragment</span></code>设置为返回值中的空字符串。</span></p><p><span class="yiyi-st" id="yiyi-34">返回值实际上是<a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>的子类的实例。</span><span class="yiyi-st" id="yiyi-35">此类具有以下额外的只读方便属性：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-36">属性</span></th><th class="head"><span class="yiyi-st" id="yiyi-37">指数</span></th><th class="head"><span class="yiyi-st" id="yiyi-38">值</span></th><th class="head"><span class="yiyi-st" id="yiyi-39">值（如果不存在）</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-40"><code class="xref py py-attr docutils literal"><span class="pre">scheme</span></code></span></td><td><span class="yiyi-st" id="yiyi-41">0</span></td><td><span class="yiyi-st" id="yiyi-42">URL方案说明符</span></td><td><span class="yiyi-st" id="yiyi-43"><em>scheme</em>参数</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-44"><code class="xref py py-attr docutils literal"><span class="pre">netloc</span></code></span></td><td><span class="yiyi-st" id="yiyi-45">1</span></td><td><span class="yiyi-st" id="yiyi-46">网络位置部分</span></td><td><span class="yiyi-st" id="yiyi-47">空字符串</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-48"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></span></td><td><span class="yiyi-st" id="yiyi-49">2</span></td><td><span class="yiyi-st" id="yiyi-50">分层路径</span></td><td><span class="yiyi-st" id="yiyi-51">空字符串</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-52"><code class="xref py py-attr docutils literal"><span class="pre">params</span></code></span></td><td><span class="yiyi-st" id="yiyi-53">3</span></td><td><span class="yiyi-st" id="yiyi-54">最后路径元素的参数</span></td><td><span class="yiyi-st" id="yiyi-55">空字符串</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-56"><code class="xref py py-attr docutils literal"><span class="pre">query</span></code></span></td><td><span class="yiyi-st" id="yiyi-57">4</span></td><td><span class="yiyi-st" id="yiyi-58">查询组件</span></td><td><span class="yiyi-st" id="yiyi-59">空字符串</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-60"><code class="xref py py-attr docutils literal"><span class="pre">fragment</span></code></span></td><td><span class="yiyi-st" id="yiyi-61">5</span></td><td><span class="yiyi-st" id="yiyi-62">片段标识符</span></td><td><span class="yiyi-st" id="yiyi-63">空字符串</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-64"><code class="xref py py-attr docutils literal"><span class="pre">username</span></code></span></td><td></td><td><span class="yiyi-st" id="yiyi-65">用户名</span></td><td><span class="yiyi-st" id="yiyi-66"><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-67"><code class="xref py py-attr docutils literal"><span class="pre">password</span></code></span></td><td></td><td><span class="yiyi-st" id="yiyi-68">密码</span></td><td><span class="yiyi-st" id="yiyi-69"><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-70"><code class="xref py py-attr docutils literal"><span class="pre">hostname</span></code></span></td><td></td><td><span class="yiyi-st" id="yiyi-71">主机名（小写）</span></td><td><span class="yiyi-st" id="yiyi-72"><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-73"><code class="xref py py-attr docutils literal"><span class="pre">port</span></code></span></td><td></td><td><span class="yiyi-st" id="yiyi-74">端口号为整数（如果存在）</span></td><td><span class="yiyi-st" id="yiyi-75"><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a></span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-76">有关结果对象的更多信息，请参见<a class="reference internal" href="#urlparse-result-object"><span> Structured Parse Results</span></a>一节。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-77"><span class="versionmodified">在版本3.2中已更改：</span>添加了IPv6 URL解析功能。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-78"><span class="versionmodified">Changed in version 3.3: </span>The fragment is now parsed for all URL schemes (unless <em>allow_fragment</em> is false), in accordance with <span class="target" id="index-2"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3986.html"><strong>RFC 3986</strong></a>. </span><span class="yiyi-st" id="yiyi-79">以前，支持片段的方案的白名单存在。</span></p></div></dd></dl><dl class="function"><dt id="urllib.parse.parse_qs"><span class="yiyi-st" id="yiyi-80"> <code class="descclassname">urllib.parse.</code><code class="descname">parse_qs</code><span class="sig-paren">(</span><em>qs</em>, <em>keep_blank_values=False</em>, <em>strict_parsing=False</em>, <em>encoding='utf-8'</em>, <em>errors='replace'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-81">解析作为字符串参数（<em class="mimetype">application / x-www-form-urlencoded</em>类型的数据）提供的查询字符串。</span><span class="yiyi-st" id="yiyi-82">数据作为字典返回。</span><span class="yiyi-st" id="yiyi-83">字典键是唯一的查询变量名，值是每个名称的值列表。</span></p><p><span class="yiyi-st" id="yiyi-84">可选参数<em>keep_blank_values</em>是指示百分比编码查询中的空白值是否应被视为空白字符串的标志。</span><span class="yiyi-st" id="yiyi-85">true值表示空白应保留为空白字符串。</span><span class="yiyi-st" id="yiyi-86">默认的false值表示将空值忽略并视为未包括空值。</span></p><p><span class="yiyi-st" id="yiyi-87">可选参数<em>strict_parsing</em>是指示如何处理解析错误的标志。</span><span class="yiyi-st" id="yiyi-88">如果为false（默认值），则错误将被忽略。</span><span class="yiyi-st" id="yiyi-89">如果为true，则错误引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>异常。</span></p><p><span class="yiyi-st" id="yiyi-90">可选的<em>编码</em>和<em>错误</em>参数指定如何将百分比编码序列解码为Unicode字符，如<a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal"><span class="pre">bytes.decode()</span></code></a>方法所接受。</span></p><p><span class="yiyi-st" id="yiyi-91">使用<a class="reference internal" href="#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal"><span class="pre">urllib.parse.urlencode()</span></code></a>函数（将<code class="docutils literal"><span class="pre">doseq</span></code>参数设置为<code class="docutils literal"><span class="pre">True</span></code>）将这些字典转换为查询字符串。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-92"><span class="versionmodified">在版本3.2中更改：</span>添加<em>编码</em>和<em>错误</em>参数。</span></p></div></dd></dl><dl class="function"><dt id="urllib.parse.parse_qsl"><span class="yiyi-st" id="yiyi-93"> <code class="descclassname">urllib.parse.</code><code class="descname">parse_qsl</code><span class="sig-paren">(</span><em>qs</em>, <em>keep_blank_values=False</em>, <em>strict_parsing=False</em>, <em>encoding='utf-8'</em>, <em>errors='replace'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-94">解析作为字符串参数（<em class="mimetype">application / x-www-form-urlencoded</em>类型的数据）提供的查询字符串。</span><span class="yiyi-st" id="yiyi-95">数据作为名称，值对的列表返回。</span></p><p><span class="yiyi-st" id="yiyi-96">The optional argument <em>keep_blank_values</em> is a flag indicating whether blank values in percent-encoded queries should be treated as blank strings. </span><span class="yiyi-st" id="yiyi-97">true值表示空白应保留为空白字符串。</span><span class="yiyi-st" id="yiyi-98">默认的false值表示将空值忽略并视为未包括空值。</span></p><p><span class="yiyi-st" id="yiyi-99">可选参数<em>strict_parsing</em>是指示如何处理解析错误的标志。</span><span class="yiyi-st" id="yiyi-100">如果为false（默认值），则错误将被忽略。</span><span class="yiyi-st" id="yiyi-101">如果为true，则错误引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>异常。</span></p><p><span class="yiyi-st" id="yiyi-102">可选的<em>编码</em>和<em>错误</em>参数指定如何将百分比编码序列解码为Unicode字符，如<a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal"><span class="pre">bytes.decode()</span></code></a>方法所接受。</span></p><p><span class="yiyi-st" id="yiyi-103">使用<a class="reference internal" href="#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal"><span class="pre">urllib.parse.urlencode()</span></code></a>函数将这些对列表转换为查询字符串。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-104"><span class="versionmodified">在版本3.2中更改：</span>添加<em>编码</em>和<em>错误</em>参数。</span></p></div></dd></dl><dl class="function"><dt id="urllib.parse.urlunparse"><span class="yiyi-st" id="yiyi-105"> <code class="descclassname">urllib.parse.</code><code class="descname">urlunparse</code><span class="sig-paren">(</span><em>parts</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-106">从<code class="docutils literal"><span class="pre">urlparse()</span></code>返回的元组构造一个URL。</span><span class="yiyi-st" id="yiyi-107"><em>部分</em>参数可以是任何六项可迭代。</span><span class="yiyi-st" id="yiyi-108">如果最初解析的URL具有不必要的分隔符（例如，<code class="docutils literal"><span class="pre">?</span></code>），则这可能会导致稍有不同，</span><span class="yiyi-st" id="yiyi-109">用空查询； RFC声明这些是等效的）。</span></p></dd></dl><dl class="function"><dt id="urllib.parse.urlsplit"><span class="yiyi-st" id="yiyi-110"> <code class="descclassname">urllib.parse.</code><code class="descname">urlsplit</code><span class="sig-paren">(</span><em>urlstring</em>, <em>scheme=''</em>, <em>allow_fragments=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-111">这类似于<a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal"><span class="pre">urlparse()</span></code></a>，但不会从URL中分离参数。</span><span class="yiyi-st" id="yiyi-112">如果最近的URL语法允许将参数应用于URL的<em>路径</em>部分的每个段（参见<span class="target" id="index-3">），则通常应使用<a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal"><span class="pre">urlparse()</span></code></a> </span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2396.html"><strong>RFC 2396</strong></a>）。</span><span class="yiyi-st" id="yiyi-113">需要单独的功能来分离路径段和参数。</span><span class="yiyi-st" id="yiyi-114">此函数返回一个5元组：（寻址方案，网络位置，路径，查询，片段标识符）。</span></p><p><span class="yiyi-st" id="yiyi-115">返回值实际上是<a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>的子类的实例。</span><span class="yiyi-st" id="yiyi-116">此类具有以下额外的只读方便属性：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-117">属性</span></th><th class="head"><span class="yiyi-st" id="yiyi-118">指数</span></th><th class="head"><span class="yiyi-st" id="yiyi-119">值</span></th><th class="head"><span class="yiyi-st" id="yiyi-120">值（如果不存在）</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-121"><code class="xref py py-attr docutils literal"><span class="pre">scheme</span></code></span></td><td><span class="yiyi-st" id="yiyi-122">0</span></td><td><span class="yiyi-st" id="yiyi-123">URL方案说明符</span></td><td><span class="yiyi-st" id="yiyi-124"><em>方案</em>参数</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-125"><code class="xref py py-attr docutils literal"><span class="pre">netloc</span></code></span></td><td><span class="yiyi-st" id="yiyi-126">1</span></td><td><span class="yiyi-st" id="yiyi-127">网络位置部分</span></td><td><span class="yiyi-st" id="yiyi-128">空字符串</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-129"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></span></td><td><span class="yiyi-st" id="yiyi-130">2</span></td><td><span class="yiyi-st" id="yiyi-131">分层路径</span></td><td><span class="yiyi-st" id="yiyi-132">空字符串</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-133"><code class="xref py py-attr docutils literal"><span class="pre">query</span></code></span></td><td><span class="yiyi-st" id="yiyi-134">3</span></td><td><span class="yiyi-st" id="yiyi-135">查询组件</span></td><td><span class="yiyi-st" id="yiyi-136">空字符串</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-137"><code class="xref py py-attr docutils literal"><span class="pre">fragment</span></code></span></td><td><span class="yiyi-st" id="yiyi-138">4</span></td><td><span class="yiyi-st" id="yiyi-139">片段标识符</span></td><td><span class="yiyi-st" id="yiyi-140">空字符串</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-141"><code class="xref py py-attr docutils literal"><span class="pre">username</span></code></span></td><td></td><td><span class="yiyi-st" id="yiyi-142">用户名</span></td><td><span class="yiyi-st" id="yiyi-143"><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-144"><code class="xref py py-attr docutils literal"><span class="pre">password</span></code></span></td><td></td><td><span class="yiyi-st" id="yiyi-145">密码</span></td><td><span class="yiyi-st" id="yiyi-146"><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-147"><code class="xref py py-attr docutils literal"><span class="pre">hostname</span></code></span></td><td></td><td><span class="yiyi-st" id="yiyi-148">主机名（小写）</span></td><td><span class="yiyi-st" id="yiyi-149"><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-150"><code class="xref py py-attr docutils literal"><span class="pre">port</span></code></span></td><td></td><td><span class="yiyi-st" id="yiyi-151">端口号为整数（如果存在）</span></td><td><span class="yiyi-st" id="yiyi-152"><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a></span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-153">有关结果对象的更多信息，请参见<a class="reference internal" href="#urlparse-result-object"><span>Structured Parse Results</span></a>一节。</span></p></dd></dl><dl class="function"><dt id="urllib.parse.urlunsplit"><span class="yiyi-st" id="yiyi-154"> <code class="descclassname">urllib.parse.</code><code class="descname">urlunsplit</code><span class="sig-paren">(</span><em>parts</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-155">将<a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal"><span class="pre">urlsplit()</span></code></a>返回的元组元素合并为一个完整的URL作为字符串。</span><span class="yiyi-st" id="yiyi-156"><em>部分</em>参数可以是任何五项可迭代。</span><span class="yiyi-st" id="yiyi-157">这可能会导致稍有不同，但等效的URL，如果解析的URL原来有不必要的分隔符（例如，</span><span class="yiyi-st" id="yiyi-158">用空查询； RFC声明这些是等效的）。</span></p></dd></dl><dl class="function"><dt id="urllib.parse.urljoin"><span class="yiyi-st" id="yiyi-159"> <code class="descclassname">urllib.parse.</code><code class="descname">urljoin</code><span class="sig-paren">(</span><em>base</em>, <em>url</em>, <em>allow_fragments=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-160">通过将“基本网址”（<em>基本</em>）与另一个网址（<em>url</em>）组合，构造完整（“绝对”）网址。</span><span class="yiyi-st" id="yiyi-161">非正式地，这使用基本URL的组件，特别是寻址方案，网络位置和（部分）路径，以在相对URL中提供缺失的组件。</span><span class="yiyi-st" id="yiyi-162">例如：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="k">import</span> <span class="n">urljoin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urljoin</span><span class="p">(</span><span class="s1">'http://www.cwi.nl/</span><span class="si">%7E</span><span class="s1">guido/Python.html'</span><span class="p">,</span> <span class="s1">'FAQ.html'</span><span class="p">)</span>
<span class="go">'http://www.cwi.nl/%7Eguido/FAQ.html'</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-163"><em>allow_fragments</em>参数与<a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal"><span class="pre">urlparse()</span></code></a>具有相同的含义和默认值。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-164">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-165">如果<em>url</em>是绝对网址（即以<code class="docutils literal"><span class="pre">//</span></code>或<code class="docutils literal"><span class="pre">scheme://</span></code>开头），则<em>url  t5 &gt;的主机名和/或方案将出现在结果中。</em></span><span class="yiyi-st" id="yiyi-166">例如：</span></p></div><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">urljoin</span><span class="p">(</span><span class="s1">'http://www.cwi.nl/</span><span class="si">%7E</span><span class="s1">guido/Python.html'</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s1">'//www.python.org/</span><span class="si">%7E</span><span class="s1">guido'</span><span class="p">)</span>
<span class="go">'http://www.python.org/%7Eguido'</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-167">如果您不想要该行为，请使用<a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal"><span class="pre">urlsplit()</span></code></a>和<a class="reference internal" href="#urllib.parse.urlunsplit" title="urllib.parse.urlunsplit"><code class="xref py py-func docutils literal"><span class="pre">urlunsplit()</span></code></a>预处理<em>url</em>，删除可能的<em>方案 t7 &gt;和<em>netloc</em>部分。</em></span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-168"><span class="versionmodified">在版本3.5中已更改：</span>已更新以符合<span class="target" id="index-4"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc3986.html"><strong>RFC 3986</strong></a>中定义的语义的行为。</span></p></div></dd></dl><dl class="function"><dt id="urllib.parse.urldefrag"><span class="yiyi-st" id="yiyi-169"> <code class="descclassname">urllib.parse.</code><code class="descname">urldefrag</code><span class="sig-paren">(</span><em>url</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-170">如果<em>url</em>包含片段标识符，则返回没有片段标识符的<em>url</em>的修改版本，片段标识符作为单独的字符串。</span><span class="yiyi-st" id="yiyi-171">如果<em>url</em>中没有片段标识符，则返回未修改的<em>url</em>和空字符串。</span></p><p><span class="yiyi-st" id="yiyi-172">返回值实际上是<a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>的子类的实例。</span><span class="yiyi-st" id="yiyi-173">此类具有以下额外的只读方便属性：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-174">属性</span></th><th class="head"><span class="yiyi-st" id="yiyi-175">指数</span></th><th class="head"><span class="yiyi-st" id="yiyi-176">值</span></th><th class="head"><span class="yiyi-st" id="yiyi-177">值（如果不存在）</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-178"><code class="xref py py-attr docutils literal"><span class="pre">url</span></code></span></td><td><span class="yiyi-st" id="yiyi-179">0</span></td><td><span class="yiyi-st" id="yiyi-180">没有片段的网址</span></td><td><span class="yiyi-st" id="yiyi-181">空字符串</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-182"><code class="xref py py-attr docutils literal"><span class="pre">fragment</span></code></span></td><td><span class="yiyi-st" id="yiyi-183">1</span></td><td><span class="yiyi-st" id="yiyi-184">片段标识符</span></td><td><span class="yiyi-st" id="yiyi-185">空字符串</span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-186">有关结果对象的更多信息，请参见<a class="reference internal" href="#urlparse-result-object"><span>Structured Parse Results</span></a>一节。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-187"><span class="versionmodified">在版本3.2中更改：</span>结果是一个结构化对象，而不是一个简单的2元组。</span></p></div></dd></dl></div><div class="section" id="parsing-ascii-encoded-bytes"><h2><span class="yiyi-st" id="yiyi-188">21.8.2. </span><span class="yiyi-st" id="yiyi-189">解析ASCII编码字节</span></h2><p><span class="yiyi-st" id="yiyi-190">URL解析函数最初设计为仅对字符串进行操作。</span><span class="yiyi-st" id="yiyi-191">在实践中，能够将正确引用和编码的URL作为ASCII字节序列进行操作是有用的。</span><span class="yiyi-st" id="yiyi-192">因此，除了<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>对象，此模块中的URL解析函数都对<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>和<a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a></span></p><p><span class="yiyi-st" id="yiyi-193">如果传递<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>数据，结果也将只包含<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>数据。</span><span class="yiyi-st" id="yiyi-194">如果传入<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>或<a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>数据，则结果将只包含<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>数据。</span></p><p><span class="yiyi-st" id="yiyi-195">尝试在单个函数调用中将<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>数据与<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>或<a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>混合会导致产生<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>而尝试传入非ASCII字节值将触发<a class="reference internal" href="exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeDecodeError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-196">为了支持在<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>和<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>之间更容易转换结果对象，来自URL解析函数的所有返回值都提供了一个<code class="xref py py-meth docutils literal"><span class="pre">encode()</span></code>结果包含<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>数据）或<code class="xref py py-meth docutils literal"><span class="pre">decode()</span></code>方法（当结果包含<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>数据时）。</span><span class="yiyi-st" id="yiyi-197">The signatures of these methods match those of the corresponding <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> and <a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> methods (except that the default encoding is <code class="docutils literal"><span class="pre">'ascii'</span></code> rather than <code class="docutils literal"><span class="pre">'utf-8'</span></code>). </span><span class="yiyi-st" id="yiyi-198">每个产生包含<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>数据（用于<code class="xref py py-meth docutils literal"><span class="pre">encode()</span></code>方法）或<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>数据（用于<code class="xref py py-meth docutils literal"><span class="pre">decode()</span></code>方法）。</span></p><p><span class="yiyi-st" id="yiyi-199">需要在可能包含非ASCII数据的可能不正确引用的URL上操作的应用程序需要在调用URL解析方法之前，从字节到字符进行自己的解码。</span></p><p><span class="yiyi-st" id="yiyi-200">此部分中描述的行为仅适用于URL解析函数。</span><span class="yiyi-st" id="yiyi-201">在生成或使用字节序列时，URL引用函数使用自己的规则，如各个URL引用函数的文档中所述。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-202"><span class="versionmodified">在版本3.2中更改：</span> URL解析函数现在接受ASCII编码的字节序列</span></p></div></div><div class="section" id="structured-parse-results"><h2><span class="yiyi-st" id="yiyi-203">21.8.3. </span><span class="yiyi-st" id="yiyi-204">结构化解析结果</span></h2><p><span class="yiyi-st" id="yiyi-205">来自<a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal"><span class="pre">urlparse()</span></code></a>，<a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal"><span class="pre">urlsplit()</span></code></a>和<a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal"><span class="pre">urldefrag()</span></code></a>函数的结果对象是<a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>类型。</span><span class="yiyi-st" id="yiyi-206">这些子类添加了文档中列出的那些功能的属性，上一节中描述的编码和解码支持以及一个附加方法：</span></p><dl class="method"><dt id="urllib.parse.urllib.parse.SplitResult.geturl"><span class="yiyi-st" id="yiyi-207"> <code class="descclassname">urllib.parse.SplitResult.</code><code class="descname">geturl</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-208">以字符串形式返回原始URL的重新组合版本。</span><span class="yiyi-st" id="yiyi-209">这可能不同于原始URL，因为方案可以归一化为小写，并且可以丢弃空组件。</span><span class="yiyi-st" id="yiyi-210">具体来说，将删除空参数，查询和片段标识符。</span></p><p><span class="yiyi-st" id="yiyi-211">对于<a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal"><span class="pre">urldefrag()</span></code></a>结果，仅删除空片段标识符。</span><span class="yiyi-st" id="yiyi-212">对于<a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal"><span class="pre">urlsplit()</span></code></a>和<a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal"><span class="pre">urlparse()</span></code></a>结果，将对由此方法返回的URL进行所有标注的更改。</span></p><p><span class="yiyi-st" id="yiyi-213">如果通过原始解析函数传回，此方法的结果保持不变：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="k">import</span> <span class="n">urlsplit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s1">'HTTP://www.Python.org/doc/#'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span> <span class="o">=</span> <span class="n">urlsplit</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span><span class="o">.</span><span class="n">geturl</span><span class="p">()</span>
<span class="go">'http://www.Python.org/doc/'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span> <span class="o">=</span> <span class="n">urlsplit</span><span class="p">(</span><span class="n">r1</span><span class="o">.</span><span class="n">geturl</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span><span class="o">.</span><span class="n">geturl</span><span class="p">()</span>
<span class="go">'http://www.Python.org/doc/'</span>
</pre></div></div></dd></dl><p><span class="yiyi-st" id="yiyi-214">当在<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>对象上操作时，以下类提供了结构化解析结果的实现：</span></p><dl class="class"><dt id="urllib.parse.DefragResult"><span class="yiyi-st" id="yiyi-215"> <em class="property">class </em><code class="descclassname">urllib.parse.</code><code class="descname">DefragResult</code><span class="sig-paren">(</span><em>url</em>, <em>fragment</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-216">包含<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>数据的<a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal"><span class="pre">urldefrag()</span></code></a>结果的具体类。</span><span class="yiyi-st" id="yiyi-217"><code class="xref py py-meth docutils literal"><span class="pre">encode()</span></code>方法返回一个<a class="reference internal" href="#urllib.parse.DefragResultBytes" title="urllib.parse.DefragResultBytes"><code class="xref py py-class docutils literal"><span class="pre">DefragResultBytes</span></code></a>实例。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-218"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="class"><dt id="urllib.parse.ParseResult"><span class="yiyi-st" id="yiyi-219"> <em class="property">class </em><code class="descclassname">urllib.parse.</code><code class="descname">ParseResult</code><span class="sig-paren">(</span><em>scheme</em>, <em>netloc</em>, <em>path</em>, <em>params</em>, <em>query</em>, <em>fragment</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-220">包含<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>数据的<a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal"><span class="pre">urlparse()</span></code></a>结果的具体类。</span><span class="yiyi-st" id="yiyi-221"><code class="xref py py-meth docutils literal"><span class="pre">encode()</span></code>方法返回一个<a class="reference internal" href="#urllib.parse.ParseResultBytes" title="urllib.parse.ParseResultBytes"><code class="xref py py-class docutils literal"><span class="pre">ParseResultBytes</span></code></a>实例。</span></p></dd></dl><dl class="class"><dt id="urllib.parse.SplitResult"><span class="yiyi-st" id="yiyi-222"> <em class="property">class </em><code class="descclassname">urllib.parse.</code><code class="descname">SplitResult</code><span class="sig-paren">(</span><em>scheme</em>, <em>netloc</em>, <em>path</em>, <em>query</em>, <em>fragment</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-223">包含<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>数据的<a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal"><span class="pre">urlsplit()</span></code></a>结果的具体类。</span><span class="yiyi-st" id="yiyi-224"><code class="xref py py-meth docutils literal"><span class="pre">encode()</span></code>方法返回一个<a class="reference internal" href="#urllib.parse.SplitResultBytes" title="urllib.parse.SplitResultBytes"><code class="xref py py-class docutils literal"><span class="pre">SplitResultBytes</span></code></a>实例。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-225">以下类提供在<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>或<a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>对象上操作时解析结果的实现：</span></p><dl class="class"><dt id="urllib.parse.DefragResultBytes"><span class="yiyi-st" id="yiyi-226"> <em class="property">class </em><code class="descclassname">urllib.parse.</code><code class="descname">DefragResultBytes</code><span class="sig-paren">(</span><em>url</em>, <em>fragment</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-227">包含<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>数据的<a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal"><span class="pre">urldefrag()</span></code></a>结果的具体类。</span><span class="yiyi-st" id="yiyi-228"><code class="xref py py-meth docutils literal"><span class="pre">decode()</span></code>方法返回一个<a class="reference internal" href="#urllib.parse.DefragResult" title="urllib.parse.DefragResult"><code class="xref py py-class docutils literal"><span class="pre">DefragResult</span></code></a>实例。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-229"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="class"><dt id="urllib.parse.ParseResultBytes"><span class="yiyi-st" id="yiyi-230"> <em class="property">class </em><code class="descclassname">urllib.parse.</code><code class="descname">ParseResultBytes</code><span class="sig-paren">(</span><em>scheme</em>, <em>netloc</em>, <em>path</em>, <em>params</em>, <em>query</em>, <em>fragment</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-231">包含<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>数据的<a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal"><span class="pre">urlparse()</span></code></a>结果的具体类。</span><span class="yiyi-st" id="yiyi-232"><code class="xref py py-meth docutils literal"><span class="pre">decode()</span></code>方法返回<a class="reference internal" href="#urllib.parse.ParseResult" title="urllib.parse.ParseResult"><code class="xref py py-class docutils literal"><span class="pre">ParseResult</span></code></a>实例。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-233"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="class"><dt id="urllib.parse.SplitResultBytes"><span class="yiyi-st" id="yiyi-234"> <em class="property">class </em><code class="descclassname">urllib.parse.</code><code class="descname">SplitResultBytes</code><span class="sig-paren">(</span><em>scheme</em>, <em>netloc</em>, <em>path</em>, <em>query</em>, <em>fragment</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-235">包含<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>数据的<a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal"><span class="pre">urlsplit()</span></code></a>结果的具体类。</span><span class="yiyi-st" id="yiyi-236"><code class="xref py py-meth docutils literal"><span class="pre">decode()</span></code>方法返回一个<a class="reference internal" href="#urllib.parse.SplitResult" title="urllib.parse.SplitResult"><code class="xref py py-class docutils literal"><span class="pre">SplitResult</span></code></a>实例。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-237"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl></div><div class="section" id="url-quoting"><h2><span class="yiyi-st" id="yiyi-238">21.8.4. </span><span class="yiyi-st" id="yiyi-239">URL转义</span></h2><p><span class="yiyi-st" id="yiyi-240">URL引用功能专注于获取程序数据，并通过引用特殊字符并适当编码非ASCII文本，使其作为URL组件安全使用。</span><span class="yiyi-st" id="yiyi-241">它们还支持反转这些操作以从URL组件的内容重新创建原始数据，如果该任务尚未被上面的URL解析函数覆盖。</span></p><dl class="function"><dt id="urllib.parse.quote"><span class="yiyi-st" id="yiyi-242"> <code class="descclassname">urllib.parse.</code><code class="descname">quote</code><span class="sig-paren">(</span><em>string</em>, <em>safe='/'</em>, <em>encoding=None</em>, <em>errors=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-243">使用<code class="docutils literal"><span class="pre">%xx</span></code>转义替换<em>string</em>中的特殊字符。</span><span class="yiyi-st" id="yiyi-244">字母、数字和字符<code class="docutils literal"><span class="pre">'_.-'</span></code>永远不会转义。</span><span class="yiyi-st" id="yiyi-245">默认情况下，此函数用于转义URL的路径部分。</span><span class="yiyi-st" id="yiyi-246">可选的<em>safe</em>参数指定不应转义的其他ASCII字符 — 其默认值为<code class="docutils literal"><span class="pre">'/'</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-247"><em>string</em>可以是<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>或<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-248">可选的<em>encoding</em>和<em>errors</em>参数指定如何处理非ASCII字符，它们会由<a class="reference internal" href="stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal"><span class="pre">str.encode()</span></code></a>方法所接受。</span><span class="yiyi-st" id="yiyi-249"><em>encoding</em>默认为<code class="docutils literal"><span class="pre">'utf-8'</span></code>。</span><span class="yiyi-st" id="yiyi-250"><em>errors</em>默认为<code class="docutils literal"><span class="pre">'strict'</span></code>，表示不支持的字符引发<a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-class docutils literal"><span class="pre">UnicodeEncodeError</span></code></a>。</span><span class="yiyi-st" id="yiyi-251">如果<em>string</em>是一个<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>，那么<em>encoding</em>和<em>errors</em>不可以指定，否则会引发一个<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-class docutils literal"><span class="pre">TypeError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-252">注意，<code class="docutils literal"><span class="pre">quote(string,</span> <span class="pre">safe,</span> <span class="pre">encoding,</span> <span class="pre">errors)</span></code>等同于<code class="docutils literal"><span class="pre">quote_from_bytes(string.encode(encoding,</span> <span class="pre">errors),</span> <span class="pre">safe)</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-253">示例：<code class="docutils literal"><span class="pre">quote('/El</span> <span class="pre">Niño/')</span></code>得到<code class="docutils literal"><span class="pre">'/El%20Ni%C3%B1o/'</span></code>。</span></p></dd></dl><dl class="function"><dt id="urllib.parse.quote_plus"><span class="yiyi-st" id="yiyi-254"> <code class="descclassname">urllib.parse.</code><code class="descname">quote_plus</code><span class="sig-paren">(</span><em>string</em>, <em>safe=''</em>, <em>encoding=None</em>, <em>errors=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-255">类似<a class="reference internal" href="#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal"><span class="pre">quote()</span></code></a>，但是用加号替换空格，在转义HTML表单值来构建查询字符串以进入URL时，这是必需的。</span><span class="yiyi-st" id="yiyi-256">原始字符串中的加号将被转义，除非它们包含在<em>safe</em>中。</span><span class="yiyi-st" id="yiyi-257">它的<em>safe</em>没有默认为<code class="docutils literal"><span class="pre">'/'</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-258">示例：<code class="docutils literal"><span class="pre">quote_plus('/El</span> <span class="pre">Niño/')</span></code>得到<code class="docutils literal"><span class="pre">'%2FEl+Ni%C3%B1o%2F'</span></code>。</span></p></dd></dl><dl class="function"><dt id="urllib.parse.quote_from_bytes"><span class="yiyi-st" id="yiyi-259"> <code class="descclassname">urllib.parse.</code><code class="descname">quote_from_bytes</code><span class="sig-paren">(</span><em>bytes</em>, <em>safe='/'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-260">像<a class="reference internal" href="#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal"><span class="pre">quote()</span></code></a>，但接受<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>对象而不是<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>，并且不执行字符串到字节编码。</span></p><p><span class="yiyi-st" id="yiyi-261">示例：<code class="docutils literal"><span class="pre">quote_from_bytes(b'a&amp;\xef')</span></code>生成<code class="docutils literal"><span class="pre">'a%26%EF'</span></code>。</span></p></dd></dl><dl class="function"><dt id="urllib.parse.unquote"><span class="yiyi-st" id="yiyi-262"> <code class="descclassname">urllib.parse.</code><code class="descname">unquote</code><span class="sig-paren">(</span><em>string</em>, <em>encoding='utf-8'</em>, <em>errors='replace'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-263">将<code class="docutils literal"><span class="pre">%xx</span></code>转义替换为等效的单字符。</span><span class="yiyi-st" id="yiyi-264">可选的<em>编码</em>和<em>错误</em>参数指定如何将百分比编码序列解码为Unicode字符，如<a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal"><span class="pre">bytes.decode()</span></code></a>方法所接受。</span></p><p><span class="yiyi-st" id="yiyi-265"><em>string</em>必须是<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-266"><em>encoding</em>默认为<code class="docutils literal"><span class="pre">'utf-8'</span></code>。</span><span class="yiyi-st" id="yiyi-267"><em>错误</em>默认为<code class="docutils literal"><span class="pre">'replace'</span></code>，表示无效序列由占位符字符替换。</span></p><p><span class="yiyi-st" id="yiyi-268">示例：<code class="docutils literal"><span class="pre">unquote('/El%20Ni%C3%B1o/')</span></code>得到<code class="docutils literal"><span class="pre">'/El</span> <span class="pre">Niño/'</span></code>。</span></p></dd></dl><dl class="function"><dt id="urllib.parse.unquote_plus"><span class="yiyi-st" id="yiyi-269"> <code class="descclassname">urllib.parse.</code><code class="descname">unquote_plus</code><span class="sig-paren">(</span><em>string</em>, <em>encoding='utf-8'</em>, <em>errors='replace'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-270">类似于<a class="reference internal" href="#urllib.parse.unquote" title="urllib.parse.unquote"><code class="xref py py-func docutils literal"><span class="pre">unquote()</span></code></a>，但是也可以用空格替换加号，这是不需要引用HTML表单值的。</span></p><p><span class="yiyi-st" id="yiyi-271"><em>string</em>必须是<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-272">示例：<code class="docutils literal"><span class="pre">unquote_plus('/El+Ni%C3%B1o/')</span></code>得到<code class="docutils literal"><span class="pre">'/El</span> <span class="pre">Niño/'</span></code>。</span></p></dd></dl><dl class="function"><dt id="urllib.parse.unquote_to_bytes"><span class="yiyi-st" id="yiyi-273"> <code class="descclassname">urllib.parse.</code><code class="descname">unquote_to_bytes</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-274">Replace <code class="docutils literal"><span class="pre">%xx</span></code> escapes by their single-octet equivalent, and return a <a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> object.</span></p><p><span class="yiyi-st" id="yiyi-275"><em>string</em>可以是<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>或<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-276">如果它是<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>，则<em>string</em>中的非转义非ASCII字符将编码为UTF-8字节。</span></p><p><span class="yiyi-st" id="yiyi-277">示例：<code class="docutils literal"><span class="pre">unquote_to_bytes('a%26%EF')</span></code>产生<code class="docutils literal"><span class="pre">b'a&amp;\xef'</span></code>。</span></p></dd></dl><dl class="function"><dt id="urllib.parse.urlencode"><span class="yiyi-st" id="yiyi-278"> <code class="descclassname">urllib.parse.</code><code class="descname">urlencode</code><span class="sig-paren">(</span><em>query</em>, <em>doseq=False</em>, <em>safe=''</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>quote_via=quote_plus</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-279">将映射对象或两元素元组序列，可以包含<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>或<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">字节</span></code></a>对象，转换为百分号编码的ASCII文本字符串。</span><span class="yiyi-st" id="yiyi-280">如果结果字符串要作为<em>data</em>用于使用<a class="reference internal" href="urllib.request.html#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal"><span class="pre">urlopen()</span></code></a>函数的POST操作，那么它应该被编码为字节，否则会导致<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre"> TypeError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-281">结果字符串是由<code class="docutils literal"><span class="pre">'&amp;'</span></code>字符分隔的一系列<code class="docutils literal"><span class="pre">key=value</span></code>对，其中<em>key</em>和<em>value</em>使用<em>quote_via</em>函数转义。</span><span class="yiyi-st" id="yiyi-282">默认情况下，<a class="reference internal" href="#urllib.parse.quote_plus" title="urllib.parse.quote_plus"><code class="xref py py-func docutils literal"><span class="pre">quote_plus()</span></code></a>用于引用值，这意味着空格被引用为<code class="docutils literal"><span class="pre">'+'</span></code>字符，'/'字符编码为<code class="docutils literal"><span class="pre">%2F</span></code>，它遵循GET请求的标准（<code class="docutils literal"><span class="pre">application/x-www-form-urlencoded</span></code>）。</span><span class="yiyi-st" id="yiyi-283">可作为<em>quote_via</em>传递的备用函数为<a class="reference internal" href="#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal"><span class="pre">quote()</span></code></a>，它将将空格编码为<code class="docutils literal"><span class="pre">%20</span></code>，而不对'/'字符进行编码。</span><span class="yiyi-st" id="yiyi-284">要最大限度地控制所引用的内容，请使用<code class="docutils literal"><span class="pre">quote</span></code>并指定<em>safe</em>的值。</span></p><p><span class="yiyi-st" id="yiyi-285">当使用两元素元组序列作为<em>query</em>参数时，每个元组的第一个元素是键，第二个元素是值。</span><span class="yiyi-st" id="yiyi-286">value元素本身可以是一个序列，在这种情况下，如果可选参数<em>doseq</em>计算为<em>True</em>，则单个<code class="docutils literal"><span class="pre">key=value</span></code>由键的值序列的每个元素生成由<code class="docutils literal"><span class="pre">'&amp;'</span></code>分隔的字符串。</span><span class="yiyi-st" id="yiyi-287">编码字符串中参数的顺序将匹配序列中参数元组的顺序。</span></p><p><span class="yiyi-st" id="yiyi-288"><em>safe</em>、<em>encoding</em>和<em>errors</em>参数将传递给<em>quote_via</em>（<em>encoding</em>和<em>errors</em>参数只有在查询元素为<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>时才会传递。）</span></p><p><span class="yiyi-st" id="yiyi-289">为了逆转此编码过程，在本模块中提供<a class="reference internal" href="#urllib.parse.parse_qs" title="urllib.parse.parse_qs"><code class="xref py py-func docutils literal"><span class="pre">parse_qs()</span></code></a>和<a class="reference internal" href="#urllib.parse.parse_qsl" title="urllib.parse.parse_qsl"><code class="xref py py-func docutils literal"><span class="pre">parse_qsl()</span></code></a>将查询字符串解析为Python数据结构。</span></p><p><span class="yiyi-st" id="yiyi-290">请参阅<a class="reference internal" href="urllib.request.html#urllib-examples"><span>urllib examples</span></a>以了解如何使用urlencode方法生成URL的数据或POST的查询字符串。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-291"><span class="versionmodified">在版本3.2中更改：</span>查询参数支持字节和字符串对象。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-292"><span class="versionmodified">新版本3.5：</span> <em>quote_via</em>参数。</span></p></div></dd></dl><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-293">也可以看看</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-294"><span class="target" id="index-5"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc3986.html"><strong>RFC 3986</strong></a>  - 统一资源标识符</span></dt><dd><span class="yiyi-st" id="yiyi-295">这是当前标准（STD66）。</span><span class="yiyi-st" id="yiyi-296">对urllib.parse模块的任何更改都应符合此。</span><span class="yiyi-st" id="yiyi-297">可以观察到某些偏差，这主要是出于向后兼容性目的和对于在主要浏览器中通常观察到的某些事实解析要求。</span></dd><dt><span class="yiyi-st" id="yiyi-298"><span class="target" id="index-6"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2732.html"><strong>RFC 2732</strong></a>  - 字面值格式IPv6地址在URL中。</span></dt><dd><span class="yiyi-st" id="yiyi-299">这指定IPv6 URL的解析要求。</span></dd><dt><span class="yiyi-st" id="yiyi-300"><span class="target" id="index-7"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2396.html"><strong>RFC 2396</strong></a>  - 统一资源标识符（URI）：通用语法</span></dt><dd><span class="yiyi-st" id="yiyi-301">描述统一资源名称（URN）和统一资源定位符（URL）的通用句法要求的文档。</span></dd><dt><span class="yiyi-st" id="yiyi-302"><span class="target" id="index-8"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2368.html"><strong>RFC 2368</strong></a>  -  mailto URL方案。</span></dt><dd><span class="yiyi-st" id="yiyi-303">解析mailto URL方案的要求。</span></dd><dt><span class="yiyi-st" id="yiyi-304"><span class="target" id="index-9"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc1808.html"><strong>RFC 1808</strong></a>  - 相对统一资源定位符</span></dt><dd><span class="yiyi-st" id="yiyi-305">此征求意见稿包括加入绝对和相对网址的规则，包括管理边境案件处理的相当数量的“异常例子”。</span></dd><dt><span class="yiyi-st" id="yiyi-306"><span class="target" id="index-10"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc1738.html"><strong>RFC 1738</strong></a>  - 统一资源定位符（URL）</span></dt><dd><span class="yiyi-st" id="yiyi-307">这指定绝对URL的形式语法和语义。</span></dd></dl></div></div></div></div>