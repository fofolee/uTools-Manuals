<div class="body" role="main"><div class="section" id="built-in-types"><h1><span class="yiyi-st" id="yiyi-9">4.</span><span class="yiyi-st" id="yiyi-10">内建类型 </span></h1><p><span class="yiyi-st" id="yiyi-11">以下部分描述了内置到解释器中的标准类型。</span></p><p id="index-0"><span class="yiyi-st" id="yiyi-12">主要的内建类型有数字、序列、映射、类、实例和异常。</span></p><p><span class="yiyi-st" id="yiyi-13">有些容器类是可变的。</span><span class="yiyi-st" id="yiyi-14">添加、删除或重新排列成员而不返回特定项的方法，不会返回容器实例本身而是返回<code class="docutils literal"><span class="pre">None</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-15">某些操作被几种对象类型支持；特别地，实际上所有对象都可以被比较，测试真值并转换为字符串（使用<a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a>函数或稍微不同的<a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a>函数） 。</span><span class="yiyi-st" id="yiyi-16">当通过<a class="reference internal" href="functions.html#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a>函数写入对象时，隐式使用后一个函数。</span></p><div class="section" id="truth-value-testing"><h2><span class="yiyi-st" id="yiyi-17">4.1.</span><span class="yiyi-st" id="yiyi-18">真值测试 </span></h2><p id="index-1"><span class="yiyi-st" id="yiyi-19">任何对象都可以被测试真值、用于<a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal"><span class="pre">if</span></code></a>或<a class="reference internal" href="../reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal"><span class="pre">while</span></code></a>条件中或作为下面的布尔操作的操作数。</span><span class="yiyi-st" id="yiyi-20">以下值被视为假：</span></p><ul id="index-2"><li><p class="first"><span class="yiyi-st" id="yiyi-21"><code class="docutils literal"><span class="pre">None</span></code></span></p></li><li id="index-3"><p class="first"><span class="yiyi-st" id="yiyi-22"><code class="docutils literal"><span class="pre">False</span></code></span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-23">任何数值类型的零，例如<code class="docutils literal"><span class="pre">0</span></code>、<code class="docutils literal"><span class="pre">0.0</span></code>、<code class="docutils literal"><span class="pre">0j</span></code>。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-24">任何空序列，例如<code class="docutils literal"><span class="pre">''</span></code>、<code class="docutils literal"><span class="pre">()</span></code>、<code class="docutils literal"><span class="pre">[]</span></code>。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-25">任何空映射，例如，<code class="docutils literal"><span class="pre">{}</span></code>。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-26">用户定义的类的实例，如果该类定义一个 <a class="reference internal" href="../reference/datamodel.html#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal"><span class="pre">__bool__()</span></code></a>或<a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal"><span class="pre">__len__()</span></code></a>方法，当该方法返回<a class="reference internal" href="functions.html#bool" title="bool"><code class="xref py py-class docutils literal"><span class="pre">布尔</span></code></a>值<code class="docutils literal"><span class="pre">False</span></code>或整数零的时候 。</span><span class="yiyi-st" id="yiyi-27"><a class="footnote-reference" href="#id11" id="id1"> [1]  T0&gt;</a></span></p></li></ul><p id="index-4"><span class="yiyi-st" id="yiyi-28">所有其他值都被认为是真 —— 所以许多类型的对象总是为真。</span></p><p id="index-5"><span class="yiyi-st" id="yiyi-29">结果为布尔值的操作和内建函数，总是返回<code class="docutils literal"><span class="pre">0</span></code>或<code class="docutils literal"><span class="pre">False</span></code>表示假，返回<code class="docutils literal"><span class="pre">1</span></code>或<code class="docutils literal"><span class="pre">True</span></code>表示真，除非另有说明。</span><span class="yiyi-st" id="yiyi-30">（重要的例外：布尔运算<code class="docutils literal"><span class="pre">or</span></code>和<code class="docutils literal"><span class="pre">and</span></code>总是返回其操作数之一。）</span></p></div><div class="section" id="boolean-operations-and-or-not"><h2><span class="yiyi-st" id="yiyi-31">4.2.</span><span class="yiyi-st" id="yiyi-32">布尔运算 — <a class="reference internal" href="../reference/expressions.html#and"><code class="xref std std-keyword docutils literal"><span class="pre">and</span></code></a>, <a class="reference internal" href="../reference/expressions.html#or"><code class="xref std std-keyword docutils literal"><span class="pre">or</span></code></a>, <a class="reference internal" href="../reference/expressions.html#not"><code class="xref std std-keyword docutils literal"><span class="pre">not</span></code></a></span></h2><p id="index-6"><span class="yiyi-st" id="yiyi-33">下面是 Boolean 操作, 按照优先级升序排列</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-34">操作</span></th><th class="head"><span class="yiyi-st" id="yiyi-35">结果</span></th><th class="head"><span class="yiyi-st" id="yiyi-36">备注</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-37"><code class="docutils literal"><span class="pre">x</span> <span class="pre">or</span> <span class="pre">y</span></code></span></td><td><span class="yiyi-st" id="yiyi-38">若 <em>x</em> 为 False, 则结果为 <em>y</em>, 否则结果为 <em>x</em></span></td><td><span class="yiyi-st" id="yiyi-39">（1）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-40"><code class="docutils literal"><span class="pre">x</span> <span class="pre">and</span> <span class="pre">y</span></code></span></td><td><span class="yiyi-st" id="yiyi-41">若<em>x</em> 为 false, 则结果为 <em>x</em>, 否则结果为 <em>y</em></span></td><td><span class="yiyi-st" id="yiyi-42">（2）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-43"><code class="docutils literal"><span class="pre">not</span> <span class="pre">x</span></code></span></td><td><span class="yiyi-st" id="yiyi-44">若 <em>x</em> 为 false, 则结果为<code class="docutils literal"><span class="pre">True</span></code>, 否则结果为 <code class="docutils literal"><span class="pre">False</span></code></span></td><td><span class="yiyi-st" id="yiyi-45">（3）</span></td></tr></tbody></table><p id="index-7"><span class="yiyi-st" id="yiyi-46">备注:</span></p><ol class="arabic simple"><li><span class="yiyi-st" id="yiyi-47">这是短路运算符，所以如果第一个参数是 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>，它就只计算第二个参数。</span></li><li><span class="yiyi-st" id="yiyi-48">这是短路运算符，所以如果第一个参数是 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>，它就只计算第二个参数。</span></li><li><span class="yiyi-st" id="yiyi-49"><code class="docutils literal"><span class="pre">not</span></code> 是一个低优先级的布尔运算符，所以 <code class="docutils literal"><span class="pre">not</span> <span class="pre">a</span> <span class="pre">= =</span> <span class="pre">b</span></code> 解释为 <code class="docutils literal"><span class="pre">not</span> <span class="pre">(a</span> <span class="pre">= =</span> <span class="pre">b)</span></code>，以及<code class="docutils literal"><span class="pre">a</span> <span class="pre">= =</span> <span class="pre">not</span> <span class="pre">b</span></code> 是一个语法错误。</span></li></ol></div><div class="section" id="comparisons"><h2><span class="yiyi-st" id="yiyi-50">4.3.</span><span class="yiyi-st" id="yiyi-51">比较 </span></h2><p id="index-8"><span class="yiyi-st" id="yiyi-52">Python有8种比较运算符。</span><span class="yiyi-st" id="yiyi-53">他们的优先级都相同（同时都比布尔运算符的优先级高）。</span><span class="yiyi-st" id="yiyi-54">比较符可以任意地连接;比如，<code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code>等价于<code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code>, 除非 <em>y</em> 是需要计算一次的 (但在这种情况下<em>z</em>都是只需要计算一次，因为 <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> 的结果是false).</span></p><p><span class="yiyi-st" id="yiyi-55">下表总结了比较运算符：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-56">操作</span></th><th class="head"><span class="yiyi-st" id="yiyi-57">含义</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-58"><code class="docutils literal"><span class="pre">&lt;</span></code></span></td><td><span class="yiyi-st" id="yiyi-59">严格小于</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-60"><code class="docutils literal"><span class="pre">&lt;=</span></code></span></td><td><span class="yiyi-st" id="yiyi-61">小于或等于</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-62"><code class="docutils literal"><span class="pre">&gt;</span></code></span></td><td><span class="yiyi-st" id="yiyi-63">严格大于</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-64"><code class="docutils literal"><span class="pre">&gt;=</span></code></span></td><td><span class="yiyi-st" id="yiyi-65">大于或等于</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-66"><code class="docutils literal"><span class="pre">==</span></code></span></td><td><span class="yiyi-st" id="yiyi-67">等于</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-68"><code class="docutils literal"><span class="pre">!=</span></code></span></td><td><span class="yiyi-st" id="yiyi-69">不等于</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-70"><code class="docutils literal"><span class="pre">is</span></code></span></td><td><span class="yiyi-st" id="yiyi-71">对象身份</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-72"><code class="docutils literal"><span class="pre">is</span> <span class="pre">not</span></code></span></td><td><span class="yiyi-st" id="yiyi-73">否定对象身份</span></td></tr></tbody></table><p id="index-9"><span class="yiyi-st" id="yiyi-74">不同类型（除了不同的数值类型），永远不会相等。</span><span class="yiyi-st" id="yiyi-75">此外，某些类型 （例如，函数对象） 支持只有退化比较，因为该类型的任何两个对象都是不相等的。</span><span class="yiyi-st" id="yiyi-76">以下的操作会使<code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code> and <code class="docutils literal"><span class="pre">&gt;=</span></code> 操作会抛出 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 异常，1、使用一个复数类型与其他的内建的数值类型进行比较；2、使用那些不能与其他类型比较的对象进行比较；3、或者其他没有定义排序规则的情况。</span></p><p id="index-10"><span class="yiyi-st" id="yiyi-77">同一个类中的不同对象，通常会被判定为不相等，除非该类定义了<a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> 方法</span></p><p><span class="yiyi-st" id="yiyi-78">Instances of a class cannot be ordered with respect to other instances of the same class, or other types of object, unless the class defines enough of the methods <a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal"><span class="pre">__le__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal"><span class="pre">__gt__()</span></code></a>, and <a class="reference internal" href="../reference/datamodel.html#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal"><span class="pre">__ge__()</span></code></a> (in general, <a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></code></a> and <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> are sufficient, if you want the conventional meanings of the comparison operators).</span></p><p><span class="yiyi-st" id="yiyi-79"><a class="reference internal" href="../reference/expressions.html#is"><code class="xref std std-keyword docutils literal"><span class="pre">is</span></code></a>和<a class="reference internal" href="../reference/expressions.html#is-not"><code class="xref std std-keyword docutils literal"><span class="pre">is</span> <span class="pre">not</span></code></a>运算符不能自定义；它们也可以应用于任何两个对象，并且不会引发异常。</span></p><p id="index-11"><span class="yiyi-st" id="yiyi-80">两个相同的语法优先级的操作, <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> 和 <a class="reference internal" href="../reference/expressions.html#not-in"><code class="xref std std-keyword docutils literal"><span class="pre">not</span> <span class="pre">in</span></code></a>, 只支持序列类型(below).</span></p></div><div class="section" id="numeric-types-int-float-complex"><h2><span class="yiyi-st" id="yiyi-81">4.4.</span><span class="yiyi-st" id="yiyi-82">数值类型 — <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>, <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal"><span class="pre">complex</span></code></a></span></h2><p id="index-12"><span class="yiyi-st" id="yiyi-83">Python有以下三种的数值类型: <em class="dfn">整型(integers)</em>, <em class="dfn">浮点型（floating point numbers）</em>, 以及 <em class="dfn">复数（complex numbers）</em>.</span><span class="yiyi-st" id="yiyi-84">另外，布尔是一个整数的子类型。</span><span class="yiyi-st" id="yiyi-85">整型拥有准确的精度。</span><span class="yiyi-st" id="yiyi-86">浮点型一般是实现C中的<code class="xref c c-type docutils literal"><span class="pre">double</span></code> 类型;有关浮点型的精度信息以及其在具体机器中的内部特性信息，可在<a class="reference internal" href="sys.html#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal"><span class="pre">sys.float_info</span></code></a>中获取。</span><span class="yiyi-st" id="yiyi-87">复数类型由一个实数部分（即实部）与一个虚数部分（即虚部）构成，而这两个部分都是浮点型。</span><span class="yiyi-st" id="yiyi-88">若要从复数 <em>z</em> 中提取这两个部分，请使用 <code class="docutils literal"><span class="pre">z.real</span></code> 和 <code class="docutils literal"><span class="pre">z.imag</span></code>。</span><span class="yiyi-st" id="yiyi-89">（标准库包括了额外的数值类型，如<a class="reference internal" href="fractions.html#module-fractions" title="fractions: Rational numbers."><code class="xref py py-mod docutils literal"><span class="pre">分数（fractions）</span></code></a> （包含了有理数），和 <a class="reference internal" href="decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic Specification."><code class="xref py py-mod docutils literal"><span class="pre">小数（decimal）</span></code></a> （包含了自定义精度的浮点型））。</span></p><p id="index-13"><span class="yiyi-st" id="yiyi-90">数字由数字文字或内置函数和运算符的结果创建。</span><span class="yiyi-st" id="yiyi-91">未修饰的整数字面值（包括十六进制，八进制和二进制数）产生整数。</span><span class="yiyi-st" id="yiyi-92">包含小数点或指数符号的数字文字会生成浮点数字。</span><span class="yiyi-st" id="yiyi-93">将<code class="docutils literal"><span class="pre">'j'</span></code>或<code class="docutils literal"><span class="pre">'J'</span></code>附加到数字字面值会产生一个虚数（具有零实数部分的复数），您可以将其添加到整数或浮点以获得具有实部和虚部的复数。</span></p><p id="index-14"><span class="yiyi-st" id="yiyi-94">Python完全支持混合算术：当二进制算术操作符具有不同数值类型的操作数时，具有“较窄”类型的操作数被加宽到另一个的操作数，其中整数比比复数的浮点窄。</span><span class="yiyi-st" id="yiyi-95">混合类型的数字之间的比较使用相同的规则。</span><span class="yiyi-st" id="yiyi-96"><a class="footnote-reference" href="#id12" id="id2">[2]</a>可以使用构造函数<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a>，<a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-func docutils literal"><span class="pre">float()</span></code></a>和<a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-func docutils literal"><span class="pre">complex()</span></code></a>特定类型的数字。</span></p><p><span class="yiyi-st" id="yiyi-97">所有数字类型（复数除外）都支持以下操作（按优先级升序排列）（所有数字操作的优先级均高于比较操作）：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-98">操作</span></th><th class="head"><span class="yiyi-st" id="yiyi-99">结果</span></th><th class="head"><span class="yiyi-st" id="yiyi-100">备注</span></th><th class="head"><span class="yiyi-st" id="yiyi-101">完整的文档</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-102"><code class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code></span></td><td><span class="yiyi-st" id="yiyi-103"><em>x</em> 和 <em>y</em> 的总和</span></td><td></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-104"><code class="docutils literal"><span class="pre">x</span> <span class="pre"> - </span> <span class="pre">y</span></code></span></td><td><span class="yiyi-st" id="yiyi-105"><em>x</em> 和 <em>y</em> 的差</span></td><td></td><td></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-106"><code class="docutils literal"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code></span></td><td><span class="yiyi-st" id="yiyi-107"><em>x</em> 和 <em>y</em> 的乘积</span></td><td></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-108"><code class="docutils literal"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code></span></td><td><span class="yiyi-st" id="yiyi-109"><em>x</em> 和 <em>y</em> 的商</span></td><td></td><td></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-110"><code class="docutils literal"><span class="pre">x</span> <span class="pre">//</span> <span class="pre">y</span></code></span></td><td><span class="yiyi-st" id="yiyi-111"><em>x</em> 除以<em>y</em>的商向下取整的整数</span></td><td><span class="yiyi-st" id="yiyi-112">（1）</span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-113"><code class="docutils literal"><span class="pre">x</span> <span class="pre">％</span> <span class="pre">y</span></code></span></td><td><span class="yiyi-st" id="yiyi-114">求余数 <code class="docutils literal"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code></span></td><td><span class="yiyi-st" id="yiyi-115">（2）</span></td><td></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-116"><code class="docutils literal"><span class="pre">-x</span></code></span></td><td><span class="yiyi-st" id="yiyi-117"><em>x</em> 取负</span></td><td></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-118"><code class="docutils literal"><span class="pre">+x</span></code></span></td><td><span class="yiyi-st" id="yiyi-119"><em>x</em> 保持不变</span></td><td></td><td></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-120"><code class="docutils literal"><span class="pre">abs(x)</span></code></span></td><td><span class="yiyi-st" id="yiyi-121"><em>x</em>的绝对值或x的大小</span></td><td></td><td><span class="yiyi-st" id="yiyi-122"><a class="reference internal" href="functions.html#abs" title="abs"><code class="xref py py-func docutils literal"><span class="pre">abs()</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-123"><code class="docutils literal"><span class="pre">int(x)</span></code></span></td><td><span class="yiyi-st" id="yiyi-124"><em>x</em> 转换为整数</span></td><td><span class="yiyi-st" id="yiyi-125">（3）（6）</span></td><td><span class="yiyi-st" id="yiyi-126"><a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-127"><code class="docutils literal"><span class="pre">float(x)</span></code></span></td><td><span class="yiyi-st" id="yiyi-128"><em>x</em> 转换为浮点数</span></td><td><span class="yiyi-st" id="yiyi-129">（4）（6）</span></td><td><span class="yiyi-st" id="yiyi-130"><a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-func docutils literal"><span class="pre">float()</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-131"><code class="docutils literal"><span class="pre">complex（re，</span> <span class="pre">im）</span></code></span></td><td><span class="yiyi-st" id="yiyi-132">将参数转化为复数，<em>re</em>为复数的实部，<em>Im</em>为复数的虚部。</span><span class="yiyi-st" id="yiyi-133"><em>im</em> 默认为0</span></td><td><span class="yiyi-st" id="yiyi-134">（6）</span></td><td><span class="yiyi-st" id="yiyi-135"><a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-func docutils literal"><span class="pre">complex()</span></code></a></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-136"><code class="docutils literal"><span class="pre">c.conjugate()</span></code></span></td><td><span class="yiyi-st" id="yiyi-137"><em>c</em> 复数的共轭</span></td><td></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-138"><code class="docutils literal"><span class="pre">divmod（x，</span> <span class="pre">y）</span></code></span></td><td><span class="yiyi-st" id="yiyi-139"><code class="docutils literal"><span class="pre">(x</span> <span class="pre">//</span> <span class="pre">y，</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y)</span></code></span></td><td><span class="yiyi-st" id="yiyi-140">（2）</span></td><td><span class="yiyi-st" id="yiyi-141"><a class="reference internal" href="functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal"><span class="pre">divmod()</span></code></a></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-142"><code class="docutils literal"><span class="pre">pow（x，</span> <span class="pre">y）</span></code></span></td><td><span class="yiyi-st" id="yiyi-143"><em>x</em> 的<em>y</em> 次幂</span></td><td><span class="yiyi-st" id="yiyi-144">（5）</span></td><td><span class="yiyi-st" id="yiyi-145"><a class="reference internal" href="functions.html#pow" title="pow"><code class="xref py py-func docutils literal"><span class="pre">pow()</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-146"><code class="docutils literal"><span class="pre">x</span> <span class="pre">**</span> <span class="pre">y</span></code></span></td><td><span class="yiyi-st" id="yiyi-147"><em>x</em> 的<em>y</em> 次幂</span></td><td><span class="yiyi-st" id="yiyi-148">（5）</span></td><td></td></tr></tbody></table><p id="index-15"><span class="yiyi-st" id="yiyi-149">笔记：</span></p><ol class="arabic"><li><p class="first"><span class="yiyi-st" id="yiyi-150">也被称为整数除法。</span><span class="yiyi-st" id="yiyi-151">结果值是一个整数，虽然结果的类型不一定是int。</span><span class="yiyi-st" id="yiyi-152">整数除法的结果总是向下取整（负无穷小）: <code class="docutils literal"><span class="pre">1//2</span></code> is <code class="docutils literal"><span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">(-1)//2</span></code> is <code class="docutils literal"><span class="pre">-1</span></code>, <code class="docutils literal"><span class="pre">1//(-2)</span></code> is <code class="docutils literal"><span class="pre">-1</span></code>, and <code class="docutils literal"><span class="pre">(-1)//(-2)</span></code> is <code class="docutils literal"><span class="pre">0</span></code>.</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-153">复数无法使用。</span><span class="yiyi-st" id="yiyi-154">如果合适的话，可以使用<a class="reference internal" href="functions.html#abs" title="abs"><code class="xref py py-func docutils literal"><span class="pre">abs()</span></code></a>转换为浮点数。</span></p></li><li><p id="index-16"><span class="yiyi-st" id="yiyi-155">从浮点到整数的转换可能在C中舍入或截断；请参阅函数<a class="reference internal" href="math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal"><span class="pre">math.floor()</span></code></a>和<a class="reference internal" href="math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal"><span class="pre">math.ceil()</span></code></a>以获得定义明确的转换。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-156">对于非数字（NaN）和正或负无穷，float还接受带有可选前缀“+”或“ - ”的字符串“nan”和“inf”。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-157">Python defines <code class="docutils literal"><span class="pre">pow(0,</span> <span class="pre">0)</span></code> and <code class="docutils literal"><span class="pre">0</span> <span class="pre">**</span> <span class="pre">0</span></code> to be <code class="docutils literal"><span class="pre">1</span></code>, as is common for programming languages.</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-158">接受的数字字面值包括数字<code class="docutils literal"><span class="pre">0</span></code>到<code class="docutils literal"><span class="pre">9</span></code>或任何Unicode等效字符（具有<code class="docutils literal"><span class="pre">Nd</span></code>属性的代码点）。</span></p><p><span class="yiyi-st" id="yiyi-159">请参阅<a class="reference external" href="http://www.unicode.org/Public/8.0.0/ucd/extracted/DerivedNumericType.txt">http://www.unicode.org/Public/8.0.0/ucd/extracted/DerivedNumericType.txt</a>以获取具有<code class="docutils literal"><span class="pre">Nd</span></code>属性的完整代码点列表。</span></p></li></ol><p><span class="yiyi-st" id="yiyi-160">所有<a class="reference internal" href="numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal"><span class="pre">number.Real</span></code></a>类型（<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>和<a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>）还包括以下操作：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-161">操作</span></th><th class="head"><span class="yiyi-st" id="yiyi-162">结果</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-163"><a class="reference internal" href="math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal"><span class="pre">math.trunc(x)</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-164"><em>x</em>截断为<a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-165"><a class="reference internal" href="functions.html#round" title="round"><code class="xref py py-func docutils literal"><span class="pre">round(x[,</span> <span class="pre">n])</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-166">将<em>x</em>四舍五入为<em>n</em>数字，将一半舍入到偶数。</span><span class="yiyi-st" id="yiyi-167">如果省略<em>n</em>，则默认为0。</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-168"><a class="reference internal" href="math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal"><span class="pre">math.floor(x)</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-169">最大的小于等于<em>x</em>的<a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">整数</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-170"><a class="reference internal" href="math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal"><span class="pre">math.ceil(x)</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-171">最小的大于等于<em>x</em>的<a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">整数</span></code></a></span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-172">有关其他数值操作，请参见<a class="reference internal" href="math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal"><span class="pre">math</span></code></a>和<a class="reference internal" href="cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal"><span class="pre">cmath</span></code></a>模块。</span></p><div class="section" id="bitwise-operations-on-integer-types"><h3><span class="yiyi-st" id="yiyi-173">4.4.1.</span><span class="yiyi-st" id="yiyi-174">整数类型的位运算</span></h3><p id="index-17"><span class="yiyi-st" id="yiyi-175">按位操作只对整数有意义。</span><span class="yiyi-st" id="yiyi-176">负数被视为其2的补码值（假设有足够的位，因此在操作期间不会发生溢出）。</span></p><p><span class="yiyi-st" id="yiyi-177">二进制按位操作的优先级都低于数值运算，并高于比较运算；一元操作<code class="docutils literal"><span class="pre">~</span></code>具有与其他一元数字操作（<code class="docutils literal"><span class="pre">+</span></code>和<code class="docutils literal"><span class="pre">-</span></code>）相同的优先级。</span></p><p><span class="yiyi-st" id="yiyi-178">此表列出按升序优先级排序的按位运算：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-179">操作</span></th><th class="head"><span class="yiyi-st" id="yiyi-180">结果</span></th><th class="head"><span class="yiyi-st" id="yiyi-181">笔记</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-182"><code class="docutils literal"><span class="pre">x</span> <span class="pre">|</span> <span class="pre">y</span></code></span></td><td><span class="yiyi-st" id="yiyi-183"><em>x</em>和<em>y</em>的按位<em class="dfn">或</em></span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-184"><code class="docutils literal"><span class="pre">x</span> <span class="pre">^</span> <span class="pre">y</span></code></span></td><td><span class="yiyi-st" id="yiyi-185"><em>x</em>和<em>y</em>的按位<em class="dfn">排除或</em></span></td><td></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-186"><code class="docutils literal"><span class="pre">x</span> <span class="pre">&amp;</span> <span class="pre">y</span></code></span></td><td><span class="yiyi-st" id="yiyi-187"><em>x</em>和<em>y</em>的按位<em class="dfn">和</em></span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-188"><code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">n</span></code></span></td><td><span class="yiyi-st" id="yiyi-189"><em>x</em>向左移动<em>n</em>位</span></td><td><span class="yiyi-st" id="yiyi-190">（1）（2）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-191"><code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">n</span></code></span></td><td><span class="yiyi-st" id="yiyi-192"><em>x</em>右移了<em>n</em>位</span></td><td><span class="yiyi-st" id="yiyi-193">（1）（3）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-194"><code class="docutils literal"><span class="pre">~x</span></code></span></td><td><span class="yiyi-st" id="yiyi-195"><em>x</em>的位反转</span></td><td></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-196">笔记：</span></p><ol class="arabic simple"><li><span class="yiyi-st" id="yiyi-197">负移位计数是非法的，并会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></li><li><span class="yiyi-st" id="yiyi-198">A left shift by <em>n</em> bits is equivalent to multiplication by <code class="docutils literal"><span class="pre">pow(2,</span> <span class="pre">n)</span></code> without overflow check.</span></li><li><span class="yiyi-st" id="yiyi-199">A right shift by <em>n</em> bits is equivalent to division by <code class="docutils literal"><span class="pre">pow(2,</span> <span class="pre">n)</span></code> without overflow check.</span></li></ol></div><div class="section" id="additional-methods-on-integer-types"><h3><span class="yiyi-st" id="yiyi-200">4.4.2.</span><span class="yiyi-st" id="yiyi-201">整数类型的其他方法</span></h3><p><span class="yiyi-st" id="yiyi-202">int类型实现<a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">numbers.Integral</span></code></a> <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a>。</span><span class="yiyi-st" id="yiyi-203">此外，它还提供了几个方法：</span></p><dl class="method"><dt id="int.bit_length"><span class="yiyi-st" id="yiyi-204"><code class="descclassname">int.</code><code class="descname">bit_length</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-205">返回表示二进制整数所需的位数，不包括符号和前导零：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">37</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">'-0b100101'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>
<span class="go">6</span>
</code></pre><p><span class="yiyi-st" id="yiyi-206">更确切的说, 如果 <code class="docutils literal"><span class="pre">x</span></code> 的值非零, 那么 <code class="docutils literal"><span class="pre">x.bit_length()</span></code> is the unique positive integer <code class="docutils literal"><span class="pre">k</span></code> such that <code class="docutils literal"><span class="pre">2**(k-1)</span> <span class="pre">&lt;=</span> <span class="pre">abs(x)</span> <span class="pre">&lt;</span> <span class="pre">2**k</span></code>. Equivalently, when <code class="docutils literal"><span class="pre">abs(x)</span></code> is small enough to have a correctly rounded logarithm, then <code class="docutils literal"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">int(log(abs(x),</span> <span class="pre">2))</span></code>.</span><span class="yiyi-st" id="yiyi-207">如果<code class="docutils literal"><span class="pre">x</span></code>为零，则<code class="docutils literal"><span class="pre">x.bit_length()</span></code>返回<code class="docutils literal"><span class="pre">0</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-208">相当于如下:</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">bit_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>       <span class="c1"># binary representation:  bin(-37) --&gt; '-0b100101'</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">'-0b'</span><span class="p">)</span> <span class="c1"># remove leading zeros and minus sign</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>       <span class="c1"># len('100101') --&gt; 6</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-209"><span class="versionmodified">版本3.1中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="int.to_bytes"><span class="yiyi-st" id="yiyi-210"><code class="descclassname">int.</code><code class="descname">to_bytes</code><span class="sig-paren">(</span><em>length</em>, <em>byteorder</em>, <em>*</em>, <em>signed=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-211">返回一个表示整数的字节数组。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">'big'</span><span class="p">)</span>
<span class="go">b'\x04\x00'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">'big'</span><span class="p">)</span>
<span class="go">b'\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">'big'</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">b'\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">//</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">'little'</span><span class="p">)</span>
<span class="go">b'\xe8\x03'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-212">整数使用<em>length</em>字节表示。</span><span class="yiyi-st" id="yiyi-213">如果整数不能用给定的字节数表示，则会引发<a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-214"><em>byteorder</em>参数确定用于表示整数的字节顺序。</span><span class="yiyi-st" id="yiyi-215">如果<em>byteorder</em>为<code class="docutils literal"><span class="pre">“big”</span></code>，则最高有效字节位于字节数组的开头。</span><span class="yiyi-st" id="yiyi-216">如果<em>byteorder</em>为<code class="docutils literal"><span class="pre">“little”</span></code>，则最高有效字节位于字节数组的末尾。</span><span class="yiyi-st" id="yiyi-217">要请求主机系统的本机字节顺序，请使用<a class="reference internal" href="sys.html#sys.byteorder" title="sys.byteorder"><code class="xref py py-data docutils literal"><span class="pre">sys.byteorder</span></code></a>作为字节顺序值。</span></p><p><span class="yiyi-st" id="yiyi-218"><em>signed</em>参数确定二进制补码是否用于表示整数。</span><span class="yiyi-st" id="yiyi-219">如果<em>signed</em>是<code class="docutils literal"><span class="pre">False</span></code>且给出了负整数，则会引发<a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a>。</span><span class="yiyi-st" id="yiyi-220"><em>signed</em>的默认值为<code class="docutils literal"><span class="pre">False</span></code>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-221"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="classmethod"><dt id="int.from_bytes"><span class="yiyi-st" id="yiyi-222"><em class="property">classmethod </em><code class="descclassname">int.</code><code class="descname">from_bytes</code><span class="sig-paren">(</span><em>bytes</em>, <em>byteorder</em>, <em>*</em>, <em>signed=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-223">返回由给定的字节数组表示的整数。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">b</span><span class="s1">'</span><span class="se">\x00\x10</span><span class="s1">'</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">'big'</span><span class="p">)</span>
<span class="go">16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">b</span><span class="s1">'</span><span class="se">\x00\x10</span><span class="s1">'</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">'little'</span><span class="p">)</span>
<span class="go">4096</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">b</span><span class="s1">'</span><span class="se">\xfc\x00</span><span class="s1">'</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">'big'</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">-1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">b</span><span class="s1">'</span><span class="se">\xfc\x00</span><span class="s1">'</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">'big'</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">64512</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">([</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">'big'</span><span class="p">)</span>
<span class="go">16711680</span>
</code></pre><p><span class="yiyi-st" id="yiyi-224">参数<em>bytes</em>必须是<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">类似字节的对象</span></a>或产生字节的可迭代对象。</span></p><p><span class="yiyi-st" id="yiyi-225"><em>byteorder</em>参数确定用于表示整数的字节顺序。</span><span class="yiyi-st" id="yiyi-226">如果<em>byteorder</em>为<code class="docutils literal"><span class="pre">“big”</span></code>，则最高有效字节位于字节数组的开头。</span><span class="yiyi-st" id="yiyi-227">如果<em>byteorder</em>为<code class="docutils literal"><span class="pre">“little”</span></code>，则最高有效字节位于字节数组的末尾。</span><span class="yiyi-st" id="yiyi-228">要请求主机系统的本机字节顺序，请使用<a class="reference internal" href="sys.html#sys.byteorder" title="sys.byteorder"><code class="xref py py-data docutils literal"><span class="pre">sys.byteorder</span></code></a>作为字节顺序值。</span></p><p><span class="yiyi-st" id="yiyi-229"><em>signed</em>参数指示是否使用二进制补码表示整数。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-230"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl></div><div class="section" id="additional-methods-on-float"><h3><span class="yiyi-st" id="yiyi-231">4.4.3.</span><span class="yiyi-st" id="yiyi-232">其他方法浮动</span></h3><p><span class="yiyi-st" id="yiyi-233">float类型实现了<a class="reference internal" href="numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal"><span class="pre">numbers.Real</span></code></a> <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a>。</span><span class="yiyi-st" id="yiyi-234">float还有以下附加方法。</span></p><dl class="method"><dt id="float.as_integer_ratio"><span class="yiyi-st" id="yiyi-235"><code class="descclassname">float.</code><code class="descname">as_integer_ratio</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-236">返回一对整数（2元组），它们的比例准确地等于浮点数的原始值，且分母为正数。</span><span class="yiyi-st" id="yiyi-237">在无穷上引发<a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a>和在NaN上引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="float.is_integer"><span class="yiyi-st" id="yiyi-238"><code class="descclassname">float.</code><code class="descname">is_integer</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-239">如果浮点数实例是整数值，则返回<code class="docutils literal"><span class="pre">True</span></code>，否则返回<code class="docutils literal"><span class="pre">False</span></code>：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span>
<span class="go">False</span>
</code></pre></dd></dl><p><span class="yiyi-st" id="yiyi-240">两种方法支持与十六进制字符串的转换。</span><span class="yiyi-st" id="yiyi-241">由于Python的浮点数在内部存储为二进制数，所以将float转换为或来自<em>十进制</em>字符串通常会涉及一个小的舍入误差。</span><span class="yiyi-st" id="yiyi-242">相反，十六进制字符串允许精确表示和指定浮点数。</span><span class="yiyi-st" id="yiyi-243">这在调试和数值工作时非常有用。</span></p><dl class="method"><dt id="float.hex"><span class="yiyi-st" id="yiyi-244"><code class="descclassname">float.</code><code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-245">将浮点数的表示形式返回为十六进制字符串。</span><span class="yiyi-st" id="yiyi-246">对于有限的浮点数，这种表示形式总是包括一个前导的<code class="docutils literal"><span class="pre">0x</span></code>和尾部的<code class="docutils literal"><span class="pre">p</span></code>及指数。</span></p></dd></dl><dl class="classmethod"><dt id="float.fromhex"><span class="yiyi-st" id="yiyi-247"><em class="property">classmethod </em><code class="descclassname">float.</code><code class="descname">fromhex</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-248">Class方法返回由十六进制字符串<em>s</em>表示的浮点数。字符串<em>s</em>可能具有前导空格和尾随空格。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-249">请注意，<a class="reference internal" href="#float.hex" title="float.hex"><code class="xref py py-meth docutils literal"><span class="pre">float.hex()</span></code></a>是一个实例方法，而<a class="reference internal" href="#float.fromhex" title="float.fromhex"><code class="xref py py-meth docutils literal"><span class="pre">float.fromhex()</span></code></a>是一个类方法。</span></p><p><span class="yiyi-st" id="yiyi-250">十六进制字符串采用以下形式：</span></p><pre><code class="language-python"><span></span><span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="p">[</span><span class="s1">'0x'</span><span class="p">]</span> <span class="n">integer</span> <span class="p">[</span><span class="s1">'.'</span> <span class="n">fraction</span><span class="p">]</span> <span class="p">[</span><span class="s1">'p'</span> <span class="n">exponent</span><span class="p">]</span>
</code></pre><p><span class="yiyi-st" id="yiyi-251">其中可选的<code class="docutils literal"><span class="pre">sign</span></code>可以由<code class="docutils literal"><span class="pre">+</span></code>或<code class="docutils literal"><span class="pre">-</span></code>，<code class="docutils literal"><span class="pre">integer</span></code>和<code class="docutils literal"><span class="pre">fraction</span></code>十六进制数字串，<code class="docutils literal"><span class="pre">exponent</span></code>是带有可选前导符号的十进制整数。</span><span class="yiyi-st" id="yiyi-252">大小写不重要，整数或小数中至少有一个十六进制数字。</span><span class="yiyi-st" id="yiyi-253">此语法与C99标准的6.4.4.2节中指定的语法类似，也与Java 1.5之后的语法类似。</span><span class="yiyi-st" id="yiyi-254">特别是，<a class="reference internal" href="#float.hex" title="float.hex"><code class="xref py py-meth docutils literal"><span class="pre">float.hex()</span></code></a>的输出可用作C或Java代码中的十六进制浮点数字，而C的<code class="docutils literal"><span class="pre">%a</span></code>格式字符可生成十六进制字符串或Java的<code class="docutils literal"><span class="pre">Double.toHexString</span></code>被<a class="reference internal" href="#float.fromhex" title="float.fromhex"><code class="xref py py-meth docutils literal"><span class="pre">float.fromhex()</span></code></a>接受。</span></p><p><span class="yiyi-st" id="yiyi-255">请注意，指数是用十进制而不是十六进制编写的，它给出了乘以系数的2的幂。</span><span class="yiyi-st" id="yiyi-256">例如，十六进制的字符串<code class="docutils literal"><span class="pre">0x3.a7p10</span></code>表示浮点数(<code class="docutils literal"><span class="pre">3</span> <span class="pre">+</span> <span class="pre">10./16</span> <span class="pre">+</span> <span class="pre">7./16**2)</span> <span class="pre">*</span> <span class="pre">2.0**10</span></code>，或<code class="docutils literal"><span class="pre">3740.0</span></code>：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">'0x3.a7p10'</span><span class="p">)</span>
<span class="go">3740.0</span>
</code></pre><p><span class="yiyi-st" id="yiyi-257">将反向转换应用于<code class="docutils literal"><span class="pre">3740.0</span></code>将给出表示相同数字的不同十六进制字符串：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="o">.</span><span class="n">hex</span><span class="p">(</span><span class="mf">3740.0</span><span class="p">)</span>
<span class="go">'0x1.d380000000000p+11'</span>
</code></pre></div><div class="section" id="hashing-of-numeric-types"><h3><span class="yiyi-st" id="yiyi-258">4.4.4.</span><span class="yiyi-st" id="yiyi-259">数字类型的散列</span></h3><p><span class="yiyi-st" id="yiyi-260">对于可能是不同类型的数字<code class="docutils literal"><span class="pre">x</span></code>和<code class="docutils literal"><span class="pre">y</span></code>，当<code class="docutils literal"><span class="pre">hash(x)</span><span class="pre">==</span><span class="pre">hash(y)</span></code>时<code class="docutils literal"><span class="pre">x</span><span class="pre">==</span><span class="pre">y</span></code>，（有关更多详细信息，请参阅<a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a>方法文档）。</span><span class="yiyi-st" id="yiyi-261">For ease of implementation and efficiency across a variety of numeric types (including <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>, <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">decimal.Decimal</span></code></a> and <a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal"><span class="pre">fractions.Fraction</span></code></a>) Python’s hash for numeric types is based on a single mathematical function that’s defined for any rational number, and hence applies to all instances of <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> and <a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal"><span class="pre">fractions.Fraction</span></code></a>, and all finite instances of <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> and <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">decimal.Decimal</span></code></a>. </span><span class="yiyi-st" id="yiyi-262">本质上，对于固定素数<code class="docutils literal"><span class="pre">P</span></code>，这个函数是通过对<code class="docutils literal"><span class="pre">P</span></code>进行模减行给出的。 <code class="docutils literal"><span class="pre">P</span></code>的值作为<a class="reference internal" href="sys.html#sys.hash_info" title="sys.hash_info"><code class="xref py py-data docutils literal"><span class="pre">sys.hash_info</span></code></a>的<code class="xref py py-attr docutils literal"><span class="pre">modulus</span></code>属性提供给Python。</span></p><div class="impl-detail compound"><p><span class="yiyi-st" id="yiyi-263"><strong>CPython implementation detail:</strong> Currently, the prime used is <code class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">2**31</span> <span class="pre">-</span> <span class="pre">1</span></code> on machines with 32-bit C longs and <code class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">2**61</span> <span class="pre">-</span> <span class="pre">1</span></code> on machines with 64-bit C longs.</span></p></div><p><span class="yiyi-st" id="yiyi-264">详细规则如下：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-265">If <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">/</span> <span class="pre">n</span></code> is a nonnegative rational number and <code class="docutils literal"><span class="pre">n</span></code> is not divisible by <code class="docutils literal"><span class="pre">P</span></code>, define <code class="docutils literal"><span class="pre">hash(x)</span></code> as <code class="docutils literal"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">invmod(n,</span> <span class="pre">P)</span> <span class="pre">%</span> <span class="pre">P</span></code>, where <code class="docutils literal"><span class="pre">invmod(n,</span> <span class="pre">P)</span></code> gives the inverse of <code class="docutils literal"><span class="pre">n</span></code> modulo <code class="docutils literal"><span class="pre">P</span></code>.</span></li><li><span class="yiyi-st" id="yiyi-266">If <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">/</span> <span class="pre">n</span></code> is a nonnegative rational number and <code class="docutils literal"><span class="pre">n</span></code> is divisible by <code class="docutils literal"><span class="pre">P</span></code> (but <code class="docutils literal"><span class="pre">m</span></code> is not) then <code class="docutils literal"><span class="pre">n</span></code> has no inverse modulo <code class="docutils literal"><span class="pre">P</span></code> and the rule above doesn’t apply; in this case define <code class="docutils literal"><span class="pre">hash(x)</span></code> to be the constant value <code class="docutils literal"><span class="pre">sys.hash_info.inf</span></code>.</span></li><li><span class="yiyi-st" id="yiyi-267">If <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">/</span> <span class="pre">n</span></code> is a negative rational number define <code class="docutils literal"><span class="pre">hash(x)</span></code> as <code class="docutils literal"><span class="pre">-hash(-x)</span></code>. </span><span class="yiyi-st" id="yiyi-268">如果结果散列是<code class="docutils literal"><span class="pre">-1</span></code>，则用<code class="docutils literal"><span class="pre">-2</span></code>替换它。</span></li><li><span class="yiyi-st" id="yiyi-269">特定值<code class="docutils literal"><span class="pre">sys.hash_info.inf</span></code>，<code class="docutils literal"><span class="pre">-sys.hash_info.inf</span></code>和<code class="docutils literal"><span class="pre">sys.hash_info.nan</span></code>用作正无限的散列值，负无穷或者nans（分别）。</span><span class="yiyi-st" id="yiyi-270">（所有可散列的nans具有相同的散列值。）</span></li><li><span class="yiyi-st" id="yiyi-271">For a <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal"><span class="pre">complex</span></code></a> number <code class="docutils literal"><span class="pre">z</span></code>, the hash values of the real and imaginary parts are combined by computing <code class="docutils literal"><span class="pre">hash(z.real)</span> <span class="pre">+</span> <span class="pre">sys.hash_info.imag</span> <span class="pre">*</span> <span class="pre">hash(z.imag)</span></code>, reduced modulo <code class="docutils literal"><span class="pre">2**sys.hash_info.width</span></code> so that it lies in <code class="docutils literal"><span class="pre">range(-2**(sys.hash_info.width</span> <span class="pre">-</span> <span class="pre">1),</span> <span class="pre">2**(sys.hash_info.width</span> <span class="pre">-</span> <span class="pre">1))</span></code>. </span><span class="yiyi-st" id="yiyi-272">同样，如果结果是<code class="docutils literal"><span class="pre">-1</span></code>，它将被替换为<code class="docutils literal"><span class="pre">-2</span></code>。</span></li></ul><p><span class="yiyi-st" id="yiyi-273">为了澄清上述规则，下面是一些用于计算有理数，<a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>或<a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal"><span class="pre">complex</span></code></a>的哈希的Python代码示例，相当于内置哈希：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">hash_fraction</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">"""Compute the hash of a rational number m / n.</span>

<span class="sd">    Assumes m and n are integers, with n positive.</span>
<span class="sd">    Equivalent to hash(fractions.Fraction(m, n)).</span>

<span class="sd">    """</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">modulus</span>
    <span class="c1"># Remove common factors of P.  (Unnecessary if m and n already coprime.)</span>
    <span class="k">while</span> <span class="n">m</span> <span class="o">%</span> <span class="n">P</span> <span class="o">==</span> <span class="n">n</span> <span class="o">%</span> <span class="n">P</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m</span> <span class="o">//</span> <span class="n">P</span><span class="p">,</span> <span class="n">n</span> <span class="o">//</span> <span class="n">P</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">P</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Fermat's Little Theorem: pow(n, P-1, P) is 1, so</span>
        <span class="c1"># pow(n, P-2, P) gives the inverse of n modulo P.</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">%</span> <span class="n">P</span><span class="p">)</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">P</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span> <span class="o">%</span> <span class="n">P</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="o">-</span><span class="n">hash_value</span>
    <span class="k">if</span> <span class="n">hash_value</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">hash_value</span>

<span class="k">def</span> <span class="nf">hash_float</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">"""Compute the hash of a float x."""</span>

    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">elif</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hash_fraction</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">hash_complex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="sd">"""Compute the hash of a complex number z."""</span>

    <span class="n">hash_value</span> <span class="o">=</span> <span class="n">hash_float</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">hash_float</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
    <span class="c1"># do a signed reduction modulo 2**sys.hash_info.width</span>
    <span class="n">M</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">hash_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash_value</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">hash_value</span> <span class="o">&amp;</span> <span class="n">M</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hash_value</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">hash_value</span>
</code></pre></div></div><div class="section" id="iterator-types"><h2><span class="yiyi-st" id="yiyi-274">4.5.</span><span class="yiyi-st" id="yiyi-275"> 迭代器类型</span></h2><p id="index-18"><span class="yiyi-st" id="yiyi-276">Python支持对容器进行迭代的概念。</span><span class="yiyi-st" id="yiyi-277">它使用两种不同的方法实现；它们用于允许用户定义的类支持迭代。</span><span class="yiyi-st" id="yiyi-278">序列总是支持迭代，更多细节后面描述。</span></p><p><span class="yiyi-st" id="yiyi-279">容器对象若要提供迭代支持，需要定义一个方法：</span></p><dl class="method"><dt id="container.__iter__"><span class="yiyi-st" id="yiyi-280"><code class="descclassname">container.</code><code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-281">返回一个迭代器对象。</span><span class="yiyi-st" id="yiyi-282">该对象需要支持下面描述的迭代器协议。</span><span class="yiyi-st" id="yiyi-283">如果容器支持不同类型的迭代，可以提供其他方法来专门请求这些迭代类型的迭代器。</span><span class="yiyi-st" id="yiyi-284">（支持多种迭代形式的对象的一个​​例子是支持宽度优先和深度优先遍历的树结构。）</span><span class="yiyi-st" id="yiyi-285">此方法对应于Python/C API中Python对象的类型结构的<a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal"><span class="pre">tp_iter</span></code></a>槽。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-286">迭代器对象本身需要支持以下两种方法，它们一起形成<em class="dfn">迭代器协议</em>：</span></p><dl class="method"><dt id="iterator.__iter__"><span class="yiyi-st" id="yiyi-287"><code class="descclassname">iterator.</code><code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-288">返回迭代器对象本身。</span><span class="yiyi-st" id="yiyi-289">它是必需的，以允许容器和迭代器在<a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a>和<a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a>语句中使用。</span><span class="yiyi-st" id="yiyi-290">此方法对应于Python/C API中Python对象的类型结构的<a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal"><span class="pre">tp_iter</span></code></a>槽。</span></p></dd></dl><dl class="method"><dt id="iterator.__next__"><span class="yiyi-st" id="yiyi-291"><code class="descclassname">iterator.</code><code class="descname">__next__</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-292">从容器中返回下一个项目。</span><span class="yiyi-st" id="yiyi-293">如果没有其他元素，则引发<a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a>异常。</span><span class="yiyi-st" id="yiyi-294">此方法对应于Python/C API中Python对象的类型结构的<a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal"><span class="pre">tp_iternext</span></code></a>槽。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-295">Python定义了多个迭代器对象以支持对一般和特定序列类型、字典和其他更专门的形式的迭代。</span><span class="yiyi-st" id="yiyi-296">除了迭代器协议的实现之外，特定类型并不重要。</span></p><p><span class="yiyi-st" id="yiyi-297">一旦迭代器的<a class="reference internal" href="#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__</span></code></a>方法引发<a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a>，它必须在后续调用中继续引发这个异常。</span><span class="yiyi-st" id="yiyi-298">不遵守此属性的实现视为不正确的。</span></p><div class="section" id="generator-types"><h3><span class="yiyi-st" id="yiyi-299">4.5.1.</span><span class="yiyi-st" id="yiyi-300"> 生成器类型</span></h3><p><span class="yiyi-st" id="yiyi-301">Python的<a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">生成器</span></a>提供了一种方便的方法来实现迭代器协议。</span><span class="yiyi-st" id="yiyi-302">如果容器对象的<a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a>方法被实现为生成器，它将自动返回提供<a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a>和<a class="reference internal" href="../reference/expressions.html#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a>方法的迭代器对象（技术上是一个生成器对象）。</span><span class="yiyi-st" id="yiyi-303">有关生成器的更多信息，请参见<a class="reference internal" href="../reference/expressions.html#yieldexpr"><span>yield表达式</span></a>的文档。</span></p></div></div><div class="section" id="sequence-types-list-tuple-range"><h2><span class="yiyi-st" id="yiyi-304">4.6.</span><span class="yiyi-st" id="yiyi-305">序列 — <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>, <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>, <a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a></span></h2><p><span class="yiyi-st" id="yiyi-306">以下是三个基本的序列类型: lists, tuples, 以及range.</span><span class="yiyi-st" id="yiyi-307">在专用章节中描述了为处理<a class="reference internal" href="#binaryseq"><span>二进制数据</span></a>和<a class="reference internal" href="#textseq"><span>文本字符串</span></a>而定制的其他序列类型。</span></p><div class="section" id="common-sequence-operations"><h3><span class="yiyi-st" id="yiyi-308">4.6.1.</span><span class="yiyi-st" id="yiyi-309">通用序列操作</span></h3><p id="index-19"><span class="yiyi-st" id="yiyi-310">大多数序列类型（包括可变序列和不可变序列）都支持下面表个中的操作。</span><span class="yiyi-st" id="yiyi-311">提供了<a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Sequence</span></code></a> ABC，以便更容易在自定义序列类型上正确实现这些操作。</span></p><p><span class="yiyi-st" id="yiyi-312">此表按照优先级升序列出了序列类型的操作。</span><span class="yiyi-st" id="yiyi-313">在表中，<em>s</em>和<em>t</em>是相同类型的序列，<em>n</em>，<em>i</em>，<em>j </em>和<em>k</em>是整数，<em>x</em>是满足<em>s</em>强加的任何类型和值限制的任意对象。</span></p><p><span class="yiyi-st" id="yiyi-314">The <code class="docutils literal"><span class="pre">in</span></code> and <code class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></code> operations have the same priorities as the comparison operations. </span><span class="yiyi-st" id="yiyi-315"><code class="docutils literal"><span class="pre">+</span></code>（连接）和<code class="docutils literal"><span class="pre">*</span></code>（重复）操作具有与相应数值操作相同的优先级。</span></p><table border="1" class="docutils" id="index-20"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-316">操作</span></th><th class="head"><span class="yiyi-st" id="yiyi-317">结果</span></th><th class="head"><span class="yiyi-st" id="yiyi-318">笔记</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-319"><code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code></span></td><td><span class="yiyi-st" id="yiyi-320">如果<em>s</em>包含<em>x</em>，返回<code class="docutils literal"><span class="pre">True</span></code>，否则返回<code class="docutils literal"><span class="pre">False</span></code></span></td><td><span class="yiyi-st" id="yiyi-321">（1）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-322"><code class="docutils literal"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></code></span></td><td><span class="yiyi-st" id="yiyi-323">如果<em>s</em>包含<em>x</em>，返回<code class="docutils literal"><span class="pre">False</span></code>，否则返回<code class="docutils literal"><span class="pre">True</span></code></span></td><td><span class="yiyi-st" id="yiyi-324">（1）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-325"><code class="docutils literal"><span class="pre">s</span> <span class="pre">+</span> <span class="pre">t</span></code></span></td><td><span class="yiyi-st" id="yiyi-326"><em>s</em>和<em>t</em>的连接操作</span></td><td><span class="yiyi-st" id="yiyi-327">（6）（7）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-328"><code class="docutils literal"><span class="pre">s</span> <span class="pre">*</span> <span class="pre">n</span></code> or <code class="docutils literal"><span class="pre">n</span> <span class="pre">*</span> <span class="pre">s</span></code></span></td><td><span class="yiyi-st" id="yiyi-329">相当于将<em>s</em>添加到自身<em>n</em>次</span></td><td><span class="yiyi-st" id="yiyi-330">（2）（7）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-331"><code class="docutils literal"><span class="pre">s[i]</span></code></span></td><td><span class="yiyi-st" id="yiyi-332"><em>s</em>的第<em>i</em>项，从第0项开始</span></td><td><span class="yiyi-st" id="yiyi-333">（3）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-334"><code class="docutils literal"><span class="pre">s[i:j]</span></code></span></td><td><span class="yiyi-st" id="yiyi-335"><em>s</em>的从第<em>i</em>项到第<em>j-1</em>项</span></td><td><span class="yiyi-st" id="yiyi-336">（3）（4）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-337"><code class="docutils literal"><span class="pre">s[i:j:k]</span></code></span></td><td><span class="yiyi-st" id="yiyi-338"><em>s</em>的从第<em>i</em>项到第<em>j-1</em>项,间隔为<em>k</em></span></td><td><span class="yiyi-st" id="yiyi-339">（3）（5）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-340"><code class="docutils literal"><span class="pre">len(s)</span></code></span></td><td><span class="yiyi-st" id="yiyi-341"><em>s</em>的长度</span></td><td></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-342"><code class="docutils literal"><span class="pre">min(s)</span></code></span></td><td><span class="yiyi-st" id="yiyi-343">最小的项目<em>s</em></span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-344"><code class="docutils literal"><span class="pre">max(s)</span></code></span></td><td><span class="yiyi-st" id="yiyi-345">最大的项目<em>s</em></span></td><td></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-346"><code class="docutils literal"><span class="pre">s.index（x [，</span> <span class="pre">i [，</span> <span class="pre">j]]）</span></code></span></td><td><span class="yiyi-st" id="yiyi-347">index of the first occurrence of <em>x</em> in <em>s</em> (at or after index <em>i</em> and before index <em>j</em>)</span></td><td><span class="yiyi-st" id="yiyi-348">（8）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-349"><code class="docutils literal"><span class="pre">s.count(x)</span></code></span></td><td><span class="yiyi-st" id="yiyi-350"><em>s</em>中出现<em>x</em>的总次数</span></td><td></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-351">相同类型的序列也支持比较。</span><span class="yiyi-st" id="yiyi-352">具体来说，元组和列表通过比较相应的元素按字典顺序进行比较。</span><span class="yiyi-st" id="yiyi-353">这意味着为了比较相等，每个元素必须相等并且两个序列必须是相同类型并具有相同长度。</span><span class="yiyi-st" id="yiyi-354">(For full details see <a class="reference internal" href="../reference/expressions.html#comparisons"><span>Comparisons</span></a> in the language reference.)</span></p><p><span class="yiyi-st" id="yiyi-355">笔记：</span></p><ol class="arabic"><li><p class="first"><span class="yiyi-st" id="yiyi-356">虽然 <code class="docutils literal"><span class="pre">in</span></code> 和 <code class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></code> 操作仅用于一般情况下的简单遏制测试, some specialised sequences (such as <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>, <a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> and <a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>) also use them for subsequence testing:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">"gg"</span> <span class="ow">in</span> <span class="s2">"eggs"</span>
<span class="go">True</span>
</code></pre></li><li><p class="first"><span class="yiyi-st" id="yiyi-357"><em>n</em>小于<code class="docutils literal"><span class="pre">0</span></code>的值被视为<code class="docutils literal"><span class="pre">0</span></code>（产生与<em>s</em> ）。</span><span class="yiyi-st" id="yiyi-358">请注意，序列<em>s</em>中的项目不会被复制；它们被多次引用。</span><span class="yiyi-st" id="yiyi-359">这经常困扰着新的Python程序员；考虑：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="o">*</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[], [], []]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[3], [3], [3]]</span>
</code></pre><p><span class="yiyi-st" id="yiyi-360">发生的事情是<code class="docutils literal"><span class="pre">[[]]</span></code>是包含空列表的单元素列表，所以<code class="docutils literal"><span class="pre">[[]]</span> <span class="pre">*  tt&gt; <span class="pre">3</span></span></code>是对单个空列表的引用。</span><span class="yiyi-st" id="yiyi-361">修改<code class="docutils literal"><span class="pre">lists</span></code>都会修改此单个列表。</span><span class="yiyi-st" id="yiyi-362">您可以通过以下方式创建不同列表的列表：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[3], [5], [7]]</span>
</code></pre><p><span class="yiyi-st" id="yiyi-363">有关详细说明，请参阅常见问题解答条目<a class="reference internal" href="../faq/programming.html#faq-multidimensional-list"><span>如何创建多维列表?</span></a>。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-364">If <em>i</em> or <em>j</em> is negative, the index is relative to the end of the string: <code class="docutils literal"><span class="pre">len(s)</span> <span class="pre">+</span> <span class="pre">i</span></code> or <code class="docutils literal"><span class="pre">len(s)</span> <span class="pre">+</span> <span class="pre">j</span></code> is substituted. </span><span class="yiyi-st" id="yiyi-365">但请注意，<code class="docutils literal"><span class="pre">-0</span></code>仍然是<code class="docutils literal"><span class="pre">0</span></code>。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-366">The slice of <em>s</em> from <em>i</em> to <em>j</em> is defined as the sequence of items with index <em>k</em> such that <code class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>. </span><span class="yiyi-st" id="yiyi-367">如果<em>i</em>或<em>j</em>大于<code class="docutils literal"><span class="pre">len(s)</span></code>，请使用<code class="docutils literal"><span class="pre">len(s)</span></code>。</span><span class="yiyi-st" id="yiyi-368">如果省略<em>i</em>或<code class="docutils literal"><span class="pre">None</span></code>，请使用<code class="docutils literal"><span class="pre">0</span></code>。</span><span class="yiyi-st" id="yiyi-369">如果省略<em>j</em>或<code class="docutils literal"><span class="pre">None</span></code>，请使用<code class="docutils literal"><span class="pre">len(s)</span></code>。</span><span class="yiyi-st" id="yiyi-370">如果<em>i</em>大于或等于<em>j</em>，则切片为空。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-371">The slice of <em>s</em> from <em>i</em> to <em>j</em> with step <em>k</em> is defined as the sequence of items with index <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></code> such that <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">(j-i)/k</span></code>. </span><span class="yiyi-st" id="yiyi-372">In other words, the indices are <code class="docutils literal"><span class="pre">i</span></code>, <code class="docutils literal"><span class="pre">i+k</span></code>, <code class="docutils literal"><span class="pre">i+2*k</span></code>, <code class="docutils literal"><span class="pre">i+3*k</span></code> and so on, stopping when <em>j</em> is reached (but never including <em>j</em>). </span><span class="yiyi-st" id="yiyi-373">如果<em>i</em>或<em>j</em>大于<code class="docutils literal"><span class="pre">len(s)</span></code>，请使用<code class="docutils literal"><span class="pre">len(s)</span></code>。</span><span class="yiyi-st" id="yiyi-374">如果省略<em>i</em>或<em>j</em>或<code class="docutils literal"><span class="pre">None</span></code>，它们将变成“结束”值（其结束取决于<em>k &lt; T4&gt;）。</em></span><span class="yiyi-st" id="yiyi-375">请注意，<em>k</em>不能为零。</span><span class="yiyi-st" id="yiyi-376">如果<em>k</em>为<code class="docutils literal"><span class="pre">None</span></code>，则将其视为<code class="docutils literal"><span class="pre">1</span></code>。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-377">串联不可变序列总是会产生一个新对象。</span><span class="yiyi-st" id="yiyi-378">这意味着通过重复串联构建序列在总序列长度中将具有二次运行成本。</span><span class="yiyi-st" id="yiyi-379">要获得线性运行时成本，您必须切换到以下选项之一：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-380">如果连接<a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>对象，则可以构建列表并在末尾使用<a class="reference internal" href="#str.join" title="str.join"><code class="xref py py-meth docutils literal"><span class="pre">str.join()</span></code></a>，否则写入<a class="reference internal" href="io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">io.StringIO</span></code></a>实例并在完成时检索其值</span></li><li><span class="yiyi-st" id="yiyi-381">if concatenating <a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> objects, you can similarly use <a class="reference internal" href="#bytes.join" title="bytes.join"><code class="xref py py-meth docutils literal"><span class="pre">bytes.join()</span></code></a> or <a class="reference internal" href="io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal"><span class="pre">io.BytesIO</span></code></a>, or you can do in-place concatenation with a <a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> object. </span><span class="yiyi-st" id="yiyi-382"><a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> objects are mutable and have an efficient overallocation mechanism</span></li><li><span class="yiyi-st" id="yiyi-383">如果串联<a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>对象，请改为扩展<a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a></span></li><li><span class="yiyi-st" id="yiyi-384">对于其他类型，请查看相关的类文档</span></li></ul></li><li><p class="first"><span class="yiyi-st" id="yiyi-385">一些序列类型（如<a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a>）仅支持遵循特定模式的项目序列，因此不支持序列连接或重复。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-386"><em>x</em>在<em>s</em>中找不到<code class="docutils literal"><span class="pre">index</span></code>会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。支持时，index方法的附加参数允许有效地搜索序列的子部分。</span><span class="yiyi-st" id="yiyi-387">传递额外的参数大致相当于使用<code class="docutils literal"><span class="pre">s[i:j].index(x)</span></code>，只是不复制任何数据并且返回的索引是相对于序列的开始而不是开始切片。</span></p></li></ol></div><div class="section" id="immutable-sequence-types"><h3><span class="yiyi-st" id="yiyi-388">4.6.2.</span><span class="yiyi-st" id="yiyi-389">不可变序列类型</span></h3><p id="index-21"><span class="yiyi-st" id="yiyi-390">对于不可变序列类型通常实现的唯一操作也不能通过可变序列类型实现，这是对<a class="reference internal" href="functions.html#hash" title="hash"><code class="xref py py-func docutils literal"><span class="pre">hash()</span></code></a>内置的支持。</span></p><p><span class="yiyi-st" id="yiyi-391">此支持允许将不可变序列（如<a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>实例）用作<a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>键并存储在<a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>和<a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a></span></p><p><span class="yiyi-st" id="yiyi-392">尝试散列包含不可取值的不可变序列将导致<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span></p></div><div class="section" id="mutable-sequence-types"><h3><span class="yiyi-st" id="yiyi-393">4.6.3.</span><span class="yiyi-st" id="yiyi-394">可变序列类型</span></h3><p id="index-22"><span class="yiyi-st" id="yiyi-395">下表中的操作定义在可变序列类型上。</span><span class="yiyi-st" id="yiyi-396">提供<a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.MutableSequence</span></code></a> ABC是为了更容易在自定义序列类型上正确实现这些操作。</span></p><p><span class="yiyi-st" id="yiyi-397">In the table <em>s</em> is an instance of a mutable sequence type, <em>t</em> is any iterable object and <em>x</em> is an arbitrary object that meets any type and value restrictions imposed by <em>s</em> (for example, <a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> only accepts integers that meet the value restriction <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">255</span></code>).</span></p><table border="1" class="docutils" id="index-23"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-398">操作</span></th><th class="head"><span class="yiyi-st" id="yiyi-399">结果</span></th><th class="head"><span class="yiyi-st" id="yiyi-400">笔记</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-401"><code class="docutils literal"><span class="pre">s[i]</span> <span class="pre">=</span> <span class="pre">x</span></code></span></td><td><span class="yiyi-st" id="yiyi-402"><em>s</em>的项目<em>i</em>被替换为<em>x</em></span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-403"><code class="docutils literal"><span class="pre">s[i:j]</span> <span class="pre">=</span> <span class="pre">t</span></code></span></td><td><span class="yiyi-st" id="yiyi-404">从<em>i</em>到<em>j</em>的<em>s</em>片段被可迭代的<em>t</em></span></td><td></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-405"><code class="docutils literal"><span class="pre">del</span> <span class="pre">s[i:j]</span></code></span></td><td><span class="yiyi-st" id="yiyi-406">与<code class="docutils literal"><span class="pre">s [i：j]</span> <span class="pre">=</span> <span class="pre">[]</span></code>相同</span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-407"><code class="docutils literal"><span class="pre">s[i:j:k]</span> <span class="pre">=</span> <span class="pre">t</span></code></span></td><td><span class="yiyi-st" id="yiyi-408"><code class="docutils literal"><span class="pre">s[i:j:k]</span></code>的元素被<em>t</em>取代</span></td><td><span class="yiyi-st" id="yiyi-409">（1）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-410"><code class="docutils literal"><span class="pre">del</span> <span class="pre">s[i:j:k]</span></code></span></td><td><span class="yiyi-st" id="yiyi-411">从列表中删除<code class="docutils literal"><span class="pre">s[i:j:k]</span></code>的元素</span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-412"><code class="docutils literal"><span class="pre">s.append(x)</span></code></span></td><td><span class="yiyi-st" id="yiyi-413">将<em>x</em>追加到序列的末尾（与<code class="docutils literal"><span class="pre">s [len（s）：len（s）]</span> <span class="pre">=</span> <span class="pre">[x]</span></code>）</span></td><td></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-414"><code class="docutils literal"><span class="pre">s.clear()</span></code></span></td><td><span class="yiyi-st" id="yiyi-415">删除<code class="docutils literal"><span class="pre">s</span></code>中的所有项目（与<code class="docutils literal"><span class="pre">del</span> <span class="pre">s [：]</span></code>相同）</span></td><td><span class="yiyi-st" id="yiyi-416">（5）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-417"><code class="docutils literal"><span class="pre">s.copy()</span></code></span></td><td><span class="yiyi-st" id="yiyi-418">创建<code class="docutils literal"><span class="pre">s</span></code>的浅拷贝（与<code class="docutils literal"><span class="pre">s[:]</span></code>相同）</span></td><td><span class="yiyi-st" id="yiyi-419">（5）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-420"><code class="docutils literal"><span class="pre">s.extend(t)</span></code> 或 <code class="docutils literal"><span class="pre">s</span> <span class="pre">+=</span> <span class="pre">t</span></code></span></td><td><span class="yiyi-st" id="yiyi-421">extends <em>s</em> with the contents of <em>t</em> (for the most part the same as <code class="docutils literal"><span class="pre">s[len(s):len(s)]</span> <span class="pre">=</span> <span class="pre">t</span></code>)</span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-422"><code class="docutils literal"><span class="pre">s</span> <span class="pre">*=</span> <span class="pre">n</span></code></span></td><td><span class="yiyi-st" id="yiyi-423">更新<em>s</em>，其内容重复<em>n</em>次</span></td><td><span class="yiyi-st" id="yiyi-424">（6）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-425"><code class="docutils literal"><span class="pre">s.insert(i,</span> <span class="pre">x)</span></code></span></td><td><span class="yiyi-st" id="yiyi-426">inserts <em>x</em> into <em>s</em> at the index given by <em>i</em> (same as <code class="docutils literal"><span class="pre">s[i:i]</span> <span class="pre">=</span> <span class="pre">[x]</span></code>)</span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-427"><code class="docutils literal"><span class="pre">s.pop([i])</span></code></span></td><td><span class="yiyi-st" id="yiyi-428">在<em>i</em>中检索该项目，并将其从<em>s</em>中删除</span></td><td><span class="yiyi-st" id="yiyi-429">（2）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-430"><code class="docutils literal"><span class="pre">s.remove(x)</span></code></span></td><td><span class="yiyi-st" id="yiyi-431">remove the first item from <em>s</em> where <code class="docutils literal"><span class="pre">s[i]</span> <span class="pre">==</span> <span class="pre">x</span></code></span></td><td><span class="yiyi-st" id="yiyi-432">（3）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-433"><code class="docutils literal"><span class="pre">s.reverse()</span></code></span></td><td><span class="yiyi-st" id="yiyi-434">反转<em>s</em>的项目</span></td><td><span class="yiyi-st" id="yiyi-435">（4）</span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-436">笔记：</span></p><ol class="arabic"><li><p class="first"><span class="yiyi-st" id="yiyi-437"><em>t</em>的长度必须与正在替换的切片长度相同。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-438">可选参数<em>i</em>默认为<code class="docutils literal"><span class="pre">-1</span></code>，因此默认情况下最后一项将被删除并返回。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-439"><em>x</em>在<em>s</em>中找不到<code class="docutils literal"><span class="pre">remove</span></code>会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-440">在逆向大序列时，<code class="xref py py-meth docutils literal"><span class="pre">reverse()</span></code>方法修改空间节约的序列。</span><span class="yiyi-st" id="yiyi-441">要提醒用户它是以副作用方式运行的，它不会返回相反的顺序。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-442">包括<code class="xref py py-meth docutils literal"><span class="pre">clear()</span></code>和<code class="xref py py-meth docutils literal"><span class="pre">copy()</span></code>以便与不支持切片操作的可变容器（例如<a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>和<a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a></span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-443"><span class="versionmodified">版本3.3新增：</span> <code class="xref py py-meth docutils literal"><span class="pre">clear()</span></code>和<code class="xref py py-meth docutils literal"><span class="pre">copy()</span></code>方法。</span></p></div></li><li><p class="first"><span class="yiyi-st" id="yiyi-444">值<em>n</em>是一个整数或实现<a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">__index__()</span></code></a>的对象。</span><span class="yiyi-st" id="yiyi-445"><em>n</em>的零和负值清除序列。</span><span class="yiyi-st" id="yiyi-446">序列中的项目不会被复制；它们被多次引用，如<a class="reference internal" href="#typesseq-common"><span>Common Sequence Operations</span></a>中<code class="docutils literal"><span class="pre">s</span> <span class="pre">*</span> <span class="pre">n</span></code> &gt;。</span></p></li></ol></div><div class="section" id="lists"><h3><span class="yiyi-st" id="yiyi-447">4.6.4.</span><span class="yiyi-st" id="yiyi-448">列表</span></h3><p id="index-24"><span class="yiyi-st" id="yiyi-449">列表是可变序列，通常用于存储同类项目的集合（其中精确的相似度因应用程序而异）。</span></p><dl class="class"><dt id="list"><span class="yiyi-st" id="yiyi-450"><em class="property">class </em><code class="descname">list</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-451">列表可以用几种方式构建：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-452">用一对方括号表示空列表：<code class="docutils literal"><span class="pre">[]</span></code></span></li><li><span class="yiyi-st" id="yiyi-453">使用方括号，用逗号分隔项目<code class="docutils literal"><span class="pre">[a]</span></code>, <code class="docutils literal"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c]</span></code></span></li><li><span class="yiyi-st" id="yiyi-454">使用列表推导式： <code class="docutils literal"><span class="pre">[x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">iterable]</span></code></span></li><li><span class="yiyi-st" id="yiyi-455">使用类型构造函数：<code class="docutils literal"><span class="pre">list()</span></code>或<code class="docutils literal"><span class="pre">list(iterable)</span></code></span></li></ul><p><span class="yiyi-st" id="yiyi-456">构造器会建立一个和<em>iterable</em>同样顺序和元素的列表.</span><span class="yiyi-st" id="yiyi-457"><em>iterable</em>可以是序列，支持迭代的容器或迭代器对象。</span><span class="yiyi-st" id="yiyi-458">如果<em>iterable</em>已经是一个列表，那么会创建并返回一个副本，类似于<code class="docutils literal"><span class="pre">iterable[:]</span></code>。</span><span class="yiyi-st" id="yiyi-459">例如，<code class="docutils literal"><span class="pre">list('abc')</span></code>返回<code class="docutils literal"><span class="pre">['a'，</span> <span class="pre">'b'，</span> <span class="pre">'c']  t&gt;&gt;</span></code>和<span class="pre"><span class="pre">list</span> <span class="pre">（1，<span class="pre"><span class="pre">2，<span class="pre"><span class="pre">3）</span> t11&gt;）返回<span class="pre">[1，</span> <span class="pre">2，</span> <span class="pre">3]</span>。</span></span></span></span></span></span><span class="yiyi-st" id="yiyi-460">如果没有给出参数，构造函数会创建一个新的空列表<code class="docutils literal"><span class="pre">[]</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-461">许多其他操作也会产生列表，包括<a class="reference internal" href="functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal"><span class="pre">sorted()</span></code></a>内置。</span></p><p><span class="yiyi-st" id="yiyi-462">列出所有的<a class="reference internal" href="#typesseq-common"><span>common</span></a>和<a class="reference internal" href="#typesseq-mutable"><span>mutable</span></a>序列操作。</span><span class="yiyi-st" id="yiyi-463">列表还提供了以下附加方法：</span></p><dl class="method"><dt id="list.sort"><span class="yiyi-st" id="yiyi-464"><code class="descname">sort</code><span class="sig-paren">(</span><em>*</em>, <em>key=None</em>, <em>reverse=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-465">此方法仅使用元素之间的<code class="docutils literal"><span class="pre">&lt;</span></code>比较对列表进行原地排序。</span><span class="yiyi-st" id="yiyi-466">异常不会被抑制 - 如果任何比较操作失败，整个排序操作将失败（并且列表可能会保持部分修改状态）。</span></p><p><span class="yiyi-st" id="yiyi-467"><a class="reference internal" href="#list.sort" title="list.sort"><code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code></a>接受只能通过关键字（<a class="reference internal" href="../glossary.html#keyword-only-parameter"><span>仅限关键字的参数</span></a>）传递的两个参数：</span></p><p><span class="yiyi-st" id="yiyi-468"><em>key</em>指定用于从每个列表元素（例如，<code class="docutils literal"><span class="pre">key=str.lower</span></code>）提取比较键的一个参数的函数。</span><span class="yiyi-st" id="yiyi-469">与列表中的每个项目相对应的键将被计算一次，然后用于整个排序过程。</span><span class="yiyi-st" id="yiyi-470"><code class="docutils literal"><span class="pre">None</span></code>的默认值意味着列表项目直接排序而不计算单独的键值。</span></p><p><span class="yiyi-st" id="yiyi-471"><a class="reference internal" href="functools.html#functools.cmp_to_key" title="functools.cmp_to_key"><code class="xref py py-func docutils literal"><span class="pre">functools.cmp_to_key()</span></code></a>实用程序可用于将2.x样式的<em>cmp</em>函数转换为<em>键</em>函数。</span></p><p><span class="yiyi-st" id="yiyi-472"><em>反向</em>是一个布尔值。</span><span class="yiyi-st" id="yiyi-473">如果设置为<code class="docutils literal"><span class="pre">True</span></code>，那么列表中元素反过来比较来排序。</span></p><p><span class="yiyi-st" id="yiyi-474">这种方法在排序大序列时修改空间经济的序列。</span><span class="yiyi-st" id="yiyi-475">为了提醒用户它以副作用的方式运行，它不会返回排序的序列（使用<a class="reference internal" href="functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal"><span class="pre">sorted()</span></code></a>显式请求一个新的排序列表实例）。</span></p><p><span class="yiyi-st" id="yiyi-476"><a class="reference internal" href="#list.sort" title="list.sort"><code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code></a>方法保证稳定。</span><span class="yiyi-st" id="yiyi-477">如果确保不会更改比较相等的元素的相对顺序，则排序是稳定的 - 这对于多次排序（例如，按部门排序，然后按薪级）进行排序很有帮助。</span></p><div class="impl-detail compound"><p><span class="yiyi-st" id="yiyi-478"><strong>CPython implementation detail:</strong> While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. </span><span class="yiyi-st" id="yiyi-479">Python的C实现使得列表在持续时间内显示为空，并且如果它能够检测列表在排序过程中发生了变异，则会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p></div></dd></dl></dd></dl></div><div class="section" id="tuples"><h3><span class="yiyi-st" id="yiyi-480">4.6.5.</span><span class="yiyi-st" id="yiyi-481">元组</span></h3><p id="index-25"><span class="yiyi-st" id="yiyi-482">元组是不变序列，通常用于存储异构数据的容器（例如由内置的<a class="reference internal" href="functions.html#enumerate" title="enumerate"><code class="xref py py-func docutils literal"><span class="pre">枚举()</span></code></a>生成的2元组）。</span><span class="yiyi-st" id="yiyi-483">元组还用于需要不变的同构数据序列（例如允许在<a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>或<a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>实例中存储）的情况。</span></p><dl class="class"><dt id="tuple"><span class="yiyi-st" id="yiyi-484"><em class="property">class </em><code class="descname">tuple</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-485">元组可以通过多种方式构建：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-486">使用一对括号来表示空元组：<code class="docutils literal"><span class="pre">()</span></code></span></li><li><span class="yiyi-st" id="yiyi-487">对单个元素的元组，结尾要有一个逗号：<code class="docutils literal"><span class="pre">a,</span></code>或<code class="docutils literal"><span class="pre">(a,)</span></code></span></li><li><span class="yiyi-st" id="yiyi-488">以逗号分隔元素：<code class="docutils literal"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c</span></code> or <code class="docutils literal"><span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code></span></li><li><span class="yiyi-st" id="yiyi-489">使用内建的<a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-func docutils literal"><span class="pre">tuple()</span></code></a>函数：<code class="docutils literal"><span class="pre">tuple()</span></code>或<code class="docutils literal"><span class="pre">tuple(iterable)</span></code></span></li></ul><p><span class="yiyi-st" id="yiyi-490">构造函数构建一个元组，其元素与<em>iterable</em>的元素相同且顺序相同。</span><span class="yiyi-st" id="yiyi-491"><em>iterable</em>可以是序列，支持迭代的容器或迭代器对象。</span><span class="yiyi-st" id="yiyi-492">如果<em>iterable</em>已经是一个元组，它将不会被返回。</span><span class="yiyi-st" id="yiyi-493">For example, <code class="docutils literal"><span class="pre">tuple('abc')</span></code> returns <code class="docutils literal"><span class="pre">('a',</span> <span class="pre">'b',</span> <span class="pre">'c')</span></code> and <code class="docutils literal"><span class="pre">tuple(</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span> <span class="pre">)</span></code> returns <code class="docutils literal"><span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></code>. </span><span class="yiyi-st" id="yiyi-494">如果没有给出参数，构造函数会创建一个新的空元组<code class="docutils literal"><span class="pre">()</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-495">请注意，它实际上是制作元组的逗号，而不是括号。</span><span class="yiyi-st" id="yiyi-496">括号是可选的，除了在空元组情况下，或者当需要避免句法歧义时。</span><span class="yiyi-st" id="yiyi-497">For example, <code class="docutils literal"><span class="pre">f(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> is a function call with three arguments, while <code class="docutils literal"><span class="pre">f((a,</span> <span class="pre">b,</span> <span class="pre">c))</span></code> is a function call with a 3-tuple as the sole argument.</span></p><p><span class="yiyi-st" id="yiyi-498">元组实现了所有的<a class="reference internal" href="#typesseq-common"><span>common</span></a>序列操作。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-499">对于按名称访问比按索引访问更清晰的异构数据集合，<a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal"><span class="pre">collections.namedtuple()</span></code></a>可能比简单的元组对象更合适。</span></p></div><div class="section" id="ranges"><h3><span class="yiyi-st" id="yiyi-500">4.6.6.</span><span class="yiyi-st" id="yiyi-501">Ranges</span></h3><p id="index-26"><span class="yiyi-st" id="yiyi-502"><a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a>类型表示不变的数字序列，通常用于在<a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a>循环中循环特定次数。</span></p><dl class="class"><dt id="range"><span class="yiyi-st" id="yiyi-503"><em class="property">class </em><code class="descname">range</code><span class="sig-paren">(</span><em>stop</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-504"><em class="property">class </em><code class="descname">range</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-505">范围构造函数的参数必须是整数（内置<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>或实现<code class="docutils literal"><span class="pre">__ index __</span></code>特殊方法的任何对象）。</span><span class="yiyi-st" id="yiyi-506">如果省略<em>step</em>参数，则默认为<code class="docutils literal"><span class="pre">1</span></code>。</span><span class="yiyi-st" id="yiyi-507">如果省略<em>start</em>参数，则默认为<code class="docutils literal"><span class="pre">0</span></code>。</span><span class="yiyi-st" id="yiyi-508">如果<em>step</em>为零，则会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-509">对于正的<em>step</em>，range <code class="docutils literal"><span class="pre">r</span></code>的内容由公式<code class="docutils literal"><span class="pre">r[i]</span> <span class="pre">=</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">step*i</span></code>确定，其中<code class="docutils literal"><span class="pre">i</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> 且 <code class="docutils literal"><span class="pre">r[i]</span> <span class="pre">&lt;</span> <span class="pre">stop</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-510">For a negative <em>step</em>, the contents of the range are still determined by the formula <code class="docutils literal"><span class="pre">r[i]</span> <span class="pre">=</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">step*i</span></code>, but the constraints are <code class="docutils literal"><span class="pre">i</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> and <code class="docutils literal"><span class="pre">r[i]</span> <span class="pre">&gt;</span> <span class="pre">stop</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-511">如果<code class="docutils literal"><span class="pre">r[0]</span></code>不符合值约束，范围对象将为空。</span><span class="yiyi-st" id="yiyi-512">范围确实支持负指数，但这些被解释为从正指数确定的序列末尾开始的索引。</span></p><p><span class="yiyi-st" id="yiyi-513">Range可以包含绝对值大于<a class="reference internal" href="sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-data docutils literal"><span class="pre">sys.maxsize</span></code></a>值，但某些函数（例如<a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a>）可能引发<a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-514">Range示例：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">[0, 5, 10, 15, 20, 25]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">[0, 3, 6, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">[]</span>
</code></pre><p><span class="yiyi-st" id="yiyi-515">范围实现了除串联和重复之外的所有<a class="reference internal" href="#typesseq-common"><span>common</span></a>序列操作（由于范围对象只能表示遵循严格模式的序列，而重复和串联通常会违反该模式）。</span></p><dl class="attribute"><dt id="range.start"><span class="yiyi-st" id="yiyi-516"><code class="descname">start</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-517"> <em>start</em>参数的值 (缺省为 <code class="docutils literal"><span class="pre">0</span></code> )</span></p></dd></dl><dl class="attribute"><dt id="range.stop"><span class="yiyi-st" id="yiyi-518"><code class="descname">stop</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-519"><em>stop</em>参数的值</span></p></dd></dl><dl class="attribute"><dt id="range.step"><span class="yiyi-st" id="yiyi-520"><code class="descname">step</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-521"><em>step</em>参数的值（或者如果参数未提供，则为<code class="docutils literal"><span class="pre">1</span></code>）</span></p></dd></dl></dd></dl><p><span class="yiyi-st" id="yiyi-522"><a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a>类型优于常规<a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>或<a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>的优点在于，<a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a>对象始终采用相同（小）的内存量，不管它表示的范围的大小（因为它只存储<code class="docutils literal"><span class="pre">start</span></code>，<code class="docutils literal"><span class="pre">stop</span></code>和<code class="docutils literal"><span class="pre">step</span></code>根据需要计算单个项目和子范围）。</span></p><p><span class="yiyi-st" id="yiyi-523">Range对象实现了<a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Sequence</span></code></a> ABC，并提供了诸如包含测试，元素索引查找，切片和负指数支持等功能（请参阅<a class="reference internal" href="#typesseq"><span>Sequence Types — list, tuple, range</span></a></span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span>
<span class="go">range(0, 20, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">11</span> <span class="ow">in</span> <span class="n">r</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">10</span> <span class="ow">in</span> <span class="n">r</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">range(0, 10, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">18</span>
</code></pre><p><span class="yiyi-st" id="yiyi-524">使用<code class="docutils literal"><span class="pre">==</span></code>和<code class="docutils literal"><span class="pre">!=</span></code>测试范围对象是否与序列相同。</span><span class="yiyi-st" id="yiyi-525">也就是说，如果两个范围对象表示相同的值序列，则它们被认为是相等的。</span><span class="yiyi-st" id="yiyi-526">(Note that two range objects that compare equal might have different <a class="reference internal" href="#range.start" title="range.start"><code class="xref py py-attr docutils literal"><span class="pre">start</span></code></a>, <a class="reference internal" href="#range.stop" title="range.stop"><code class="xref py py-attr docutils literal"><span class="pre">stop</span></code></a> and <a class="reference internal" href="#range.step" title="range.step"><code class="xref py py-attr docutils literal"><span class="pre">step</span></code></a> attributes, for example <code class="docutils literal"><span class="pre">range(0)</span> <span class="pre">==</span> <span class="pre">range(2,</span> <span class="pre">1,</span> <span class="pre">3)</span></code> or <code class="docutils literal"><span class="pre">range(0,</span> <span class="pre">3,</span> <span class="pre">2)</span> <span class="pre">==</span> <span class="pre">range(0,</span> <span class="pre">4,</span> <span class="pre">2)</span></code>.)</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-527"><span class="versionmodified">在版本3.2中更改：</span>实现序列ABC。</span><span class="yiyi-st" id="yiyi-528">支持切片和负指数。</span><span class="yiyi-st" id="yiyi-529">在恒定时间内测试<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>对象的成员资格，而不是迭代所有项目。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-530"><span class="versionmodified">在版本3.3中更改：</span>定义'=='和'！='以根据它们定义的值序列比较范围对象（而不是根据对象标识进行比较）。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-531"><span class="versionmodified">版本3.3新增：<a class="reference internal" href="#range.start" title="range.start"><code class="xref py py-attr docutils literal"><span class="pre">start</span></code></a>，<a class="reference internal" href="#range.stop" title="range.stop"><code class="xref py py-attr docutils literal"><span class="pre">stop</span></code></a>和<a class="reference internal" href="#range.step" title="range.step"><code class="xref py py-attr docutils literal"><span class="pre">step</span></code></a>属性。</span></span></p></div></div></div><div class="section" id="text-sequence-type-str"><h2><span class="yiyi-st" id="yiyi-532">4.7. </span><span class="yiyi-st" id="yiyi-533">文本序列类型 — <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a></span></h2><p><span class="yiyi-st" id="yiyi-534">Python中的文本数据由<a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>对象或<em class="dfn">strings</em>进行处理。</span><span class="yiyi-st" id="yiyi-535">字符串是不可变的Unicode码点<a class="reference internal" href="#typesseq"><span>序列</span></a>。</span><span class="yiyi-st" id="yiyi-536">字符串字面值的写法有多种方式：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-537">单引号: <code class="docutils literal"><span class="pre">'允许</span> <span class="pre">嵌入</span> <span class="pre">"一对"</span> <span class="pre">双引号'</span></code>。</span></li><li><span class="yiyi-st" id="yiyi-538">双引号: <code class="docutils literal"><span class="pre">"允许</span> <span class="pre">嵌入</span> <span class="pre">'一对'</span> <span class="pre">单引号"</span></code>。</span></li><li><span class="yiyi-st" id="yiyi-539">三引号：<code class="docutils literal"><span class="pre">'''三个</span><span class="pre">单</span><span class="pre">引号'''</span></code>，<code class="docutils literal"><span class="pre">"""三个</span><span class="pre">双</span><span class="pre">引号"""</span></code>。</span></li></ul><p><span class="yiyi-st" id="yiyi-540">三引号字符串可以跨越多行，引号内的空格也会包含在字符串中。</span></p><p><span class="yiyi-st" id="yiyi-541">如果多个字符串字面值都是单个表达式的一个部分并且它们之间只有空格，那么它们将被隐式转换为单个字符串字面值。</span><span class="yiyi-st" id="yiyi-542">也就是说，<code class="docutils literal"><span class="pre">("spam</span> <span class="pre">"</span> <span class="pre">"eggs")</span> <span class="pre">==</span> <span class="pre">"spam</span> <span class="pre">eggs"</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-543">有关字符串面面值的各种形式，包括支持的转义序列和使大多数转义序列处理失效的<code class="docutils literal"><span class="pre">r</span></code>（“raw”）前缀的详细信息，请参见<a class="reference internal" href="../reference/lexical_analysis.html#strings"><span>字符串和字节字面值</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-544">字符串也可以使用<a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>构造函数从其他对象创建。</span></p><p><span class="yiyi-st" id="yiyi-545">由于没有单独的“字符”类型，索引字符串会生成长度为1的字符串。</span><span class="yiyi-st" id="yiyi-546">也就是说，对于非空字符串<em>s</em>，<code class="docutils literal"><span class="pre">s[0]</span> <span class="pre">==</span> <span class="pre">s[0:1]</span></code>。</span></p><p id="index-28"><span class="yiyi-st" id="yiyi-547">同样没有可变字符串类型，但<a class="reference internal" href="#str.join" title="str.join"><code class="xref py py-meth docutils literal"><span class="pre">str.join()</span></code></a>或<a class="reference internal" href="io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">io.StringIO</span></code></a>可用于从多个片段有效地构造字符串。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-548"><span class="versionmodified">在版本3.3中更改：</span>为了向后兼容Python 2系列，字符串文字再次允许使用<code class="docutils literal"><span class="pre">u</span></code>前缀。</span><span class="yiyi-st" id="yiyi-549">它对字符串文字的含义没有影响，不能与<code class="docutils literal"><span class="pre">r</span></code>前缀结合使用。</span></p></div><dl class="class"><dt id="str"><span class="yiyi-st" id="yiyi-550"><em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=''</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-551"><em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=b''</em>, <em>encoding='utf-8'</em>, <em>errors='strict'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-552">返回<em>object</em>的<a class="reference internal" href="#textseq"><span>字符串</span></a>版本。</span><span class="yiyi-st" id="yiyi-553">如果未提供<em>object</em>，则返回空字符串。</span><span class="yiyi-st" id="yiyi-554">否则，<code class="docutils literal"><span class="pre">str()</span></code>的行为取决于是否给出<em>encoding</em>或<em>errors</em>，如下所示。</span></p><p><span class="yiyi-st" id="yiyi-555">如果既不给出<em>encoding</em>也不给出<em>errors</em>，则<code class="docutils literal"><span class="pre">str(object)</span></code>返回<a class="reference internal" href="../reference/datamodel.html#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal"><span class="pre">object.__str__()</span></code></a>，即<em>object</em>“非正式”的或可打印字符串表示。</span><span class="yiyi-st" id="yiyi-556">对于字符串对象，这是字符串本身。</span><span class="yiyi-st" id="yiyi-557">如果<em>object</em>没有<a class="reference internal" href="../reference/datamodel.html#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal"><span class="pre">__str__()</span></code></a>方法，则<a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a>回退到返回<a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-meth docutils literal"><span class="pre">repr(object)</span></code></a>。</span></p><p id="index-30"><span class="yiyi-st" id="yiyi-558">如果给出<em>encoding</em>或<em>errors</em>中的至少一个，则<em>object</em>应该是<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">类字节对象</span></a>（即</span><span class="yiyi-st" id="yiyi-559"><a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>或<a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>）。</span><span class="yiyi-st" id="yiyi-560">在这种情况下，如果<em>object</em>是<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>（或<a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>）对象，则<code class="docutils literal"><span class="pre">str(bytes,</span> <span class="pre">encoding,</span> <span class="pre">errors)</span></code>等效于<a class="reference internal" href="#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal"><span class="pre">bytes.decode(encoding,</span> <span class="pre">errors)</span></code></a>。</span><span class="yiyi-st" id="yiyi-561">否则，在调用<a class="reference internal" href="#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal"><span class="pre">bytes.decode()</span></code></a>之前获取缓冲区对象下的字节对象。</span><span class="yiyi-st" id="yiyi-562">有关缓冲对象的信息，请参见<a class="reference internal" href="#binaryseq"><span>字节序列类型 — bytes, bytearray, memoryview</span></a>和<a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span>Buffer Protocol</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-563">不带<em>encoding</em>或<em>errors</em>参数传递<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>对象传递到<a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a>属于第一种情况，即返回非正式的字符串表示（另请参阅Python的<a class="reference internal" href="../using/cmdline.html#cmdoption-b"><code class="xref std std-option docutils literal"><span class="pre">-b</span></code></a>命令行选项）。</span><span class="yiyi-st" id="yiyi-564">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="s1">'Zoot!'</span><span class="p">)</span>
<span class="go">"b'Zoot!'"</span>
</code></pre><p><span class="yiyi-st" id="yiyi-565">有关<code class="docutils literal"><span class="pre">str</span></code>类及其方法的详细信息，请参见下面的<a class="reference internal" href="#textseq"><span>文本序列类型 — str</span></a>和<a class="reference internal" href="#string-methods"><span>字符串的方法</span></a>部分。</span><span class="yiyi-st" id="yiyi-566">要输出格式化的字符串，请参阅<a class="reference internal" href="string.html#formatstrings"><span>Format String Syntax</span></a>部分。</span><span class="yiyi-st" id="yiyi-567">另外，请参阅<a class="reference internal" href="text.html#stringservices"><span>Text Processing Services</span></a>部分。</span></p></dd></dl><div class="section" id="string-methods"><h3><span class="yiyi-st" id="yiyi-568">4.7.1.</span><span class="yiyi-st" id="yiyi-569">字符串方法</span></h3><p id="index-32"><span class="yiyi-st" id="yiyi-570">字符串实现了所有的<a class="reference internal" href="#typesseq-common"><span>common</span></a>序列操作，以及下面描述的其他方法。</span></p><p><span class="yiyi-st" id="yiyi-571">Strings also support two styles of string formatting, one providing a large degree of flexibility and customization (see <a class="reference internal" href="#str.format" title="str.format"><code class="xref py py-meth docutils literal"><span class="pre">str.format()</span></code></a>, <a class="reference internal" href="string.html#formatstrings"><span>Format String Syntax</span></a> and <a class="reference internal" href="string.html#string-formatting"><span>Custom String Formatting</span></a>) and the other based on C <code class="docutils literal"><span class="pre">printf</span></code> style formatting that handles a narrower range of types and is slightly harder to use correctly, but is often faster for the cases it can handle (<a class="reference internal" href="#old-string-formatting"><span>printf-style String Formatting</span></a>).</span></p><p><span class="yiyi-st" id="yiyi-572">标准库的<a class="reference internal" href="text.html#textservices"><span>Text Processing Services</span></a>部分涵盖了许多其他模块，这些模块提供各种文本相关实用程序（包括<a class="reference internal" href="re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a>模块中的正则表达式支持）。</span></p><dl class="method"><dt id="str.capitalize"><span class="yiyi-st" id="yiyi-573"><code class="descclassname">str.</code><code class="descname">capitalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-574">返回字符串的一个副本，其首字母大写，其余的小写。</span></p></dd></dl><dl class="method"><dt id="str.casefold"><span class="yiyi-st" id="yiyi-575"><code class="descclassname">str.</code><code class="descname">casefold</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-576">返回字符串的casefolded副本。</span><span class="yiyi-st" id="yiyi-577">可折叠的字符串可用于无外壳匹配。</span></p><p><span class="yiyi-st" id="yiyi-578">Casefolding与lowercasing类似，但更具侵略性，因为它旨在删除字符串中的所有大小写区别。</span><span class="yiyi-st" id="yiyi-579">例如，德语小写字母<code class="docutils literal"><span class="pre">'ß'</span></code>等同于<code class="docutils literal"><span class="pre">"ss"</span></code>。</span><span class="yiyi-st" id="yiyi-580">Since it is already lowercase, <a class="reference internal" href="#str.lower" title="str.lower"><code class="xref py py-meth docutils literal"><span class="pre">lower()</span></code></a> would do nothing to <code class="docutils literal"><span class="pre">'ß'</span></code>; <a class="reference internal" href="#str.casefold" title="str.casefold"><code class="xref py py-meth docutils literal"><span class="pre">casefold()</span></code></a> converts it to <code class="docutils literal"><span class="pre">"ss"</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-581">Unicode标准的第3.13节描述了casefolding算法。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-582"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="str.center"><span class="yiyi-st" id="yiyi-583"><code class="descclassname">str.</code><code class="descname">center</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-584">返回以长度<em>宽度</em>的字符串为中心。</span><span class="yiyi-st" id="yiyi-585">填充是使用指定的<em>fillchar</em>完成的（默认是ASCII空间）。</span><span class="yiyi-st" id="yiyi-586">The original string is returned if <em>width</em> is less than or equal to <code class="docutils literal"><span class="pre">len(s)</span></code>.</span></p></dd></dl><dl class="method"><dt id="str.count"><span class="yiyi-st" id="yiyi-587"> <code class="descclassname">str.</code><code class="descname">count</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-588">返回范围[<em>start</em>，<em>end</em>]中子字符串<em>sub</em>的非重叠次数。</span><span class="yiyi-st" id="yiyi-589">可选参数<em>start</em>和<em>end</em>被解释为切片表示法。</span></p></dd></dl><dl class="method"><dt id="str.encode"><span class="yiyi-st" id="yiyi-590"> <code class="descclassname">str.</code><code class="descname">encode</code><span class="sig-paren">(</span><em>encoding="utf-8"</em>, <em>errors="strict"</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-591">以字节对象的形式返回字符串的编码版本。</span><span class="yiyi-st" id="yiyi-592">默认编码为<code class="docutils literal"><span class="pre">'utf-8'</span></code>。</span><span class="yiyi-st" id="yiyi-593">可能会给出<em>错误</em>来设置不同的错误处理方案。</span><span class="yiyi-st" id="yiyi-594"><em>错误</em>的缺省值是<code class="docutils literal"><span class="pre">'strict'</span></code>，这意味着编码错误会引发一个<a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a>。</span><span class="yiyi-st" id="yiyi-595">其他可能的值是<code class="docutils literal"><span class="pre">'ignore'</span></code>，<code class="docutils literal"><span class="pre">'replace'</span></code>，<code class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></code>，<code class="docutils literal"><span class="pre">'backslashreplace'</span></code>以及其他任何可能的值通过<a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal"><span class="pre">codecs.register_error()</span></code></a>注册的名称，请参见<a class="reference internal" href="codecs.html#error-handlers"><span>Error Handlers</span></a>部分。</span><span class="yiyi-st" id="yiyi-596">有关可能的编码列表，请参见<a class="reference internal" href="codecs.html#standard-encodings"><span>Standard Encodings</span></a>部分。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-597"><span class="versionmodified">在版本3.1中更改：</span>添加了对关键字参数的支持。</span></p></div></dd></dl><dl class="method"><dt id="str.endswith"><span class="yiyi-st" id="yiyi-598"><code class="descclassname">str.</code><code class="descname">endswith</code><span class="sig-paren">(</span><em>suffix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-599">如果字符串以指定的<em>suffix</em>结尾则返回<code class="docutils literal"><span class="pre">True</span></code>，否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span><span class="yiyi-st" id="yiyi-600"><em>后缀</em>也可以是要查找的后缀元组。</span><span class="yiyi-st" id="yiyi-601">使用可选的<em>start</em>，从该位置开始测试。</span><span class="yiyi-st" id="yiyi-602">使用可选的<em>结束</em>，停止在该位置进行比较。</span></p></dd></dl><dl class="method"><dt id="str.expandtabs"><span class="yiyi-st" id="yiyi-603"><code class="descclassname">str.</code><code class="descname">expandtabs</code><span class="sig-paren">(</span><em>tabsize=8</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-604">返回字符串的副本，其中所有制表符由一个或多个空格替换，具体取决于当前列和给定制表符大小。</span><span class="yiyi-st" id="yiyi-605">每个<em>tabsize</em>字符都会出现制表符位置（默认值为8，在列0,8,16等处提供制表位置）。</span><span class="yiyi-st" id="yiyi-606">要扩展字符串，当前列设置为零，字符串逐个检查。</span><span class="yiyi-st" id="yiyi-607">如果该字符是一个制表符（<code class="docutils literal"><span class="pre">\t</span></code>），则在结果中插入一个或多个空格字符，直到当前列等于下一个制表符位置。</span><span class="yiyi-st" id="yiyi-608">（制表符本身不被复制。）</span><span class="yiyi-st" id="yiyi-609">如果该字符是换行符（<code class="docutils literal"><span class="pre">\n</span></code>）或返回（<code class="docutils literal"><span class="pre">\r</span></code>），则会将其复制并将当前列重置为零。</span><span class="yiyi-st" id="yiyi-610">任何其他字符都将被不变地复制，而当前列增加1，无论打印时字符如何表示。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">'01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234'</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
<span class="go">'01      012     0123    01234'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234'</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">'01  012 0123    01234'</span>
</code></pre></dd></dl><dl class="method"><dt id="str.find"><span class="yiyi-st" id="yiyi-611"><code class="descclassname">str.</code><code class="descname">find</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-612">返回在片段<code class="docutils literal"><span class="pre">s[start:end]</span></code>内找到子字符串<em>sub</em>的字符串中最小的索引。</span><span class="yiyi-st" id="yiyi-613">可选参数<em>start</em>和<em>end</em>被解释为切片表示法。</span><span class="yiyi-st" id="yiyi-614">如果未找到<em>sub</em>，则返回<code class="docutils literal"><span class="pre">-1</span></code>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-615">注意</span></p><p><span class="yiyi-st" id="yiyi-616">只有当你需要知道<em>sub</em>的位置时，才应该使用<a class="reference internal" href="#str.find" title="str.find"><code class="xref py py-meth docutils literal"><span class="pre">find()</span></code></a>方法。</span><span class="yiyi-st" id="yiyi-617">要检查<em>sub</em>是否为子字符串，请使用运算符中的<a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a></span></p><div class="last highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">'Py'</span> <span class="ow">in</span> <span class="s1">'Python'</span>
<span class="go">True</span>
</pre></div></div></div></dd></dl><dl class="method"><dt id="str.format"><span class="yiyi-st" id="yiyi-618"><code class="descclassname">str.</code><code class="descname">format</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-619">执行字符串格式化操作。</span><span class="yiyi-st" id="yiyi-620">调用此方法的字符串可以包含由大括号<code class="docutils literal"><span class="pre">{}</span></code>分隔的文本文本或替换字段。</span><span class="yiyi-st" id="yiyi-621">每个替换字段包含位置参数的数字索引或关键字参数的名称。</span><span class="yiyi-st" id="yiyi-622">返回字符串的副本，其中每个替换字段将替换为相应参数的字符串值。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">"The sum of 1 + 2 is </span><span class="si">{0}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
<span class="go">'The sum of 1 + 2 is 3'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-623">有关可以在格式字符串中指定的各种格式选项的说明，请参阅<a class="reference internal" href="string.html#formatstrings"><span>Format String Syntax</span></a>。</span></p></dd></dl><dl class="method"><dt id="str.format_map"><span class="yiyi-st" id="yiyi-624"><code class="descclassname">str.</code><code class="descname">format_map</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-625">与<code class="docutils literal"><span class="pre">str.format(**mapping)</span></code>类似，除了直接使用<code class="docutils literal"><span class="pre">mapping</span></code>并且不复制到<a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>。</span><span class="yiyi-st" id="yiyi-626">如果例如<code class="docutils literal"><span class="pre">mapping</span></code>是字典子类，这很有用：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Default</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">key</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'</span><span class="si">{name}</span><span class="s1"> was born in </span><span class="si">{country}</span><span class="s1">'</span><span class="o">.</span><span class="n">format_map</span><span class="p">(</span><span class="n">Default</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">'Guido'</span><span class="p">))</span>
<span class="go">'Guido was born in country'</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-627"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="str.index"><span class="yiyi-st" id="yiyi-628"><code class="descclassname">str.</code><code class="descname">index</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-629">像<a class="reference internal" href="#str.find" title="str.find"><code class="xref py py-meth docutils literal"><span class="pre">find()</span></code></a>一样，但在找不到子字符串时引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="str.isalnum"><span class="yiyi-st" id="yiyi-630"><code class="descclassname">str.</code><code class="descname">isalnum</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-631">如果字符串中的所有字符都是字母数字并且至少有一个字符，则返回true，否则返回false。</span><span class="yiyi-st" id="yiyi-632">A character <code class="docutils literal"><span class="pre">c</span></code> is alphanumeric if one of the following returns <code class="docutils literal"><span class="pre">True</span></code>: <code class="docutils literal"><span class="pre">c.isalpha()</span></code>, <code class="docutils literal"><span class="pre">c.isdecimal()</span></code>, <code class="docutils literal"><span class="pre">c.isdigit()</span></code>, or <code class="docutils literal"><span class="pre">c.isnumeric()</span></code>.</span></p></dd></dl><dl class="method"><dt id="str.isalpha"><span class="yiyi-st" id="yiyi-633"><code class="descclassname">str.</code><code class="descname">isalpha</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-634">如果字符串中的所有字符都是字母并且至少有一个字符，则返回true，否则返回false。</span><span class="yiyi-st" id="yiyi-635">字母字符是在Unicode字符数据库中定义为“Letter”的那些字符，即具有一般类别属性为“Lm”，“Lt”，“Lu”，“Ll”或“Lo”之一的那些字符。</span><span class="yiyi-st" id="yiyi-636">请注意，这与Unicode标准中定义的“字母”属性不同。</span></p></dd></dl><dl class="method"><dt id="str.isdecimal"><span class="yiyi-st" id="yiyi-637"><code class="descclassname">str.</code><code class="descname">isdecimal</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-638">如果字符串中的所有字符都是十进制字符并且至少有一个字符，则返回true，否则返回false。</span><span class="yiyi-st" id="yiyi-639">十进制字符是来自一般类别“Nd”的字符。</span><span class="yiyi-st" id="yiyi-640">该类别包括数字字符和可用于形成十进制小数数字的所有字符，例如</span><span class="yiyi-st" id="yiyi-641">U + 0660，阿拉伯数字ZERO。</span></p></dd></dl><dl class="method"><dt id="str.isdigit"><span class="yiyi-st" id="yiyi-642"><code class="descclassname">str.</code><code class="descname">isdigit</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-643">如果字符串中的所有字符都是数字，并且至少有一个字符，则返回真，否则返回假。</span><span class="yiyi-st" id="yiyi-644">数字包含需要特殊处理的十进制字符和数字，例如兼容性上标数字。</span><span class="yiyi-st" id="yiyi-645">形式上，数字是具有属性值Numeric_Type = Digit或Numeric_Type = Decimal的字符。</span></p></dd></dl><dl class="method"><dt id="str.isidentifier"><span class="yiyi-st" id="yiyi-646"><code class="descclassname">str.</code><code class="descname">isidentifier</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-647">根据语言定义<a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span>Identifiers and keywords</span></a>，如果字符串是有效标识符，则返回true。</span></p><p><span class="yiyi-st" id="yiyi-648">使用<a class="reference internal" href="keyword.html#keyword.iskeyword" title="keyword.iskeyword"><code class="xref py py-func docutils literal"><span class="pre">keyword.iskeyword()</span></code></a>来测试保留的标识符，例如<a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal"><span class="pre">def</span></code></a>和<a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal"><span class="pre">class</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="str.islower"><span class="yiyi-st" id="yiyi-649"><code class="descclassname">str.</code><code class="descname">islower</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-650">如果字符串中的所有套用字符<a class="footnote-reference" href="#id14" id="id5">[4]</a>都是小写字母，并且至少有一个套用字符，则返回true，否则返回false。</span></p></dd></dl><dl class="method"><dt id="str.isnumeric"><span class="yiyi-st" id="yiyi-651"><code class="descclassname">str.</code><code class="descname">isnumeric</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-652">如果字符串中的所有字符都是数字字符，并且此字符串至少有一个字符（译者注：非空），则返回true，否则返回false。</span><span class="yiyi-st" id="yiyi-653">数字字符包括数字字符和具有Unicode数字值属性的所有字符，例如</span><span class="yiyi-st" id="yiyi-654">U + 2155，VULGAR FRACTION ONE FIFTH。</span><span class="yiyi-st" id="yiyi-655">形式上，数字字符是具有属性值Numeric_Type = Digit，Numeric_Type = Decimal或Numeric_Type = Numeric的字符。</span></p></dd></dl><dl class="method"><dt id="str.isprintable"><span class="yiyi-st" id="yiyi-656"><code class="descclassname">str.</code><code class="descname">isprintable</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-657">如果字符串中的所有字符都可打印或字符串为空，则返回true，否则返回false。</span><span class="yiyi-st" id="yiyi-658">非可打印字符是在Unicode字符数据库中定义为“Other”或“Separator”的字符，但ASCII空格（0x20）被认为是可打印的。</span><span class="yiyi-st" id="yiyi-659">（请注意，在此上下文中的可打印字符是在字符串上调用<a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a>时不应该转义的字符。</span><span class="yiyi-st" id="yiyi-660">它对写入<a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></code></a>或<a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal"><span class="pre">sys.stderr</span></code></a>的字符串的处理没有任何影响。）</span></p></dd></dl><dl class="method"><dt id="str.isspace"><span class="yiyi-st" id="yiyi-661"><code class="descclassname">str.</code><code class="descname">isspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-662">如果字符串中只有空格字符，并且至少有一个字符，则返回true，否则返回false。</span><span class="yiyi-st" id="yiyi-663">空格字符是在Unicode字符数据库中定义为“其他”或“分隔符”并且具有双向属性为“WS”、“B”或“S”之一的那些字符。</span></p></dd></dl><dl class="method"><dt id="str.istitle"><span class="yiyi-st" id="yiyi-664"><code class="descclassname">str.</code><code class="descname">istitle</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-665">如果字符串是一个标题字符串并且至少有一个字符，则返回true，例如，大写字符只能跟在未写入的字符之后，而小写字母只能在已封装的字符之后。</span><span class="yiyi-st" id="yiyi-666">否则返回false。</span></p></dd></dl><dl class="method"><dt id="str.isupper"><span class="yiyi-st" id="yiyi-667"><code class="descclassname">str.</code><code class="descname">isupper</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-668">如果字符串中的所有套用字符<a class="footnote-reference" href="#id14" id="id6">[4]</a>都是大写且至少有一个套用字符，则返回true，否则返回false。</span></p></dd></dl><dl class="method"><dt id="str.join"><span class="yiyi-st" id="yiyi-669"><code class="descclassname">str.</code><code class="descname">join</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-670">返回一个字符串，它是<a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> <em>可迭代</em>中字符串的串联。</span><span class="yiyi-st" id="yiyi-671">如果<em>iterable</em>中包含<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>对象中存在任何非字符串值，则会引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span><span class="yiyi-st" id="yiyi-672">元素之间的分隔符是提供此方法的字符串。</span></p></dd></dl><dl class="method"><dt id="str.ljust"><span class="yiyi-st" id="yiyi-673"><code class="descclassname">str.</code><code class="descname">ljust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-674">以长度<em>宽度</em>的字符串将字符串左对齐。</span><span class="yiyi-st" id="yiyi-675">填充是使用指定的<em>fillchar</em>完成的（默认是ASCII空间）。</span><span class="yiyi-st" id="yiyi-676">The original string is returned if <em>width</em> is less than or equal to <code class="docutils literal"><span class="pre">len(s)</span></code>.</span></p></dd></dl><dl class="method"><dt id="str.lower"><span class="yiyi-st" id="yiyi-677"><code class="descclassname">str.</code><code class="descname">lower</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-678">返回所有字符串的副本<a class="footnote-reference" href="#id14" id="id7">[4]</a>转换为小写字母。</span></p><p><span class="yiyi-st" id="yiyi-679">Unicode标准的第3.13节描述了使用的低级算法。</span></p></dd></dl><dl class="method"><dt id="str.lstrip"><span class="yiyi-st" id="yiyi-680"><code class="descclassname">str.</code><code class="descname">lstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-681">返回删除前导字符的字符串的副本。</span><span class="yiyi-st" id="yiyi-682"><em>chars</em>参数是一个字符串，用于指定要删除的字符集。</span><span class="yiyi-st" id="yiyi-683">如果省略或<code class="docutils literal"><span class="pre">None</span></code>，<em>chars</em>参数默认为删除空白。</span><span class="yiyi-st" id="yiyi-684"><em>字符</em>参数不是前缀；相反，其值的所有组合都被剥离：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">'   spacious   '</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
<span class="go">'spacious   '</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'www.example.com'</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">'cmowz.'</span><span class="p">)</span>
<span class="go">'example.com'</span>
</code></pre></dd></dl><dl class="staticmethod"><dt id="str.maketrans"><span class="yiyi-st" id="yiyi-685"><em class="property">static </em><code class="descclassname">str.</code><code class="descname">maketrans</code><span class="sig-paren">(</span><em>x</em><span class="optional">[</span>, <em>y</em><span class="optional">[</span>, <em>z</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-686">这个静态方法返回一个可用于<a class="reference internal" href="#str.translate" title="str.translate"><code class="xref py py-meth docutils literal"><span class="pre">str.translate()</span></code></a>的转换表。</span></p><p><span class="yiyi-st" id="yiyi-687">如果只有一个参数，它必须是一个将Unicode序数（整数）或字符（长度为1的字符串）映射到Unicode序号，字符串（任意长度）或None的字典。</span><span class="yiyi-st" id="yiyi-688">字符键将被转换为序号。</span></p><p><span class="yiyi-st" id="yiyi-689">如果有两个参数，它们必须是等长的字符串，并且在结果字典中，x中的每个字符将映射到y中相同位置的字符。</span><span class="yiyi-st" id="yiyi-690">如果有第三个参数，它必须是一个字符串，在结果中这些字符将被映射到“None”。</span></p></dd></dl><dl class="method"><dt id="str.partition"><span class="yiyi-st" id="yiyi-691"><code class="descclassname">str.</code><code class="descname">partition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-692">在第一次出现<em>sep</em>时分割字符串，并返回包含分隔符之前的部分，分隔符本身和分隔符之后的部分的3元组。</span><span class="yiyi-st" id="yiyi-693">如果未找到分隔符，则返回包含该字符串本身的三元组，然后返回两个空字符串。</span></p></dd></dl><dl class="method"><dt id="str.replace"><span class="yiyi-st" id="yiyi-694"><code class="descclassname">str.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>old</em>, <em>new</em><span class="optional">[</span>, <em>count</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-695">返回字符串的副本，其中所有出现的子字符串<em>old</em>由<em>new</em>替换。</span><span class="yiyi-st" id="yiyi-696">如果给出可选参数<em>count</em>，则仅替换第一个<em>count</em>出现次数。</span></p></dd></dl><dl class="method"><dt id="str.rfind"><span class="yiyi-st" id="yiyi-697"><code class="descclassname">str.</code><code class="descname">rfind</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-698">返回找到子字符串<em>sub</em>的字符串中的最高索引，使得<em>sub</em>包含在<code class="docutils literal"><span class="pre">s[start:end]</span></code>内。</span><span class="yiyi-st" id="yiyi-699">可选参数<em>start</em>和<em>end</em>被解释为切片表示法。</span><span class="yiyi-st" id="yiyi-700">失败时返回<code class="docutils literal"><span class="pre">-1</span></code>。</span></p></dd></dl><dl class="method"><dt id="str.rindex"><span class="yiyi-st" id="yiyi-701"><code class="descclassname">str.</code><code class="descname">rindex</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-702">像<a class="reference internal" href="#str.rfind" title="str.rfind"><code class="xref py py-meth docutils literal"><span class="pre">rfind()</span></code></a>一样，但当子字符串<em>sub</em>未找到时引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="str.rjust"><span class="yiyi-st" id="yiyi-703"><code class="descclassname">str.</code><code class="descname">rjust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-704">以长度<em>宽度</em>的字符串返回右对齐的字符串。</span><span class="yiyi-st" id="yiyi-705">填充是使用指定的<em>fillchar</em>完成的（默认是ASCII空间）。</span><span class="yiyi-st" id="yiyi-706">The original string is returned if <em>width</em> is less than or equal to <code class="docutils literal"><span class="pre">len(s)</span></code>.</span></p></dd></dl><dl class="method"><dt id="str.rpartition"><span class="yiyi-st" id="yiyi-707"><code class="descclassname">str.</code><code class="descname">rpartition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-708">在最后出现的<em>sep</em>处拆分字符串，并返回包含分隔符之前的部分，分隔符本身和分隔符之后的部分的3元组。</span><span class="yiyi-st" id="yiyi-709">如果未找到分隔符，则返回包含两个空字符串的三元组，然后返回字符串本身。</span></p></dd></dl><dl class="method"><dt id="str.rsplit"><span class="yiyi-st" id="yiyi-710"><code class="descclassname">str.</code><code class="descname">rsplit</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-711">在字符串中，使用<em>sep</em>作为分隔符分割字符串，返回分割后的列表。</span><span class="yiyi-st" id="yiyi-712">如果给出<em>maxsplit</em>，则最多<em>maxsplit</em>分割完成，<em>最右边</em>个分割。</span><span class="yiyi-st" id="yiyi-713">如果未指定<em>sep</em>或<code class="docutils literal"><span class="pre">None</span></code>，则任何空格字符串都是分隔符。</span><span class="yiyi-st" id="yiyi-714">除了从右边分割外，<a class="reference internal" href="#str.rsplit" title="str.rsplit"><code class="xref py py-meth docutils literal"><span class="pre">rsplit()</span></code></a>的行为与<a class="reference internal" href="#str.split" title="str.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a>的行为类似，下面详细介绍。</span></p></dd></dl><dl class="method"><dt id="str.rstrip"><span class="yiyi-st" id="yiyi-715"><code class="descclassname">str.</code><code class="descname">rstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-716">返回删除了尾随字符的字符串副本。</span><span class="yiyi-st" id="yiyi-717"><em>chars</em>参数是一个字符串，用于指定要删除的字符集。</span><span class="yiyi-st" id="yiyi-718">如果省略或<code class="docutils literal"><span class="pre">None</span></code>，<em>chars</em>参数默认为删除空格。</span><span class="yiyi-st" id="yiyi-719"><em>chars</em>参数不是后缀；相反，其值的所有组合都被剥离：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">'   spacious   '</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
<span class="go">'   spacious'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'mississippi'</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">'ipz'</span><span class="p">)</span>
<span class="go">'mississ'</span>
</code></pre></dd></dl><dl class="method"><dt id="str.split"><span class="yiyi-st" id="yiyi-720"><code class="descclassname">str.</code><code class="descname">split</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-721">在字符串中，使用<em>sep</em>作为分隔符分割字符串，返回分割后的列表。</span><span class="yiyi-st" id="yiyi-722">如果给出<em>maxsplit</em>，则至多完成<em>maxsplit</em>分割（因此，列表最多只能有<code class="docutils literal"><span class="pre">maxsplit+1</span></code>元素）。</span><span class="yiyi-st" id="yiyi-723">如果没有指定<em>maxsplit</em>或<code class="docutils literal"><span class="pre">-1</span></code>，那么分割数量没有限制（所有可能的分割）。</span></p><p><span class="yiyi-st" id="yiyi-724">如果给出了<em>sep</em>，则连续的分隔符不会分组在一起，并被视为分隔空字符串（例如，<code class="docutils literal"><span class="pre">'1,,2'.split(',')</span></code>返回<code class="docutils literal"><span class="pre">['1'，</span> <span class="pre">''，</span> <span class="pre">'2']</span></code>）。</span><span class="yiyi-st" id="yiyi-725"><em>sep</em>参数可以由多个字符组成（例如，<code class="docutils literal"><span class="pre">'1&lt;&gt;2&lt;&gt;3'.split('&lt;&gt;')</span></code>返回<code class="docutils literal"> <span class="pre">['1'，</span> <span class="pre">'2'，</span> <span class="pre">'3']</span></code>）。</span><span class="yiyi-st" id="yiyi-726">用指定的分隔符分割空字符串会返回<code class="docutils literal"><span class="pre">['']</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-727">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">'1,2,3'</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">','</span><span class="p">)</span>
<span class="go">['1', '2', '3']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'1,2,3'</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">','</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">['1', '2,3']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'1,2,,3,'</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">','</span><span class="p">)</span>
<span class="go">['1', '2', '', '3', '']</span>
</code></pre><p><span class="yiyi-st" id="yiyi-728">如果没有指定<em>sep</em>或者是<code class="docutils literal"><span class="pre">None</span></code>，则应用不同的分割算法：将连续空白的运行视为单个分隔符，结果将不包含空字符串如果字符串具有前导或尾随空白，则开始或结束。</span><span class="yiyi-st" id="yiyi-729">因此，使用<code class="docutils literal"><span class="pre">None</span></code>分隔符将空字符串或仅由空白组成的字符串拆分返回<code class="docutils literal"><span class="pre">[]</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-730">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">'1 2 3'</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">['1', '2', '3']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'1 2 3'</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">['1', '2 3']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'   1   2   3   '</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">['1', '2', '3']</span>
</code></pre></dd></dl><dl class="method"><dt id="str.splitlines"><span class="yiyi-st" id="yiyi-731"> <code class="descclassname">str.</code><code class="descname">splitlines</code><span class="sig-paren">(</span><span class="optional">[</span><em>keepends</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-732">返回字符串中行的列表，在行边界处突破。</span><span class="yiyi-st" id="yiyi-733">换行符不包含在结果列表中，除非给出<em>keepends</em>且为true。</span></p><p><span class="yiyi-st" id="yiyi-734">此方法分割在以下行边界上。</span><span class="yiyi-st" id="yiyi-735">特别是，边界是<a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a>的超集。</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-736">表示</span></th><th class="head"><span class="yiyi-st" id="yiyi-737">描述</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-738"><code class="docutils literal"><span class="pre">\n</span></code></span></td><td><span class="yiyi-st" id="yiyi-739">换行</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-740"><code class="docutils literal"><span class="pre">\r</span></code></span></td><td><span class="yiyi-st" id="yiyi-741">回车</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-742"><code class="docutils literal"><span class="pre">\r\n</span></code></span></td><td><span class="yiyi-st" id="yiyi-743">回车+换行</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-744"><code class="docutils literal"><span class="pre">\v</span></code>或<code class="docutils literal"><span class="pre">\x0b</span></code></span></td><td><span class="yiyi-st" id="yiyi-745">线条制表</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-746"><code class="docutils literal"><span class="pre">\f</span></code>或<code class="docutils literal"><span class="pre">\x0c</span></code></span></td><td><span class="yiyi-st" id="yiyi-747">表单Feed</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-748"><code class="docutils literal"><span class="pre">\x1c</span></code></span></td><td><span class="yiyi-st" id="yiyi-749">文件分隔符</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-750"><code class="docutils literal"><span class="pre">\x1d</span></code></span></td><td><span class="yiyi-st" id="yiyi-751">组分隔符</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-752"><code class="docutils literal"><span class="pre">\x1e</span></code></span></td><td><span class="yiyi-st" id="yiyi-753">记录分隔符</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-754"><code class="docutils literal"><span class="pre">\x85</span></code></span></td><td><span class="yiyi-st" id="yiyi-755">下一行（C1控制代码）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-756"><code class="docutils literal"><span class="pre">\u2028</span></code></span></td><td><span class="yiyi-st" id="yiyi-757">线分隔符</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-758"><code class="docutils literal"><span class="pre">\u2029</span></code></span></td><td><span class="yiyi-st" id="yiyi-759">段落分隔符</span></td></tr></tbody></table><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-760"><span class="versionmodified">在版本3.2中更改：</span> <code class="docutils literal"><span class="pre">\v</span></code>和<code class="docutils literal"><span class="pre">\f</span></code>添加到行边界列表中。</span></p></div><p><span class="yiyi-st" id="yiyi-761">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">'ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">'</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">['ab c', '', 'de fg', 'kl']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">'</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">['ab c\n', '\n', 'de fg\r', 'kl\r\n']</span>
</code></pre><p><span class="yiyi-st" id="yiyi-762">与给定分隔符字符串<em>sep</em>时的<a class="reference internal" href="#str.split" title="str.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a>不同，此方法返回空字符串的空列表，并且终端行分隔符不会导致额外的行：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">""</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">"One line</span><span class="se">\n</span><span class="s2">"</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">['One line']</span>
</code></pre><p><span class="yiyi-st" id="yiyi-763">For comparison, <code class="docutils literal"><span class="pre">split('\n')</span></code> gives:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">''</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
<span class="go">['']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'Two lines</span><span class="se">\n</span><span class="s1">'</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
<span class="go">['Two lines', '']</span>
</code></pre></dd></dl><dl class="method"><dt id="str.startswith"><span class="yiyi-st" id="yiyi-764"><code class="descclassname">str.</code><code class="descname">startswith</code><span class="sig-paren">(</span><em>prefix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-765">如果字符串以<em>prefix</em>开头则返回<code class="docutils literal"><span class="pre">True</span></code>，否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span><span class="yiyi-st" id="yiyi-766"><em>前缀</em>也可以是要查找的前缀元组。</span><span class="yiyi-st" id="yiyi-767">使用可选的<em>start</em>，测试字符串从该位置开始。</span><span class="yiyi-st" id="yiyi-768">使用可选的<em>结束</em>，停止在该位置比较字符串。</span></p></dd></dl><dl class="method"><dt id="str.strip"><span class="yiyi-st" id="yiyi-769"> <code class="descclassname">str.</code><code class="descname">strip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-770">返回删除前导字符和尾随字符的字符串副本。</span><span class="yiyi-st" id="yiyi-771"><em>chars</em>参数是一个字符串，用于指定要删除的字符集。</span><span class="yiyi-st" id="yiyi-772">如果省略或<code class="docutils literal"><span class="pre">None</span></code>，<em>chars</em>参数默认为删除空白。</span><span class="yiyi-st" id="yiyi-773"><em>chars</em>参数不是前缀或后缀；相反，其值的所有组合都被剥离：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">'   spacious   '</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="go">'spacious'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'www.example.com'</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">'cmowz.'</span><span class="p">)</span>
<span class="go">'example'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-774">从字符串中剥离最外面的前导和尾随<em>字符</em>参数值。</span><span class="yiyi-st" id="yiyi-775">从前端删除字符，直到达到<em>字符集</em>中字符集中未包含的字符串字符。</span><span class="yiyi-st" id="yiyi-776">尾端发生类似的行为。</span><span class="yiyi-st" id="yiyi-777">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">comment_string</span> <span class="o">=</span> <span class="s1">'#....... Section 3.2.1 Issue #32 .......'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comment_string</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">'.#! '</span><span class="p">)</span>
<span class="go">'Section 3.2.1 Issue #32'</span>
</code></pre></dd></dl><dl class="method"><dt id="str.swapcase"><span class="yiyi-st" id="yiyi-778"><code class="descclassname">str.</code><code class="descname">swapcase</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-779">返回大写字符转换为小写字符串的副本，反之亦然。</span><span class="yiyi-st" id="yiyi-780">请注意，<code class="docutils literal"><span class="pre">s.swapcase().swapcase()</span> <span class="pre">==</span> <span class="pre">s</span></code>不一定是真的。</span></p></dd></dl><dl class="method"><dt id="str.title"><span class="yiyi-st" id="yiyi-781"><code class="descclassname">str.</code><code class="descname">title</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-782">返回字符串的字幕版本，其中字以大写字符开头，其余字符为小写字母。</span></p><p><span class="yiyi-st" id="yiyi-783">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">'Hello world'</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">'Hello World'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-784">该算法使用简单的与语言无关的单词作为连续字母组的定义。</span><span class="yiyi-st" id="yiyi-785">该定义在许多情况下都有效，但这意味着收缩和占有者中的撇号会形成单词边界，这可能不是理想的结果：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">"they're bill's friends from the UK"</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">"They'Re Bill'S Friends From The Uk"</span>
</code></pre><p><span class="yiyi-st" id="yiyi-786">可以使用正则表达式构造撇号的解决方法：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">titlecase</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">r"[A-Za-z]+('[A-Za-z]+)?"</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="k">lambda</span> <span class="n">mo</span><span class="p">:</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span>
<span class="gp">... </span>                             <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
<span class="gp">... </span>                  <span class="n">s</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">titlecase</span><span class="p">(</span><span class="s2">"they're bill's friends."</span><span class="p">)</span>
<span class="go">"They're Bill's Friends."</span>
</code></pre></dd></dl><dl class="method"><dt id="str.translate"><span class="yiyi-st" id="yiyi-787"><code class="descclassname">str.</code><code class="descname">translate</code><span class="sig-paren">(</span><em>table</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-788">返回通过给定转换表映射每个字符的字符串的副本。</span><span class="yiyi-st" id="yiyi-789">该表必须是通过<a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a>，通常是<a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a>或<a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequence</span></a>实现索引的对象。</span><span class="yiyi-st" id="yiyi-790">当通过Unicode序数（整数）索引时，表对象可以执行以下任何操作：返回Unicode序号或字符串，将字符映射为一个或多个其他字符；返回<code class="docutils literal"><span class="pre">None</span></code>，从返回字符串中删除字符；或者引发<a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a>异常，将字符映射到自身。</span></p><p><span class="yiyi-st" id="yiyi-791">您可以使用<a class="reference internal" href="#str.maketrans" title="str.maketrans"><code class="xref py py-meth docutils literal"><span class="pre">str.maketrans()</span></code></a>从不同格式的字符到字符映射创建转换映射。</span></p><p><span class="yiyi-st" id="yiyi-792">另请参阅<a class="reference internal" href="codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal"><span class="pre">codecs</span></code></a>模块，以获得更灵活的自定义字符映射方法。</span></p></dd></dl><dl class="method"><dt id="str.upper"><span class="yiyi-st" id="yiyi-793"><code class="descclassname">str.</code><code class="descname">upper</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-794">返回所有字符串的副本<a class="footnote-reference" href="#id14" id="id8">[4]</a>转换为大写字符。</span><span class="yiyi-st" id="yiyi-795">Note that <code class="docutils literal"><span class="pre">str.upper().isupper()</span></code> might be <code class="docutils literal"><span class="pre">False</span></code> if <code class="docutils literal"><span class="pre">s</span></code> contains uncased characters or if the Unicode category of the resulting character(s) is not “Lu” (Letter, uppercase), but e.g. </span><span class="yiyi-st" id="yiyi-796">“Lt”（Letter，titlecase）。</span></p><p><span class="yiyi-st" id="yiyi-797">Unicode标准的第3.13节描述了使用的大写算法。</span></p></dd></dl><dl class="method"><dt id="str.zfill"><span class="yiyi-st" id="yiyi-798"><code class="descclassname">str.</code><code class="descname">zfill</code><span class="sig-paren">(</span><em>width</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-799">返回左侧填充有ASCII <code class="docutils literal"><span class="pre">'0'</span></code>位的字符串的副本，以生成长度<em>宽度</em>的字符串。</span><span class="yiyi-st" id="yiyi-800">前导符号前缀（<code class="docutils literal"><span class="pre">'+'</span></code> / <code class="docutils literal"><span class="pre">'-'</span></code>）通过在符号字符后面插入填充符<em>来处理，而不是在之前。</em></span><span class="yiyi-st" id="yiyi-801">The original string is returned if <em>width</em> is less than or equal to <code class="docutils literal"><span class="pre">len(s)</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-802">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">"42"</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">'00042'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">"-42"</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">'-0042'</span>
</code></pre></dd></dl></div><div class="section" id="printf-style-string-formatting"><h3><span class="yiyi-st" id="yiyi-803">4.7.2. <code class="docutils literal"><span class="pre">printf</span></code>风格的字符串格式化</span></h3><div class="admonition note" id="index-34"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-804">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-805">这里描述的格式化操作表现出各种各样的怪癖，导致许多常见错误（如未能正确显示元组和字典）。</span><span class="yiyi-st" id="yiyi-806">使用新的<a class="reference internal" href="#str.format" title="str.format"><code class="xref py py-meth docutils literal"><span class="pre">str.format()</span></code></a>接口有助于避免这些错误，并且还提供了一种通用的功能更强大，灵活且可扩展的文本格式化方法。</span></p></div><p><span class="yiyi-st" id="yiyi-807">字符串对象有一个独特的内建操作：<code class="docutils literal"><span class="pre">%</span></code>操作符（取模）。</span><span class="yiyi-st" id="yiyi-808">这也被称为字符串<em>formatting</em>或<em>插值</em>运算符。</span><span class="yiyi-st" id="yiyi-809">给定<code class="docutils literal"><span class="pre">format</span> <span class="pre">%</span> <span class="pre">values</span></code> （其中<em>format</em>是一个字符串），<em>format</em>中的<code class="docutils literal"><span class="pre">%</span></code>转换说明被<em>values</em>的零个或多个元素替换。</span><span class="yiyi-st" id="yiyi-810">其效果与在C语言中使用<code class="xref c c-func docutils literal"><span class="pre">sprintf()</span></code>类似。</span></p><p><span class="yiyi-st" id="yiyi-811">如果<em>格式</em>需要单个参数，则<em>值</em>可能是单个非元组对象。</span><span class="yiyi-st" id="yiyi-812"><a class="footnote-reference" href="#id15" id="id9">[5]</a> Otherwise, <em>values</em> must be a tuple with exactly the number of items specified by the format string, or a single mapping object (for example, a dictionary).</span></p><p><span class="yiyi-st" id="yiyi-813">转换说明符包含两个或多个字符，并具有以下组件，它们必须按以下顺序出现：</span></p><ol class="arabic simple"><li><span class="yiyi-st" id="yiyi-814"><code class="docutils literal"><span class="pre">'%'</span></code>字符表示说明符的开始。</span></li><li><span class="yiyi-st" id="yiyi-815">映射键（可选），由括号括起来的字符序列（例如，<code class="docutils literal"><span class="pre">(somename)</span></code>）组成。</span></li><li><span class="yiyi-st" id="yiyi-816">转换标志（可选），影响某些转换类型的结果。</span></li><li><span class="yiyi-st" id="yiyi-817">最小字段宽度（可选）。</span><span class="yiyi-st" id="yiyi-818">如果指定为<code class="docutils literal"><span class="pre">'*'</span></code>（星号），则实际宽度将从<em>值</em>中的元组的下一个元素中读取，并且要转换的对象位于最小字段宽度和可选精度。</span></li><li><span class="yiyi-st" id="yiyi-819">精度（可选），作为<code class="docutils literal"><span class="pre">'.'</span></code>给出</span><span class="yiyi-st" id="yiyi-820">（点），然后是精度。</span><span class="yiyi-st" id="yiyi-821">如果指定为<code class="docutils literal"><span class="pre">'*'</span></code>（星号），则从<em>values</em>中的元组的下一个元素读取实际精度，并且要转换的值在精度之后。</span></li><li><span class="yiyi-st" id="yiyi-822">长度修饰符（可选）。</span></li><li><span class="yiyi-st" id="yiyi-823">转换类型。</span></li></ol><p><span class="yiyi-st" id="yiyi-824">当右侧参数是一个字典（或其它映射类型）时，那么字符串中的formats<em>必须</em>包含一个圆括号括起来的映射到那个字典的键，并紧接在<code class="docutils literal"><span class="pre">'%'</span></code>字符之后。</span><span class="yiyi-st" id="yiyi-825">映射键从映射中选择要格式化的值。</span><span class="yiyi-st" id="yiyi-826">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="si">%(language)s</span><span class="s1"> has </span><span class="si">%(number)03d</span><span class="s1"> quote types.'</span> <span class="o">%</span>
<span class="gp">... </span>      <span class="p">{</span><span class="s1">'language'</span><span class="p">:</span> <span class="s2">"Python"</span><span class="p">,</span> <span class="s2">"number"</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">Python has 002 quote types.</span>
</code></pre><p><span class="yiyi-st" id="yiyi-827">在这种情况下format中不可以出现<code class="docutils literal"><span class="pre">*</span></code>指示符（因为它们需要一个序列参数的列表）。</span></p><p><span class="yiyi-st" id="yiyi-828">转换标志字符是：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-829">旗</span></th><th class="head"><span class="yiyi-st" id="yiyi-830">含义</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-831"><code class="docutils literal"><span class="pre">'#'</span></code></span></td><td><span class="yiyi-st" id="yiyi-832">值转换将使用“替代形式”（如下定义）。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-833"><code class="docutils literal"><span class="pre">'0'</span></code></span></td><td><span class="yiyi-st" id="yiyi-834">对于数值，转换将用零填充。</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-835"><code class="docutils literal"><span class="pre">'-'</span></code></span></td><td><span class="yiyi-st" id="yiyi-836">转换的值被左调整（如果给出两者，则覆盖<code class="docutils literal"><span class="pre">'0'</span></code>转换标志）。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-837"><code class="docutils literal"><span class="pre">'</span> <span class="pre">'</span></code></span></td><td><span class="yiyi-st" id="yiyi-838">（空格）空白应留在由有符号转换产生的正数（或空字符串）之前。</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-839"><code class="docutils literal"><span class="pre">'+'</span></code></span></td><td><span class="yiyi-st" id="yiyi-840">将在转换说明之前加上符号字符（<code class="docutils literal"><span class="pre">'+'</span></code>或<code class="docutils literal"><span class="pre">'-'</span></code>）（覆盖“空格”标志）。</span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-841">长度修饰符（<code class="docutils literal"><span class="pre">h</span></code>，<code class="docutils literal"><span class="pre">l</span></code>或<code class="docutils literal"><span class="pre">L</span></code>）可能会出现，但会被忽略，因为它对Python不是必需的 - 例如，</span><span class="yiyi-st" id="yiyi-842"><code class="docutils literal"><span class="pre">%ld</span></code>与<code class="docutils literal"><span class="pre">%d</span></code>完全相同。</span></p><p><span class="yiyi-st" id="yiyi-843">转换类型是：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-844">转变</span></th><th class="head"><span class="yiyi-st" id="yiyi-845">含义</span></th><th class="head"><span class="yiyi-st" id="yiyi-846">笔记</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-847"><code class="docutils literal"><span class="pre">'d'</span></code></span></td><td><span class="yiyi-st" id="yiyi-848">带符号的整数小数。</span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-849"><code class="docutils literal"><span class="pre">'i'</span></code></span></td><td><span class="yiyi-st" id="yiyi-850">带符号的整数小数。</span></td><td></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-851"><code class="docutils literal"><span class="pre">'o'</span></code></span></td><td><span class="yiyi-st" id="yiyi-852">签署八进制值。</span></td><td><span class="yiyi-st" id="yiyi-853">（1）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-854"><code class="docutils literal"><span class="pre">'u'</span></code></span></td><td><span class="yiyi-st" id="yiyi-855">已过时的类型 - 与<code class="docutils literal"><span class="pre">'d'</span></code>完全相同。</span></td><td><span class="yiyi-st" id="yiyi-856">（7）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-857"><code class="docutils literal"><span class="pre">'x'</span></code></span></td><td><span class="yiyi-st" id="yiyi-858">签名的十六进制（小写）。</span></td><td><span class="yiyi-st" id="yiyi-859">（2）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-860"><code class="docutils literal"><span class="pre">'X'</span></code></span></td><td><span class="yiyi-st" id="yiyi-861">签名的十六进制（大写）。</span></td><td><span class="yiyi-st" id="yiyi-862">（2）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-863"><code class="docutils literal"><span class="pre">'e'</span></code></span></td><td><span class="yiyi-st" id="yiyi-864">浮点指数格式（小写）。</span></td><td><span class="yiyi-st" id="yiyi-865">（3）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-866"><code class="docutils literal"><span class="pre">'e'</span></code></span></td><td><span class="yiyi-st" id="yiyi-867">浮点指数格式（大写）。</span></td><td><span class="yiyi-st" id="yiyi-868">（3）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-869"><code class="docutils literal"><span class="pre">'f'</span></code></span></td><td><span class="yiyi-st" id="yiyi-870">浮点十进制格式。</span></td><td><span class="yiyi-st" id="yiyi-871">（3）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-872"><code class="docutils literal"><span class="pre">'F'</span></code></span></td><td><span class="yiyi-st" id="yiyi-873">浮点十进制格式。</span></td><td><span class="yiyi-st" id="yiyi-874">（3）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-875"><code class="docutils literal"><span class="pre">'g'</span></code></span></td><td><span class="yiyi-st" id="yiyi-876">浮点格式。</span><span class="yiyi-st" id="yiyi-877">如果指数小于-4或小于精度，则使用小写指数格式，否则使用小数格式。</span></td><td><span class="yiyi-st" id="yiyi-878">（4）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-879"><code class="docutils literal"><span class="pre">'g'</span></code></span></td><td><span class="yiyi-st" id="yiyi-880">浮点格式。</span><span class="yiyi-st" id="yiyi-881">如果指数小于-4或者不小于精度，则使用大写指数格式，否则使用小数格式。</span></td><td><span class="yiyi-st" id="yiyi-882">（4）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-883"><code class="docutils literal"><span class="pre">'c'</span></code></span></td><td><span class="yiyi-st" id="yiyi-884">单个字符（接受整数或单个字符串）。</span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-885"><code class="docutils literal"><span class="pre">'r'</span></code></span></td><td><span class="yiyi-st" id="yiyi-886">字符串（使用<a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a>转换任何Python对象）。</span></td><td><span class="yiyi-st" id="yiyi-887">（5）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-888"><code class="docutils literal"><span class="pre">'s'</span></code></span></td><td><span class="yiyi-st" id="yiyi-889">String（使用<a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a>转换任何Python对象）。</span></td><td><span class="yiyi-st" id="yiyi-890">（5）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-891"><code class="docutils literal"><span class="pre">'a'</span></code></span></td><td><span class="yiyi-st" id="yiyi-892">字符串（使用<a class="reference internal" href="functions.html#ascii" title="ascii"><code class="xref py py-func docutils literal"><span class="pre">ascii()</span></code></a>转换任何Python对象）。</span></td><td><span class="yiyi-st" id="yiyi-893">（5）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-894"><code class="docutils literal"><span class="pre">'%'</span></code></span></td><td><span class="yiyi-st" id="yiyi-895">没有参数被转换，导致结果中有一个<code class="docutils literal"><span class="pre">'%'</span></code>字符。</span></td><td></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-896">笔记：</span></p><ol class="arabic"><li><p class="first"><span class="yiyi-st" id="yiyi-897">替代形式造成左侧填充零 (<code class="docutils literal"><span class="pre">'0'</span></code>) ，且数字的格式，如果结果的前导字符插入不是零。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-898">替代形式导致<code class="docutils literal"><span class="pre">'0x'</span></code>或<code class="docutils literal"><span class="pre">'0X'</span></code>（取决于<code class="docutils literal"><span class="pre">'x'</span></code>或<code class="docutils literal"><span class="pre">'X'</span></code></span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-899">替代形式会导致结果始终包含小数点，即使没有数字跟着它。</span></p><p><span class="yiyi-st" id="yiyi-900">精度决定小数点后的位数，默认为6。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-901">替代形式使结果总是包含小数点，在其他情况下会删除的尾随零不会被删除。</span></p><p><span class="yiyi-st" id="yiyi-902">精度决定小数点前后的有效位数，默认值为6。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-903">如果precision <code class="docutils literal"><span class="pre">N</span></code>，则输出将被截断为<code class="docutils literal"><span class="pre">N</span></code>个字符。</span></p></li></ol><ol class="arabic simple" start="7"><li><span class="yiyi-st" id="yiyi-904">参见<span class="target" id="index-35"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0237"><strong>PEP 237</strong></a>。</span></li></ol><p><span class="yiyi-st" id="yiyi-905">由于Python字符串具有明确的长度，因此<code class="docutils literal"><span class="pre">%s</span></code>转换不会假定<code class="docutils literal"><span class="pre">'\0'</span></code>是字符串的结尾。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-906"><span class="versionmodified">在版本3.1中进行了更改：绝对值超过1e50的数字不再被<code class="docutils literal"><span class="pre">%g</span></code>转换所取代。</span> <code class="docutils literal"><span class="pre">%f</span></code></span></p></div></div></div><div class="section" id="binary-sequence-types-bytes-bytearray-memoryview"><h2><span class="yiyi-st" id="yiyi-907">4.8.</span><span class="yiyi-st" id="yiyi-908">二进制序列类型 -  <a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>，<a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>，<a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> </span></h2><p id="index-37"><span class="yiyi-st" id="yiyi-909">用于处理二进制数据的核心内置类型是<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>和<a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>。</span><span class="yiyi-st" id="yiyi-910">它们由<a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a>支持，它使用<a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span>buffer protocol</span></a>访问其他二进制对象的内存，而无需进行复制。</span></p><p><span class="yiyi-st" id="yiyi-911"><a class="reference internal" href="array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal"><span class="pre">array</span></code></a>模块支持基本数据类型（如32位整数和IEEE754双精度浮点值）的高效存储。</span></p><div class="section" id="bytes"><h3><span class="yiyi-st" id="yiyi-912">4.8.1.</span><span class="yiyi-st" id="yiyi-913">字节</span></h3><p id="index-38"><span class="yiyi-st" id="yiyi-914">字节对象是单个字节的不可变序列。</span><span class="yiyi-st" id="yiyi-915">由于许多主要的二进制协议都基于ASCII文本编码，因此字节对象提供了几种方法，这些方法仅在使用ASCII兼容数据时有效，并且以各种其他方式与字符串对象密切相关。</span></p><p><span class="yiyi-st" id="yiyi-916">首先，除了添加了<code class="docutils literal"><span class="pre">b</span></code>前缀之外，字节文本的语法与字符串文本的语法基本相同：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-917">单引号 <code class="docutils literal"><span class="pre">b'still</span> <span class="pre">allows</span> <span class="pre">embedded</span> <span class="pre">"double"</span> <span class="pre">quotes'</span></code></span></li><li><span class="yiyi-st" id="yiyi-918">双引号: <code class="docutils literal"><span class="pre">b"still</span> <span class="pre">allows</span> <span class="pre">embedded</span> <span class="pre">'single'</span> <span class="pre">quotes"</span></code>.</span></li><li><span class="yiyi-st" id="yiyi-919">三引号: <code class="docutils literal"><span class="pre">b'''3</span> <span class="pre">single</span> <span class="pre">quotes'''</span></code>, <code class="docutils literal"><span class="pre">b"""3</span> <span class="pre">double</span> <span class="pre">quotes"""</span></code></span></li></ul><p><span class="yiyi-st" id="yiyi-920">只允许以字节为单位的ASCII字符（不管声明的源代码编码如何）。</span><span class="yiyi-st" id="yiyi-921">必须使用适当的转义序列将127以上的任何二进制值输入字节文字。</span></p><p><span class="yiyi-st" id="yiyi-922">与字符串文字一样，字节文字也可以使用<code class="docutils literal"><span class="pre">r</span></code>前缀来禁用转义序列的处理。</span><span class="yiyi-st" id="yiyi-923">请参阅<a class="reference internal" href="../reference/lexical_analysis.html#strings"><span>String and Bytes literals</span></a>了解更多关于各种形式的字节文字的信息，包括支持的转义序列。</span></p><p><span class="yiyi-st" id="yiyi-924">While bytes literals and representations are based on ASCII text, bytes objects actually behave like immutable sequences of integers, with each value in the sequence restricted such that <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code> (attempts to violate this restriction will trigger <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>. </span><span class="yiyi-st" id="yiyi-925">这是故意强调的，尽管很多二进制格式包括基于ASCII的元素，并且可以用一些面向文本的算法进行有效的操作，但对于任意二进制数据通常不是这样（将文本处理算法盲目地应用于不是二进制数据格式ASCII兼容通常会导致数据损坏）。</span></p><p><span class="yiyi-st" id="yiyi-926">除了文字形式之外，字节对象还可以通过其他方式创建：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-927">一个指定长度的零填充字节对象：<code class="docutils literal"><span class="pre">bytes(10)</span></code></span></li><li><span class="yiyi-st" id="yiyi-928">从整数迭代：<code class="docutils literal"><span class="pre">bytes(range(20))</span></code></span></li><li><span class="yiyi-st" id="yiyi-929">通过缓冲区协议复制现有的二进制数据：<code class="docutils literal"><span class="pre">bytes(obj)</span></code></span></li></ul><p><span class="yiyi-st" id="yiyi-930">另请参阅内置的<a class="reference internal" href="functions.html#func-bytes"><span>bytes</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-931">由于2个十六进制数字精确地对应于单个字节，所以十六进制数字是用于描述二进制数据的通常使用的格式。</span><span class="yiyi-st" id="yiyi-932">因此，字节类型具有额外的类方法来读取该格式的数据：</span></p><dl class="classmethod"><dt id="bytes.fromhex"><span class="yiyi-st" id="yiyi-933"><em class="property">classmethod </em><code class="descclassname">bytes.</code><code class="descname">fromhex</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-934">这个<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>类方法返回一个字节对象，解码给定的字符串对象。</span><span class="yiyi-st" id="yiyi-935">该字符串必须包含每个字节两个十六进制数字，忽略ASCII空格。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">'2Ef0 F1f2  '</span><span class="p">)</span>
<span class="go">b'.\xf0\xf1\xf2'</span>
</code></pre></dd></dl><p><span class="yiyi-st" id="yiyi-936">存在反向转换函数将字节对象转换为其十六进制表示形式。</span></p><dl class="method"><dt id="bytes.hex"><span class="yiyi-st" id="yiyi-937"><code class="descclassname">bytes.</code><code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-938">返回一个字符串对象，在实例中每个字节包含两个十六进制数字。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'</span><span class="se">\xf0\xf1\xf2</span><span class="s1">'</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">'f0f1f2'</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-939"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-940">由于字节对象是整数序列（类似于元组），对于字节对象<em>b</em>，<code class="docutils literal"><span class="pre">b[0]</span></code>将是一个整数，而<code class="docutils literal"><span class="pre">b[0:1]</span></code>将是一个长度为1的字节对象。</span><span class="yiyi-st" id="yiyi-941">（这与文本字符串形成对比，其中索引和切片将产生长度为1的字符串）</span></p><p><span class="yiyi-st" id="yiyi-942">字节对象的表示使用字面格式（<code class="docutils literal"><span class="pre">b'...'</span></code>），因为它通常比实例更有用。</span><span class="yiyi-st" id="yiyi-943"><code class="docutils literal"><span class="pre">字节（[46，</span> <span class="pre">46，</span> <span class="pre">46]）</span></code>。</span><span class="yiyi-st" id="yiyi-944">您总是可以使用<code class="docutils literal"><span class="pre">list(b)</span></code>将字节对象转换为整数列表。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-945">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-946">对于Python 2.x用户：在Python 2.x系列中，允许在8位字符串（最接近的2.x提供给内置二进制数据类型）和Unicode字符串之间进行各种隐式转换。</span><span class="yiyi-st" id="yiyi-947">这是一个向后兼容的解决方法，以说明Python最初只支持8位文本，而Unicode文本是后来的补充。</span><span class="yiyi-st" id="yiyi-948">在Python 3.x中，这些隐式转换消失了 -  8位二进制数据和Unicode文本之间的转换必须是明确的，而字节和字符串对象总是会比较不等。</span></p></div></div><div class="section" id="bytearray-objects"><h3><span class="yiyi-st" id="yiyi-949">4.8.2.</span><span class="yiyi-st" id="yiyi-950">Bytearray对象</span></h3><p id="index-39"><span class="yiyi-st" id="yiyi-951"><a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>对象是<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>对象的可变对象。</span><span class="yiyi-st" id="yiyi-952">对于bytearray对象没有专用的字面值语法，而是总是通过调用构造函数创建的：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-953">创建一个空实例：<code class="docutils literal"><span class="pre">bytearray()</span></code></span></li><li><span class="yiyi-st" id="yiyi-954">创建一个给定10个字节长度的零填充实例：<code class="docutils literal"><span class="pre">bytearray（10）</span></code></span></li><li><span class="yiyi-st" id="yiyi-955">从一个可迭代的整数对象填充数据：<code class="docutils literal"><span class="pre">bytearray（range（20））</span></code></span></li><li><span class="yiyi-st" id="yiyi-956">通过缓冲区协议复制现有的二进制数据：<code class="docutils literal"><span class="pre">bytearray（b'Hi！'）</span></code></span></li></ul><p><span class="yiyi-st" id="yiyi-957">由于bytearray对象是可变的，除了在<a class="reference internal" href="#bytes-methods"><span>Bytes and Bytearray Operations</span></a>中描述的常见字节和字节阵列操作之外，它们还支持<a class="reference internal" href="#typesseq-mutable"><span>mutable</span></a>序列操作。</span></p><p><span class="yiyi-st" id="yiyi-958">另请参阅内置的<a class="reference internal" href="functions.html#func-bytearray"><span>bytearray</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-959">由于2个十六进制数字精确地对应于单个字节，所以十六进制数字是用于描述二进制数据的通常使用的格式。</span><span class="yiyi-st" id="yiyi-960">因此，bytearray类型具有一个附加类方法来读取该格式的数据：</span></p><dl class="classmethod"><dt id="bytearray.fromhex"><span class="yiyi-st" id="yiyi-961"><em class="property">classmethod </em><code class="descclassname">bytearray.</code><code class="descname">fromhex</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-962">这个<a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>类方法返回bytearray对象，解码给定的字符串对象。</span><span class="yiyi-st" id="yiyi-963">该字符串必须包含每个字节两个十六进制数字，忽略ASCII空格。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytearray</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">'2Ef0 F1f2  '</span><span class="p">)</span>
<span class="go">bytearray(b'.\xf0\xf1\xf2')</span>
</code></pre></dd></dl><p><span class="yiyi-st" id="yiyi-964">存在一个逆转换函数将一个bytearray对象转换为十六进制表示。</span></p><dl class="method"><dt id="bytearray.hex"><span class="yiyi-st" id="yiyi-965"><code class="descclassname">bytearray.</code><code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-966">返回一个字符串对象，在实例中每个字节包含两个十六进制数字。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s1">'</span><span class="se">\xf0\xf1\xf2</span><span class="s1">'</span><span class="p">)</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">'f0f1f2'</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-967"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-968">由于bytearray对象是整数序列（类似于列表），对于bytearray对象<em>b</em>，<code class="docutils literal"><span class="pre">b [0]</span></code>将是整数，而<code class="docutils literal"><span class="pre">b [0 ：1]</span></code>将是长度为1的bytearray对象。</span><span class="yiyi-st" id="yiyi-969">（这与文本字符串形成对比，其中索引和切片将产生长度为1的字符串）</span></p><p><span class="yiyi-st" id="yiyi-970">bytearray对象的表示使用字节字面值格式（<code class="docutils literal"><span class="pre">bytearray（b'...'）</span></code>），因为它通常比例如。</span><span class="yiyi-st" id="yiyi-971"><code class="docutils literal"><span class="pre">bytearray（[46，</span> <span class="pre">46，</span> <span class="pre">46]）</span></code>。</span><span class="yiyi-st" id="yiyi-972">您总是可以使用<code class="docutils literal"><span class="pre">list（b）</span></code>将bytearray对象转换为整数列表。</span></p></div><div class="section" id="bytes-and-bytearray-operations"><h3><span class="yiyi-st" id="yiyi-973">4.8.3.</span><span class="yiyi-st" id="yiyi-974">Bytes和Bytearray操作</span></h3><p id="index-40"><span class="yiyi-st" id="yiyi-975">bytes和bytearray对象都支持<a class="reference internal" href="#typesseq-common"><span>公共</span></a>序列操作。</span><span class="yiyi-st" id="yiyi-976">它们不仅与相同类型的操作数互操作，而且可与任何<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">字节状对象</span></a>进行互操作。</span><span class="yiyi-st" id="yiyi-977">由于这种灵活性，它们可以在操作中自由混合而不引起错误。</span><span class="yiyi-st" id="yiyi-978">但是，结果的返回类型可能取决于操作数的顺序。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-979">注意</span></p><p><span class="yiyi-st" id="yiyi-980">字节和bytearray对象的方法不接受字符串作为它们的参数，就像字符串上的方法不接受字节作为它们的参数一样。</span><span class="yiyi-st" id="yiyi-981">例如，你必须写：</span></p><pre><code class="language-python"><span></span><span class="n">a</span> <span class="o">=</span> <span class="s2">"abc"</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"a"</span><span class="p">,</span> <span class="s2">"f"</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-982">和：</span></p><div class="last highlight-python3"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="s2">"abc"</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">b</span><span class="s2">"a"</span><span class="p">,</span> <span class="n">b</span><span class="s2">"f"</span><span class="p">)</span>
</pre></div></div></div><p><span class="yiyi-st" id="yiyi-983">一些字节和bytearray操作假定使用ASCII兼容的二进制格式，因此在使用任意二进制数据时应避免使用。</span><span class="yiyi-st" id="yiyi-984">这些限制如下。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-985">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-986">使用这些基于ASCII的操作来处理未以ASCII格式存储的二进制数据可能导致数据损坏。</span></p></div><p><span class="yiyi-st" id="yiyi-987">字节和bytearray对象的以下方法可以与任意二进制数据一起使用。</span></p><dl class="method"><dt id="bytes.count"><span class="yiyi-st" id="yiyi-988"><code class="descclassname">bytes.</code><code class="descname">count</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.count"><span class="yiyi-st" id="yiyi-989"><code class="descclassname">bytearray.</code><code class="descname">count</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-990">返回范围[<em>开始</em>，<em>结束</em>]中的子序列<em>sub</em>的字节对象的个数。</span><span class="yiyi-st" id="yiyi-991">可选参数<em>start</em>和<em>end</em>被解释为切片表示法。</span></p><p><span class="yiyi-st" id="yiyi-992">要搜索的子序列可以是任何<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">字节类对象</span></a>或0到255范围内的整数。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-993"><span class="versionmodified">在版本3.3中更改：</span>还接受范围为0到255的整数作为子序列。</span></p></div></dd></dl><dl class="method"><dt id="bytes.decode"><span class="yiyi-st" id="yiyi-994"><code class="descclassname">bytes.</code><code class="descname">decode</code><span class="sig-paren">(</span><em>encoding="utf-8"</em>, <em>errors="strict"</em><span class="sig-paren">)</span></span></dt><dt id="bytearray.decode"><span class="yiyi-st" id="yiyi-995"><code class="descclassname">bytearray.</code><code class="descname">decode</code><span class="sig-paren">(</span><em>encoding="utf-8"</em>, <em>errors="strict"</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-996">从bytes对象返回一个指定解码类型的字符串。</span><span class="yiyi-st" id="yiyi-997">默认编码为<code class="docutils literal"><span class="pre">'utf-8'</span></code>。</span><span class="yiyi-st" id="yiyi-998">可能会给出<em>错误</em>来设置不同的错误处理方案。</span><span class="yiyi-st" id="yiyi-999"><em>错误</em>的缺省值是<code class="docutils literal"><span class="pre">'strict'</span></code>，这意味着编码错误会引发一个<a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a>。</span><span class="yiyi-st" id="yiyi-1000">其他可能的值为<code class="docutils literal"><span class="pre">'ignore'</span></code>，<code class="docutils literal"><span class="pre">'replace'</span></code>和通过<a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal"><span class="pre">codecs.register_error()</span></code></a>注册的任何其他名称，请参见<a class="reference internal" href="codecs.html#error-handlers"><span>错误处理程序</span></a>。</span><span class="yiyi-st" id="yiyi-1001">有关可能的编码列表，请参见<a class="reference internal" href="codecs.html#standard-encodings"><span>Standard Encodings</span></a>部分。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1002">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1003">将<em>encoding</em>参数传递给<a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>允许直接解码任何<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes</span></a>，而不需要创建临时字节或bytearray对象。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1004"><span class="versionmodified">在版本3.1中已更改：</span>添加了对关键字参数的支持。</span></p></div></dd></dl><dl class="method"><dt id="bytes.endswith"><span class="yiyi-st" id="yiyi-1005"><code class="descclassname">bytes.</code><code class="descname">endswith</code><span class="sig-paren">(</span><em>suffix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.endswith"><span class="yiyi-st" id="yiyi-1006"><code class="descclassname">bytearray.</code><code class="descname">endswith</code><span class="sig-paren">(</span><em>suffix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1007">如果二进制数据以指定的<em>后缀</em>结尾，则返回<code class="docutils literal"><span class="pre">True </span></code>，否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span><span class="yiyi-st" id="yiyi-1008"><em>后缀</em>也可以是要查找的后缀元组。</span><span class="yiyi-st" id="yiyi-1009">使用可选的<em>start</em>，从该位置开始测试。</span><span class="yiyi-st" id="yiyi-1010">使用可选的<em>结束</em>，停止在该位置进行比较。</span></p><p><span class="yiyi-st" id="yiyi-1011">要搜索的后缀可以是任何<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">字节状对象</span></a>。</span></p></dd></dl><dl class="method"><dt id="bytes.find"><span class="yiyi-st" id="yiyi-1012"><code class="descclassname">bytes.</code><code class="descname">find</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.find"><span class="yiyi-st" id="yiyi-1013"><code class="descclassname">bytearray.</code><code class="descname">find</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1014">返回发现子序列<em>sub</em>的数据中的最低索引，使得<em>sub</em>包含在片<code class="docutils literal"><span class="pre">s [start：end]</span></code>中。</span><span class="yiyi-st" id="yiyi-1015">可选参数<em>start</em>和<em>end</em>被解释为切片表示法。</span><span class="yiyi-st" id="yiyi-1016">如果未找到<em>sub</em>，则返回<code class="docutils literal"><span class="pre">-1</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-1017">要搜索的子序列可以是任何<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">字节状对象</span></a>或0到255范围内的整数。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1018">注意</span></p><p><span class="yiyi-st" id="yiyi-1019">只有当你需要知道<em>sub</em>的位置时，才应该使用<a class="reference internal" href="#bytes.find" title="bytes.find"><code class="xref py py-meth docutils literal"><span class="pre">find()</span></code></a>方法。</span><span class="yiyi-st" id="yiyi-1020">要检查<em>sub</em>是否为子字符串，请使用运算符中的<a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a></span></p><div class="last highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'Py'</span> <span class="ow">in</span> <span class="n">b</span><span class="s1">'Python'</span>
<span class="go">True</span>
</pre></div></div></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1021"><span class="versionmodified">在版本3.3中更改：</span>还接受范围为0到255的整数作为子序列。</span></p></div></dd></dl><dl class="method"><dt id="bytes.index"><span class="yiyi-st" id="yiyi-1022"><code class="descclassname">bytes.</code><code class="descname">index</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.index"><span class="yiyi-st" id="yiyi-1023"><code class="descclassname">bytearray.</code><code class="descname">index</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1024">像<a class="reference internal" href="#bytes.find" title="bytes.find"><code class="xref py py-meth docutils literal"><span class="pre">find()</span></code></a>，但是如果找不到子序列，则会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>异常。</span></p><p><span class="yiyi-st" id="yiyi-1025">要搜索的子序列可以是任何<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">字节状对象</span></a>或0到255范围内的整数。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1026"><span class="versionmodified">在版本3.3中更改：</span>还接受范围为0到255的整数作为子序列。</span></p></div></dd></dl><dl class="method"><dt id="bytes.join"><span class="yiyi-st" id="yiyi-1027"><code class="descclassname">bytes.</code><code class="descname">join</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span></span></dt><dt id="bytearray.join"><span class="yiyi-st" id="yiyi-1028"><code class="descclassname">bytearray.</code><code class="descname">join</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1029">返回字节或bytearray对象，它是<a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">可迭代</span></a> <em>可迭代</em>中二进制数据序列的连接。译者例子:b''.join([b'a',b'b'])。</span><span class="yiyi-st" id="yiyi-1030">如果<em>iterable</em>中有任何值不是<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes的对象</span></a>，包括<a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>，则会引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>对象。</span><span class="yiyi-st" id="yiyi-1031">元素之间的分隔符是提供此方法的字节或bytearray对象的内容。</span></p></dd></dl><dl class="staticmethod"><dt id="bytes.maketrans"><span class="yiyi-st" id="yiyi-1032"><em class="property">static </em><code class="descclassname">bytes.</code><code class="descname">maketrans</code><span class="sig-paren">(</span><em>from</em>, <em>to</em><span class="sig-paren">)</span></span></dt><dt id="bytearray.maketrans"><span class="yiyi-st" id="yiyi-1033"><em class="property">static </em><code class="descclassname">bytearray.</code><code class="descname">maketrans</code><span class="sig-paren">(</span><em>from</em>, <em>to</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1034">此静态方法返回可用于<a class="reference internal" href="#bytes.translate" title="bytes.translate"><code class="xref py py-meth docutils literal"><span class="pre">bytes.translate()</span></code></a>的翻译表，它将<em>中的每个字符从</em>映射到<em>中相同位置的字符到</em>； <em>从</em>和<em>到</em>必须都是<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">字节状对象</span></a>，并具有相同的长度。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1035"><span class="versionmodified">版本3.1中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="bytes.partition"><span class="yiyi-st" id="yiyi-1036"><code class="descclassname">bytes.</code><code class="descname">partition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span></span></dt><dt id="bytearray.partition"><span class="yiyi-st" id="yiyi-1037"><code class="descclassname">bytearray.</code><code class="descname">partition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1038">在第一次出现<em>sep</em>时分割序列，并返回包含分隔符之前的部分，分隔符和分隔符后面的部分的3元组。</span><span class="yiyi-st" id="yiyi-1039">如果找不到分隔符，则返回包含原始序列副本的3元组，后跟两个空字节或bytearray对象。</span></p><p><span class="yiyi-st" id="yiyi-1040">要搜索的分隔符可以是任何<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">字节状对象</span></a>。</span></p></dd></dl><dl class="method"><dt id="bytes.replace"><span class="yiyi-st" id="yiyi-1041"><code class="descclassname">bytes.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>old</em>, <em>new</em><span class="optional">[</span>, <em>count</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.replace"><span class="yiyi-st" id="yiyi-1042"><code class="descclassname">bytearray.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>old</em>, <em>new</em><span class="optional">[</span>, <em>count</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1043">返回序列的副本，其中所有出现的<em>old</em>替换为<em>new</em>。</span><span class="yiyi-st" id="yiyi-1044">如果给出可选参数<em>count</em>，则仅替换第一个<em>count</em>出现次数。</span></p><p><span class="yiyi-st" id="yiyi-1045">搜索和替换的子序列可以是任何<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">字节状对象</span></a>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1046">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1047">此方法的bytearray版本<em>不会</em>原地操作 - 它总是产生一个新对象，即使没有进行任何更改。</span></p></div></dd></dl><dl class="method"><dt id="bytes.rfind"><span class="yiyi-st" id="yiyi-1048"><code class="descclassname">bytes.</code><code class="descname">rfind</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.rfind"><span class="yiyi-st" id="yiyi-1049"><code class="descclassname">bytearray.</code><code class="descname">rfind</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1050">返回序列中找到子序列<em>sub</em>的最高索引，以使<em>sub</em>包含在<code class="docutils literal"><span class="pre">s [start：end]</span></code>中。</span><span class="yiyi-st" id="yiyi-1051">可选参数<em>start</em>和<em>end</em>被解释为切片表示法。</span><span class="yiyi-st" id="yiyi-1052">失败时返回<code class="docutils literal"><span class="pre">-1</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-1053">要搜索的子序列可以是任何<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">字节类对象</span></a>或0到255范围内的整数。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1054"><span class="versionmodified">在版本3.3中更改：</span>还接受范围为0到255的整数作为子序列。</span></p></div></dd></dl><dl class="method"><dt id="bytes.rindex"><span class="yiyi-st" id="yiyi-1055"><code class="descclassname">bytes.</code><code class="descname">rindex</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.rindex"><span class="yiyi-st" id="yiyi-1056"><code class="descclassname">bytearray.</code><code class="descname">rindex</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1057">与<a class="reference internal" href="#bytes.rfind" title="bytes.rfind"><code class="xref py py-meth docutils literal"><span class="pre">rfind()</span></code></a>类似，但在未找到子序列<em>子</em>时引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-1058">要搜索的子序列可以是任何<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">字节类对象</span></a>或0到255范围内的整数。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1059"><span class="versionmodified">在版本3.3中更改：</span>还接受范围为0到255的整数作为子序列。</span></p></div></dd></dl><dl class="method"><dt id="bytes.rpartition"><span class="yiyi-st" id="yiyi-1060"><code class="descclassname">bytes.</code><code class="descname">rpartition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span></span></dt><dt id="bytearray.rpartition"><span class="yiyi-st" id="yiyi-1061"><code class="descclassname">bytearray.</code><code class="descname">rpartition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1062">拆分最后一次<em>sep</em>的序列，并返回包含分隔符之前的部分，分隔符和分隔符后面的部分的3元组。</span><span class="yiyi-st" id="yiyi-1063">如果找不到分隔符，则返回包含原始序列副本的3元组，后跟两个空字节或bytearray对象。</span></p><p><span class="yiyi-st" id="yiyi-1064">要搜索的分隔符可以是任何<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">字节状对象</span></a>。</span></p></dd></dl><dl class="method"><dt id="bytes.startswith"><span class="yiyi-st" id="yiyi-1065"> <code class="descclassname">bytes.</code><code class="descname">startswith</code><span class="sig-paren">(</span><em>prefix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.startswith"><span class="yiyi-st" id="yiyi-1066"><code class="descclassname">bytearray.</code><code class="descname">startswith</code><span class="sig-paren">(</span><em>prefix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1067">如果二进制数据以指定的<em>前缀</em>开头，则返回<code class="docutils literal"><span class="pre">True</span></code>，否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span><span class="yiyi-st" id="yiyi-1068"><em>前缀</em>也可以是要查找的前缀元组。</span><span class="yiyi-st" id="yiyi-1069">使用可选的<em>start</em>，从该位置开始测试。</span><span class="yiyi-st" id="yiyi-1070">使用可选的<em>结束</em>，停止在该位置进行比较。</span></p><p><span class="yiyi-st" id="yiyi-1071">要搜索的前缀可以是任何<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">字节状对象</span></a>。</span></p></dd></dl><dl class="method"><dt id="bytes.translate"><span class="yiyi-st" id="yiyi-1072"> <code class="descclassname">bytes.</code><code class="descname">translate</code><span class="sig-paren">(</span><em>table</em><span class="optional">[</span>, <em>delete</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.translate"><span class="yiyi-st" id="yiyi-1073"> <code class="descclassname">bytearray.</code><code class="descname">translate</code><span class="sig-paren">(</span><em>table</em><span class="optional">[</span>, <em>delete</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1074">返回字节或bytearray对象的副本，其中发生在可选参数<em>delete</em>中的所有字节都被删除，剩余的字节已通过给定的转换表映射，该转换表必须是长度为256的字节对象。</span></p><p><span class="yiyi-st" id="yiyi-1075">您可以使用<a class="reference internal" href="#bytes.maketrans" title="bytes.maketrans"><code class="xref py py-func docutils literal"><span class="pre">bytes.maketrans()</span></code></a>方法来创建转换表。</span></p><p><span class="yiyi-st" id="yiyi-1076">对于只删除字符的转换，将<em>表</em>参数设置为<code class="docutils literal"><span class="pre">None</span></code>：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'read this short text'</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">b</span><span class="s1">'aeiou'</span><span class="p">)</span>
<span class="go">b'rd ths shrt txt'</span>
</code></pre></dd></dl><p><span class="yiyi-st" id="yiyi-1077">以下对字节和bytearray对象的方法具有默认行为，它们假定使用ASCII兼容的二进制格式，但仍然可以通过传递适当的参数与任意二进制数据一起使用。</span><span class="yiyi-st" id="yiyi-1078">请注意，本节中的所有bytearray方法都不会<em></em>原地操作，而是生成新对象。</span></p><dl class="method"><dt id="bytes.center"><span class="yiyi-st" id="yiyi-1079"> <code class="descclassname">bytes.</code><code class="descname">center</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.center"><span class="yiyi-st" id="yiyi-1080"><code class="descclassname">bytearray.</code><code class="descname">center</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1081">返回以长度<em>width</em>的序列居中的对象的副本。</span><span class="yiyi-st" id="yiyi-1082">填充使用指定的<em>fillbyte</em>（默认为ASCII空格）完成。</span><span class="yiyi-st" id="yiyi-1083">对于<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">字节</span></code></a>对象，如果<em>width</em>小于或等于<code class="docutils literal"><span class="pre">len（s）</span></code>，则返回原始序列。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1084">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1085">此方法的bytearray版本<em>不会</em>原地操作 - 它总是产生一个新对象，即使没有进行任何更改。</span></p></div></dd></dl><dl class="method"><dt id="bytes.ljust"><span class="yiyi-st" id="yiyi-1086"><code class="descclassname">bytes.</code><code class="descname">ljust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.ljust"><span class="yiyi-st" id="yiyi-1087"><code class="descclassname">bytearray.</code><code class="descname">ljust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1088">以长度<em>width</em>的顺序返回左对齐的对象的副本。</span><span class="yiyi-st" id="yiyi-1089">填充使用指定的<em>fillbyte</em>（默认为ASCII空格）完成。</span><span class="yiyi-st" id="yiyi-1090">对于<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">字节</span></code></a>对象，如果<em>width</em>小于或等于<code class="docutils literal"><span class="pre">len（s）</span></code>，则返回原始序列。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1091">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1092">此方法的bytearray版本<em>不会</em>原地操作 - 它总是产生一个新对象，即使没有进行任何更改。</span></p></div></dd></dl><dl class="method"><dt id="bytes.lstrip"><span class="yiyi-st" id="yiyi-1093"> <code class="descclassname">bytes.</code><code class="descname">lstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.lstrip"><span class="yiyi-st" id="yiyi-1094"> <code class="descclassname">bytearray.</code><code class="descname">lstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1095">返回删除指定前导字节的序列副本。</span><span class="yiyi-st" id="yiyi-1096"><em>chars</em>参数是一个二进制序列，用于指定要删除的字节值集合 - 名称是指此方法通常与ASCII字符一起使用的事实。</span><span class="yiyi-st" id="yiyi-1097">如果省略或<code class="docutils literal"><span class="pre">None</span></code>，<em>chars</em>参数默认为删除ASCII空格。</span><span class="yiyi-st" id="yiyi-1098"><em>字符</em>参数不是前缀；相反，其值的所有组合都被剥离：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'   spacious   '</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
<span class="go">b'spacious   '</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'www.example.com'</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="n">b</span><span class="s1">'cmowz.'</span><span class="p">)</span>
<span class="go">b'example.com'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1099">要移除的字节值的二进制序列可以是任何<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1100">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1101">此方法的bytearray版本<em>不会</em>原地操作 - 它总是产生一个新对象，即使没有进行任何更改。</span></p></div></dd></dl><dl class="method"><dt id="bytes.rjust"><span class="yiyi-st" id="yiyi-1102"> <code class="descclassname">bytes.</code><code class="descname">rjust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.rjust"><span class="yiyi-st" id="yiyi-1103"> <code class="descclassname">bytearray.</code><code class="descname">rjust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1104">按照长度<em>宽度</em>的顺序返回右对齐的对象的副本。</span><span class="yiyi-st" id="yiyi-1105">填充使用指定的<em>fillbyte</em>（默认为ASCII空格）完成。</span><span class="yiyi-st" id="yiyi-1106">对于<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">字节</span></code></a>对象，如果<em>width</em>小于或等于<code class="docutils literal"><span class="pre">len（s）</span></code>，则返回原始序列。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1107">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1108">此方法的bytearray版本<em>不会</em>原地操作 - 它总是产生一个新对象，即使没有进行任何更改。</span></p></div></dd></dl><dl class="method"><dt id="bytes.rsplit"><span class="yiyi-st" id="yiyi-1109"><code class="descclassname">bytes.</code><code class="descname">rsplit</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span></span></dt><dt id="bytearray.rsplit"><span class="yiyi-st" id="yiyi-1110"><code class="descclassname">bytearray.</code><code class="descname">rsplit</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1111">将二进制序列拆分为相同类型的子序列，使用<em>sep</em>作为分隔符字符串。</span><span class="yiyi-st" id="yiyi-1112">如果给出<em>maxsplit</em>，则最多<em>maxsplit</em>分割完成，<em>最右边</em>个分割。</span><span class="yiyi-st" id="yiyi-1113">如果未指定<em>sep</em>或<code class="docutils literal"><span class="pre">None</span></code>，则任何仅由ASCII空白组成的子序列都是分隔符。</span><span class="yiyi-st" id="yiyi-1114">除了从右边分割外，<a class="reference internal" href="#bytearray.rsplit" title="bytearray.rsplit"><code class="xref py py-meth docutils literal"><span class="pre">rsplit()</span></code></a>的行为与<a class="reference internal" href="#bytearray.split" title="bytearray.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a>的行为类似，下面详细介绍。</span></p></dd></dl><dl class="method"><dt id="bytes.rstrip"><span class="yiyi-st" id="yiyi-1115"> <code class="descclassname">bytes.</code><code class="descname">rstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.rstrip"><span class="yiyi-st" id="yiyi-1116"> <code class="descclassname">bytearray.</code><code class="descname">rstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1117">返回删除指定尾随字节的序列副本。</span><span class="yiyi-st" id="yiyi-1118"><em>chars</em>参数是一个二进制序列，用于指定要删除的字节值集合 - 名称是指此方法通常与ASCII字符一起使用的事实。</span><span class="yiyi-st" id="yiyi-1119">如果省略或<code class="docutils literal"><span class="pre">None</span></code>，<em>chars</em>参数默认为删除ASCII空格。</span><span class="yiyi-st" id="yiyi-1120"><em>chars</em>参数不是后缀；相反，其值的所有组合都被剥离：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'   spacious   '</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
<span class="go">b'   spacious'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'mississippi'</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="n">b</span><span class="s1">'ipz'</span><span class="p">)</span>
<span class="go">b'mississ'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1121">要移除的字节值的二进制序列可以是任何<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1122">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1123">此方法的bytearray版本<em>不会</em>原地操作 - 它总是产生一个新对象，即使没有进行任何更改。</span></p></div></dd></dl><dl class="method"><dt id="bytes.split"><span class="yiyi-st" id="yiyi-1124"><code class="descclassname">bytes.</code><code class="descname">split</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span></span></dt><dt id="bytearray.split"><span class="yiyi-st" id="yiyi-1125"><code class="descclassname">bytearray.</code><code class="descname">split</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1126">将二进制序列拆分为相同类型的子序列，使用<em>sep</em>作为分隔符字符串。</span><span class="yiyi-st" id="yiyi-1127">如果给出了<em>maxsplit</em>并且是非负的，那么至多完成<em>maxsplit</em>分割（因此，列表最多将具有<code class="docutils literal"><span class="pre">maxsplit+1</span></code></span><span class="yiyi-st" id="yiyi-1128">如果没有指定<em>maxsplit</em>或者<code class="docutils literal"><span class="pre">-1</span></code>，那么分割数量没有限制（所有可能的分割）。</span></p><p><span class="yiyi-st" id="yiyi-1129">If <em>sep</em> is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, <code class="docutils literal"><span class="pre">b'1,,2'.split(b',')</span></code> returns <code class="docutils literal"><span class="pre">[b'1',</span> <span class="pre">b'',</span> <span class="pre">b'2']</span></code>). </span><span class="yiyi-st" id="yiyi-1130">The <em>sep</em> argument may consist of a multibyte sequence (for example, <code class="docutils literal"><span class="pre">b'1&lt;&gt;2&lt;&gt;3'.split(b'&lt;&gt;')</span></code> returns <code class="docutils literal"><span class="pre">[b'1',</span> <span class="pre">b'2',</span> <span class="pre">b'3']</span></code>). </span><span class="yiyi-st" id="yiyi-1131">根据要拆分的对象的类型，将指定分隔符的空序列拆分返回<code class="docutils literal"><span class="pre">[b'']</span></code>或<code class="docutils literal"><span class="pre">[bytearray(b'')]</span></code></span><span class="yiyi-st" id="yiyi-1132"><em>sep</em>参数可以是任何<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-1133">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'1,2,3'</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">b</span><span class="s1">','</span><span class="p">)</span>
<span class="go">[b'1', b'2', b'3']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'1,2,3'</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">b</span><span class="s1">','</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[b'1', b'2,3']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'1,2,,3,'</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">b</span><span class="s1">','</span><span class="p">)</span>
<span class="go">[b'1', b'2', b'', b'3', b'']</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1134">如果没有指定<em>sep</em>或者是<code class="docutils literal"><span class="pre">None</span></code>，则应用不同的拆分算法：将连续的ASCII空格运行视为单个分隔符，结果将不包含空字符串在开始或结束时如果序列具有前导或尾随空白。</span><span class="yiyi-st" id="yiyi-1135">因此，分割一个空白序列或一个仅由ASCII空白组成的序列而没有指定的分隔符会返回<code class="docutils literal"><span class="pre">[]</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-1136">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'1 2 3'</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[b'1', b'2', b'3']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'1 2 3'</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[b'1', b'2 3']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'   1   2   3   '</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[b'1', b'2', b'3']</span>
</code></pre></dd></dl><dl class="method"><dt id="bytes.strip"><span class="yiyi-st" id="yiyi-1137"> <code class="descclassname">bytes.</code><code class="descname">strip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.strip"><span class="yiyi-st" id="yiyi-1138"> <code class="descclassname">bytearray.</code><code class="descname">strip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1139">返回删除指定前导字节和尾随字节的副本。</span><span class="yiyi-st" id="yiyi-1140"><em>chars</em>参数是一个二进制序列，用于指定要删除的字节值集合 - 名称是指此方法通常与ASCII字符一起使用的事实。</span><span class="yiyi-st" id="yiyi-1141">如果省略或<code class="docutils literal"><span class="pre">None</span></code>，<em>chars</em>参数默认为删除ASCII空格。</span><span class="yiyi-st" id="yiyi-1142"><em>chars</em>参数不是前缀或后缀；相反，其值的所有组合都被剥离：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'   spacious   '</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="go">b'spacious'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'www.example.com'</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="n">b</span><span class="s1">'cmowz.'</span><span class="p">)</span>
<span class="go">b'example'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1143">要移除的字节值的二进制序列可以是任何<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1144">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1145">此方法的bytearray版本<em>不会</em>原地操作 - 它总是产生一个新对象，即使没有进行任何更改。</span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-1146">字节和字节数组对象的以下方法假定使用ASCII兼容的二进制格式，不应将其应用于任意二进制数据。</span><span class="yiyi-st" id="yiyi-1147">请注意，本节中的所有bytearray方法都不会<em></em>原地操作，而是生成新对象。</span></p><dl class="method"><dt id="bytes.capitalize"><span class="yiyi-st" id="yiyi-1148"><code class="descclassname">bytes.</code><code class="descname">capitalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.capitalize"><span class="yiyi-st" id="yiyi-1149"><code class="descclassname">bytearray.</code><code class="descname">capitalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1150">返回序列的一个副本，每个字节解释为一个ASCII字符，第一个字节大写，其余的小写。</span><span class="yiyi-st" id="yiyi-1151">非ASCII字节值通过不变。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1152">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1153">此方法的bytearray版本<em>不会</em>原地操作 - 它总是产生一个新对象，即使没有进行任何更改。</span></p></div></dd></dl><dl class="method"><dt id="bytes.expandtabs"><span class="yiyi-st" id="yiyi-1154"><code class="descclassname">bytes.</code><code class="descname">expandtabs</code><span class="sig-paren">(</span><em>tabsize=8</em><span class="sig-paren">)</span></span></dt><dt id="bytearray.expandtabs"><span class="yiyi-st" id="yiyi-1155"><code class="descclassname">bytearray.</code><code class="descname">expandtabs</code><span class="sig-paren">(</span><em>tabsize=8</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1156">根据当前列和给定的选项卡大小，将所有ASCII选项卡字符替换为一个或多个ASCII空格的序列副本返回。</span><span class="yiyi-st" id="yiyi-1157">每个<em>tabsize</em>字节都会出现制表位（默认值为8，在列0,8,16等处提供制表位置）。</span><span class="yiyi-st" id="yiyi-1158">要扩展序列，将当前列设置为零，并逐个字节地检查序列。</span><span class="yiyi-st" id="yiyi-1159">如果该字节是ASCII制表符（<code class="docutils literal"><span class="pre">b'\t'</span></code>），则在结果中插入一个或多个空格字符，直到当前列等于下一个制表符位置。</span><span class="yiyi-st" id="yiyi-1160">（制表符本身不被复制。）</span><span class="yiyi-st" id="yiyi-1161">如果当前字节是一个ASCII换行符（<code class="docutils literal"><span class="pre">b'\n'</span></code>）或回车符（<code class="docutils literal"><span class="pre">b'\r'</span></code>），它将被复制并且当前列被重置为零。</span><span class="yiyi-st" id="yiyi-1162">不管打印时字节值的表示方式如何，任何其他字节值都将保持不变并且当前列增加1：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234'</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
<span class="go">b'01      012     0123    01234'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234'</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">b'01  012 0123    01234'</span>
</code></pre><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1163">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1164">此方法的bytearray版本<em>不会</em>原地操作 - 它总是产生一个新对象，即使没有进行任何更改。</span></p></div></dd></dl><dl class="method"><dt id="bytes.isalnum"><span class="yiyi-st" id="yiyi-1165"><code class="descclassname">bytes.</code><code class="descname">isalnum</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.isalnum"><span class="yiyi-st" id="yiyi-1166"><code class="descclassname">bytearray.</code><code class="descname">isalnum</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1167">如果序列中的所有字节均为字母ASCII字符或ASCII十进制数字，且序列不为空，则返回true，否则返回false。</span><span class="yiyi-st" id="yiyi-1168">Alphabetic ASCII characters are those byte values in the sequence <code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>. </span><span class="yiyi-st" id="yiyi-1169">ASCII十进制数字是序列<code class="docutils literal"><span class="pre">b'0123456789'</span></code>中的那些字节值。</span></p><p><span class="yiyi-st" id="yiyi-1170">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'ABCabc1'</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'ABC abc1'</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span>
<span class="go">False</span>
</code></pre></dd></dl><dl class="method"><dt id="bytes.isalpha"><span class="yiyi-st" id="yiyi-1171"><code class="descclassname">bytes.</code><code class="descname">isalpha</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.isalpha"><span class="yiyi-st" id="yiyi-1172"><code class="descclassname">bytearray.</code><code class="descname">isalpha</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1173">如果序列中的所有字节均为字母ASCII字符且序列不为空，则返回true，否则返回false。</span><span class="yiyi-st" id="yiyi-1174">Alphabetic ASCII characters are those byte values in the sequence <code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-1175">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'ABCabc'</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'ABCabc1'</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span>
<span class="go">False</span>
</code></pre></dd></dl><dl class="method"><dt id="bytes.isdigit"><span class="yiyi-st" id="yiyi-1176"><code class="descclassname">bytes.</code><code class="descname">isdigit</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.isdigit"><span class="yiyi-st" id="yiyi-1177"><code class="descclassname">bytearray.</code><code class="descname">isdigit</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1178">如果序列中的所有字节均为ASCII十进制数字，且序列不为空，则返回true，否则返回false。</span><span class="yiyi-st" id="yiyi-1179">ASCII十进制数字是序列<code class="docutils literal"><span class="pre">b'0123456789'</span></code>中的那些字节值。</span></p><p><span class="yiyi-st" id="yiyi-1180">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'1234'</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'1.23'</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span>
<span class="go">False</span>
</code></pre></dd></dl><dl class="method"><dt id="bytes.islower"><span class="yiyi-st" id="yiyi-1181"><code class="descclassname">bytes.</code><code class="descname">islower</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.islower"><span class="yiyi-st" id="yiyi-1182"><code class="descclassname">bytearray.</code><code class="descname">islower</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1183">如果序列中至少有一个小写ASCII字符，并且没有大写ASCII字符，则返回true，否则返回false。</span></p><p><span class="yiyi-st" id="yiyi-1184">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'hello world'</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'Hello world'</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span>
<span class="go">False</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1185">小写ASCII字符是序列中的那些字节值<code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>。</span><span class="yiyi-st" id="yiyi-1186">大写ASCII字符是序列<code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>中的那些字节值。</span></p></dd></dl><dl class="method"><dt id="bytes.isspace"><span class="yiyi-st" id="yiyi-1187"><code class="descclassname">bytes.</code><code class="descname">isspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.isspace"><span class="yiyi-st" id="yiyi-1188"><code class="descclassname">bytearray.</code><code class="descname">isspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1189">如果序列中的所有字节均为ASCII空格且序列不为空，则返回true，否则返回false。</span><span class="yiyi-st" id="yiyi-1190">ASCII whitespace characters are those byte values in the sequence <code class="docutils literal"><span class="pre">b'</span> <span class="pre">\t\n\r\x0b\f'</span></code> (space, tab, newline, carriage return, vertical tab, form feed).</span></p></dd></dl><dl class="method"><dt id="bytes.istitle"><span class="yiyi-st" id="yiyi-1191"><code class="descclassname">bytes.</code><code class="descname">istitle</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.istitle"><span class="yiyi-st" id="yiyi-1192"><code class="descclassname">bytearray.</code><code class="descname">istitle</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1193">如果序列是ASCII标题并且序列不为空，则返回true，否则返回false。</span><span class="yiyi-st" id="yiyi-1194">有关“titlecase”定义的更多详细信息，请参见<a class="reference internal" href="#bytes.title" title="bytes.title"><code class="xref py py-meth docutils literal"><span class="pre">bytes.title()</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-1195">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'Hello World'</span><span class="o">.</span><span class="n">istitle</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'Hello world'</span><span class="o">.</span><span class="n">istitle</span><span class="p">()</span>
<span class="go">False</span>
</code></pre></dd></dl><dl class="method"><dt id="bytes.isupper"><span class="yiyi-st" id="yiyi-1196"><code class="descclassname">bytes.</code><code class="descname">isupper</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.isupper"><span class="yiyi-st" id="yiyi-1197"><code class="descclassname">bytearray.</code><code class="descname">isupper</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1198">如果序列中至少有一个大写字母ASCII字符，并且没有小写ASCII字符，则返回true，否则返回false。</span></p><p><span class="yiyi-st" id="yiyi-1199">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'HELLO WORLD'</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'Hello world'</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
<span class="go">False</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1200">小写ASCII字符是序列中的那些字节值<code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>。</span><span class="yiyi-st" id="yiyi-1201">大写ASCII字符是序列<code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>中的那些字节值。</span></p></dd></dl><dl class="method"><dt id="bytes.lower"><span class="yiyi-st" id="yiyi-1202"><code class="descclassname">bytes.</code><code class="descname">lower</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.lower"><span class="yiyi-st" id="yiyi-1203"><code class="descclassname">bytearray.</code><code class="descname">lower</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1204">将所有大写ASCII字符转换为其对应的小写字母的序列的副本。</span></p><p><span class="yiyi-st" id="yiyi-1205">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'Hello World'</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="go">b'hello world'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1206">小写ASCII字符是序列中的那些字节值<code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>。</span><span class="yiyi-st" id="yiyi-1207">大写ASCII字符是序列<code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>中的那些字节值。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1208">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1209">此方法的bytearray版本<em>不会</em>原地操作 - 它总是产生一个新对象，即使没有进行任何更改。</span></p></div></dd></dl><dl class="method"><dt id="bytes.splitlines"><span class="yiyi-st" id="yiyi-1210"><code class="descclassname">bytes.</code><code class="descname">splitlines</code><span class="sig-paren">(</span><em>keepends=False</em><span class="sig-paren">)</span></span></dt><dt id="bytearray.splitlines"><span class="yiyi-st" id="yiyi-1211"><code class="descclassname">bytearray.</code><code class="descname">splitlines</code><span class="sig-paren">(</span><em>keepends=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1212">返回二进制序列中的行列表，以ASCII行边界为中心。</span><span class="yiyi-st" id="yiyi-1213">此方法使用<a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a>方法来分割行。</span><span class="yiyi-st" id="yiyi-1214">换行符不包含在结果列表中，除非给出<em>keepends</em>且为true。</span></p><p><span class="yiyi-st" id="yiyi-1215">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">'</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[b'ab c', b'', b'de fg', b'kl']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">'</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[b'ab c\n', b'\n', b'de fg\r', b'kl\r\n']</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1216">与给定分隔符字符串<em>sep</em>时的<a class="reference internal" href="#bytes.split" title="bytes.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a>不同，此方法返回空字符串的空列表，并且终端行分隔符不会导致额外的行：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s2">""</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">b</span><span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">),</span> <span class="n">b</span><span class="s2">"Two lines</span><span class="se">\n</span><span class="s2">"</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">b</span><span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
<span class="go">([b''], [b'Two lines', b''])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s2">""</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(),</span> <span class="n">b</span><span class="s2">"One line</span><span class="se">\n</span><span class="s2">"</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">([], [b'One line'])</span>
</code></pre></dd></dl><dl class="method"><dt id="bytes.swapcase"><span class="yiyi-st" id="yiyi-1217"><code class="descclassname">bytes.</code><code class="descname">swapcase</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.swapcase"><span class="yiyi-st" id="yiyi-1218"><code class="descclassname">bytearray.</code><code class="descname">swapcase</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1219">将所有小写ASCII字符转换为相应的大写字母，反之亦然。</span></p><p><span class="yiyi-st" id="yiyi-1220">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'Hello World'</span><span class="o">.</span><span class="n">swapcase</span><span class="p">()</span>
<span class="go">b'hELLO wORLD'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1221">小写ASCII字符是序列中的那些字节值<code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>。</span><span class="yiyi-st" id="yiyi-1222">大写ASCII字符是序列<code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>中的那些字节值。</span></p><p><span class="yiyi-st" id="yiyi-1223">Unlike <a class="reference internal" href="#str.swapcase" title="str.swapcase"><code class="xref py py-func docutils literal"><span class="pre">str.swapcase()</span></code></a>, it is always the case that <code class="docutils literal"><span class="pre">bin.swapcase().swapcase()</span> <span class="pre">==</span> <span class="pre">bin</span></code> for the binary versions. </span><span class="yiyi-st" id="yiyi-1224">大小写转换在ASCII中是对称的，即使对于任意的Unicode代码点通常不是这样。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1225">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1226">此方法的bytearray版本<em>不会</em>原地操作 - 它总是产生一个新对象，即使没有进行任何更改。</span></p></div></dd></dl><dl class="method"><dt id="bytes.title"><span class="yiyi-st" id="yiyi-1227"><code class="descclassname">bytes.</code><code class="descname">title</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.title"><span class="yiyi-st" id="yiyi-1228"><code class="descclassname">bytearray.</code><code class="descname">title</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1229">返回二进制序列的标题版本，其中单词以大写ASCII字符开头，其余字符为小写。</span><span class="yiyi-st" id="yiyi-1230">Uncased字节值保持不变。</span></p><p><span class="yiyi-st" id="yiyi-1231">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'Hello world'</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">b'Hello World'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1232">小写ASCII字符是序列中的那些字节值<code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>。</span><span class="yiyi-st" id="yiyi-1233">大写ASCII字符是序列<code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>中的那些字节值。</span><span class="yiyi-st" id="yiyi-1234">所有其他字节值都是uncased。</span></p><p><span class="yiyi-st" id="yiyi-1235">该算法使用简单的与语言无关的单词作为连续字母组的定义。</span><span class="yiyi-st" id="yiyi-1236">该定义在许多情况下都有效，但这意味着收缩和占有者中的撇号会形成单词边界，这可能不是理想的结果：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s2">"they're bill's friends from the UK"</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">b"They'Re Bill'S Friends From The Uk"</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1237">可以使用正则表达式构造撇号的解决方法：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">titlecase</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">rb</span><span class="s2">"[A-Za-z]+('[A-Za-z]+)?"</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="k">lambda</span> <span class="n">mo</span><span class="p">:</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span>
<span class="gp">... </span>                             <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
<span class="gp">... </span>                  <span class="n">s</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">titlecase</span><span class="p">(</span><span class="n">b</span><span class="s2">"they're bill's friends."</span><span class="p">)</span>
<span class="go">b"They're Bill's Friends."</span>
</code></pre><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1238">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1239">此方法的bytearray版本<em>不会</em>原地操作 - 它总是产生一个新对象，即使没有进行任何更改。</span></p></div></dd></dl><dl class="method"><dt id="bytes.upper"><span class="yiyi-st" id="yiyi-1240"><code class="descclassname">bytes.</code><code class="descname">upper</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dt id="bytearray.upper"><span class="yiyi-st" id="yiyi-1241"><code class="descclassname">bytearray.</code><code class="descname">upper</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1242">将所有小写ASCII字符转换为其对应的大写字母的序列的副本。</span></p><p><span class="yiyi-st" id="yiyi-1243">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s1">'Hello World'</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
<span class="go">b'HELLO WORLD'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1244">小写ASCII字符是序列中的那些字节值<code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>。</span><span class="yiyi-st" id="yiyi-1245">大写ASCII字符是序列<code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>中的那些字节值。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1246">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1247">此方法的bytearray版本<em>不会</em>原地操作 - 它总是产生一个新对象，即使没有进行任何更改。</span></p></div></dd></dl><dl class="method"><dt id="bytes.zfill"><span class="yiyi-st" id="yiyi-1248"><code class="descclassname">bytes.</code><code class="descname">zfill</code><span class="sig-paren">(</span><em>width</em><span class="sig-paren">)</span></span></dt><dt id="bytearray.zfill"><span class="yiyi-st" id="yiyi-1249"><code class="descclassname">bytearray.</code><code class="descname">zfill</code><span class="sig-paren">(</span><em>width</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1250">返回左侧用ASCII <code class="docutils literal"><span class="pre">b'0'</span></code>数字填充的序列副本，以产生长度<em>宽度</em>的序列。</span><span class="yiyi-st" id="yiyi-1251">前导符号前缀（<code class="docutils literal"><span class="pre">b'+'</span></code> / <code class="docutils literal"><span class="pre">b'-'</span></code>是通过在符号字符后插入填充符<em>而不是在之前处理的。</em></span><span class="yiyi-st" id="yiyi-1252">对于<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>对象，如果<em>width</em>小于或等于<code class="docutils literal"><span class="pre">len(seq)</span></code>，则返回原始序列。</span></p><p><span class="yiyi-st" id="yiyi-1253">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s2">"42"</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">b'00042'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s2">"-42"</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">b'-0042'</span>
</code></pre><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1254">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1255">此方法的bytearray版本<em>不会</em>原地操作 - 它总是产生一个新对象，即使没有进行任何更改。</span></p></div></dd></dl></div><div class="section" id="printf-style-bytes-formatting"><h3><span class="yiyi-st" id="yiyi-1256">4.8.4.  <code class="docutils literal"><span class="pre">printf</span></code> -style字节格式</span></h3><div class="admonition note" id="index-42"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1257">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1258">这里描述的格式化操作表现出各种各样的怪癖，导致许多常见错误（如未能正确显示元组和字典）。</span><span class="yiyi-st" id="yiyi-1259">如果要打印的值可能是元组或字典，请将其包装在一个元组中。</span></p></div><p><span class="yiyi-st" id="yiyi-1260">字节对象（<code class="docutils literal"><span class="pre">bytes</span></code> / <code class="docutils literal"><span class="pre">bytearray</span></code>）有一个独特的内置操作：<code class="docutils literal"><span class="pre">%</span></code>运算符（模数）。</span><span class="yiyi-st" id="yiyi-1261">这也被称为字节<em>格式</em>或<em>插值</em>运算符。</span><span class="yiyi-st" id="yiyi-1262">Given <code class="docutils literal"><span class="pre">format</span> <span class="pre">%</span> <span class="pre">values</span></code> (where <em>format</em> is a bytes object), <code class="docutils literal"><span class="pre">%</span></code> conversion specifications in <em>format</em> are replaced with zero or more elements of <em>values</em>. </span><span class="yiyi-st" id="yiyi-1263">其效果与在C语言中使用<code class="xref c c-func docutils literal"><span class="pre">sprintf()</span></code>类似。</span></p><p><span class="yiyi-st" id="yiyi-1264">如果<em>格式</em>需要单个参数，则<em>值</em>可能是单个非元组对象。</span><span class="yiyi-st" id="yiyi-1265"><a class="footnote-reference" href="#id15" id="id10">[5]</a> Otherwise, <em>values</em> must be a tuple with exactly the number of items specified by the format bytes object, or a single mapping object (for example, a dictionary).</span></p><p><span class="yiyi-st" id="yiyi-1266">转换说明符包含两个或多个字符，并具有以下组件，它们必须按以下顺序出现：</span></p><ol class="arabic simple"><li><span class="yiyi-st" id="yiyi-1267"><code class="docutils literal"><span class="pre">'%'</span></code>字符表示说明符的开始。</span></li><li><span class="yiyi-st" id="yiyi-1268">映射键（可选），由括号括起来的字符序列（例如，<code class="docutils literal"><span class="pre">(somename)</span></code>）组成。</span></li><li><span class="yiyi-st" id="yiyi-1269">转换标志（可选），影响某些转换类型的结果。</span></li><li><span class="yiyi-st" id="yiyi-1270">最小字段宽度（可选）。</span><span class="yiyi-st" id="yiyi-1271">如果指定为<code class="docutils literal"><span class="pre">'*'</span></code>（星号），则实际宽度将从<em>值</em>中的元组的下一个元素中读取，并且要转换的对象位于最小字段宽度和可选精度。</span></li><li><span class="yiyi-st" id="yiyi-1272">精度（可选），作为<code class="docutils literal"><span class="pre">'.'</span></code>给出</span><span class="yiyi-st" id="yiyi-1273">（点），然后是精度。</span><span class="yiyi-st" id="yiyi-1274">如果指定为<code class="docutils literal"><span class="pre">'*'</span></code>（星号），则从<em>values</em>中的元组的下一个元素读取实际精度，并且要转换的值在精度之后。</span></li><li><span class="yiyi-st" id="yiyi-1275">长度修饰符（可选）。</span></li><li><span class="yiyi-st" id="yiyi-1276">转换类型。</span></li></ol><p><span class="yiyi-st" id="yiyi-1277">如果右参数是一个字典（或其他映射类型），那么字节对象<em>中的格式必须</em>在<code class="docutils literal"><span class="pre">'%'</span></code>之后插入该字典中的括号映射键。 &gt;字符。</span><span class="yiyi-st" id="yiyi-1278">映射键从映射中选择要格式化的值。</span><span class="yiyi-st" id="yiyi-1279">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="s1">'</span><span class="si">%(language)s</span><span class="s1"> has </span><span class="si">%(number)03d</span><span class="s1"> quote types.'</span> <span class="o">%</span>
<span class="gp">... </span>      <span class="p">{</span><span class="n">b</span><span class="s1">'language'</span><span class="p">:</span> <span class="n">b</span><span class="s2">"Python"</span><span class="p">,</span> <span class="n">b</span><span class="s2">"number"</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">b'Python has 002 quote types.'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1280">在这种情况下format中不可以出现<code class="docutils literal"><span class="pre">*</span></code>指示符（因为它们需要一个序列参数的列表）。</span></p><p><span class="yiyi-st" id="yiyi-1281">转换标志字符是：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-1282">旗</span></th><th class="head"><span class="yiyi-st" id="yiyi-1283">含义</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-1284"><code class="docutils literal"><span class="pre">'#'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1285">值转换将使用“替代形式”（如下定义）。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-1286"><code class="docutils literal"><span class="pre">'0'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1287">对于数值，转换将用零填充。</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-1288"><code class="docutils literal"><span class="pre">'-'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1289">转换的值被左调整（如果给出两者，则覆盖<code class="docutils literal"><span class="pre">'0'</span></code>转换标志）。</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-1290"><code class="docutils literal"><span class="pre">'</span> <span class="pre">'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1291">（空格）空白应留在由有符号转换产生的正数（或空字符串）之前。</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-1292"><code class="docutils literal"><span class="pre">'+'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1293">将在转换说明之前加上符号字符（<code class="docutils literal"><span class="pre">'+'</span></code>或<code class="docutils literal"><span class="pre">'-'</span></code>）（覆盖“空格”标志）。</span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-1294">长度修饰符（<code class="docutils literal"><span class="pre">h</span></code>，<code class="docutils literal"><span class="pre">l</span></code>或<code class="docutils literal"><span class="pre">L</span></code>）可能会出现，但会被忽略，因为它对Python不是必需的 - 例如，</span><span class="yiyi-st" id="yiyi-1295"><code class="docutils literal"><span class="pre">%ld</span></code>与<code class="docutils literal"><span class="pre">%d</span></code>完全相同。</span></p><p><span class="yiyi-st" id="yiyi-1296">转换类型是：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-1297">转变</span></th><th class="head"><span class="yiyi-st" id="yiyi-1298">含义</span></th><th class="head"><span class="yiyi-st" id="yiyi-1299">笔记</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-1300"><code class="docutils literal"><span class="pre">'d'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1301">带符号的整数小数。</span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-1302"><code class="docutils literal"><span class="pre">'i'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1303">带符号的整数小数。</span></td><td></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-1304"><code class="docutils literal"><span class="pre">'o'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1305">签署八进制值。</span></td><td><span class="yiyi-st" id="yiyi-1306">（1）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-1307"><code class="docutils literal"><span class="pre">'u'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1308">已过时的类型 - 与<code class="docutils literal"><span class="pre">'d'</span></code>完全相同。</span></td><td><span class="yiyi-st" id="yiyi-1309">（8）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-1310"><code class="docutils literal"><span class="pre">'x'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1311">签名的十六进制（小写）。</span></td><td><span class="yiyi-st" id="yiyi-1312">（2）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-1313"><code class="docutils literal"><span class="pre">'X'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1314">签名的十六进制（大写）。</span></td><td><span class="yiyi-st" id="yiyi-1315">（2）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-1316"><code class="docutils literal"><span class="pre">'e'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1317">浮点指数格式（小写）。</span></td><td><span class="yiyi-st" id="yiyi-1318">（3）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-1319"><code class="docutils literal"><span class="pre">'e'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1320">浮点指数格式（大写）。</span></td><td><span class="yiyi-st" id="yiyi-1321">（3）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-1322"><code class="docutils literal"><span class="pre">'f'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1323">浮点十进制格式。</span></td><td><span class="yiyi-st" id="yiyi-1324">（3）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-1325"><code class="docutils literal"><span class="pre">'F'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1326">浮点十进制格式。</span></td><td><span class="yiyi-st" id="yiyi-1327">（3）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-1328"><code class="docutils literal"><span class="pre">'g'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1329">浮点格式。</span><span class="yiyi-st" id="yiyi-1330">如果指数小于-4或小于精度，则使用小写指数格式，否则使用小数格式。</span></td><td><span class="yiyi-st" id="yiyi-1331">（4）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-1332"><code class="docutils literal"><span class="pre">'g'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1333">浮点格式。</span><span class="yiyi-st" id="yiyi-1334">如果指数小于-4或者不小于精度，则使用大写指数格式，否则使用小数格式。</span></td><td><span class="yiyi-st" id="yiyi-1335">（4）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-1336"><code class="docutils literal"><span class="pre">'c'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1337">单字节（接受整数或单字节对象）。</span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-1338"><code class="docutils literal"><span class="pre">'b'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1339">字节（任何遵循<a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span>buffer protocol</span></a>或具有<a class="reference internal" href="../reference/datamodel.html#object.__bytes__" title="object.__bytes__"><code class="xref py py-meth docutils literal"><span class="pre">__bytes__()</span></code></a>的对象）。</span></td><td><span class="yiyi-st" id="yiyi-1340">（5）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-1341"><code class="docutils literal"><span class="pre">'s'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1342"><code class="docutils literal"><span class="pre">'s'</span></code>是<code class="docutils literal"><span class="pre">'b'</span></code>的别名，只能用于Python2 / 3代码库。</span></td><td><span class="yiyi-st" id="yiyi-1343">（6）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-1344"><code class="docutils literal"><span class="pre">'a'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1345">字节（使用<code class="docutils literal"><span class="pre">repr(obj).encode('ascii','backslashreplace)</span></code>）转换任何Python对象。</span></td><td><span class="yiyi-st" id="yiyi-1346">（5）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-1347"><code class="docutils literal"><span class="pre">'r'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1348"><code class="docutils literal"><span class="pre">'r'</span></code>是<code class="docutils literal"><span class="pre">'a'</span></code>的别名，只能用于Python2 / 3代码库。</span></td><td><span class="yiyi-st" id="yiyi-1349">（7）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-1350"><code class="docutils literal"><span class="pre">'%'</span></code></span></td><td><span class="yiyi-st" id="yiyi-1351">没有参数被转换，导致结果中有一个<code class="docutils literal"><span class="pre">'%'</span></code>字符。</span></td><td></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-1352">笔记：</span></p><ol class="arabic"><li><p class="first"><span class="yiyi-st" id="yiyi-1353">替代形式造成左侧填充零 (<code class="docutils literal"><span class="pre">'0'</span></code>) ，且数字的格式，如果结果的前导字符插入不是零。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-1354">替代形式导致<code class="docutils literal"><span class="pre">'0x'</span></code>或<code class="docutils literal"><span class="pre">'0X'</span></code>（取决于<code class="docutils literal"><span class="pre">'x'</span></code>或<code class="docutils literal"><span class="pre">'X'</span></code></span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-1355">替代形式会导致结果始终包含小数点，即使没有数字跟着它。</span></p><p><span class="yiyi-st" id="yiyi-1356">精度决定小数点后的位数，默认为6。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-1357">替代形式使结果总是包含小数点，在其他情况下会删除的尾随零不会被删除。</span></p><p><span class="yiyi-st" id="yiyi-1358">精度决定小数点前后的有效位数，默认值为6。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-1359">如果precision <code class="docutils literal"><span class="pre">N</span></code>，则输出将被截断为<code class="docutils literal"><span class="pre">N</span></code>个字符。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-1360"><code class="docutils literal"><span class="pre">b'%s'</span></code> is deprecated, but will not be removed during the 3.x series.</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-1361"><code class="docutils literal"><span class="pre">b'%r'</span></code> is deprecated, but will not be removed during the 3.x series.</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-1362">参见<span class="target" id="index-43"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0237"><strong>PEP 237</strong></a>。</span></p></li></ol><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1363">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-1364">此方法的bytearray版本<em>不会</em>原地操作 - 它总是产生一个新对象，即使没有进行任何更改。</span></p></div><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1365">也可以看看</span></p><p class="last"><span class="yiyi-st" id="yiyi-1366"><span class="target" id="index-44"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0461"><strong>PEP 461</strong></a>。</span></p></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1367"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></div><div class="section" id="memory-views"><h3><span class="yiyi-st" id="yiyi-1368">4.8.5.</span><span class="yiyi-st" id="yiyi-1369">内存视图</span></h3><p><span class="yiyi-st" id="yiyi-1370"><a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> objects allow Python code to access the internal data of an object that supports the <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span>buffer protocol</span></a> without copying.</span></p><dl class="class"><dt id="memoryview"><span class="yiyi-st" id="yiyi-1371"><em class="property">class </em><code class="descname">memoryview</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1372">创建引用<em>obj</em>的<a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a>。</span><span class="yiyi-st" id="yiyi-1373"><em>obj</em> must support the buffer protocol. </span><span class="yiyi-st" id="yiyi-1374">支持缓冲协议的内置对象包括<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>和<a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-1375">一个<a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a>具有<em>元素的概念</em>，它是由原始对象<em>obj</em>处理的原子内存单元。</span><span class="yiyi-st" id="yiyi-1376">对于许多简单类型，例如<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>和<a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>，元素是单个字节，但是其他类型，如<a class="reference internal" href="array.html#array.array" title="array.array"><code class="xref py py-class docutils literal"><span class="pre">array.array</span></code></a>，可能有更大的元素 。</span></p><p><span class="yiyi-st" id="yiyi-1377"><code class="docutils literal"><span class="pre">len(view)</span></code>等于<a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-class docutils literal"><span class="pre">tolist</span></code></a>的长度。</span><span class="yiyi-st" id="yiyi-1378">如果<code class="docutils literal"><span class="pre">view.ndim</span> <span class="pre">=</span> <span class="pre">0</span></code>，则长度为1。</span><span class="yiyi-st" id="yiyi-1379">如果<code class="docutils literal"><span class="pre">view.ndim</span> <span class="pre">=</span> <span class="pre">1</span></code>，则长度等于视图中元素的数量。</span><span class="yiyi-st" id="yiyi-1380">对于更高维度，长度等于视图的嵌套列表表示的长度。</span><span class="yiyi-st" id="yiyi-1381"><a class="reference internal" href="#memoryview.itemsize" title="memoryview.itemsize"><code class="xref py py-class docutils literal"><span class="pre">itemsize</span></code></a>属性会给你单个元素的字节数。</span></p><p><span class="yiyi-st" id="yiyi-1382">一个<a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a>支持切片和索引以显示其数据。</span><span class="yiyi-st" id="yiyi-1383">一维切片将产生一个子视图：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="s1">'abcefg'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">98</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">103</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">&lt;memory at 0x7f3ddc9f4350&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
<span class="go">b'bce'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1384">如果<a class="reference internal" href="#memoryview.format" title="memoryview.format"><code class="xref py py-class docutils literal"><span class="pre">format</span></code></a>是来自<a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a>模块的本机格式说明符之一，则还支持使用整数或整数元组进行索引，并返回一个<em>元素 t6&gt;正确的类型。</em></span><span class="yiyi-st" id="yiyi-1385">一维记忆体视图可以用一个整数或一个整数元组索引。</span><span class="yiyi-st" id="yiyi-1386">多维内存视图可以用<em>ndim</em>整数元组索引，其中<em>ndim</em>是维数。</span><span class="yiyi-st" id="yiyi-1387">零维内存视图可以使用空元组索引。</span></p><p><span class="yiyi-st" id="yiyi-1388">这是一个非字节格式的例子：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">'l'</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">11111111</span><span class="p">,</span> <span class="mi">22222222</span><span class="p">,</span> <span class="o">-</span><span class="mi">33333333</span><span class="p">,</span> <span class="mi">44444444</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-11111111</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">44444444</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[-11111111, -33333333]</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1389">如果底层对象是可写的，则内存视图支持一维切片分配。</span><span class="yiyi-st" id="yiyi-1390">不允许调整大小：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s1">'abcefg'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">readonly</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">b</span><span class="s1">'z'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b'zbcefg')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="s1">'123'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b'z123fg')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="s1">'spam'</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">memoryview assignment: lvalue and rvalue have different structures</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="s1">'spam'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b'z1spam')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1391">具有格式“B”，“b”或“c”的可哈希（只读）类型的一维记忆视图也是可散列的。</span><span class="yiyi-st" id="yiyi-1392">散列被定义为<code class="docutils literal"><span class="pre">散列（m）</span> <span class="pre">==</span> <span class="pre">散列（m.tobytes()）</span></code>：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="s1">'abcefg'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="n">b</span><span class="s1">'abcefg'</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="n">b</span><span class="s1">'ce'</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="n">b</span><span class="s1">'abcefg'</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
</code></pre><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1393"><span class="versionmodified">在版本3.3中更改：</span>一维memoryviews现在可以切片。</span><span class="yiyi-st" id="yiyi-1394">格式为'B'，'b'或'c'的一维记忆体现在是可散列的。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1395"><span class="versionmodified">版本3.4中更改：</span> memoryview现在通过<a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Sequence</span></code></a>自动注册</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1396"><span class="versionmodified">版本3.5中的变化：</span>现在可以使用整数元组将索引编入索引。</span></p></div><p><span class="yiyi-st" id="yiyi-1397"><a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a>有几种方法：</span></p><dl class="method"><dt id="memoryview.__eq__"><span class="yiyi-st" id="yiyi-1398"><code class="descname">__eq__</code><span class="sig-paren">(</span><em>exporter</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1399">如果一个memoryview和一个<span class="target" id="index-45"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3118"><strong>PEP 3118</strong></a>导出器的形状是相同的，并且所有对应的值在操作数各自的格式代码使用<a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a></span></p><p><span class="yiyi-st" id="yiyi-1400">For the subset of <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> format strings currently supported by <a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal"><span class="pre">tolist()</span></code></a>, <code class="docutils literal"><span class="pre">v</span></code> and <code class="docutils literal"><span class="pre">w</span></code> are equal if <code class="docutils literal"><span class="pre">v.tolist()</span> <span class="pre">==</span> <span class="pre">w.tolist()</span></code>:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">'I'</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">'d'</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">'b'</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="n">a</span> <span class="o">==</span> <span class="n">y</span> <span class="o">==</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">==</span> <span class="n">c</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">c</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">True</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1401">如果<a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a>模块不支持任一格式字符串，那么这些对象将总是比较为不相等（即使格式字符串和缓冲区内容相同）：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="n">BigEndianStructure</span><span class="p">,</span> <span class="n">c_long</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">BEPoint</span><span class="p">(</span><span class="n">BigEndianStructure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">"x"</span><span class="p">,</span> <span class="n">c_long</span><span class="p">),</span> <span class="p">(</span><span class="s2">"y"</span><span class="p">,</span> <span class="n">c_long</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">BEPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">point</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
<span class="go">False</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1402">Note that, as with floating point numbers, <code class="docutils literal"><span class="pre">v</span> <span class="pre">is</span> <span class="pre">w</span></code> does <em>not</em> imply <code class="docutils literal"><span class="pre">v</span> <span class="pre">==</span> <span class="pre">w</span></code> for memoryview objects.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1403"><span class="versionmodified">在版本3.3中进行了更改：</span>以前的版本比较了不考虑项目格式和逻辑阵列结构的原始内存。</span></p></div></dd></dl><dl class="method"><dt id="memoryview.tobytes"><span class="yiyi-st" id="yiyi-1404"><code class="descname">tobytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1405">以字节串形式返回缓冲区中的数据。</span><span class="yiyi-st" id="yiyi-1406">这相当于在memoryview上调用<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>构造函数。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="s2">"abc"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b'abc'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">b'abc'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1407">对于非连续数组，结果等于所有元素转换为字节的展平列表表示。</span><span class="yiyi-st" id="yiyi-1408"><a class="reference internal" href="#memoryview.tobytes" title="memoryview.tobytes"><code class="xref py py-meth docutils literal"><span class="pre">tobytes()</span></code></a> supports all format strings, including those that are not in <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> module syntax.</span></p></dd></dl><dl class="method"><dt id="memoryview.hex"><span class="yiyi-st" id="yiyi-1409"><code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1410">返回包含缓冲区中每个字节的两个十六进制数字的字符串对象。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="s2">"abc"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">'616263'</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1411"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="memoryview.tolist"><span class="yiyi-st" id="yiyi-1412"><code class="descname">tolist</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1413">将缓冲区中的数据作为元素列表返回。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="s1">'abc'</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[97, 98, 99]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">'d'</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[1.1, 2.2, 3.3]</span>
</code></pre><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1414"><span class="versionmodified">版本3.3中更改：</span> <a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal"><span class="pre">tolist()</span></code></a>现在支持<a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a></span></p></div></dd></dl><dl class="method"><dt id="memoryview.release"><span class="yiyi-st" id="yiyi-1415"><code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1416">释放由memoryview对象公开的底层缓冲区。</span><span class="yiyi-st" id="yiyi-1417">许多对象在对其进行查看时会采取特殊的操作（例如，<a class="reference internal" href="functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>会临时禁止调整大小）。因此，调用release()可以方便地尽快删除这些限制（并释放任何悬挂的资源）。</span></p><p><span class="yiyi-st" id="yiyi-1418">在这个方法被调用之后，视图上的任何进一步操作都会引发一个<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-class docutils literal"><span class="pre">ValueError</span></code></a>（除了<a class="reference internal" href="#memoryview.release" title="memoryview.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a>本身，它可以被多次调用）：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="s1">'abc'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">operation forbidden on released memoryview object</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1419">上下文管理协议可用于类似的效果，使用<code class="docutils literal"><span class="pre">with</span></code>语句：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="s1">'abc'</span><span class="p">)</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">97</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">operation forbidden on released memoryview object</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1420"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="memoryview.cast"><span class="yiyi-st" id="yiyi-1421"><code class="descname">cast</code><span class="sig-paren">(</span><em>format</em><span class="optional">[</span>, <em>shape</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1422">将内存视图转换为新的格式或形状。</span><span class="yiyi-st" id="yiyi-1423"><em>shape</em>默认为<code class="docutils literal"><span class="pre">[byte_length//new_itemsize]</span></code>，这意味着结果视图将是一维的。</span><span class="yiyi-st" id="yiyi-1424">返回值是一个新的内存视图，但缓冲区本身未被复制。</span><span class="yiyi-st" id="yiyi-1425">支持的转换为1D  - &gt; C- <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a>和C连续 - &gt; 1D。</span></p><p><span class="yiyi-st" id="yiyi-1426">目标格式仅限于<a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a>语法中的单个元素原生格式。</span><span class="yiyi-st" id="yiyi-1427">其中一种格式必须是字节格式（'B'，'b'或'c'）。</span><span class="yiyi-st" id="yiyi-1428">结果的字节长度必须与原始长度相同。</span></p><p><span class="yiyi-st" id="yiyi-1429">投1D /长到1D /无符号字节：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">'l'</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">format</span>
<span class="go">'l'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">'B'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">format</span>
<span class="go">'B'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">24</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1430">将1D /无符号字节转换为1D / char：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s1">'zyz'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="s1">'a'</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">memoryview: invalid value for format "B"</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">'c'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="s1">'a'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">bytearray(b'ayz')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1431">将1D /字节转换为3D /整数至1D / signed char：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"i"</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">'i'</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">format</span>
<span class="go">'i'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">format</span>
<span class="go">'b'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1432">将1D /无符号字符转换为2D /无符号长整型：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"L"</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span> <span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">'L'</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[0, 1, 2], [3, 4, 5]]</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1433"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1434"><span class="versionmodified">在版本3.5中更改：</span>转换为字节视图时，源格式不再受到限制。</span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-1435">还有几个只读属性可用：</span></p><dl class="attribute"><dt id="memoryview.obj"><span class="yiyi-st" id="yiyi-1436"> <code class="descname">obj</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1437">内存视图的基础对象：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s1">'xyz'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">obj</span> <span class="ow">is</span> <span class="n">b</span>
<span class="go">True</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1438"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="attribute"><dt id="memoryview.nbytes"><span class="yiyi-st" id="yiyi-1439"> <code class="descname">nbytes</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1440"><code class="docutils literal"><span class="pre">nbytes</span> <span class="pre">==</span> <span class="pre">product(shape)</span> <span class="pre">*</span> <span class="pre">itemsize</span> <span class="pre">==</span> <span class="pre">len(m.tobytes())</span></code>. </span><span class="yiyi-st" id="yiyi-1441">这是数组在连续表示中使用的空间数量。</span><span class="yiyi-st" id="yiyi-1442">它不一定等于len（m）：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">'i'</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">m</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">12</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1443">多维数组：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"d"</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="mf">1.5</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">'d'</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">96</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1444"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="attribute"><dt id="memoryview.readonly"><span class="yiyi-st" id="yiyi-1445"> <code class="descname">readonly</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1446">指示内存是否只读的布尔值。</span></p></dd></dl><dl class="attribute"><dt id="memoryview.format"><span class="yiyi-st" id="yiyi-1447"><code class="descname">format</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1448">包含视图中每个元素的格式（<a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a>模块样式）的字符串。</span><span class="yiyi-st" id="yiyi-1449">内存视图可以从具有任意格式字符串的出口商创建，但是一些方法（例如，</span><span class="yiyi-st" id="yiyi-1450"><a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal"><span class="pre">tolist()</span></code></a>）仅限于本地单个元素格式。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1451"><span class="versionmodified">在版本3.3中改变：</span>格式现在根据结构模块语法处理<code class="docutils literal"><span class="pre">'B'</span></code>。</span><span class="yiyi-st" id="yiyi-1452">这意味着<code class="docutils literal"><span class="pre">memoryview（b'abc'）[0]</span> <span class="pre">==</span> <span class="pre">b'abc'[0]</span> <span class="pre">= =</span> <span class="pre">97</span></code>。</span></p></div></dd></dl><dl class="attribute"><dt id="memoryview.itemsize"><span class="yiyi-st" id="yiyi-1453"> <code class="descname">itemsize</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1454">memoryview每个元素的大小（以字节为单位）：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span><span class="o">,</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">'H'</span><span class="p">,</span> <span class="p">[</span><span class="mi">32000</span><span class="p">,</span> <span class="mi">32001</span><span class="p">,</span> <span class="mi">32002</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">32000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="s1">'H'</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">True</span>
</code></pre></dd></dl><dl class="attribute"><dt id="memoryview.ndim"><span class="yiyi-st" id="yiyi-1455"> <code class="descname">ndim</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1456">一个整数，指示内存所代表的多维数组的维数。</span></p></dd></dl><dl class="attribute"><dt id="memoryview.shape"><span class="yiyi-st" id="yiyi-1457"><code class="descname">shape</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1458">整数元组是<a class="reference internal" href="#memoryview.ndim" title="memoryview.ndim"><code class="xref py py-attr docutils literal"><span class="pre">ndim</span></code></a>的长度，将存储器的形状表示为N维数组。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1459"><span class="versionmodified">在版本3.3中更改：</span>当ndim = 0时，为空而不是无。</span></p></div></dd></dl><dl class="attribute"><dt id="memoryview.strides"><span class="yiyi-st" id="yiyi-1460"><code class="descname">strides</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1461">整数元组的长度为<a class="reference internal" href="#memoryview.ndim" title="memoryview.ndim"><code class="xref py py-attr docutils literal"><span class="pre">ndim</span></code></a>的长度，以字节为单位来访问数组中每个维度的每个元素。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-1462"><span class="versionmodified">在版本3.3中更改：</span>当ndim = 0时，为空而不是无。</span></p></div></dd></dl><dl class="attribute"><dt id="memoryview.suboffsets"><span class="yiyi-st" id="yiyi-1463"><code class="descname">suboffsets</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1464">在内部用于PIL风格的阵列。</span><span class="yiyi-st" id="yiyi-1465">该值仅供参考。</span></p></dd></dl><dl class="attribute"><dt id="memoryview.c_contiguous"><span class="yiyi-st" id="yiyi-1466"> <code class="descname">c_contiguous</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1467">指示内存是否为C- <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a>的布尔值。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1468"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="attribute"><dt id="memoryview.f_contiguous"><span class="yiyi-st" id="yiyi-1469"> <code class="descname">f_contiguous</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1470">指示内存是否为Fortran <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a>的bool。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1471"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="attribute"><dt id="memoryview.contiguous"><span class="yiyi-st" id="yiyi-1472"> <code class="descname">contiguous</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1473">指示内存是否<a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a>的bool。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1474"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl></dd></dl></div></div><div class="section" id="set-types-set-frozenset"><h2><span class="yiyi-st" id="yiyi-1475">4.9.</span><span class="yiyi-st" id="yiyi-1476">集合类型 — <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>, <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a></span></h2><p id="index-46"><span class="yiyi-st" id="yiyi-1477"><em class="dfn">集合</em>对象是一个由互不相同的<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>对象组成的无序集合。</span><span class="yiyi-st" id="yiyi-1478">常见用途包括成员资格测试，删除序列中的重复项，以及计算数学运算，如交集，联合，差异和对称差异。</span><span class="yiyi-st" id="yiyi-1479">（对于其他容器，请参阅内置的<a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>，<a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>和<a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>类以及<a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a>模块。 ）</span></p><p><span class="yiyi-st" id="yiyi-1480">Like other collections, sets support <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">set</span></code>, <code class="docutils literal"><span class="pre">len(set)</span></code>, and <code class="docutils literal"><span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">set</span></code>. </span><span class="yiyi-st" id="yiyi-1481">作为无序集合，集合不会记录元素位置或插入顺序。</span><span class="yiyi-st" id="yiyi-1482">因此，集合不支持索引，切片或其他类序列行为。</span></p><p><span class="yiyi-st" id="yiyi-1483">目前有两种内置集合类型，<a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>和<a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>。</span><span class="yiyi-st" id="yiyi-1484"><a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>类型是可变的 - 可以使用像<a class="reference internal" href="#set.add" title="set.add"><code class="xref py py-meth docutils literal"><span class="pre">add()</span></code></a>和<a class="reference internal" href="#set.remove" title="set.remove"><code class="xref py py-meth docutils literal"><span class="pre">remove()</span></code></a>这样的方法更改内容。</span><span class="yiyi-st" id="yiyi-1485">由于它是可变的，因此它没有散列值，不能用作字典键或另一个集的元素。</span><span class="yiyi-st" id="yiyi-1486"><a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>类型是不可变的，<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">可哈希的</span></a>  - 其内容创建后不能更改；它因此可以用作字典键或作为另一个集合的元素。</span></p><p><span class="yiyi-st" id="yiyi-1487">除了使用<a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>构造函数外，还可以通过在大括号中放置逗号分隔的元素列表来创建非空的集合（不是frozensets），例如：<code class="docutils literal"><span class="pre">{'jack'，</span> <span class="pre">'sjoerd'} </span></code>，</span></p><p><span class="yiyi-st" id="yiyi-1488">这两个类的构造函数都是一样的：</span></p><dl class="class"><dt id="set"><span class="yiyi-st" id="yiyi-1489"><em class="property">class </em><code class="descname">set</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dt id="frozenset"><span class="yiyi-st" id="yiyi-1490"><em class="property">class </em><code class="descname">frozenset</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1491">返回其元素取自<em>iterable</em>的新集或冻结集对象。</span><span class="yiyi-st" id="yiyi-1492">一个集合的元素必须是<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>。</span><span class="yiyi-st" id="yiyi-1493">为了表示集合集合，内部集合必须是<a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>对象。</span><span class="yiyi-st" id="yiyi-1494">如果未指定<em>iterable</em>，则返回一个新的空集。</span></p><p><span class="yiyi-st" id="yiyi-1495"><a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>和<a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>的实例提供以下操作：</span></p><dl class="describe"><dt><span class="yiyi-st" id="yiyi-1496"><code class="descname">len(s)</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1497">返回集合 <em>s</em> 的元素个数（即<em>s</em>的基数）</span></p></dd></dl><dl class="describe"><dt><span class="yiyi-st" id="yiyi-1498"><code class="descname">x在s</code>中</span></dt><dd><p><span class="yiyi-st" id="yiyi-1499">返回<em>x</em> 是否 是 <em>s</em>的元素.</span></p></dd></dl><dl class="describe"><dt><span class="yiyi-st" id="yiyi-1500"><code class="descname">x not in s</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1501">返回<em>x</em> 是否 不是 <em>s</em>的元素.</span></p></dd></dl><dl class="method"><dt id="set.isdisjoint"><span class="yiyi-st" id="yiyi-1502"><code class="descname">isdisjoint</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1503">如果该集合中任何一个元素都与另一个集合<em>other</em>中的任何一个元素都不一样（即两集合不相交），则返回<code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-1504">当且仅当两集合的交集为空集时，这两个集合不相交</span></p></dd></dl><dl class="method"><dt id="set.issubset"><span class="yiyi-st" id="yiyi-1505"><code class="descname">issubset</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-1506"><code class="descname">set &lt;= other</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1507">测试集合中的每个元素是否在<em>其他</em>中。</span></p></dd></dl><dl class="method"><dt><span class="yiyi-st" id="yiyi-1508"><code class="descname">set &lt; other</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1509">测试该集合是否是<em>other</em>的一个子集，即<code class="docutils literal"><span class="pre">set</span> <span class="pre">&lt;=</span> <span class="pre">其他</span> <span class="pre">和</span> <span class="pre">set</span> <span class="pre">！=</span> <span class="pre">其他</span></code>。</span></p></dd></dl><dl class="method"><dt id="set.issuperset"><span class="yiyi-st" id="yiyi-1510"><code class="descname">issuperset</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-1511"><code class="descname">set &gt;= other</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1512">测试<em>other</em>中的每个元素是否在集合中。</span></p></dd></dl><dl class="method"><dt><span class="yiyi-st" id="yiyi-1513"><code class="descname">set &gt; other</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1514">测试集合是否是<em>other</em>，即<code class="docutils literal"><span class="pre">set</span> <span class="pre">＆gt； =</span> <span class="pre">其他</span> <span class="pre">和</span> <span class="pre">set</span> <span class="pre">！=</span> <span class="pre">其他</span></code>。</span></p></dd></dl><dl class="method"><dt id="set.union"><span class="yiyi-st" id="yiyi-1515"><code class="descname">union</code><span class="sig-paren">(</span><em>other</em>, <em>...</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-1516"><code class="descname">set | other | ...</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1517">用集合中的元素和所有其他元素返回一个新集合。</span></p></dd></dl><dl class="method"><dt id="set.intersection"><span class="yiyi-st" id="yiyi-1518"><code class="descname">intersection</code><span class="sig-paren">(</span><em>other</em>, <em>...</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-1519"><code class="descname">set &amp; other &amp; ...</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1520">返回一个新集合，其中包含该集合和其他所有元素共有的元素。</span></p></dd></dl><dl class="method"><dt id="set.difference"><span class="yiyi-st" id="yiyi-1521"><code class="descname">difference</code><span class="sig-paren">(</span><em>other</em>, <em>...</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-1522"><code class="descname">set - other - ...</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1523">返回集合中不包含其他元素的新集合。</span></p></dd></dl><dl class="method"><dt id="set.symmetric_difference"><span class="yiyi-st" id="yiyi-1524"><code class="descname">symmetric_difference</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-1525"><code class="descname">set ^ other</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1526">返回集合中的元素或<em>其他</em>中的元素，但不能同时返回。</span></p></dd></dl><dl class="method"><dt id="set.copy"><span class="yiyi-st" id="yiyi-1527"><code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1528">用<em>s</em>的浅拷贝返回一个新集合。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-1529">Note, the non-operator versions of <a class="reference internal" href="#set.union" title="set.union"><code class="xref py py-meth docutils literal"><span class="pre">union()</span></code></a>, <a class="reference internal" href="#set.intersection" title="set.intersection"><code class="xref py py-meth docutils literal"><span class="pre">intersection()</span></code></a>, <a class="reference internal" href="#set.difference" title="set.difference"><code class="xref py py-meth docutils literal"><span class="pre">difference()</span></code></a>, and <a class="reference internal" href="#set.symmetric_difference" title="set.symmetric_difference"><code class="xref py py-meth docutils literal"><span class="pre">symmetric_difference()</span></code></a>, <a class="reference internal" href="#set.issubset" title="set.issubset"><code class="xref py py-meth docutils literal"><span class="pre">issubset()</span></code></a>, and <a class="reference internal" href="#set.issuperset" title="set.issuperset"><code class="xref py py-meth docutils literal"><span class="pre">issuperset()</span></code></a> methods will accept any iterable as an argument. </span><span class="yiyi-st" id="yiyi-1530">相反，他们的基于操作符号的对等体需要它们的参数是集合。</span><span class="yiyi-st" id="yiyi-1531">This precludes error-prone constructions like <code class="docutils literal"><span class="pre">set('abc')</span> <span class="pre">&amp;</span> <span class="pre">'cbs'</span></code> in favor of the more readable <code class="docutils literal"><span class="pre">set('abc').intersection('cbs')</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-1532">既可以将<a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>和<a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>支持集设置为比较。</span><span class="yiyi-st" id="yiyi-1533">当且仅当每个集合中的每个元素都包含在另一个中（每个元素是另一个的子集）时，两个集合是相等的。</span><span class="yiyi-st" id="yiyi-1534">当且仅当第一组是第二组的合适子集（是子集，但不相等）时，集合小于另一集合。</span><span class="yiyi-st" id="yiyi-1535">当且仅当第一个集合是第二个集合的适当超集（是超集，但不相等）时，集合比另一集合大。</span></p><p><span class="yiyi-st" id="yiyi-1536"><a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>的实例将根据其成员与<a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>的实例进行比较。</span><span class="yiyi-st" id="yiyi-1537">For example, <code class="docutils literal"><span class="pre">set('abc')</span> <span class="pre">==</span> <span class="pre">frozenset('abc')</span></code> returns <code class="docutils literal"><span class="pre">True</span></code> and so does <code class="docutils literal"><span class="pre">set('abc')</span> <span class="pre">in</span> <span class="pre">set([frozenset('abc')])</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-1538">子集和等式比较不推广到总排序函数。</span><span class="yiyi-st" id="yiyi-1539">For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so <em>all</em> of the following return <code class="docutils literal"><span class="pre">False</span></code>: <code class="docutils literal"><span class="pre">a&lt;b</span></code>, <code class="docutils literal"><span class="pre">a==b</span></code>, or <code class="docutils literal"><span class="pre">a&gt;b</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-1540">由于集合只定义了部分排序（子集关系），所以<a class="reference internal" href="#list.sort" title="list.sort"><code class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></code></a>方法的输出对于集合列表是未定义的。</span></p><p><span class="yiyi-st" id="yiyi-1541">设置元素，如字典键，必须是<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-1542">将<a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>实例与<a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>混合的二元运算返回第一个操作数的类型。</span><span class="yiyi-st" id="yiyi-1543">For example: <code class="docutils literal"><span class="pre">frozenset('ab')</span> <span class="pre">|</span> <span class="pre">set('bc')</span></code> returns an instance of <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-1544">下表列出了<a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>不适用于<a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>的不可变实例的可用操作：</span></p><dl class="method"><dt id="set.update"><span class="yiyi-st" id="yiyi-1545"><code class="descname">update</code><span class="sig-paren">(</span><em>other</em>, <em>...</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-1546"><code class="descname">set |= other | ...</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1547">更新集合，添加所有其他元素。</span></p></dd></dl><dl class="method"><dt id="set.intersection_update"><span class="yiyi-st" id="yiyi-1548"><code class="descname">intersection_update</code><span class="sig-paren">(</span><em>other</em>, <em>...</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-1549"><code class="descname">set &amp;= other &amp; ...</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1550">更新集合，只保留其中的元素和其他所有元素。</span></p></dd></dl><dl class="method"><dt id="set.difference_update"><span class="yiyi-st" id="yiyi-1551"><code class="descname">difference_update</code><span class="sig-paren">(</span><em>other</em>, <em>...</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-1552"><code class="descname">set -= other | ...</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1553">更新设置，删除其他设备中的元素。</span></p></dd></dl><dl class="method"><dt id="set.symmetric_difference_update"><span class="yiyi-st" id="yiyi-1554"><code class="descname">symmetric_difference_update</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-1555"><code class="descname">set ^= other</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1556">更新集合，只保留任一集合中的元素，但不能同时存在于两者中。</span></p></dd></dl><dl class="method"><dt id="set.add"><span class="yiyi-st" id="yiyi-1557"><code class="descname">add</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1558">将元素<em>elem</em>添加到集合中。</span></p></dd></dl><dl class="method"><dt id="set.remove"><span class="yiyi-st" id="yiyi-1559"><code class="descname">remove</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1560">从集合中移除元素<em>elem</em>。</span><span class="yiyi-st" id="yiyi-1561">如果<em>elem</em>不包含在集合中，提出了<a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> 。</span></p></dd></dl><dl class="method"><dt id="set.discard"><span class="yiyi-st" id="yiyi-1562"><code class="descname">discard</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1563">从集合中移除元素<em>elem</em>，如果它存在。</span></p></dd></dl><dl class="method"><dt id="set.pop"><span class="yiyi-st" id="yiyi-1564"><code class="descname">pop</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1565">删除并返回该集合中的任意元素。</span><span class="yiyi-st" id="yiyi-1566">如果该集合为空，则引发<a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="set.clear"><span class="yiyi-st" id="yiyi-1567"><code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1568">删除集合中的所有元素。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-1569">注意，<a class="reference internal" href="#set.update" title="set.update"><code class="xref py py-meth docutils literal"><span class="pre">update()</span></code></a>，<a class="reference internal" href="#set.intersection_update" title="set.intersection_update"><code class="xref py py-meth docutils literal"><span class="pre">intersection_update()</span></code></a>，<a class="reference internal" href="#set.difference_update" title="set.difference_update"><code class="xref py py-meth docutils literal"><span class="pre">difference_update()</span></code></a>和<a class="reference internal" href="#set.symmetric_difference_update" title="set.symmetric_difference_update"><code class="xref py py-meth docutils literal"><span class="pre">symmetric_difference_update()</span></code></a></span></p><p><span class="yiyi-st" id="yiyi-1570">Note, the <em>elem</em> argument to the <a class="reference internal" href="../reference/datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></code></a>, <a class="reference internal" href="#set.remove" title="set.remove"><code class="xref py py-meth docutils literal"><span class="pre">remove()</span></code></a>, and <a class="reference internal" href="#set.discard" title="set.discard"><code class="xref py py-meth docutils literal"><span class="pre">discard()</span></code></a> methods may be a set. </span><span class="yiyi-st" id="yiyi-1571">为了支持搜索等效的冻结集，<em>elem</em>集在搜索过程中暂时发生变化，然后进行恢复。</span><span class="yiyi-st" id="yiyi-1572">在搜索期间，<em>elem</em>集不应该被读取或者变异，因为它没有一个有意义的值。</span></p></dd></dl></div><div class="section" id="mapping-types-dict"><h2><span class="yiyi-st" id="yiyi-1573">4.10.</span><span class="yiyi-st" id="yiyi-1574">映射类型 -  <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> </span></h2><p id="index-47"><span class="yiyi-st" id="yiyi-1575">一个<a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a>对象将<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>值映射到任意对象。</span><span class="yiyi-st" id="yiyi-1576">映射是可变对象。</span><span class="yiyi-st" id="yiyi-1577">目前只有一种标准映射类型，那就是<em class="dfn">字典</em>。</span><span class="yiyi-st" id="yiyi-1578">（对于其他容器，请参阅内置的<a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">列表</span></code></a>，<a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">集合</span></code></a>和<a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">元组</span></code></a>类和<a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">容器</span></code></a>模块。 ）</span></p><p><span class="yiyi-st" id="yiyi-1579">A dictionary’s keys are <em>almost</em> arbitrary values. </span><span class="yiyi-st" id="yiyi-1580">值是不能<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>，也就是包含列表、字典或其它可变类型的值（它们通过值而不是对象ID进行比较）不可以用作键。</span><span class="yiyi-st" id="yiyi-1581">用于键的数字类型服从数字比较的正常规则：如果两个数字相等（如<code class="docutils literal"><span class="pre">1</span></code>和<code class="docutils literal"><span class="pre">1.0</span></code>），则它们可以互换使用以索引相同的字典条目。</span><span class="yiyi-st" id="yiyi-1582">（但请注意，由于计算机将浮点数字存储为近似值，因此将它们用作字典键通常是不明智的。）</span></p><p><span class="yiyi-st" id="yiyi-1583">Dictionaries can be created by placing a comma-separated list of <code class="docutils literal"><span class="pre">key:</span> <span class="pre">value</span></code> pairs within braces, for example: <code class="docutils literal"><span class="pre">{'jack':</span> <span class="pre">4098,</span> <span class="pre">'sjoerd':</span> <span class="pre">4127}</span></code> or <code class="docutils literal"><span class="pre">{4098:</span> <span class="pre">'jack',</span> <span class="pre">4127:</span> <span class="pre">'sjoerd'}</span></code>, or by the <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> constructor.</span></p><dl class="class"><dt id="dict"><span class="yiyi-st" id="yiyi-1584"><em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>**kwarg</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-1585"><em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>mapping</em>, <em>**kwarg</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-1586"><em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>iterable</em>, <em>**kwarg</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1587">返回从可选的位置参数和可能为空的关键字参数集合初始化的新字典。</span></p><p><span class="yiyi-st" id="yiyi-1588">如果没有给出位置参数，则创建空字典。</span><span class="yiyi-st" id="yiyi-1589">如果给出了位置参数并且它是一个映射对象，则将使用与映射对象相同的键值对创建一个字典。</span><span class="yiyi-st" id="yiyi-1590">否则，位置参数必须是一个<a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a>的对象。</span><span class="yiyi-st" id="yiyi-1591">迭代器中的每个项目本身必须是一个具有两个对象的迭代器。</span><span class="yiyi-st" id="yiyi-1592">每个项目的第一个对象成为新字典中的一个键，第二个对象成为相应的值。</span><span class="yiyi-st" id="yiyi-1593">如果某个键出现多次，则该键的最后一个值将成为新词典中的对应值。</span></p><p><span class="yiyi-st" id="yiyi-1594">如果给出关键字参数，则将关键字参数及其值添加到从位置参数创建的字典中。</span><span class="yiyi-st" id="yiyi-1595">如果添加的键已经存在，那么来自关键字参数的值将替换位置参数中的值。</span></p><p><span class="yiyi-st" id="yiyi-1596">To illustrate, the following examples all return a dictionary equal to <code class="docutils literal"><span class="pre">{"one":</span> <span class="pre">1,</span> <span class="pre">"two":</span> <span class="pre">2,</span> <span class="pre">"three":</span> <span class="pre">3}</span></code>:</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">one</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">two</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">three</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'one'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'two'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'three'</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s1">'one'</span><span class="p">,</span> <span class="s1">'two'</span><span class="p">,</span> <span class="s1">'three'</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="s1">'two'</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">'one'</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">'three'</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="s1">'three'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'one'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'two'</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="o">==</span> <span class="n">c</span> <span class="o">==</span> <span class="n">d</span> <span class="o">==</span> <span class="n">e</span>
<span class="go">True</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1597">如第一个示例中提供的关键字参数仅适用于有效Python标识符的键。</span><span class="yiyi-st" id="yiyi-1598">否则，可以使用任何有效的密钥。</span></p><p><span class="yiyi-st" id="yiyi-1599">这些是字典支持的操作（因此，自定义映射类型也应该支持）：</span></p><dl class="describe"><dt><span class="yiyi-st" id="yiyi-1600"><code class="descname">len(d)</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1601">返回字典中的项目数量<em>d</em>。</span></p></dd></dl><dl class="describe"><dt><span class="yiyi-st" id="yiyi-1602"><code class="descname">d[key]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1603">用键<em>键</em>返回<em>d</em>的项目。</span><span class="yiyi-st" id="yiyi-1604">如果<em>键</em>不在地图中，则引发<a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a>。</span></p><p id="index-48"><span class="yiyi-st" id="yiyi-1605">如果一个dict的子类定义了一个方法<a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a>并且<em>键</em>不存在，那么<code class="docutils literal"><span class="pre">d[key]</span></code> <em>键</em>作为参数。</span><span class="yiyi-st" id="yiyi-1606">然后<code class="docutils literal"><span class="pre">d[key]</span></code>操作返回或引发由<code class="docutils literal"><span class="pre">__missing__(key)</span></code>调用返回或引发的任何操作。</span><span class="yiyi-st" id="yiyi-1607">没有其他操作或方法调用<a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a>。</span><span class="yiyi-st" id="yiyi-1608">如果未定义<a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a>，则引发<a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a>。</span><span class="yiyi-st" id="yiyi-1609"><a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a>必须是一种方法；它不能是一个实例变量：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Counter</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">'red'</span><span class="p">]</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">'red'</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">'red'</span><span class="p">]</span>
<span class="go">1</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1610">上面的例子显示了<a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal"><span class="pre">collections.Counter</span></code></a>的部分实现。</span><span class="yiyi-st" id="yiyi-1611"><a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal"><span class="pre">collections.defaultdict</span></code></a>使用了不同的<code class="docutils literal"><span class="pre">__missing__</span></code>方法。</span></p></dd></dl><dl class="describe"><dt><span class="yiyi-st" id="yiyi-1612"><code class="descname">d[key] = value</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1613">将<code class="docutils literal"><span class="pre">d[key]</span></code>设置为<em>值</em>。</span></p></dd></dl><dl class="describe"><dt><span class="yiyi-st" id="yiyi-1614"><code class="descname">del d[key]</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1615">从<em>d</em>中删除<code class="docutils literal"><span class="pre">d [key]</span></code>。引发<a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a>如果<em>键</em>不在映射中。</span></p></dd></dl><dl class="describe"><dt><span class="yiyi-st" id="yiyi-1616"><code class="descname">key in d</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1617">如果<em>d</em>有键<em>key</em>，则返回<code class="docutils literal"><span class="pre">True</span></code>，否则<code class="docutils literal"><span class="pre">False</span></code>。</span></p></dd></dl><dl class="describe"><dt><span class="yiyi-st" id="yiyi-1618"><code class="descname">key not in d</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1619">等于<code class="docutils literal"><span class="pre">not</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">d</span></code>。</span></p></dd></dl><dl class="describe"><dt><span class="yiyi-st" id="yiyi-1620"><code class="descname">iter(d)</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1621">返回字典键的迭代器。</span><span class="yiyi-st" id="yiyi-1622">这是<code class="docutils literal"><span class="pre">iter(d.keys())</span></code>的快捷方式。</span></p></dd></dl><dl class="method"><dt id="dict.clear"><span class="yiyi-st" id="yiyi-1623"><code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1624">从字典中删除所有项目。</span></p></dd></dl><dl class="method"><dt id="dict.copy"><span class="yiyi-st" id="yiyi-1625"><code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1626">返回字典的浅表副本。</span></p></dd></dl><dl class="classmethod"><dt id="dict.fromkeys"><span class="yiyi-st" id="yiyi-1627"><em class="property">classmethod </em><code class="descname">fromkeys</code><span class="sig-paren">(</span><em>seq</em><span class="optional">[</span>, <em>value</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1628">创建一个新字典，键来自<em>seq</em>且值设置为<em>value</em>。</span></p><p><span class="yiyi-st" id="yiyi-1629"><a class="reference internal" href="#dict.fromkeys" title="dict.fromkeys"><code class="xref py py-meth docutils literal"><span class="pre">fromkeys()</span></code></a>是一个类方法，返回一个新的字典。</span><span class="yiyi-st" id="yiyi-1630"><em>value</em>默认为<code class="docutils literal"><span class="pre">None</span></code>。</span></p></dd></dl><dl class="method"><dt id="dict.get"><span class="yiyi-st" id="yiyi-1631"> <code class="descname">get</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1632">如果 <em>key</em> 在字典里，返回 <em>key</em> 的值，否则返回 <em>default</em> 值。</span><span class="yiyi-st" id="yiyi-1633">如果 <em>default</em> 未给出，它默认为 <code class="docutils literal"><span class="pre">None</span></code>，此方法永远不会引发 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="dict.items"><span class="yiyi-st" id="yiyi-1634"><code class="descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1635">返回字典条目的一个新视图（<code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code>对）。</span><span class="yiyi-st" id="yiyi-1636">请参阅<a class="reference internal" href="#dict-views"><span>视图对象的文档</span></a>。</span></p></dd></dl><dl class="method"><dt id="dict.keys"><span class="yiyi-st" id="yiyi-1637"><code class="descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1638">返回字典密钥的新视图。</span><span class="yiyi-st" id="yiyi-1639">请参阅<a class="reference internal" href="#dict-views"><span>视图对象的文档</span></a>。</span></p></dd></dl><dl class="method"><dt id="dict.pop"><span class="yiyi-st" id="yiyi-1640"> <code class="descname">pop</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1641">如果<em>键</em>在字典中，请将其删除并返回其值，否则返回<em>默认值</em>。</span><span class="yiyi-st" id="yiyi-1642">如果未给出<em>默认值</em>且<em>键</em>不在字典中，则会引发<a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="dict.popitem"><span class="yiyi-st" id="yiyi-1643"><code class="descname">popitem</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1644">从字典中删除并返回一个任意的<code class="docutils literal"><span class="pre">（键，</span> <span class="pre">值）</span></code>对。</span></p><p><span class="yiyi-st" id="yiyi-1645"><a class="reference internal" href="#dict.popitem" title="dict.popitem"><code class="xref py py-meth docutils literal"><span class="pre">popitem()</span></code></a> is useful to destructively iterate over a dictionary, as often used in set algorithms. </span><span class="yiyi-st" id="yiyi-1646">如果字典为空，调用<a class="reference internal" href="#dict.popitem" title="dict.popitem"><code class="xref py py-meth docutils literal"><span class="pre">popitem()</span></code></a>会产生一个<a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="dict.setdefault"><span class="yiyi-st" id="yiyi-1647"><code class="descname">setdefault</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1648">如果<em>key</em>在字典中，则返回其值。</span><span class="yiyi-st" id="yiyi-1649">如果没有，则插入值为<em>default</em>的<em>key</em>，并返回<em>default</em>。</span><span class="yiyi-st" id="yiyi-1650"><em>default</em>默认为<code class="docutils literal"><span class="pre">None</span></code>。</span></p></dd></dl><dl class="method"><dt id="dict.update"><span class="yiyi-st" id="yiyi-1651"><code class="descname">update</code><span class="sig-paren">(</span><span class="optional">[</span><em>other</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1652">使用<em>其他</em>中的键/值对更新字典，覆盖现有的键。</span><span class="yiyi-st" id="yiyi-1653">返回<code class="docutils literal"><span class="pre">None</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-1654"><a class="reference internal" href="#dict.update" title="dict.update"><code class="xref py py-meth docutils literal"><span class="pre">update()</span></code></a>接受另一个字典对象或键/值对的迭代（作为元组或其他长度为2的迭代）。</span><span class="yiyi-st" id="yiyi-1655">如果指定了关键字参数，则字典随后会使用这些键/值对进行更新：<code class="docutils literal"><span class="pre">d.update（red = 1，</span> <span class="pre">blue = 2）</span>  t0 &gt;。</code></span></p></dd></dl><dl class="method"><dt id="dict.values"><span class="yiyi-st" id="yiyi-1656"><code class="descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1657">返回字典值的新视图。</span><span class="yiyi-st" id="yiyi-1658">请参阅<a class="reference internal" href="#dict-views"><span>视图对象的文档</span></a>。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-1659">当且仅当它们具有相同的<code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code>对时，字典才会相等。</span><span class="yiyi-st" id="yiyi-1660">其它比较(‘&lt;’, ‘&lt;=’, ‘&gt;=’, ‘&gt;’) 将引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span></p></dd></dl><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-1661">另见</span></p><p class="last"><span class="yiyi-st" id="yiyi-1662"><a class="reference internal" href="types.html#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-class docutils literal"><span class="pre">types.MappingProxyType</span></code></a>可用于创建<a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>的只读视图。</span></p></div><div class="section" id="dictionary-view-objects"><h3><span class="yiyi-st" id="yiyi-1663">4.10.1.</span><span class="yiyi-st" id="yiyi-1664">字典视图对象</span></h3><p><span class="yiyi-st" id="yiyi-1665"><a class="reference internal" href="#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal"><span class="pre">dict.keys()</span></code></a>、<a class="reference internal" href="#dict.values" title="dict.values"><code class="xref py py-meth docutils literal"><span class="pre">dict.values()</span></code></a> 和 <a class="reference internal" href="#dict.items" title="dict.items"><code class="xref py py-meth docutils literal"><span class="pre">dict.items()</span></code></a> 返回的对象是<em>视图对象</em>。</span><span class="yiyi-st" id="yiyi-1666">它们提供了有关字典条目的动态视图，这意味着当字典更改时，视图反映了这些更改。</span></p><p><span class="yiyi-st" id="yiyi-1667">字典视图可以迭代以产生它们各自的数据，并支持成员资格测试：</span></p><dl class="describe"><dt><span class="yiyi-st" id="yiyi-1668"><code class="descname">len(dictview)</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1669">返回字典中的条目数量。</span></p></dd></dl><dl class="describe"><dt><span class="yiyi-st" id="yiyi-1670"><code class="descname">iter(dictview)</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1671">返回字典中的键，值或项（表示为<code class="docutils literal"><span class="pre">（键，</span> <span class="pre">值）</span></code>的元组）的迭代器。</span></p><p><span class="yiyi-st" id="yiyi-1672">键和值以非随机的任意顺序迭代，在Python实现中有所不同，并取决于字典的插入和删除历史。</span><span class="yiyi-st" id="yiyi-1673">如果按键，值和项目视图被重复执行而不对词典进行中间修改，则项目顺序将直接对应。</span><span class="yiyi-st" id="yiyi-1674">This allows the creation of <code class="docutils literal"><span class="pre">(value,</span> <span class="pre">key)</span></code> pairs using <a class="reference internal" href="functions.html#zip" title="zip"><code class="xref py py-func docutils literal"><span class="pre">zip()</span></code></a>: <code class="docutils literal"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">zip(d.values(),</span> <span class="pre">d.keys())</span></code>. </span><span class="yiyi-st" id="yiyi-1675">Another way to create the same list is <code class="docutils literal"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">[(v,</span> <span class="pre">k)</span> <span class="pre">for</span> <span class="pre">(k,</span> <span class="pre">v)</span> <span class="pre">in</span> <span class="pre">d.items()]</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-1676">在字典中添加或删除条目时迭代视图可能会引发<a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a>或无法迭代所有条目。</span></p></dd></dl><dl class="describe"><dt><span class="yiyi-st" id="yiyi-1677"> <code class="descname">x in dictview</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1678">Return <code class="docutils literal"><span class="pre">True</span></code> if <em>x</em> is in the underlying dictionary’s keys, values or items (in the latter case, <em>x</em> should be a <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> tuple).</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-1679">按键视图像集合一样，因为它们的条目是独特且可散列的。</span><span class="yiyi-st" id="yiyi-1680">如果所有的值都是可散列的，那么<code class="docutils literal"><span class="pre">（key，</span> <span class="pre">value）</span></code>对是唯一且可散列的，那么items视图也是set-like的。</span><span class="yiyi-st" id="yiyi-1681">（由于条目通常不是唯一的，因此值视图不会被视为集合类。）</span><span class="yiyi-st" id="yiyi-1682">For set-like views, all of the operations defined for the abstract base class <a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Set</span></code></a> are available (for example, <code class="docutils literal"><span class="pre">==</span></code>, <code class="docutils literal"><span class="pre">&lt;</span></code>, or <code class="docutils literal"><span class="pre">^</span></code>).</span></p><p><span class="yiyi-st" id="yiyi-1683">字典视图用法的示例：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dishes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'eggs'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'sausage'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'bacon'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'spam'</span><span class="p">:</span> <span class="mi">500</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">=</span> <span class="n">dishes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">dishes</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># iteration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">n</span> <span class="o">+=</span> <span class="n">val</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">504</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># keys and values are iterated over in the same order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="go">['eggs', 'bacon', 'sausage', 'spam']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">[2, 1, 1, 500]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># view objects are dynamic and reflect dict changes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">dishes</span><span class="p">[</span><span class="s1">'eggs'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">dishes</span><span class="p">[</span><span class="s1">'sausage'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="go">['spam', 'bacon']</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># set operations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">&amp;</span> <span class="p">{</span><span class="s1">'eggs'</span><span class="p">,</span> <span class="s1">'bacon'</span><span class="p">,</span> <span class="s1">'salad'</span><span class="p">}</span>
<span class="go">{'bacon'}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">^</span> <span class="p">{</span><span class="s1">'sausage'</span><span class="p">,</span> <span class="s1">'juice'</span><span class="p">}</span>
<span class="go">{'juice', 'sausage', 'bacon', 'spam'}</span>
</code></pre></div></div><div class="section" id="context-manager-types"><h2><span class="yiyi-st" id="yiyi-1684">4.11.</span><span class="yiyi-st" id="yiyi-1685">上下文管理器类型</span></h2><p id="index-49"><span class="yiyi-st" id="yiyi-1686">Python的<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>语句支持由上下文管理器定义的运行时上下文的概念。</span><span class="yiyi-st" id="yiyi-1687">这是使用一对方法实现的，该方法允许自定义用户类去定义在语句体执行前进入并且在语句结束时退出的运行时上下文。</span></p><dl class="method"><dt id="contextmanager.__enter__"><span class="yiyi-st" id="yiyi-1688"><code class="descclassname">contextmanager.</code><code class="descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1689">进入运行时上下文，返回此对象或另一个相关的运行时上下文的对象。</span><span class="yiyi-st" id="yiyi-1690">此方法返回的值被绑定到使用此上下文管理器<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>语句的<a class="reference internal" href="../reference/compound_stmts.html#as"><code class="xref std std-keyword docutils literal"><span class="pre">as</span></code></a>子句中的标识符上。</span></p><p><span class="yiyi-st" id="yiyi-1691">一个返回自身的上下文管理器的例子是一个<a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>。</span><span class="yiyi-st" id="yiyi-1692">文件对象从 __enter__()返回自己使得<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>作为上下文表达式被用在<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>语句中。</span></p><p><span class="yiyi-st" id="yiyi-1693">管理器返回相关对象的一个例子参见<a class="reference internal" href="decimal.html#decimal.localcontext" title="decimal.localcontext"><code class="xref py py-func docutils literal"><span class="pre">decimal.localcontext()</span></code></a>。</span><span class="yiyi-st" id="yiyi-1694">这些管理器将活跃的十进制上下文设置为原始的十进制上下文的副本，然后返回该副本。</span><span class="yiyi-st" id="yiyi-1695">This allows changes to be made to the current decimal context in the body of the <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> statement without affecting code outside the <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> statement.</span></p></dd></dl><dl class="method"><dt id="contextmanager.__exit__"><span class="yiyi-st" id="yiyi-1696"><code class="descclassname">contextmanager.</code><code class="descname">__exit__</code><span class="sig-paren">(</span><em>exc_type</em>, <em>exc_val</em>, <em>exc_tb</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1697">退出运行时环境并返回一个布尔标志，指示是否应该抑制发生的任何异常。</span><span class="yiyi-st" id="yiyi-1698">如果在使用语句执行<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a></span><span class="yiyi-st" id="yiyi-1699">否则，所有三个参数都是<code class="docutils literal"><span class="pre">None</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-1700">Returning a true value from this method will cause the <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> statement to suppress the exception and continue execution with the statement immediately following the <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> statement. </span><span class="yiyi-st" id="yiyi-1701">否则在该方法执行完成后异常继续传播。</span><span class="yiyi-st" id="yiyi-1702">在执行此方法期间发生的异常将用语句替换发生在<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a></span></p><p><span class="yiyi-st" id="yiyi-1703">传入的异常不应该显式重新显示 - 相反，此方法应该返回一个false值，以指示该方法已成功完成，并且不希望抑制引发的异常。</span><span class="yiyi-st" id="yiyi-1704">这允许上下文管理代码轻松检测<a class="reference internal" href="#contextmanager.__exit__" title="contextmanager.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a>方法是否实际失败。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-1705">Python定义了几个上下文管理器来支持简单的线程同步，及时关闭文件或其他对象，并简化对活动的十进制算术上下文的操作。</span><span class="yiyi-st" id="yiyi-1706">特定的类型没有特别对待它们的上下文管理协议的实现。</span><span class="yiyi-st" id="yiyi-1707">有关示例，请参阅<a class="reference internal" href="contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal"><span class="pre">contextlib</span></code></a>模块。</span></p><p><span class="yiyi-st" id="yiyi-1708">Python的<a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>和<a class="reference internal" href="contextlib.html#contextlib.contextmanager" title="contextlib.contextmanager"><code class="xref py py-class docutils literal"><span class="pre">contextlib.contextmanager</span></code></a>装饰器提供了实现这些协议的便捷方式。</span><span class="yiyi-st" id="yiyi-1709">如果一个生成器函数使用<a class="reference internal" href="contextlib.html#contextlib.contextmanager" title="contextlib.contextmanager"><code class="xref py py-class docutils literal"><span class="pre">contextlib.contextmanager</span></code></a>修饰器进行修饰，它将返回一个实现必要的<a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a>和<a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a>方法，而不是由未修饰的生成器函数生成的迭代器。</span></p><p><span class="yiyi-st" id="yiyi-1710">请注意，Python / C API中的Python对象的类型结构中没有任何这些方法的特定插槽。</span><span class="yiyi-st" id="yiyi-1711">想要定义这些方法的扩展类型必须提供它们作为普通的Python可访问方法。</span><span class="yiyi-st" id="yiyi-1712">与设置运行时环境的开销相比，单个类字典查找的开销可以忽略不计。</span></p></div><div class="section" id="other-built-in-types"><h2><span class="yiyi-st" id="yiyi-1713">4.12.</span><span class="yiyi-st" id="yiyi-1714">其他内置类型</span></h2><p><span class="yiyi-st" id="yiyi-1715">解释器支持几种其他类型的对象。</span><span class="yiyi-st" id="yiyi-1716">其中大多数支持只有一个或两个操作。</span></p><div class="section" id="modules"><h3><span class="yiyi-st" id="yiyi-1717">4.12.1.</span><span class="yiyi-st" id="yiyi-1718">模块</span></h3><p><span class="yiyi-st" id="yiyi-1719">模块上唯一的特殊操作是属性访问：<code class="docutils literal"><span class="pre">m.name</span></code>，其中<em>m</em>是模块，<em>name</em>访问<em>m</em>的符号表中定义的名称。</span><span class="yiyi-st" id="yiyi-1720">模块的属性可以赋值。</span><span class="yiyi-st" id="yiyi-1721">（请注意，严格地说，<a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a>语句不是对模块对象的操作；<code class="docutils literal"><span class="pre">import</span> <span class="pre">foo</span></code>不需要名为<em>foo</em>的模块对象存在，而是需要某个名为<em>foo</em>的模块的（外部）<em>定义</em>。）</span></p><p><span class="yiyi-st" id="yiyi-1722">每个模块的特殊属性是<a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a>。</span><span class="yiyi-st" id="yiyi-1723">这是包含模块符号表的字典。</span><span class="yiyi-st" id="yiyi-1724">修改这个字典实际上将改变模块的符号表，但是直接给<a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a>属性赋值是不可能的（你可以写成<code class="docutils literal"><span class="pre">m.__dict__['a']</span> <span class="pre">=</span> <span class="pre">1</span></code>，它定义<code class="docutils literal"><span class="pre">m.a</span></code> 为 <code class="docutils literal"><span class="pre">1</span></code>，但你不能写成<code class="docutils literal"><span class="pre">m.__dict__</span> <span class="pre">=</span> <span class="pre">{}</span></code>）。</span><span class="yiyi-st" id="yiyi-1725">不建议直接修改<a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-1726">内置于解释器中的模块写成这样：<code class="docutils literal"><span class="pre">&lt;module</span> <span class="pre">'sys'</span> <span class="pre">(built-in)&gt;</span></code>。</span><span class="yiyi-st" id="yiyi-1727">如果是从文件中加载的，则它们写成 <code class="docutils literal"><span class="pre">&lt;module</span> <span class="pre">'os'</span> <span class="pre">from</span> <span class="pre">'/usr/local/lib/pythonX.Y/os.pyc'&gt;</span></code>。</span></p></div><div class="section" id="classes-and-class-instances"><h3><span class="yiyi-st" id="yiyi-1728">4.12.2.</span><span class="yiyi-st" id="yiyi-1729">类和类实例</span></h3><p><span class="yiyi-st" id="yiyi-1730">请参阅<a class="reference internal" href="../reference/datamodel.html#objects"><span>Objects, values and types</span></a>和<a class="reference internal" href="../reference/compound_stmts.html#class"><span>Class definitions</span></a>。</span></p></div><div class="section" id="functions"><h3><span class="yiyi-st" id="yiyi-1731">4.12.3.</span><span class="yiyi-st" id="yiyi-1732">函数</span></h3><p><span class="yiyi-st" id="yiyi-1733">函数对象由函数定义创建。</span><span class="yiyi-st" id="yiyi-1734">函数对象的唯一操作是调用它：<code class="docutils literal"><span class="pre">func(argument-list)</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-1735">真的有两种类型的函数对象：内建函数和用户定义的函数。</span><span class="yiyi-st" id="yiyi-1736">两者都支持相同的操作（来调用函数），但实现是不同的，因此不同的对象类型。</span></p><p><span class="yiyi-st" id="yiyi-1737">有关更多信息，请参见<a class="reference internal" href="../reference/compound_stmts.html#function"><span>Function definitions</span></a>。</span></p></div><div class="section" id="methods"><h3><span class="yiyi-st" id="yiyi-1738">4.12.4.</span><span class="yiyi-st" id="yiyi-1739">方法</span></h3><p id="index-50"><span class="yiyi-st" id="yiyi-1740">方法是使用属性表示法调用的函数。</span><span class="yiyi-st" id="yiyi-1741">有两种风格：内置方法（如列表上的<code class="xref py py-meth docutils literal"><span class="pre">append()</span></code>）和类实例方法。</span><span class="yiyi-st" id="yiyi-1742">内置方法用支持它们的类型来描述。</span></p><p><span class="yiyi-st" id="yiyi-1743">如果通过实例访问方法（在类名称空间中定义的函数），则会得到一个特殊对象：一个<em class="dfn">绑定方法</em>（也称为<em class="dfn">实例方法</em>）对象。</span><span class="yiyi-st" id="yiyi-1744">调用时，它会将<code class="docutils literal"><span class="pre">self</span></code>参数添加到参数列表中。</span><span class="yiyi-st" id="yiyi-1745">Bound methods have two special read-only attributes: <code class="docutils literal"><span class="pre">m.__self__</span></code> is the object on which the method operates, and <code class="docutils literal"><span class="pre">m.__func__</span></code> is the function implementing the method. </span><span class="yiyi-st" id="yiyi-1746">Calling <code class="docutils literal"><span class="pre">m(arg-1,</span> <span class="pre">arg-2,</span> <span class="pre">...,</span> <span class="pre">arg-n)</span></code> is completely equivalent to calling <code class="docutils literal"><span class="pre">m.__func__(m.__self__,</span> <span class="pre">arg-1,</span> <span class="pre">arg-2,</span> <span class="pre">...,</span> <span class="pre">arg-n)</span></code>.</span></p><p><span class="yiyi-st" id="yiyi-1747">像函数对象一样，绑定方法对象支持获取任意属性。</span><span class="yiyi-st" id="yiyi-1748">但是，由于方法属性实际上存储在底层函数对象（<code class="docutils literal"><span class="pre">meth.__func__</span></code>）中，所以绑定方法的设置方法属性是不允许的。</span><span class="yiyi-st" id="yiyi-1749">尝试在方法上设置属性会导致引发<a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a>。</span><span class="yiyi-st" id="yiyi-1750">为了设置一个方法属性，你需要在底层函数对象上明确地设置它：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">whoami</span> <span class="o">=</span> <span class="s1">'my name is method'</span>  <span class="c1"># can't set on the method</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">'method' object has no attribute 'whoami'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">__func__</span><span class="o">.</span><span class="n">whoami</span> <span class="o">=</span> <span class="s1">'my name is method'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">whoami</span>
<span class="go">'my name is method'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-1751">有关更多信息，请参阅<a class="reference internal" href="../reference/datamodel.html#types"><span>The standard type hierarchy</span></a>。</span></p></div><div class="section" id="code-objects"><h3><span class="yiyi-st" id="yiyi-1752">4.12.5.</span><span class="yiyi-st" id="yiyi-1753">代码对象</span></h3><p id="index-52"><span class="yiyi-st" id="yiyi-1754">代码对象被实现用来表示“伪编译”的可执行Python代码，如函数体。</span><span class="yiyi-st" id="yiyi-1755">它们不同于函数对象，因为它们不包含对其全局执行环境的引用。</span><span class="yiyi-st" id="yiyi-1756">代码对象由内置的<a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a>函数返回，并且可以通过它们的<code class="xref py py-attr docutils literal"><span class="pre">__code__</span></code>属性从函数对象中提取。</span><span class="yiyi-st" id="yiyi-1757">另请参阅<a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-mod docutils literal"><span class="pre">code</span></code></a>模块。</span></p><p id="index-53"><span class="yiyi-st" id="yiyi-1758">通过将代码对象（而不是源字符串）传递给<a class="reference internal" href="functions.html#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a>或<a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a>内置函数，可以执行或评估代码对象。</span></p><p><span class="yiyi-st" id="yiyi-1759">有关更多信息，请参阅<a class="reference internal" href="../reference/datamodel.html#types"><span>The standard type hierarchy</span></a>。</span></p></div><div class="section" id="type-objects"><h3><span class="yiyi-st" id="yiyi-1760">4.12.6.</span><span class="yiyi-st" id="yiyi-1761">输入对象</span></h3><p id="index-54"><span class="yiyi-st" id="yiyi-1762">类型对象表示各种对象类型。</span><span class="yiyi-st" id="yiyi-1763">一个对象的类型通过内建函数<a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-func docutils literal"><span class="pre">type()</span></code></a>访问。</span><span class="yiyi-st" id="yiyi-1764">类型没有特别的操作。</span><span class="yiyi-st" id="yiyi-1765">标准模块<a class="reference internal" href="types.html#module-types" title="types: Names for built-in types."><code class="xref py py-mod docutils literal"><span class="pre">types</span></code></a>定义所有标准的内建类型的名称。</span></p><p><span class="yiyi-st" id="yiyi-1766">类型写成这样：<code class="docutils literal"><span class="pre">&lt;class</span> <span class="pre">'int'&gt;</span></code>.</span></p></div><div class="section" id="the-null-object"><h3><span class="yiyi-st" id="yiyi-1767">4.12.7.</span><span class="yiyi-st" id="yiyi-1768">空对象</span></h3><p><span class="yiyi-st" id="yiyi-1769">该对象由不显式返回值的函数返回。</span><span class="yiyi-st" id="yiyi-1770">它不支持特殊操作。</span><span class="yiyi-st" id="yiyi-1771">有一个空对象，名为<code class="docutils literal"><span class="pre">None</span></code>（内置名称）。</span><span class="yiyi-st" id="yiyi-1772"><code class="docutils literal"><span class="pre">type(None)()</span></code>产生相同的单例。</span></p><p><span class="yiyi-st" id="yiyi-1773">它被写为<code class="docutils literal"><span class="pre">None</span></code>。</span></p></div><div class="section" id="the-ellipsis-object"><h3><span class="yiyi-st" id="yiyi-1774">4.12.8.</span><span class="yiyi-st" id="yiyi-1775"> Ellipsis对象</span></h3><p><span class="yiyi-st" id="yiyi-1776">这个对象通常被切片使用（参见<a class="reference internal" href="../reference/expressions.html#slicings"><span>Slicings</span></a>）。</span><span class="yiyi-st" id="yiyi-1777">它不支持特殊操作。</span><span class="yiyi-st" id="yiyi-1778">Ellipsis对象有且只有一个，名为<a class="reference internal" href="constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal"><span class="pre">Ellipsis</span></code></a>（内建的名称）。</span><span class="yiyi-st" id="yiyi-1779"><code class="docutils literal"><span class="pre">type(Ellipsis)()</span></code>生成的也是这个唯一的<a class="reference internal" href="constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal"><span class="pre">Ellipsis</span></code></a>实例。</span></p><p><span class="yiyi-st" id="yiyi-1780">它被写为<code class="docutils literal"><span class="pre">Ellipsis</span></code>或<code class="docutils literal"><span class="pre">...</span></code>。</span></p></div><div class="section" id="the-notimplemented-object"><h3><span class="yiyi-st" id="yiyi-1781">4.12.9.</span><span class="yiyi-st" id="yiyi-1782">NotImplemented 对象</span></h3><p><span class="yiyi-st" id="yiyi-1783">当它们被要求对不支持的类型进行操作时，该对象从比较和二进制操作中返回。</span><span class="yiyi-st" id="yiyi-1784">有关更多信息，请参见<a class="reference internal" href="../reference/expressions.html#comparisons"><span>Comparisons</span></a>。</span><span class="yiyi-st" id="yiyi-1785">只有一个<code class="docutils literal"><span class="pre">NotImplemented</span></code>对象。</span><span class="yiyi-st" id="yiyi-1786"><code class="docutils literal"><span class="pre">type(NotImplemented)()</span></code>产生单例实例。</span></p><p><span class="yiyi-st" id="yiyi-1787">它被写为<code class="docutils literal"><span class="pre">NotImplemented</span></code>。</span></p></div><div class="section" id="boolean-values"><h3><span class="yiyi-st" id="yiyi-1788">4.12.10.</span><span class="yiyi-st" id="yiyi-1789">布尔值</span></h3><p><span class="yiyi-st" id="yiyi-1790">布尔值是两个常量对象<code class="docutils literal"><span class="pre">False</span></code>和<code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-1791">它们被用来表示真值（尽管其他值也可以被认为是错误或真实的）。</span><span class="yiyi-st" id="yiyi-1792">在数值上下文中（例如，当用作算术运算符的参数时），它们的行为分别与整数0和1相同。</span><span class="yiyi-st" id="yiyi-1793">内建函数<a class="reference internal" href="functions.html#bool" title="bool"><code class="xref py py-func docutils literal"><span class="pre">bool()</span></code></a>可用于将任何值转换为一个布尔值，如果值可以解释为真值（见上面<a class="reference internal" href="#truth"><span>Truth Value Testing</span></a>一节）。</span></p><p id="index-55"><span class="yiyi-st" id="yiyi-1794">它们分别写为<code class="docutils literal"><span class="pre">False</span></code>和<code class="docutils literal"><span class="pre">True</span></code>。</span></p></div><div class="section" id="internal-objects"><h3><span class="yiyi-st" id="yiyi-1795">4.12.11.</span><span class="yiyi-st" id="yiyi-1796">内部对象</span></h3><p><span class="yiyi-st" id="yiyi-1797">有关此信息，请参阅<a class="reference internal" href="../reference/datamodel.html#types"><span>The standard type hierarchy</span></a>。</span><span class="yiyi-st" id="yiyi-1798">它描述了堆栈框架对象，追溯对象和切片对象。</span></p></div></div><div class="section" id="special-attributes"><h2><span class="yiyi-st" id="yiyi-1799">4.13.</span><span class="yiyi-st" id="yiyi-1800">特殊属性</span></h2><p><span class="yiyi-st" id="yiyi-1801">当前的实现向几个对象类型添加了一些特殊的对它们有意义的只读属性。</span><span class="yiyi-st" id="yiyi-1802">它们其中有一些无法通过內建函数<a class="reference internal" href="functions.html#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a>检测出来。</span></p><dl class="attribute"><dt id="object.__dict__"><span class="yiyi-st" id="yiyi-1803"><code class="descclassname">object.</code><code class="descname">__dict__</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1804">用于存储对象（可写）属性的一个字典或映射对象。</span></p></dd></dl><dl class="attribute"><dt id="instance.__class__"><span class="yiyi-st" id="yiyi-1805"><code class="descclassname">instance.</code><code class="descname">__class__</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1806">类实例所属的类。</span></p></dd></dl><dl class="attribute"><dt id="class.__bases__"><span class="yiyi-st" id="yiyi-1807"><code class="descclassname">class.</code><code class="descname">__bases__</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1808">类对象的基类组成的元组。</span></p></dd></dl><dl class="attribute"><dt id="definition.__name__"><span class="yiyi-st" id="yiyi-1809"><code class="descclassname">definition.</code><code class="descname">__name__</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1810">类、函数、方法、描述器或生成器实例的名称。</span></p></dd></dl><dl class="attribute"><dt id="definition.__qualname__"><span class="yiyi-st" id="yiyi-1811"><code class="descclassname">definition.</code><code class="descname">__qualname__</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1812">类、函数、方法、描述器或生成器实例的<a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">限定名</span></a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-1813"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="attribute"><dt id="class.__mro__"><span class="yiyi-st" id="yiyi-1814"><code class="descclassname">class.</code><code class="descname">__mro__</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-1815">此属性是在方法解析期间查找基类时考虑的类的元组。</span></p></dd></dl><dl class="method"><dt id="class.mro"><span class="yiyi-st" id="yiyi-1816"><code class="descclassname">class.</code><code class="descname">mro</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1817">此方法可以由元类覆盖以自定义其实例的方法解析顺序。</span><span class="yiyi-st" id="yiyi-1818">它在类实例化时调用，其结果存储在<a class="reference internal" href="#class.__mro__" title="class.__mro__"><code class="xref py py-attr docutils literal"><span class="pre">__mro__</span></code></a>中。</span></p></dd></dl><dl class="method"><dt id="class.__subclasses__"><span class="yiyi-st" id="yiyi-1819"><code class="descclassname">class.</code><code class="descname">__subclasses__</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-1820">每个类保存一个弱引用列表到它的直接子类。</span><span class="yiyi-st" id="yiyi-1821">此方法返回所有仍然活着的引用的列表。</span><span class="yiyi-st" id="yiyi-1822">例：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">()</span>
<span class="go">[&lt;class 'bool'&gt;]</span>
</code></pre></dd></dl><p class="rubric"><span class="yiyi-st" id="yiyi-1823">脚注</span></p><table class="docutils footnote" frame="void" id="id11" rules="none"><tbody valign="top"><tr><td class="label"><span class="yiyi-st" id="yiyi-1824"><a class="fn-backref" href="#id1">[1]</a></span></td><td><span class="yiyi-st" id="yiyi-1825">有关这些特殊方法的更多信息，请参阅Python参考手册（<a class="reference internal" href="../reference/datamodel.html#customization"><span>Basic customization</span></a>）。</span></td></tr></tbody></table><table class="docutils footnote" frame="void" id="id12" rules="none"><tbody valign="top"><tr><td class="label"><span class="yiyi-st" id="yiyi-1826"><a class="fn-backref" href="#id2">[2]</a></span></td><td><span class="yiyi-st" id="yiyi-1827">As a consequence, the list <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">2]</span></code> is considered equal to <code class="docutils literal"><span class="pre">[1.0,</span> <span class="pre">2.0]</span></code>, and similarly for tuples.</span></td></tr></tbody></table><table class="docutils footnote" frame="void" id="id13" rules="none"><tbody valign="top"><tr><td class="label"><span class="yiyi-st" id="yiyi-1828">[3]</span></td><td><span class="yiyi-st" id="yiyi-1829">自解析器无法分辨操作数的类型以来，它们必须具备。</span></td></tr></tbody></table><table class="docutils footnote" frame="void" id="id14" rules="none"><tbody valign="top"><tr><td class="label"><span class="yiyi-st" id="yiyi-1830">[4]</span></td><td><span class="yiyi-st" id="yiyi-1831"><em>（<a class="fn-backref" href="#id5">1</a>，<a class="fn-backref" href="#id6">2</a>，<a class="fn-backref" href="#id7">3</a>，<a class="fn-backref" href="#id8">4</a>）</em>类别属性是“Lu”（Letter，大写），“Ll”（Letter，小写）或“Lt”（Letter，titlecase）之一。</span></td></tr></tbody></table><table class="docutils footnote" frame="void" id="id15" rules="none"><tbody valign="top"><tr><td class="label"><span class="yiyi-st" id="yiyi-1832">[5]</span></td><td><span class="yiyi-st" id="yiyi-1833"><em>(<a class="fn-backref" href="#id9">1</a>, <a class="fn-backref" href="#id10">2</a>)</em> To format only a tuple you should therefore provide a singleton tuple whose only element is the tuple to be formatted.</span></td></tr></tbody></table></div></div></div>