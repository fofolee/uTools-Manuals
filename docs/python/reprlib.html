<div class="body" role="main"><div class="section" id="module-reprlib"><h1><span class="yiyi-st" id="yiyi-10">8.12. <a class="reference internal" href="#module-reprlib" title="reprlib: Alternate repr() implementation with size limits."><code class="xref py py-mod docutils literal"><span class="pre">reprlib</span></code></a>  - 替代<a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a>实现</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/reprlib.py">Lib/reprlib.py</a></span></p><p><span class="yiyi-st" id="yiyi-12"><a class="reference internal" href="#module-reprlib" title="reprlib: Alternate repr() implementation with size limits."><code class="xref py py-mod docutils literal"><span class="pre">reprlib</span></code></a> 模块提供了手段，为生产对象交涉的结果字符串的大小限制。</span><span class="yiyi-st" id="yiyi-13">这用在 Python 调试器中和在其他上下文可能很有用。</span></p><p><span class="yiyi-st" id="yiyi-14">本模块提供了一个类、 实例和一个函数︰</span></p><dl class="class"><dt id="reprlib.Repr"><span class="yiyi-st" id="yiyi-15"><em class="property">class </em><code class="descclassname">reprlib.</code><code class="descname">Repr</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-16">类提供格式化服务有用在执行功能类似于内置 <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a>;为避免过长的意见书的代添加不同的对象类型的大小限制。</span></p></dd></dl><dl class="data"><dt id="reprlib.aRepr"><span class="yiyi-st" id="yiyi-17"><code class="descclassname">reprlib.</code><code class="descname">aRepr</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-18">这是 <a class="reference internal" href="#reprlib.Repr" title="reprlib.Repr"><code class="xref py py-class docutils literal"><span class="pre">repr</span></code></a> 用来提供如下所述的 <a class="reference internal" href="#reprlib.repr" title="reprlib.repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> 函数的一个实例。</span><span class="yiyi-st" id="yiyi-19">更改此对象的属性将影响由 <a class="reference internal" href="#reprlib.repr" title="reprlib.repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> 和 Python 调试器使用的大小限制。</span></p></dd></dl><dl class="function"><dt id="reprlib.repr"><span class="yiyi-st" id="yiyi-20"><code class="descclassname">reprlib.</code><code class="descname">repr</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-21">这是<code class="docutils literal"><span class="pre">aRepr</span></code>的<a class="reference internal" href="#reprlib.Repr.repr" title="reprlib.Repr.repr"><code class="xref py py-meth docutils literal"><span class="pre">repr()</span></code></a>方法。</span><span class="yiyi-st" id="yiyi-22">它返回一个类似于由同名内建函数返回的字符串，但对大多数大小有限制。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-23">除了大小限制工具，模块还提供了装饰器，用于检测对<a class="reference internal" href="../reference/datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal"><span class="pre">__repr__()</span></code></a>的递归调用，并替换为占位符字符串。</span></p><dl class="function"><dt id="reprlib.recursive_repr"><span class="yiyi-st" id="yiyi-24"><code class="descclassname">@</code><code class="descclassname">reprlib.</code><code class="descname">recursive_repr</code><span class="sig-paren">(</span><em>fillvalue="..."</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-25">装饰器用于检测同一线程中的递归调用的<a class="reference internal" href="../reference/datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal"><span class="pre">__repr__()</span></code></a>方法。</span><span class="yiyi-st" id="yiyi-26">如果进行了递归调用，则会返回<em>fillvalue</em>，否则，将执行通常的<a class="reference internal" href="../reference/datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal"><span class="pre">__repr__()</span></code></a>调用。</span><span class="yiyi-st" id="yiyi-27">例如：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyList</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nd">@recursive_repr</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s1">'&lt;'</span> <span class="o">+</span> <span class="s1">'|'</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">repr</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span> <span class="o">+</span> <span class="s1">'&gt;'</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MyList</span><span class="p">(</span><span class="s1">'abc'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'x'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">&lt;'a'|'b'|'c'|...|'x'&gt;</span>
</pre></div></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-28"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><div class="section" id="repr-objects"><h2><span class="yiyi-st" id="yiyi-29">8.12.1.</span><span class="yiyi-st" id="yiyi-30">Repr对象</span></h2><p><span class="yiyi-st" id="yiyi-31"><a class="reference internal" href="#reprlib.Repr" title="reprlib.Repr"><code class="xref py py-class docutils literal"><span class="pre">Repr</span></code></a>实例提供了几个属性，可用于为不同对象类型的表示提供大小限制，以及格式化特定对象类型的方法。</span></p><dl class="attribute"><dt id="reprlib.Repr.maxlevel"><span class="yiyi-st" id="yiyi-32"><code class="descclassname">Repr.</code><code class="descname">maxlevel</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-33">创建递归表示的深度限制。</span><span class="yiyi-st" id="yiyi-34">默认值为<code class="docutils literal"><span class="pre">6</span></code>。</span></p></dd></dl><dl class="attribute"><dt id="reprlib.Repr.maxdict"><span class="yiyi-st" id="yiyi-35"><code class="descclassname">Repr.</code><code class="descname">maxdict</code></span></dt><dt id="reprlib.Repr.maxlist"><span class="yiyi-st" id="yiyi-36"><code class="descclassname">Repr.</code><code class="descname">maxlist</code></span></dt><dt id="reprlib.Repr.maxtuple"><span class="yiyi-st" id="yiyi-37"><code class="descclassname">Repr.</code><code class="descname">maxtuple</code></span></dt><dt id="reprlib.Repr.maxset"><span class="yiyi-st" id="yiyi-38"><code class="descclassname">Repr.</code><code class="descname">maxset</code></span></dt><dt id="reprlib.Repr.maxfrozenset"><span class="yiyi-st" id="yiyi-39"><code class="descclassname">Repr.</code><code class="descname">maxfrozenset</code></span></dt><dt id="reprlib.Repr.maxdeque"><span class="yiyi-st" id="yiyi-40"><code class="descclassname">Repr.</code><code class="descname">maxdeque</code></span></dt><dt id="reprlib.Repr.maxarray"><span class="yiyi-st" id="yiyi-41"><code class="descclassname">Repr.</code><code class="descname">maxarray</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-42">对指定对象类型表示的条目数的限制。</span><span class="yiyi-st" id="yiyi-43">对于<a class="reference internal" href="#reprlib.Repr.maxdict" title="reprlib.Repr.maxdict"><code class="xref py py-attr docutils literal"><span class="pre">maxdict</span></code></a>，<code class="docutils literal"><span class="pre">5</span></code>的<a class="reference internal" href="#reprlib.Repr.maxarray" title="reprlib.Repr.maxarray"><code class="xref py py-attr docutils literal"><span class="pre">maxarray</span></code></a>和<code class="docutils literal"><span class="pre">6</span></code>，默认值为<code class="docutils literal"><span class="pre">4</span></code>其他。</span></p></dd></dl><dl class="attribute"><dt id="reprlib.Repr.maxlong"><span class="yiyi-st" id="yiyi-44"><code class="descclassname">Repr.</code><code class="descname">maxlong</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-45">整数的表示中的最大字符数。</span><span class="yiyi-st" id="yiyi-46">数字从中间掉落。</span><span class="yiyi-st" id="yiyi-47">默认值为<code class="docutils literal"><span class="pre">40</span></code>。</span></p></dd></dl><dl class="attribute"><dt id="reprlib.Repr.maxstring"><span class="yiyi-st" id="yiyi-48"><code class="descclassname">Repr.</code><code class="descname">maxstring</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-49">限制字符串表示中的字符数。</span><span class="yiyi-st" id="yiyi-50">注意，字符串的“正常”表示被用作字符源：如果在表示中需要转义序列，当表示被缩短时，这些可能被破坏。</span><span class="yiyi-st" id="yiyi-51">默认值为<code class="docutils literal"><span class="pre">30</span></code>。</span></p></dd></dl><dl class="attribute"><dt id="reprlib.Repr.maxother"><span class="yiyi-st" id="yiyi-52"><code class="descclassname">Repr.</code><code class="descname">maxother</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-53">此限制用于控制在<a class="reference internal" href="#reprlib.Repr" title="reprlib.Repr"><code class="xref py py-class docutils literal"><span class="pre">Repr</span></code></a>对象上没有可用的特定格式化方法的对象类型的大小。</span><span class="yiyi-st" id="yiyi-54">它以与<a class="reference internal" href="#reprlib.Repr.maxstring" title="reprlib.Repr.maxstring"><code class="xref py py-attr docutils literal"><span class="pre">maxstring</span></code></a>类似的方式应用。</span><span class="yiyi-st" id="yiyi-55">默认值为<code class="docutils literal"><span class="pre">20</span></code>。</span></p></dd></dl><dl class="method"><dt id="reprlib.Repr.repr"><span class="yiyi-st" id="yiyi-56"><code class="descclassname">Repr.</code><code class="descname">repr</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-57">相当于内建<a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a>，它使用实例强加的格式。</span></p></dd></dl><dl class="method"><dt id="reprlib.Repr.repr1"><span class="yiyi-st" id="yiyi-58"><code class="descclassname">Repr.</code><code class="descname">repr1</code><span class="sig-paren">(</span><em>obj</em>, <em>level</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-59"><a class="reference internal" href="#reprlib.Repr.repr" title="reprlib.Repr.repr"><code class="xref py py-meth docutils literal"><span class="pre">repr()</span></code></a>使用递归实现。</span><span class="yiyi-st" id="yiyi-60">这使用<em>obj</em>类型来确定要调用的格式化方法，将其传递<em>obj</em>和<em>级别</em>。</span><span class="yiyi-st" id="yiyi-61">The type-specific methods should call <a class="reference internal" href="#reprlib.Repr.repr1" title="reprlib.Repr.repr1"><code class="xref py py-meth docutils literal"><span class="pre">repr1()</span></code></a> to perform recursive formatting, with <code class="docutils literal"><span class="pre">level</span> <span class="pre">-</span> <span class="pre">1</span></code> for the value of <em>level</em> in the recursive call.</span></p></dd></dl><dl class="method"><dt><span class="yiyi-st" id="yiyi-62"><code class="descclassname">Repr.</code><code class="descname">repr_TYPE</code><span class="sig-paren">(</span><em>obj</em>, <em>level</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-63">特定类型的格式化方法实现为基于类型名称的名称的方法。</span><span class="yiyi-st" id="yiyi-64">在方法名称中，<strong>TYPE</strong>被替换为<code class="docutils literal"><span class="pre">'_'.join(type(obj).__name__.split())</span></code>。</span><span class="yiyi-st" id="yiyi-65">对这些方法的调度由<a class="reference internal" href="#reprlib.Repr.repr1" title="reprlib.Repr.repr1"><code class="xref py py-meth docutils literal"><span class="pre">repr1()</span></code></a>处理。</span><span class="yiyi-st" id="yiyi-66">需要递归格式化值的类型特定方法应调用<code class="docutils literal"><span class="pre">self.repr1（subobj，</span> <span class="pre">level</span> <span class="pre"> - </span> <span class="pre">1） </span></code>。</span></p></dd></dl></div><div class="section" id="subclassing-repr-objects"><h2><span class="yiyi-st" id="yiyi-67">8.12.2.</span><span class="yiyi-st" id="yiyi-68">子类Repr对象</span></h2><p><span class="yiyi-st" id="yiyi-69">通过<a class="reference internal" href="#reprlib.Repr.repr1" title="reprlib.Repr.repr1"><code class="xref py py-meth docutils literal"><span class="pre">Repr.repr1()</span></code></a>使用动态分发允许<a class="reference internal" href="#reprlib.Repr" title="reprlib.Repr"><code class="xref py py-class docutils literal"><span class="pre">Repr</span></code></a>的子类添加对其他内建对象类型的支持或修改已支持类型的处理。</span><span class="yiyi-st" id="yiyi-70">此示例显示如何添加对文件对象的特殊支持：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">reprlib</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">class</span> <span class="nc">MyRepr</span><span class="p">(</span><span class="n">reprlib</span><span class="o">.</span><span class="n">Repr</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">repr_TextIOWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">'&lt;stdin&gt;'</span><span class="p">,</span> <span class="s1">'&lt;stdout&gt;'</span><span class="p">,</span> <span class="s1">'&lt;stderr&gt;'</span><span class="p">}:</span>
            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

<span class="n">aRepr</span> <span class="o">=</span> <span class="n">MyRepr</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">aRepr</span><span class="o">.</span><span class="n">repr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="p">))</span>         <span class="c1"># prints '&lt;stdin&gt;'</span>
</pre></div></div></div></div></div>