<div class="body" role="main"><div class="section" id="module-math"><h1><span class="yiyi-st" id="yiyi-10">9.2. <a class="reference internal" href="#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal"><span class="pre">math</span></code></a> — 数学函数</span></h1><p><span class="yiyi-st" id="yiyi-11">本模块始终是可用的。</span><span class="yiyi-st" id="yiyi-12">它提供对由 C 标准定义的数学函数访问。</span></p><p><span class="yiyi-st" id="yiyi-13">这些函数不能用于复数；如果您需要支持复数，从 <a class="reference internal" href="cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal"><span class="pre">cmath</span></code></a> 使用相同的函数。</span><span class="yiyi-st" id="yiyi-14">对复数支持与否的区别取决于此模块的大多数使用者不想学习像理解复数这么深层的数学理论。</span><span class="yiyi-st" id="yiyi-15">接收到异常而不是复杂的结果允许意外复杂的数字作为参数使用的早期检测，以便程序员可以确定如何以及为什么它生成放在第一位。</span></p><p><span class="yiyi-st" id="yiyi-16">本模块提供以下功能。</span><span class="yiyi-st" id="yiyi-17">除明确说明，否则，所有返回值都是浮点型。</span></p><div class="section" id="number-theoretic-and-representation-functions"><h2><span class="yiyi-st" id="yiyi-18">9.2.1.</span><span class="yiyi-st" id="yiyi-19">数理论和表示函数</span></h2><dl class="function"><dt id="math.ceil"><span class="yiyi-st" id="yiyi-20"><code class="descclassname">math.</code><code class="descname">ceil</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-21">Return the ceiling of <em>x</em>, 大于等于 <em>x</em> 的最小整数.</span><span class="yiyi-st" id="yiyi-22">如果 <em>x</em> 不是浮点型，委托 <code class="docutils literal"><span class="pre">x.__ceil__()</span></code> 方法，将会返回 <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a> （整型）值。</span></p></dd></dl><dl class="function"><dt id="math.copysign"><span class="yiyi-st" id="yiyi-23"><code class="descclassname">math.</code><code class="descname">copysign</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span> </span></dt><dd><p><span class="yiyi-st" id="yiyi-24">返回<em>x</em>的绝对值大小和<em>y</em>的符号。</span><span class="yiyi-st" id="yiyi-25">On platforms that support signed zeros, <code class="docutils literal"><span class="pre">copysign(1.0,</span> <span class="pre">-0.0)</span></code> returns <em>-1.0</em>.</span></p></dd></dl><dl class="function"><dt id="math.fabs"><span class="yiyi-st" id="yiyi-26"><code class="descclassname">math.</code><code class="descname">fabs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-27">返回<em>x</em>的绝对值。</span></p></dd></dl><dl class="function"><dt id="math.factorial"><span class="yiyi-st" id="yiyi-28"><code class="descclassname">math.</code><code class="descname">factorial</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-29">返回<em>x</em>的阶乘。</span><span class="yiyi-st" id="yiyi-30">如果<em>x</em>不是整数或者是负数，返回错误<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="math.floor"><span class="yiyi-st" id="yiyi-31"><code class="descclassname">math.</code><code class="descname">floor</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-32">Return the floor of <em>x</em>, 小于等于 <em>x</em>的最大整数.</span><span class="yiyi-st" id="yiyi-33">如果 <em>x</em> 不是浮点型，委托 <code class="docutils literal"><span class="pre">x.__floor__()</span></code> 方法，将会返回 <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a> （整型）值。</span></p></dd></dl><dl class="function"><dt id="math.fmod"><span class="yiyi-st" id="yiyi-34"><code class="descclassname">math.</code><code class="descname">fmod</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-35">返回由平台C库定义的<code class="docutils literal"><span class="pre">fmod（x，</span> <span class="pre">y）</span></code>。</span><span class="yiyi-st" id="yiyi-36">请注意，Python表达式<code class="docutils literal"><span class="pre">x</span> <span class="pre">％</span> <span class="pre">y</span></code>可能不会返回相同的结果。</span><span class="yiyi-st" id="yiyi-37">The intent of the C standard is that <code class="docutils literal"><span class="pre">fmod(x,</span> <span class="pre">y)</span></code> be exactly (mathematically; to infinite precision) equal to <code class="docutils literal"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">n*y</span></code> for some integer <em>n</em> such that the result has the same sign as <em>x</em> and magnitude less than <code class="docutils literal"><span class="pre">abs(y)</span></code>. </span><span class="yiyi-st" id="yiyi-38">Python的<code class="docutils literal"><span class="pre">x</span> <span class="pre">％</span> <span class="pre">y</span></code>返回具有<em>y</em>符号的结果，可能不能精确计算float参数。</span><span class="yiyi-st" id="yiyi-39">例如，<code class="docutils literal"><span class="pre">fmod（-1e-100，</span> <span class="pre">1e100）</span></code>是<code class="docutils literal"><span class="pre">-1e-100</span></code>，但是结果Python的<code class="docutils literal"><span class="pre">-1e-100</span> <span class="pre">％</span> <span class="pre">1e100</span></code>是<code class="docutils literal"><span class="pre">1e100-1e-100</span></code>不能精确地表示为float，并且舍入到令人惊讶的<code class="docutils literal"><span class="pre">1e100</span></code>。</span><span class="yiyi-st" id="yiyi-40">因此，使用浮动时，通常优先使用函数<a class="reference internal" href="#math.fmod" title="math.fmod"><code class="xref py py-func docutils literal"><span class="pre">fmod()</span></code></a>，而Python的<code class="docutils literal"><span class="pre">x</span> <span class="pre">％</span> <span class="pre">t6&gt;</span></code>在使用整数时是首选。</span></p></dd></dl><dl class="function"><dt id="math.frexp"><span class="yiyi-st" id="yiyi-41"><code class="descclassname">math.</code><code class="descname">frexp</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-42">将<em>x</em>的尾数和指数作为对<code class="docutils literal"><span class="pre">(m, </span> <span class="pre">e)</span></code>返回。</span><span class="yiyi-st" id="yiyi-43"><em>m</em>是浮点，并且<em>e</em>是使得<code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">/ t5&gt; <span class="pre">*</span> <span class="pre">2 ** e</span></span></code>。</span><span class="yiyi-st" id="yiyi-44">If <em>x</em> is zero, returns <code class="docutils literal"><span class="pre">(0.0,</span> <span class="pre">0)</span></code>, otherwise <code class="docutils literal"><span class="pre">0.5</span> <span class="pre">&lt;=</span> <span class="pre">abs(m)</span> <span class="pre">&lt;</span> <span class="pre">1</span></code>.</span><span class="yiyi-st" id="yiyi-45">这用来"条分缕析"一个浮点数的内部表示形式可移植的方式。</span></p></dd></dl><dl class="function"><dt id="math.fsum"><span class="yiyi-st" id="yiyi-46"><code class="descclassname">math.</code><code class="descname">fsum</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-47">在可迭代中返回值的准确浮动点总和。</span><span class="yiyi-st" id="yiyi-48">通过跟踪多个中间部分款项，避免了精度损失：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">([</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0.9999999999999999</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fsum</span><span class="p">([</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">])</span>
<span class="go">1.0</span>
</pre></div></div><p><span class="yiyi-st" id="yiyi-49">该算法的准确性取决于 IEEE 754 算法，保证和典型案例的舍入模式在哪里，甚至一半。</span><span class="yiyi-st" id="yiyi-50">在一些非 Windows 版本中，底层的 C 库使用扩展的精度加法并可能偶尔双圆中间的总和，从而导致该关闭其最低有效位。</span></p><p><span class="yiyi-st" id="yiyi-51">有关进一步的讨论和两种替代方法，请参阅<a class="reference external" href="https://code.activestate.com/recipes/393090/">ASPN食谱的准确浮点和</a>。</span></p></dd></dl><dl class="function"><dt id="math.gcd"><span class="yiyi-st" id="yiyi-52"> <code class="descclassname">math.</code><code class="descname">gcd</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-53">返回整数<em>a</em>和<em>b</em>的最大公约数。</span><span class="yiyi-st" id="yiyi-54">如果<em>a</em>或<em>b</em>为非零，则<code class="docutils literal"><span class="pre">gcd（a，</span> <span class="pre">b）</span> / t2&gt;是分割<em>a</em>和<em>b</em>的最大正整数。 <code class="docutils literal"><span class="pre">gcd（0，</span> <span class="pre">0）</span></code>返回<code class="docutils literal"><span class="pre">0</span></code>。</code></span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-55"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="math.isclose"><span class="yiyi-st" id="yiyi-56"><code class="descclassname">math.</code><code class="descname">isclose</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>*</em>, <em>rel_tol=1e-09</em>, <em>abs_tol=0.0</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-57">如果<em>a</em>和<em>b</em>的值彼此接近，则返回<code class="docutils literal"><span class="pre">True</span></code>, 反之则<code class="docutils literal"><span class="pre">False</span></code></span></p><p><span class="yiyi-st" id="yiyi-58">根据给定的绝对和相对容限确定两个值是否接近。</span></p><p><span class="yiyi-st" id="yiyi-59"><em>rel_tol</em>是相对容限 - 它是<em>a</em>和<em>b</em>之间的最大允许差值，相对于<em>/ t3&gt;或<em>b</em>。</em></span><span class="yiyi-st" id="yiyi-60">例如，要将公差设置为5％，请传递<code class="docutils literal"><span class="pre">rel_tol=0.05</span></code>。</span><span class="yiyi-st" id="yiyi-61">默认容差为<code class="docutils literal"><span class="pre">1e-09</span></code>，它确保两个值在大约9个十进制数字内相同。</span><span class="yiyi-st" id="yiyi-62"><em>rel_tol</em>必须大于零。</span></p><p><span class="yiyi-st" id="yiyi-63"><em>abs_tol</em>是最小绝对公差 - 对于接近零的比较有用。</span><span class="yiyi-st" id="yiyi-64"><em>abs_tol</em>必须至少为零。</span></p><p><span class="yiyi-st" id="yiyi-65">如果没有错误发生，则结果将是：<code class="docutils literal"><span class="pre">abs（ab）</span> <span class="pre"> <span class="pre">max（rel_tol</span> <span class="pre">t4&gt; <span class="pre">max（abs（a），</span> <span class="pre">abs（b）），</span> <span class="pre">abs_tol）</span></span></span></code>。</span></p><p><span class="yiyi-st" id="yiyi-66">将根据IEEE规则处理特殊值<code class="docutils literal"><span class="pre">NaN</span></code>，<code class="docutils literal"><span class="pre">inf</span></code>和<code class="docutils literal"><span class="pre">-inf</span></code>。</span><span class="yiyi-st" id="yiyi-67">具体地，不认为<code class="docutils literal"><span class="pre">NaN</span></code>接近任何其他值，包括<code class="docutils literal"><span class="pre">NaN</span></code>。</span><span class="yiyi-st" id="yiyi-68"><code class="docutils literal"><span class="pre">inf</span></code>和<code class="docutils literal"><span class="pre">-inf</span></code>只被认为接近自己。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-69"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-70">请参见</span></p><p class="last"><span class="yiyi-st" id="yiyi-71"><span class="target" id="index-0"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0485"><strong>PEP 485</strong></a>  - 测试近似相等的函数</span></p></div></dd></dl><dl class="function"><dt id="math.isfinite"><span class="yiyi-st" id="yiyi-72"><code class="descclassname">math.</code><code class="descname">isfinite</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-73">如果<em>x</em>既不是无穷大也不是NaN，则返回<code class="docutils literal"><span class="pre">True</span></code>，否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span><span class="yiyi-st" id="yiyi-74">（注意<code class="docutils literal"><span class="pre">0.0</span></code> <em>是</em>被认为是有限的。）</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-75"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="math.isinf"><span class="yiyi-st" id="yiyi-76"><code class="descclassname">math.</code><code class="descname">isinf</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-77">如果<em>x</em>是正或负无穷大，则返回<code class="docutils literal"><span class="pre">True</span></code>，否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p></dd></dl><dl class="function"><dt id="math.isnan"><span class="yiyi-st" id="yiyi-78"><code class="descclassname">math.</code><code class="descname">isnan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-79">如果<em>x</em>是NaN（不是数字），则返回<code class="docutils literal"><span class="pre">True</span></code>，否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p></dd></dl><dl class="function"><dt id="math.ldexp"><span class="yiyi-st" id="yiyi-80"><code class="descclassname">math.</code><code class="descname">ldexp</code><span class="sig-paren">(</span><em>x</em>, <em>i</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-81">返回<code class="docutils literal"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">（2 ** i）</span></code>。</span><span class="yiyi-st" id="yiyi-82">这基本上是函数<a class="reference internal" href="#math.frexp" title="math.frexp"><code class="xref py py-func docutils literal"><span class="pre">frexp()</span></code></a>的逆。</span></p></dd></dl><dl class="function"><dt id="math.modf"><span class="yiyi-st" id="yiyi-83"><code class="descclassname">math.</code><code class="descname">modf</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-84">返回<em>x</em>的小数和整数部分。</span><span class="yiyi-st" id="yiyi-85">这两个结果携带的<em>x</em>标志，也是浮点型。</span></p></dd></dl><dl class="function"><dt id="math.trunc"><span class="yiyi-st" id="yiyi-86"><code class="descclassname">math.</code><code class="descname">trunc</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-87">将<a class="reference internal" href="numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal"><span class="pre">Real</span></code></a>值<em>x</em>返回到<a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a>（通常为整数）。</span><span class="yiyi-st" id="yiyi-88">代表<code class="docutils literal"><span class="pre">x.__trunc__()</span></code>。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-89">注意，<a class="reference internal" href="#math.frexp" title="math.frexp"><code class="xref py py-func docutils literal"><span class="pre">frexp()</span></code></a>和<a class="reference internal" href="#math.modf" title="math.modf"><code class="xref py py-func docutils literal"><span class="pre">modf()</span></code></a>有与它们的C语言不同的调用/返回模式：它们接受一个参数并返回一对值，它们的第二个返回值通过一个'输出参数'（在Python中没有这样的事情）。</span></p><p><span class="yiyi-st" id="yiyi-90">对于<a class="reference internal" href="#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal"><span class="pre">ceil()</span></code></a>，<a class="reference internal" href="#math.floor" title="math.floor"><code class="xref py py-func docutils literal"><span class="pre">floor()</span></code></a>和<a class="reference internal" href="#math.modf" title="math.modf"><code class="xref py py-func docutils literal"><span class="pre">modf()</span></code></a>函数，请注意<em>all</em>足够大的数值是精确的整数。</span><span class="yiyi-st" id="yiyi-91">Python浮点通常不会超过53位的精度（与平台C double类型相同），在这种情况下，任何float <em>x</em>与<code class="docutils literal"><span class="pre">abs（x）</span> <span class="pre">＆gt； =</span> <span class="pre">2 ** 52</span></code>必然没有小数位。</span></p></div><div class="section" id="power-and-logarithmic-functions"><h2><span class="yiyi-st" id="yiyi-92">9.2.2.</span><span class="yiyi-st" id="yiyi-93">幂函数和对数函数</span></h2><dl class="function"><dt id="math.exp"><span class="yiyi-st" id="yiyi-94"><code class="descclassname">math.</code><code class="descname">exp</code> <span class="sig-paren">（</span> <em>x</em> <span class="sig-paren">）</span> </span></dt><dd><p><span class="yiyi-st" id="yiyi-95">返回 <code class="docutils literal"><span class="pre">e**x</span></code> （e的x幂方）。</span></p></dd></dl><dl class="function"><dt id="math.expm1"><span class="yiyi-st" id="yiyi-96"><code class="descclassname">math.</code><code class="descname">expm1</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-97">返回<code class="docutils literal"><span class="pre">e ** x</span> <span class="pre"> - </span> <span class="pre">1</span></code>。</span><span class="yiyi-st" id="yiyi-98">对于小浮点<em>x</em>，在<code class="docutils literal"><span class="pre">exp（x）</span> <span class="pre"> - </span> <span class="pre">1</span> 导致<a class="reference external" href="https://en.wikipedia.org/wiki/Loss_of_significance">显着的精度损失</a>； <a class="reference internal" href="#math.expm1" title="math.expm1"><code class="xref py py-func docutils literal"><span class="pre">expm1()</span></code></a>函数提供了一种将该数量计算为全精度的方法：</code></span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">expm1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># gives result accurate to 11 places</span>
<span class="go">1.0000050000069649e-05</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expm1</span><span class="p">(</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span>    <span class="c1"># result accurate to full precision</span>
<span class="go">1.0000050000166668e-05</span>
</pre></div></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-99"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="math.log"><span class="yiyi-st" id="yiyi-100"><code class="descclassname">math.</code><code class="descname">log</code><span class="sig-paren">(</span><em>x</em><span class="optional">[</span>, <em>base</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-101">具有一个参数，返回的<em>x</em> （以<em>e</em>） 的自然对数。</span></p><p><span class="yiyi-st" id="yiyi-102">有两个参数，将<em>x</em>的对数返回给定的<em>基本</em>，计算为<code class="docutils literal"><span class="pre">log(x)/log(base)</span></code>。</span></p></dd></dl><dl class="function"><dt id="math.log1p"><span class="yiyi-st" id="yiyi-103"><code class="descclassname">math.</code><code class="descname">log1p</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-104">返回<em>1 + x</em> （底数<em>e</em>） 的自然对数。</span><span class="yiyi-st" id="yiyi-105">其结果被计算在某种程度上是准确，可用于<em>x</em>接近于零。</span></p></dd></dl><dl class="function"><dt id="math.log2"><span class="yiyi-st" id="yiyi-106"> <code class="descclassname">math.</code><code class="descname">log2</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-107">返回<em>x</em>的基2对数。</span><span class="yiyi-st" id="yiyi-108">这通常比<code class="docutils literal"><span class="pre">log（x，</span> <span class="pre">2）</span></code>更准确。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-109"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-110">请参见</span></p><p class="last"><span class="yiyi-st" id="yiyi-111"><a class="reference internal" href="stdtypes.html#int.bit_length" title="int.bit_length"><code class="xref py py-meth docutils literal"><span class="pre">int.bit_length()</span></code></a>返回表示二进制整数所需的位数，不包括符号和前导零。</span></p></div></dd></dl><dl class="function"><dt id="math.log10"><span class="yiyi-st" id="yiyi-112"><code class="descclassname">math.</code><code class="descname">log10</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-113">返回<em>x</em>的对数。</span><span class="yiyi-st" id="yiyi-114">这通常比<code class="docutils literal"><span class="pre">log（x，</span> <span class="pre">10）</span></code>更准确。</span></p></dd></dl><dl class="function"><dt id="math.pow"><span class="yiyi-st" id="yiyi-115"><code class="descclassname">math.</code><code class="descname">pow</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-116">返回<code class="docutils literal"><span class="pre">x</span></code>的<code class="docutils literal"><span class="pre">y</span></code>次幂。</span><span class="yiyi-st" id="yiyi-117">特殊情况下遵循附件 C99 标准的 ' F' 可能的范围内。</span><span class="yiyi-st" id="yiyi-118">具体地，<code class="docutils literal"><span class="pre">pow（1.0，</span> <span class="pre">x）</span></code>和<code class="docutils literal"><span class="pre">pow（x，</span> <span class="pre"></span></code>始终返回<code class="docutils literal"><span class="pre">1.0</span></code>，即使<code class="docutils literal"><span class="pre">x</span></code>为零或NaN。</span><span class="yiyi-st" id="yiyi-119">If both <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> are finite, <code class="docutils literal"><span class="pre">x</span></code> is negative, and <code class="docutils literal"><span class="pre">y</span></code> is not an integer then <code class="docutils literal"><span class="pre">pow(x,</span> <span class="pre">y)</span></code> is undefined, and raises <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>.</span></p><p><span class="yiyi-st" id="yiyi-120">与内建<code class="docutils literal"><span class="pre">**</span></code>操作符不同，<a class="reference internal" href="#math.pow" title="math.pow"><code class="xref py py-func docutils literal"><span class="pre">math.pow()</span></code></a>将其参数转换为<a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>。</span><span class="yiyi-st" id="yiyi-121">使用<code class="docutils literal"><span class="pre">**</span></code>或内建<a class="reference internal" href="functions.html#pow" title="pow"><code class="xref py py-func docutils literal"><span class="pre">pow()</span></code></a>函数计算精确的整数幂。</span></p></dd></dl><dl class="function"><dt id="math.sqrt"><span class="yiyi-st" id="yiyi-122"><code class="descclassname">math.</code><code class="descname">sqrt</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-123">返回 <em>x</em> 的平方根。</span></p></dd></dl></div><div class="section" id="trigonometric-functions"><h2><span class="yiyi-st" id="yiyi-124">9.2.3.</span><span class="yiyi-st" id="yiyi-125">三角函数</span></h2><dl class="function"><dt id="math.acos"><span class="yiyi-st" id="yiyi-126"> <code class="descclassname">math.</code><code class="descname">acos</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-127">返回以弧度表示的角的<em>x</em>，余弦。</span></p></dd></dl><dl class="function"><dt id="math.asin"><span class="yiyi-st" id="yiyi-128"><code class="descclassname">math.</code><code class="descname">asin</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-129">返回以弧度表示的正弦值的<em>x</em>。</span></p></dd></dl><dl class="function"><dt id="math.atan"><span class="yiyi-st" id="yiyi-130"><code class="descclassname">math.</code><code class="descname">atan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-131">返回反正切值的<em>x</em>，以弧度为单位。</span></p></dd></dl><dl class="function"><dt id="math.atan2"><span class="yiyi-st" id="yiyi-132"><code class="descclassname">math.</code><code class="descname">atan2</code><span class="sig-paren">(</span><em>y</em>, <em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-133">以弧度返回<code class="docutils literal"><span class="pre">atan（y</span> <span class="pre">/</span> <span class="pre">x）</span></code>。</span><span class="yiyi-st" id="yiyi-134">结果在<code class="docutils literal"><span class="pre">-pi</span></code>和<code class="docutils literal"><span class="pre">pi</span></code>之间。</span><span class="yiyi-st" id="yiyi-135">从原点到点<code class="docutils literal"><span class="pre">（x，</span> <span class="pre">y）</span></code>的平面中的矢量与正X轴形成该角度。</span><span class="yiyi-st" id="yiyi-136"><a class="reference internal" href="#math.atan2" title="math.atan2"><code class="xref py py-func docutils literal"><span class="pre">atan2()</span></code></a>的点是两个输入的符号都是已知的，因此它可以计算角度的正确象限。</span><span class="yiyi-st" id="yiyi-137">例如，<code class="docutils literal"><span class="pre">atan(1)</span></code>和<code class="docutils literal"><span class="pre">atan2（1，</span> <span class="pre">1）</span></code>都是<code class="docutils literal"><span class="pre">pi/4</span></code>，但<code class="docutils literal"><span class="pre">atan2（-1，</span> <span class="pre">-1）</span></code>为<code class="docutils literal"><span class="pre">-3*pi/4</span></code>。</span></p></dd></dl><dl class="function"><dt id="math.cos"><span class="yiyi-st" id="yiyi-138"><code class="descclassname">math.</code><code class="descname">cos</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-139">返回<em>x</em>弧度的余弦值。</span></p></dd></dl><dl class="function"><dt id="math.hypot"><span class="yiyi-st" id="yiyi-140"><code class="descclassname">math.</code><code class="descname">hypot</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-141">返回欧氏方程，<code class="docutils literal"><span class="pre">sqrt（x * x</span> <span class="pre">+</span> <span class="pre">y * y）</span></code>。</span><span class="yiyi-st" id="yiyi-142">这是从原点到点<code class="docutils literal"><span class="pre">（x，</span> <span class="pre">y）</span></code>的向量长度。</span></p></dd></dl><dl class="function"><dt id="math.sin"><span class="yiyi-st" id="yiyi-143"><code class="descclassname">math.</code><code class="descname">sin</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-144">返回<em>x</em>弧度的正弦值。</span></p></dd></dl><dl class="function"><dt id="math.tan"><span class="yiyi-st" id="yiyi-145"><code class="descclassname">math.</code><code class="descname">tan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-146">返回<em>x</em>弧度的正切值。</span></p></dd></dl></div><div class="section" id="angular-conversion"><h2><span class="yiyi-st" id="yiyi-147">9.2.4.</span><span class="yiyi-st" id="yiyi-148">角度转换</span></h2><dl class="function"><dt id="math.degrees"><span class="yiyi-st" id="yiyi-149"><code class="descclassname">math.</code><code class="descname">degrees</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-150">将角度<em>x</em>从弧度转换为度。</span></p></dd></dl><dl class="function"><dt id="math.radians"><span class="yiyi-st" id="yiyi-151"><code class="descclassname">math.</code><code class="descname">radians</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-152">将角度<em>x</em>从度转换为弧度。</span></p></dd></dl></div><div class="section" id="hyperbolic-functions"><h2><span class="yiyi-st" id="yiyi-153">9.2.5.</span><span class="yiyi-st" id="yiyi-154">双曲函数</span></h2><p><span class="yiyi-st" id="yiyi-155"><a class="reference external" href="https://en.wikipedia.org/wiki/Hyperbolic_function">双曲线函数</a>是基于双曲线而不是圆的三角函数的类似。</span></p><dl class="function"><dt id="math.acosh"><span class="yiyi-st" id="yiyi-156"><code class="descclassname">math.</code><code class="descname">acosh</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-157">返回<em>x</em>的反双曲余弦值。</span></p></dd></dl><dl class="function"><dt id="math.asinh"><span class="yiyi-st" id="yiyi-158"><code class="descclassname">math.</code><code class="descname">asinh</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-159">返回<em>x</em>的反双曲正弦值。</span></p></dd></dl><dl class="function"><dt id="math.atanh"><span class="yiyi-st" id="yiyi-160"><code class="descclassname">math.</code><code class="descname">atanh</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-161">返回<em>x</em>的反双曲正切值。</span></p></dd></dl><dl class="function"><dt id="math.cosh"><span class="yiyi-st" id="yiyi-162"><code class="descclassname">math.</code><code class="descname">cosh</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-163">返回<em>x</em>的双曲余弦值。</span></p></dd></dl><dl class="function"><dt id="math.sinh"><span class="yiyi-st" id="yiyi-164"><code class="descclassname">math.</code><code class="descname">sinh</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-165">返回<em>x</em>的双曲正弦值。</span></p></dd></dl><dl class="function"><dt id="math.tanh"><span class="yiyi-st" id="yiyi-166"><code class="descclassname">math.</code><code class="descname">tanh</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-167">返回<em>x</em>的双曲正切值。</span></p></dd></dl></div><div class="section" id="special-functions"><h2><span class="yiyi-st" id="yiyi-168">9.2.6.</span><span class="yiyi-st" id="yiyi-169">特殊的函数</span></h2><dl class="function"><dt id="math.erf"><span class="yiyi-st" id="yiyi-170"> <code class="descclassname">math.</code><code class="descname">erf</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-171">在<em>x</em>返回<a class="reference external" href="https://en.wikipedia.org/wiki/Error_function">错误函数</a>。</span></p><p><span class="yiyi-st" id="yiyi-172"><a class="reference internal" href="#math.erf" title="math.erf"><code class="xref py py-func docutils literal"><span class="pre">erf()</span></code></a>函数可用于计算传统的统计函数，例如<a class="reference external" href="https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function">累积标准正态分布</a>：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="s1">'Cumulative distribution function for the standard normal distribution'</span>
    <span class="k">return</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">erf</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)))</span> <span class="o">/</span> <span class="mf">2.0</span>
</pre></div></div><div class="versionadded"><p><span class="yiyi-st" id="yiyi-173"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="math.erfc"><span class="yiyi-st" id="yiyi-174"><code class="descclassname">math.</code><code class="descname">erfc</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-175">返回在<em>x</em>的余误差函数。</span><span class="yiyi-st" id="yiyi-176"><a class="reference external" href="https://en.wikipedia.org/wiki/Error_function">定义为<code class="docutils literal"><span class="pre">1.0</span> <span class="pre"> - </span> <span class="pre">erf（x）</span></code>。</a></span><span class="yiyi-st" id="yiyi-177">它用于<em>x</em>的大值，其中从一个减去将导致<a class="reference external" href="https://en.wikipedia.org/wiki/Loss_of_significance">重要性损失</a>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-178"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="math.gamma"><span class="yiyi-st" id="yiyi-179"> <code class="descclassname">math.</code><code class="descname">gamma</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-180">返回 <em>x</em> 的 <a class="reference external" href="https://en.wikipedia.org/wiki/Gamma_function">Gamma function</a> （伽马函数）。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-181"><span class="versionmodified"> 3.2版本新增。</span></span></p></div></dd></dl><dl class="function"><dt id="math.lgamma"><span class="yiyi-st" id="yiyi-182"><code class="descclassname">math.</code><code class="descname">lgamma</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-183">返回伽玛函数在<em>x</em>的绝对值的自然对数。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-184"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl></div><div class="section" id="constants"><h2><span class="yiyi-st" id="yiyi-185">9.2.7.</span><span class="yiyi-st" id="yiyi-186">常量</span></h2><dl class="data"><dt id="math.pi"><span class="yiyi-st" id="yiyi-187"><code class="descclassname">math.</code><code class="descname">pi</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-188">数学常量 π = 3.141592......，到现有的精度。</span></p></dd></dl><dl class="data"><dt id="math.e"><span class="yiyi-st" id="yiyi-189"><code class="descclassname">math.</code><code class="descname">e</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-190">数学常数 e = 2.718281......，到现有的精度。</span></p></dd></dl><dl class="data"><dt id="math.inf"><span class="yiyi-st" id="yiyi-191"><code class="descclassname">math.</code><code class="descname">inf</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-192">浮点正无穷大。</span><span class="yiyi-st" id="yiyi-193">（对于负无穷大，请使用<code class="docutils literal"><span class="pre">-math.inf</span></code>。）</span><span class="yiyi-st" id="yiyi-194">相当于<code class="docutils literal"><span class="pre">float('inf')</span></code>的输出。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-195"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="data"><dt id="math.nan"><span class="yiyi-st" id="yiyi-196"><code class="descclassname">math.</code><code class="descname">nan</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-197">浮点数“不是数字”（NaN）值。</span><span class="yiyi-st" id="yiyi-198">等效于<code class="docutils literal"><span class="pre">float('nan')</span></code>的输出。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-199"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><div class="impl-detail compound"><p class="compound-first"><span class="yiyi-st" id="yiyi-200"><strong>CPython实现详细信息：</strong> <a class="reference internal" href="#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal"><span class="pre">math</span></code></a>模块主要由围绕平台C math库函数的thin包装器组成。</span><span class="yiyi-st" id="yiyi-201">在特殊情况下的行为遵循附件 F 的 C99 标准在适当情况下。</span><span class="yiyi-st" id="yiyi-202">当前实现将针对<code class="docutils literal"><span class="pre">sqrt(-1.0)</span></code>或<code class="docutils literal"><span class="pre">log(0.0)</span></code>的无效操作引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>（其中C99附件F建议发送无效操作（例如，<code class="docutils literal"><span class="pre">exp(1000.0)</span></code>），或者对于溢出的结果<a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a></span><span class="yiyi-st" id="yiyi-203">除非一个或多个输入参数是NaN，否则NaN不会从上述任何函数返回；在这种情况下，大多数函数将返回NaN，但是（再次遵循C99附件F），该规则有一些例外，例如<code class="docutils literal"><span class="pre">pow（float（'nan'），</span> <span class="pre"> 0.0）</span></code>或<code class="docutils literal"><span class="pre">hypot（float（'nan'），</span> <span class="pre">float（'inf'））</span></code>。</span></p><p class="compound-last"><span class="yiyi-st" id="yiyi-204">请注意 Python 还可以不遗余力的区分从安静的 Nan，信号 Nan 信号 Nan 的行为仍未指定。</span><span class="yiyi-st" id="yiyi-205">典型行为是对待所有 Nan，好像他们是安静。</span></p></div><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-206">请参见</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-207">模块<a class="reference internal" href="cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal"><span class="pre">cmath</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-208">上述函数的复数版本。</span></dd></dl></div></div></div></div>