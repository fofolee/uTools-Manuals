<div class="body" role="main"><div class="section" id="module-array"><h1><span class="yiyi-st" id="yiyi-10">8.7. <a class="reference internal" href="#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal"><span class="pre">array</span></code></a> — 高效的数值数组</span></h1><p><span class="yiyi-st" id="yiyi-11">该模块定义了一个对象类型，可以紧凑地表示一个基本值的数组：字符，整数，浮点数。</span><span class="yiyi-st" id="yiyi-12">数组是序列类型，并且表现得非常像列表，除了存储在它们中的对象的类型是受约束的。</span><span class="yiyi-st" id="yiyi-13">类型在对象创建时使用<em class="dfn">类型代码</em>指定，该类型代码是单个字符。</span><span class="yiyi-st" id="yiyi-14">定义了以下类型代码：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-15">类型代码</span></th><th class="head"><span class="yiyi-st" id="yiyi-16">C类型</span></th><th class="head"><span class="yiyi-st" id="yiyi-17">Python类型</span></th><th class="head"><span class="yiyi-st" id="yiyi-18">最小大小（以字节为单位）</span></th><th class="head"><span class="yiyi-st" id="yiyi-19">笔记</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-20"><code class="docutils literal"><span class="pre">'b'</span></code></span></td><td><span class="yiyi-st" id="yiyi-21">signed char</span></td><td><span class="yiyi-st" id="yiyi-22">INT</span></td><td><span class="yiyi-st" id="yiyi-23">1</span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-24"><code class="docutils literal"><span class="pre">'B'</span></code></span></td><td><span class="yiyi-st" id="yiyi-25">unsigned char</span></td><td><span class="yiyi-st" id="yiyi-26">INT</span></td><td><span class="yiyi-st" id="yiyi-27">1</span></td><td></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-28"><code class="docutils literal"><span class="pre">'u'</span></code></span></td><td><span class="yiyi-st" id="yiyi-29">Py_UNICODE</span></td><td><span class="yiyi-st" id="yiyi-30">Unicode字符</span></td><td><span class="yiyi-st" id="yiyi-31">2</span></td><td><span class="yiyi-st" id="yiyi-32">（1）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-33"><code class="docutils literal"><span class="pre">'h'</span></code></span></td><td><span class="yiyi-st" id="yiyi-34">signed short</span></td><td><span class="yiyi-st" id="yiyi-35">INT</span></td><td><span class="yiyi-st" id="yiyi-36">2</span></td><td></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-37"><code class="docutils literal"><span class="pre">'H'</span></code></span></td><td><span class="yiyi-st" id="yiyi-38">unsigned short</span></td><td><span class="yiyi-st" id="yiyi-39">INT</span></td><td><span class="yiyi-st" id="yiyi-40">2</span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-41"><code class="docutils literal"><span class="pre">'i'</span></code></span></td><td><span class="yiyi-st" id="yiyi-42">签名int</span></td><td><span class="yiyi-st" id="yiyi-43">INT</span></td><td><span class="yiyi-st" id="yiyi-44">2</span></td><td></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-45"><code class="docutils literal"><span class="pre">'I'</span></code></span></td><td><span class="yiyi-st" id="yiyi-46">无符号整数</span></td><td><span class="yiyi-st" id="yiyi-47">INT</span></td><td><span class="yiyi-st" id="yiyi-48">2</span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-49"><code class="docutils literal"><span class="pre">'l'</span></code></span></td><td><span class="yiyi-st" id="yiyi-50">signed long</span></td><td><span class="yiyi-st" id="yiyi-51">INT</span></td><td><span class="yiyi-st" id="yiyi-52">4</span></td><td></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-53"><code class="docutils literal"><span class="pre">'L'</span></code></span></td><td><span class="yiyi-st" id="yiyi-54">无符号长整数</span></td><td><span class="yiyi-st" id="yiyi-55">INT</span></td><td><span class="yiyi-st" id="yiyi-56">4</span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-57"><code class="docutils literal"><span class="pre">'q'</span></code></span></td><td><span class="yiyi-st" id="yiyi-58">signed long long</span></td><td><span class="yiyi-st" id="yiyi-59">INT</span></td><td><span class="yiyi-st" id="yiyi-60">8</span></td><td><span class="yiyi-st" id="yiyi-61">（2）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-62"><code class="docutils literal"><span class="pre">'q'</span></code></span></td><td><span class="yiyi-st" id="yiyi-63">无符号long long</span></td><td><span class="yiyi-st" id="yiyi-64">INT</span></td><td><span class="yiyi-st" id="yiyi-65">8</span></td><td><span class="yiyi-st" id="yiyi-66">（2）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-67"><code class="docutils literal"><span class="pre">'f'</span></code></span></td><td><span class="yiyi-st" id="yiyi-68">float</span></td><td><span class="yiyi-st" id="yiyi-69">float</span></td><td><span class="yiyi-st" id="yiyi-70">4</span></td><td></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-71"><code class="docutils literal"><span class="pre">'d'</span></code></span></td><td><span class="yiyi-st" id="yiyi-72">double</span></td><td><span class="yiyi-st" id="yiyi-73">float</span></td><td><span class="yiyi-st" id="yiyi-74">8</span></td><td></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-75">笔记：</span></p><ol class="arabic"><li><p class="first"><span class="yiyi-st" id="yiyi-76"><code class="docutils literal"><span class="pre">'u'</span></code>类型代码对应于Python的过时unicode字符（<a class="reference internal" href="../c-api/unicode.html#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></code></a>，即<code class="xref c c-type docutils literal"><span class="pre">wchar_t</span></code>）。</span><span class="yiyi-st" id="yiyi-77">根据平台，它可以是16位或32位。</span></p><p><span class="yiyi-st" id="yiyi-78"><code class="docutils literal"><span class="pre">'u'</span></code>将与<a class="reference internal" href="../c-api/unicode.html#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></code></a> API的其余部分一起删除。</span></p><div class="deprecated-removed"><p><span class="yiyi-st" id="yiyi-79"><span class="versionmodified">从版本3.3开始弃用，将在4.0版中删除。</span></span></p></div></li><li><p class="first"><span class="yiyi-st" id="yiyi-80">The <code class="docutils literal"><span class="pre">'q'</span></code> and <code class="docutils literal"><span class="pre">'Q'</span></code> type codes are available only if the platform C compiler used to build Python supports C <code class="xref c c-type docutils literal"><span class="pre">long</span> <span class="pre">long</span></code>, or, on Windows, <code class="xref c c-type docutils literal"><span class="pre">__int64</span></code>.</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-81"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></li></ol><p><span class="yiyi-st" id="yiyi-82">值的实际表示由机器架构（严格地说，由C实现）确定。</span><span class="yiyi-st" id="yiyi-83">实际大小可以通过<code class="xref py py-attr docutils literal"><span class="pre">itemsize</span></code>属性访问。</span></p><p><span class="yiyi-st" id="yiyi-84">模块定义以下类型：</span></p><dl class="class"><dt id="array.array"><span class="yiyi-st" id="yiyi-85"><em class="property">class </em><code class="descclassname">array.</code><code class="descname">array</code><span class="sig-paren">(</span><em>typecode</em><span class="optional">[</span>, <em>initializer</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-86">项目受<em>类型代码</em>限制并从可选的<em>初始化器</em>值初始化的新数组，它必须是一个列表，<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> ，或者在适当类型的元素上迭代。</span></p><p><span class="yiyi-st" id="yiyi-87">如果给定一个列表或字符串，初始化器被传递到新数组的<a class="reference internal" href="#array.array.fromlist" title="array.array.fromlist"><code class="xref py py-meth docutils literal"><span class="pre">fromlist()</span></code></a>，<a class="reference internal" href="#array.array.frombytes" title="array.array.frombytes"><code class="xref py py-meth docutils literal"><span class="pre">frombytes()</span></code></a>或<a class="reference internal" href="#array.array.fromunicode" title="array.array.fromunicode"><code class="xref py py-meth docutils literal"><span class="pre">fromunicode()</span></code></a></span><span class="yiyi-st" id="yiyi-88">否则，可迭代初始化器传递到<a class="reference internal" href="#array.array.extend" title="array.array.extend"><code class="xref py py-meth docutils literal"><span class="pre">extend()</span></code></a>方法。</span></p></dd></dl><dl class="data"><dt id="array.typecodes"><span class="yiyi-st" id="yiyi-89"><code class="descclassname">array.</code><code class="descname">typecodes</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-90">包含所有可用类型代码的字符串。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-91">数组对象支持索引，切片，级联和乘法的常规顺序操作。</span><span class="yiyi-st" id="yiyi-92">当使用切片分配时，分配的值必须是具有相同类型代码的数组对象；在所有其他情况下，会引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span><span class="yiyi-st" id="yiyi-93">数组对象还实现缓冲区接口，并且可以在支持<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a>的任何位置使用。</span></p><p><span class="yiyi-st" id="yiyi-94">还支持以下数据项和方法：</span></p><dl class="attribute"><dt id="array.array.typecode"><span class="yiyi-st" id="yiyi-95"><code class="descclassname">array.</code><code class="descname">typecode</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-96">用于创建数组的类型代码字符。</span></p></dd></dl><dl class="attribute"><dt id="array.array.itemsize"><span class="yiyi-st" id="yiyi-97"><code class="descclassname">array.</code><code class="descname">itemsize</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-98">内部表示中一个数组项的字节长度。</span></p></dd></dl><dl class="method"><dt id="array.array.append"><span class="yiyi-st" id="yiyi-99"><code class="descclassname">array.</code><code class="descname">append</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-100">将值为<em>x</em>的新项目附加到数组的末尾。</span></p></dd></dl><dl class="method"><dt id="array.array.buffer_info"><span class="yiyi-st" id="yiyi-101"><code class="descclassname">array.</code><code class="descname">buffer_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-102">返回一个元组<code class="docutils literal"><span class="pre">（地址，</span> <span class="pre">长度）</span></code>给出当前存储器地址和用于保存数组内容的缓冲区元素的长度。</span><span class="yiyi-st" id="yiyi-103">以字节为单位的存储器缓冲区的大小可以计算为<code class="docutils literal"><span class="pre">array.buffer_info()[1]</span> <span class="pre">*</span> <span class="pre">array.itemsize</span> t0&gt;。</code></span><span class="yiyi-st" id="yiyi-104">当使用需要存储器地址的低级（和本质上不安全的）I / O接口时，这有时很有用，例如某些<code class="xref c c-func docutils literal"><span class="pre">ioctl()</span></code>操作。</span><span class="yiyi-st" id="yiyi-105">只要数组存在并且不对其应用长度改变操作，返回的数字是有效的。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-106">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-107">当使用以C或C ++编写的代码（有效利用此信息的唯一方法）使用数组对象时，使用数组对象支持的缓冲区接口更有意义。</span><span class="yiyi-st" id="yiyi-108">此方法是为了向后兼容性而保留的，应在新代码中避免。</span><span class="yiyi-st" id="yiyi-109">缓冲区接口记录在<a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span>Buffer Protocol</span></a>中。</span></p></div></dd></dl><dl class="method"><dt id="array.array.byteswap"><span class="yiyi-st" id="yiyi-110"><code class="descclassname">array.</code><code class="descname">byteswap</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-111">“Byteswap”数组的所有项。</span><span class="yiyi-st" id="yiyi-112">这仅适用于大小为1,2,4或8个字节的值；对于其他类型的值，会引发<a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a>。</span><span class="yiyi-st" id="yiyi-113">在从具有不同字节顺序的机器上写入的文件读取数据时非常有用。</span></p></dd></dl><dl class="method"><dt id="array.array.count"><span class="yiyi-st" id="yiyi-114"><code class="descclassname">array.</code><code class="descname">count</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-115">返回数组中 <em>x</em> 的次数。</span></p></dd></dl><dl class="method"><dt id="array.array.extend"><span class="yiyi-st" id="yiyi-116"><code class="descclassname">array.</code><code class="descname">extend</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-117">将<em>可迭代对象</em>的项目附加到数组的末尾。</span><span class="yiyi-st" id="yiyi-118">如果<em>iterable</em>是另一个数组，它必须具有<em>完全</em>相同的类型代码；否则，则会引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>异常。</span><span class="yiyi-st" id="yiyi-119">如果<em>iterable</em>不是一个数组，它必须是可迭代的，并且其元素必须是要附加到数组的正确类型。</span></p></dd></dl><dl class="method"><dt id="array.array.frombytes"><span class="yiyi-st" id="yiyi-120"><code class="descclassname">array.</code><code class="descname">frombytes</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-121">从字符串中追加项目，将字符串解释为机器值数组（就好像它是使用<a class="reference internal" href="#array.array.fromfile" title="array.array.fromfile"><code class="xref py py-meth docutils literal"><span class="pre">fromfile()</span></code></a>方法从文件中读取的）。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-122"><span class="versionmodified">版本3.2中的新功能：</span> <a class="reference internal" href="#array.array.fromstring" title="array.array.fromstring"><code class="xref py py-meth docutils literal"><span class="pre">fromstring()</span></code></a>重命名为<a class="reference internal" href="#array.array.frombytes" title="array.array.frombytes"><code class="xref py py-meth docutils literal"><span class="pre">frombytes()</span></code></a>。</span></p></div></dd></dl><dl class="method"><dt id="array.array.fromfile"><span class="yiyi-st" id="yiyi-123"><code class="descclassname">array.</code><code class="descname">fromfile</code><span class="sig-paren">(</span><em>f</em>, <em>n</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-124">从<a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> <em>f</em>读取<em>n</em>项目（作为机器值），并将它们附加到数组的末尾。</span><span class="yiyi-st" id="yiyi-125">如果少于<em>n</em>个项目可用，则会引发<a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal"><span class="pre">EOFError</span></code></a>，但可用的项目仍会插入数组。</span><span class="yiyi-st" id="yiyi-126"><em>f</em>必须是真正的内建文件对象；其他与<code class="xref py py-meth docutils literal"><span class="pre">read()</span></code>方法不会做。</span></p></dd></dl><dl class="method"><dt id="array.array.fromlist"><span class="yiyi-st" id="yiyi-127"><code class="descclassname">array.</code><code class="descname">fromlist</code><span class="sig-paren">(</span><em>list</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-128">从列表中追加项目。</span><span class="yiyi-st" id="yiyi-129">这等效于 t&gt;&gt; <span class="pre">列表中的<code class="docutils literal"><span class="pre">： t&gt; <span class="pre">x</span> <span class="pre">：</span></span></code></span> <span class="pre">a.append / t5&gt;，但是如果存在类型错误，则数组不更改。</span></span></p></dd></dl><dl class="method"><dt id="array.array.fromstring"><span class="yiyi-st" id="yiyi-130"><code class="descclassname">array.</code><code class="descname">fromstring</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-131"><a class="reference internal" href="#array.array.frombytes" title="array.array.frombytes"><code class="xref py py-meth docutils literal"><span class="pre">frombytes()</span></code></a>的已弃用别名。</span></p></dd></dl><dl class="method"><dt id="array.array.fromunicode"><span class="yiyi-st" id="yiyi-132"><code class="descclassname">array.</code><code class="descname">fromunicode</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-133">使用给定的unicode字符串中的数据扩展此数组。</span><span class="yiyi-st" id="yiyi-134">数组必须是类型<code class="docutils literal"><span class="pre">'u'</span></code>数组；否则会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span><span class="yiyi-st" id="yiyi-135">使用<code class="docutils literal"><span class="pre">array.frombytes(unicodestring.encode(enc))</span></code>将Unicode数据附加到某个其他类型的数组。</span></p></dd></dl><dl class="method"><dt id="array.array.index"><span class="yiyi-st" id="yiyi-136"><code class="descclassname">array.</code><code class="descname">index</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-137">返回最小的<em>i</em>，使得<em>i</em>是数组中第一次出现的<em>x</em>的索引。</span></p></dd></dl><dl class="method"><dt id="array.array.insert"><span class="yiyi-st" id="yiyi-138"><code class="descclassname">array.</code><code class="descname">insert</code><span class="sig-paren">(</span><em>i</em>, <em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-139">在位置<em>i</em>之前的数组中插入值为<em>x</em>的新项目。</span><span class="yiyi-st" id="yiyi-140">负值被视为相对于数组的结尾。</span></p></dd></dl><dl class="method"><dt id="array.array.pop"><span class="yiyi-st" id="yiyi-141"> <code class="descclassname">array.</code><code class="descname">pop</code><span class="sig-paren">(</span><span class="optional">[</span><em>i</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-142">从数组中删除索引为<em>i</em>的项并返回它。</span><span class="yiyi-st" id="yiyi-143">可选参数默认为<code class="docutils literal"><span class="pre">-1</span></code>，因此默认情况下，最后一个项目被删除并返回。</span></p></dd></dl><dl class="method"><dt id="array.array.remove"><span class="yiyi-st" id="yiyi-144"><code class="descclassname">array.</code><code class="descname">remove</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-145">从数组中删除第一次出现的<em>x</em>。</span></p></dd></dl><dl class="method"><dt id="array.array.reverse"><span class="yiyi-st" id="yiyi-146"><code class="descclassname">array.</code><code class="descname">reverse</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-147">反转数组中项目的顺序。</span></p></dd></dl><dl class="method"><dt id="array.array.tobytes"><span class="yiyi-st" id="yiyi-148"><code class="descclassname">array.</code><code class="descname">tobytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-149">将数组转换为机器值数组，并返回字节表示（与<a class="reference internal" href="#array.array.tofile" title="array.array.tofile"><code class="xref py py-meth docutils literal"><span class="pre">tofile()</span></code></a>方法写入文件的字节序列相同）。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-150"><span class="versionmodified">版本3.2中的新功能：</span> <a class="reference internal" href="#array.array.tostring" title="array.array.tostring"><code class="xref py py-meth docutils literal"><span class="pre">tostring()</span></code></a>被重命名为<a class="reference internal" href="#array.array.tobytes" title="array.array.tobytes"><code class="xref py py-meth docutils literal"><span class="pre">tobytes()</span></code></a>。</span></p></div></dd></dl><dl class="method"><dt id="array.array.tofile"><span class="yiyi-st" id="yiyi-151"><code class="descclassname">array.</code><code class="descname">tofile</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-152">将所有项目（作为机器值）写入<a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> <em>f</em>。</span></p></dd></dl><dl class="method"><dt id="array.array.tolist"><span class="yiyi-st" id="yiyi-153"><code class="descclassname">array.</code><code class="descname">tolist</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-154">将数组转换为具有相同项目的普通列表。</span></p></dd></dl><dl class="method"><dt id="array.array.tostring"><span class="yiyi-st" id="yiyi-155"><code class="descclassname">array.</code><code class="descname">tostring</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-156"><a class="reference internal" href="#array.array.tobytes" title="array.array.tobytes"><code class="xref py py-meth docutils literal"><span class="pre">tobytes()</span></code></a>的已弃用别名。</span></p></dd></dl><dl class="method"><dt id="array.array.tounicode"><span class="yiyi-st" id="yiyi-157"><code class="descclassname">array.</code><code class="descname">tounicode</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-158">将数组转换为unicode字符串。</span><span class="yiyi-st" id="yiyi-159">数组必须是类型<code class="docutils literal"><span class="pre">'u'</span></code>数组；否则会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span><span class="yiyi-st" id="yiyi-160">使用<code class="docutils literal"><span class="pre">array.tobytes().decode(enc)</span></code>从某个其他类型的数组获取unicode字符串。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-161">当数组对象被打印或转换为字符串时，它被表示为<code class="docutils literal"><span class="pre">array（typecode，</span> <span class="pre">initializer）</span></code>。</span><span class="yiyi-st" id="yiyi-162">如果数组为空，则省略<em>初始化器</em>，否则如果<em>类型代码</em>为<code class="docutils literal"><span class="pre">'u'</span></code>，则为字符串，否则为列表数字。</span><span class="yiyi-st" id="yiyi-163">只要<a class="reference internal" href="#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-func docutils literal"><span class="pre">array()</span></code></a>函数使用<code class="docutils literal"><span class="pre">from</span> <span class="pre">array</span> <span class="pre">import</span> <span class="pre">array</span></code>被导入，使用<a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a>，该字符串就保证能够被转换回一个相同类型和值的数组。</span><span class="yiyi-st" id="yiyi-164">例子：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">array</span><span class="p">(</span><span class="s1">'l'</span><span class="p">)</span>
<span class="n">array</span><span class="p">(</span><span class="s1">'u'</span><span class="p">,</span> <span class="s1">'hello </span><span class="se">\u2641</span><span class="s1">'</span><span class="p">)</span>
<span class="n">array</span><span class="p">(</span><span class="s1">'l'</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="n">array</span><span class="p">(</span><span class="s1">'d'</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">])</span>
</pre></div></div><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-165">也可以看看</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-166">模块<a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-167">异构二进制数据的封装和分拆。</span></dd><dt><span class="yiyi-st" id="yiyi-168">模块<a class="reference internal" href="xdrlib.html#module-xdrlib" title="xdrlib: Encoders and decoders for the External Data Representation (XDR)."><code class="xref py py-mod docutils literal"><span class="pre">xdrlib</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-169">一些远程过程调用系统中使用的外部数据表示（XDR）数据的封装和分拆。</span></dd><dt><span class="yiyi-st" id="yiyi-170"><a class="reference external" href="https://docs.scipy.org/doc/">数值Python文档</a></span></dt><dd><span class="yiyi-st" id="yiyi-171">Numeric Python扩展（NumPy）定义另一个数组类型；有关数值Python的更多信息，请参见<a class="reference external" href="http://www.numpy.org/">http://www.numpy.org/</a>。</span></dd></dl></div></div></div>