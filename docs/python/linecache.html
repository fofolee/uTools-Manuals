<div class="body" role="main"><div class="section" id="module-linecache"><h1><span class="yiyi-st" id="yiyi-10">11.9. <a class="reference internal" href="#module-linecache" title="linecache: This module provides random access to individual lines from text files."><code class="xref py py-mod docutils literal"><span class="pre">linecache</span></code></a>  - 随机存取文字行</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源代码：</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/linecache.py">Lib / linecache.py</a></span></p><p><span class="yiyi-st" id="yiyi-12"><a class="reference internal" href="#module-linecache" title="linecache: This module provides random access to individual lines from text files."><code class="xref py py-mod docutils literal"><span class="pre">linecache</span></code></a>模块允许从Python源文件获取任何行，同时尝试使用高速缓存在内部进行优化，这是从单个文件读取多行的常见情况。</span><span class="yiyi-st" id="yiyi-13">这由<a class="reference internal" href="traceback.html#module-traceback" title="traceback: Print or retrieve a stack traceback."><code class="xref py py-mod docutils literal"><span class="pre">traceback</span></code></a>模块使用，以检索包含在格式化回迹中的源行。</span></p><p><span class="yiyi-st" id="yiyi-14"><a class="reference internal" href="tokenize.html#tokenize.open" title="tokenize.open"><code class="xref py py-func docutils literal"><span class="pre">tokenize.open()</span></code></a>函数用于打开文件。</span><span class="yiyi-st" id="yiyi-15">此函数使用<a class="reference internal" href="tokenize.html#tokenize.detect_encoding" title="tokenize.detect_encoding"><code class="xref py py-func docutils literal"><span class="pre">tokenize.detect_encoding()</span></code></a>获取文件的编码；在没有编码令牌的情况下，文件编码默认为UTF-8。</span></p><p><span class="yiyi-st" id="yiyi-16"><a class="reference internal" href="#module-linecache" title="linecache: This module provides random access to individual lines from text files."><code class="xref py py-mod docutils literal"><span class="pre">linecache</span></code></a>模块定义了以下函数：</span></p><dl class="function"><dt id="linecache.getline"><span class="yiyi-st" id="yiyi-17"> <code class="descclassname">linecache.</code><code class="descname">getline</code><span class="sig-paren">(</span><em>filename</em>, <em>lineno</em>, <em>module_globals=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-18">从名为<em>filename</em>的文件中获取行<em>lineno</em>。</span><span class="yiyi-st" id="yiyi-19">这个函数永远不会引发异常 - 它会在错误时返回<code class="docutils literal"><span class="pre">''</span></code>（对于找到的行，将包含终止换行符）。</span></p><p id="index-0"><span class="yiyi-st" id="yiyi-20">If a file named <em>filename</em> is not found, the function will look for it in the module search path, <code class="docutils literal"><span class="pre">sys.path</span></code>, after first checking for a <span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> <code class="docutils literal"><span class="pre">__loader__</span></code> in <em>module_globals</em>, in case the module was imported from a zipfile or other non-filesystem import source.</span></p></dd></dl><dl class="function"><dt id="linecache.clearcache"><span class="yiyi-st" id="yiyi-21"> <code class="descclassname">linecache.</code><code class="descname">clearcache</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-22">清除缓存。</span><span class="yiyi-st" id="yiyi-23">如果您不再需要使用<a class="reference internal" href="#linecache.getline" title="linecache.getline"><code class="xref py py-func docutils literal"><span class="pre">getline()</span></code></a>读取的文件中的行，请使用此函数。</span></p></dd></dl><dl class="function"><dt id="linecache.checkcache"><span class="yiyi-st" id="yiyi-24"> <code class="descclassname">linecache.</code><code class="descname">checkcache</code><span class="sig-paren">(</span><em>filename=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-25">检查缓存的有效性。</span><span class="yiyi-st" id="yiyi-26">如果缓存中的文件可能在磁盘上更改，并且需要更新版本，请使用此函数。</span><span class="yiyi-st" id="yiyi-27">如果省略<em>filename</em>，它将检查缓存中的所有条目。</span></p></dd></dl><dl class="function"><dt id="linecache.lazycache"><span class="yiyi-st" id="yiyi-28"> <code class="descclassname">linecache.</code><code class="descname">lazycache</code><span class="sig-paren">(</span><em>filename</em>, <em>module_globals</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-29">捕获有关非基于文件的模块的足够详细信息，以允许稍后通过<a class="reference internal" href="#linecache.getline" title="linecache.getline"><code class="xref py py-func docutils literal"><span class="pre">getline()</span></code></a>获取其行，即使<em>module_globals</em>在后面的调用中为None。</span><span class="yiyi-st" id="yiyi-30">这避免了做I / O直到实际需要一行，而不必无限地携带模块全局变量。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-31"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-32">例：</span></p><div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">linecache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linecache</span><span class="o">.</span><span class="n">getline</span><span class="p">(</span><span class="n">linecache</span><span class="o">.</span><span class="n">__file__</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">'import sys\n'</span>
</pre></div></div></div></div>