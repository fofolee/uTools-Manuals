<html>
<body>

<h3>函数功能</h3>该函数将给定的虚拟键码和键盘状态翻译成相应的字符或字符串。<br>
<h3>函数原型</h3>int ToUnicode(UINT wVirtKey,UINT wScanCode，PBYTE lpKeyState，LPWSTR pwszBuff，int cchBuff，UINTwFlags)；<br>
<h3>参数</h3>
wVirtKey：定义将被翻译的虚拟键码。<br>
wScanCode：定义被翻译键的硬件扫描码。若该值的最高为被置为1，则该键处于Up状态。<br>
lpKeyState：指向一个包含当前键盘状态的256字节数组。数组中的每个成员（字节）包含了一个键的状态。若一字节的最高位被置为1，则该键处于down状态。<br>
PwszBuff：接受翻译所得Unicode宇符或字符串的缓冲区指针。<br>
cchBuff：定义pwszBuff参数指向的缓冲区中字符串的大小。<br>
wFlags：形成函数执行条件的一个标志域集。若一个菜单处于激活状态，则将第0位设置为1。第1位到第31位保留。<br>
<h3>返回值</h3>该函数返回一个如下的值：<br>
-1：指定的虚拟键码是死键（重音或双音字符）。即使已敲击了几个字符，且这几个字符已存储在键盘状态中时，也将忽略键盘布局，返回该值。如果可能的话，即使对于Unicode键盘布局，该函数也己给出了一个将死键字符写入pwszBuff参数定义的缓冲区的间隔形式。例如，函数写入字符SPACING ACUTE<br>
（0x00B4），而不是写入字符NON_SPACING ACUTE（0x0301）。<br>
0：对于当前键盘状态，所定义的键没有翻译。没有写人任何东西到pwszBuff参数定义的缓冲区。<br>
1：一个字符被写入pwszBuff参数定义的缓冲区<br>
2：两个或两个以上字符被写入pwszBuff参数定义的缓冲区。发生这种情况最常见的原因是由于存放在键盘布局中的一个死键无法由指定的虚拟键码组合成单键字符。<br>
备注：若键盘布局中原先存放了一个死键，则提供给ToUnicode函数的参数可能不足以翻译虚拟键码。典型地，ToUnicode函数只执行基于虚拟键码的翻译。然而，在某些情况下，wScanCode参数的第15位可能被用来区分一个键的按下状态和释放状态。<br>
<h3>速查</h3>Windows NT：3.1及以上版本；Windows：不支持；Windows CE：不支持；头文件：winuser.h；库文件： user32.lib。<br>

</body>
</html>
