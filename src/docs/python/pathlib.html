<div class="body" role="main"><div class="section" id="module-pathlib"><h1><span class="yiyi-st" id="yiyi-10">11.1. <a class="reference internal" href="#module-pathlib" title="pathlib: Object-oriented filesystem paths"><code class="xref py py-mod docutils literal"><span class="pre">pathlib</span></code></a> — 面向对象的文件系统路径</span></h1><div class="versionadded"><p><span class="yiyi-st" id="yiyi-11"><span class="versionmodified">3.4版本新增.</span></span></p></div><p><span class="yiyi-st" id="yiyi-12"><strong>源码:</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/pathlib.py">Lib/pathlib.py</a></span></p><p><span class="yiyi-st" id="yiyi-13">本模块提供适合于不同操作系统的类来对文件系统路径进行操作。</span><span class="yiyi-st" id="yiyi-14">路径类在<a class="reference internal" href="#pure-paths"><span>pure paths</span></a>和<a class="reference internal" href="#concrete-paths"><span>concrete paths</span></a>之间划分，它提供纯粹的计算操作，而不是I / O，它继承纯路径，但也提供I / O操作。</span></p><p><span class="yiyi-st" id="yiyi-15">如果您以前从未使用过此模块，或者只是不确定哪个类适合您的任务，则<a class="reference internal" href="#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal"><span class="pre">pathlib</span></code></a>很有可能是您需要的。</span><span class="yiyi-st" id="yiyi-16">它为代码运行的平台实例化一个<a class="reference internal" href="#concrete-paths"><span>concrete path</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-17">在某些特殊情况下，Pure paths非常有用，例如:</span></p><ol class="arabic simple"><li><span class="yiyi-st" id="yiyi-18">如果你想在Unix机器上操作Windows路径（反之亦然）。</span><span class="yiyi-st" id="yiyi-19">在Unix上运行时，不能实例化<a class="reference internal" href="#pathlib.WindowsPath" title="pathlib.WindowsPath"><code class="xref py py-class docutils literal"><span class="pre">WindowsPath</span></code></a>，但可以实例化<a class="reference internal" href="#pathlib.PureWindowsPath" title="pathlib.PureWindowsPath"><code class="xref py py-class docutils literal"><span class="pre">PureWindowsPath</span></code></a>。</span></li><li><span class="yiyi-st" id="yiyi-20">您希望确保您的代码只操作路径而不实际访问操作系统。</span><span class="yiyi-st" id="yiyi-21">在这种情况下，实例化纯类之一可能是有用的，因为那些简单地没有任何OS访问操作。</span></li></ol><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-22">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-23">该模块已被包含在<a class="reference internal" href="../glossary.html#term-provisional-package"><span class="xref std std-term">provisional basis</span></a>标准库中。</span><span class="yiyi-st" id="yiyi-24">如果核心开发者认为有必要，可能会发生向后不兼容的更改（直到并包括删除程序包）。</span></p></div><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-25">也可以看看</span></p><p class="last"><span class="yiyi-st" id="yiyi-26"><span class="target" id="index-1"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0428"><strong>PEP 428</strong></a>：pathlib模块 - 面向对象的文件系统路径。</span></p></div><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-27">也可以看看</span></p><p class="last"><span class="yiyi-st" id="yiyi-28">对于字符串的低级别路径处理，您还可以使用<a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a>模块。</span></p></div><div class="section" id="basic-use"><h2><span class="yiyi-st" id="yiyi-29">11.1.1.</span><span class="yiyi-st" id="yiyi-30">基本使用</span></h2><p><span class="yiyi-st" id="yiyi-31">导入主类：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="k">import</span> <span class="n">Path</span>
</code></pre><p><span class="yiyi-st" id="yiyi-32">列出子目录：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">'.'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">iterdir</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_dir</span><span class="p">()]</span>
<span class="go">[PosixPath('.hg'), PosixPath('docs'), PosixPath('dist'),</span>
<span class="go"> PosixPath('__pycache__'), PosixPath('build')]</span>
</code></pre><p><span class="yiyi-st" id="yiyi-33">在此目录树中列出Python源文件：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">'**/*.py'</span><span class="p">))</span>
<span class="go">[PosixPath('test_pathlib.py'), PosixPath('setup.py'),</span>
<span class="go"> PosixPath('pathlib.py'), PosixPath('docs/conf.py'),</span>
<span class="go"> PosixPath('build/lib/pathlib.py')]</span>
</code></pre><p><span class="yiyi-st" id="yiyi-34">在目录树中导航：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">'/etc'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="s1">'init.d'</span> <span class="o">/</span> <span class="s1">'reboot'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span>
<span class="go">PosixPath('/etc/init.d/reboot')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
<span class="go">PosixPath('/etc/rc.d/init.d/halt')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-35">查询路径属性：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">is_dir</span><span class="p">()</span>
<span class="go">False</span>
</code></pre><p><span class="yiyi-st" id="yiyi-36">打开文件：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">q</span><span class="o">.</span><span class="n">open</span><span class="p">()</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">'#!/bin/bash\n'</span>
</code></pre></div><div class="section" id="pure-paths"><h2><span class="yiyi-st" id="yiyi-37">11.1.2.</span><span class="yiyi-st" id="yiyi-38">纯路径</span></h2><p><span class="yiyi-st" id="yiyi-39">纯路径对象提供实际上不访问文件系统的路径处理操作。</span><span class="yiyi-st" id="yiyi-40">有三种方法来访问这些类，我们也称为<em>flavors</em>：</span></p><dl class="class"><dt id="pathlib.PurePath"><span class="yiyi-st" id="yiyi-41"><em class="property">class </em><code class="descclassname">pathlib.</code><code class="descname">PurePath</code><span class="sig-paren">(</span><em>*pathsegments</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-42">表示系统的路径风格（实例化它创建<a class="reference internal" href="#pathlib.PurePosixPath" title="pathlib.PurePosixPath"><code class="xref py py-class docutils literal"><span class="pre">PurePosixPath</span></code></a>或<a class="reference internal" href="#pathlib.PureWindowsPath" title="pathlib.PureWindowsPath"><code class="xref py py-class docutils literal"><span class="pre">PureWindowsPath</span></code></a>）的通用类：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PurePath</span><span class="p">(</span><span class="s1">'setup.py'</span><span class="p">)</span>      <span class="c1"># Running on a Unix machine</span>
<span class="go">PurePosixPath('setup.py')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-43"><em>pathsegments</em>的每个元素可以是表示路径段的字符串，也可以是其他路径对象：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PurePath</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="s1">'some/path'</span><span class="p">,</span> <span class="s1">'bar'</span><span class="p">)</span>
<span class="go">PurePosixPath('foo/some/path/bar')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PurePath</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">),</span> <span class="n">Path</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">))</span>
<span class="go">PurePosixPath('foo/bar')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-44">当<em>pathsegments</em>为空时，假定当前目录为：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PurePath</span><span class="p">()</span>
<span class="go">PurePosixPath('.')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-45">当给定几个绝对路径时，最后一个作为锚点（模仿<a class="reference internal" href="os.path.html#os.path.join" title="os.path.join"><code class="xref py py-func docutils literal"><span class="pre">os.path.join()</span></code></a>的行为）：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PurePath</span><span class="p">(</span><span class="s1">'/etc'</span><span class="p">,</span> <span class="s1">'/usr'</span><span class="p">,</span> <span class="s1">'lib64'</span><span class="p">)</span>
<span class="go">PurePosixPath('/usr/lib64')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'c:/Windows'</span><span class="p">,</span> <span class="s1">'d:bar'</span><span class="p">)</span>
<span class="go">PureWindowsPath('d:bar')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-46">但是，在Windows路径中，更改本地根目录不会舍弃以前的驱动器设置：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'c:/Windows'</span><span class="p">,</span> <span class="s1">'/Program Files'</span><span class="p">)</span>
<span class="go">PureWindowsPath('c:/Program Files')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-47">虚线斜线和单个点折叠，但双点（<code class="docutils literal"><span class="pre">'..'</span></code>）不是，因为这将改变符号链接面的路径的含义：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PurePath</span><span class="p">(</span><span class="s1">'foo//bar'</span><span class="p">)</span>
<span class="go">PurePosixPath('foo/bar')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PurePath</span><span class="p">(</span><span class="s1">'foo/./bar'</span><span class="p">)</span>
<span class="go">PurePosixPath('foo/bar')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PurePath</span><span class="p">(</span><span class="s1">'foo/../bar'</span><span class="p">)</span>
<span class="go">PurePosixPath('foo/../bar')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-48">（一个朴素的方法会使<code class="docutils literal"><span class="pre">PurePosixPath('foo/../bar')</span></code>等效于<code class="docutils literal"><span class="pre">PurePosixPath('bar')</span></code>，如果<code class="docutils literal"><span class="pre">foo</span></code></span></p></dd></dl><dl class="class"><dt id="pathlib.PurePosixPath"><span class="yiyi-st" id="yiyi-49"><em class="property">class </em><code class="descclassname">pathlib.</code><code class="descname">PurePosixPath</code><span class="sig-paren">(</span><em>*pathsegments</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-50"><a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code class="xref py py-class docutils literal"><span class="pre">PurePath</span></code></a>的子类，此路径flavor表示非Windows文件系统路径：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'/etc'</span><span class="p">)</span>
<span class="go">PurePosixPath('/etc')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-51"><em>pathsegments</em>与<a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code class="xref py py-class docutils literal"><span class="pre">PurePath</span></code></a>类似地指定。</span></p></dd></dl><dl class="class"><dt id="pathlib.PureWindowsPath"><span class="yiyi-st" id="yiyi-52"><em class="property">class </em><code class="descclassname">pathlib.</code><code class="descname">PureWindowsPath</code><span class="sig-paren">(</span><em>*pathsegments</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-53"><a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code class="xref py py-class docutils literal"><span class="pre">PurePath</span></code></a>的子类，此路径flavor表示Windows文件系统路径：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'c:/Program Files/'</span><span class="p">)</span>
<span class="go">PureWindowsPath('c:/Program Files')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-54"><em>pathsegments</em>与<a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code class="xref py py-class docutils literal"><span class="pre">PurePath</span></code></a>类似地指定。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-55">无论您正在运行的系统如何，都可以实例化所有这些类，因为它们不提供任何执行系统调用的操作。</span></p><div class="section" id="general-properties"><h3><span class="yiyi-st" id="yiyi-56">11.1.2.1.</span><span class="yiyi-st" id="yiyi-57">一般属性</span></h3><p><span class="yiyi-st" id="yiyi-58">路径是不可变的和哈希的。</span><span class="yiyi-st" id="yiyi-59">相同味道的路径是可比较和有序的。</span><span class="yiyi-st" id="yiyi-60">这些属性尊重风格的case-folding语义：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span> <span class="o">==</span> <span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'FOO'</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span> <span class="o">==</span> <span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'FOO'</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'FOO'</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span> <span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span> <span class="p">}</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'C:'</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'d:'</span><span class="p">)</span>
<span class="go">True</span>
</code></pre><p><span class="yiyi-st" id="yiyi-61">不同风味的路径比较不等，不能排序：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span> <span class="o">==</span> <span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">unorderable types: PureWindowsPath() &lt; PurePosixPath()</span>
</code></pre></div><div class="section" id="operators"><h3><span class="yiyi-st" id="yiyi-62">11.1.2.2.</span><span class="yiyi-st" id="yiyi-63">运算符</span></h3><p><span class="yiyi-st" id="yiyi-64">slash操作符号有助于创建子路径，类似于<a class="reference internal" href="os.path.html#os.path.join" title="os.path.join"><code class="xref py py-func docutils literal"><span class="pre">os.path.join()</span></code></a>：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PurePath</span><span class="p">(</span><span class="s1">'/etc'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">PurePosixPath('/etc')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">/</span> <span class="s1">'init.d'</span> <span class="o">/</span> <span class="s1">'apache2'</span>
<span class="go">PurePosixPath('/etc/init.d/apache2')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">PurePath</span><span class="p">(</span><span class="s1">'bin'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'/usr'</span> <span class="o">/</span> <span class="n">q</span>
<span class="go">PurePosixPath('/usr/bin')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-65">路径的字符串表示是原始文件系统路径本身（以原生形式，例如，</span><span class="yiyi-st" id="yiyi-66">在Windows下使用反斜杠），您可以将其传递给将文件路径用作字符串的任何函数：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PurePath</span><span class="p">(</span><span class="s1">'/etc'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">'/etc'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'c:/Program Files'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">'c:\\Program Files'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-67">类似地，在路径上调用<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>会将原始文件系统路径作为字节对象，由<a class="reference internal" href="os.html#os.fsencode" title="os.fsencode"><code class="xref py py-func docutils literal"><span class="pre">os.fsencode()</span></code></a>编码：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">b'/etc'</span>
</code></pre><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-68">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-69">仅在Unix下推荐调用<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>。</span><span class="yiyi-st" id="yiyi-70">在Windows下，unicode形式是文件系统路径的规范表示。</span></p></div></div><div class="section" id="accessing-individual-parts"><h3><span class="yiyi-st" id="yiyi-71">11.1.2.3.</span><span class="yiyi-st" id="yiyi-72">访问各个部分</span></h3><p><span class="yiyi-st" id="yiyi-73">要访问路径的各个“parts”（组件），请使用以下属性：</span></p><dl class="data"><dt id="pathlib.PurePath.parts"><span class="yiyi-st" id="yiyi-74"><code class="descclassname">PurePath.</code><code class="descname">parts</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-75">可以访问路径各个组件的元组：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PurePath</span><span class="p">(</span><span class="s1">'/usr/bin/python3'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">parts</span>
<span class="go">('/', 'usr', 'bin', 'python3')</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'c:/Program Files/PSF'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">parts</span>
<span class="go">('c:\\', 'Program Files', 'PSF')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-76">（请注意驱动器和本地根在单个部分中如何重新分组）</span></p></dd></dl></div><div class="section" id="methods-and-properties"><h3><span class="yiyi-st" id="yiyi-77">11.1.2.4.</span><span class="yiyi-st" id="yiyi-78">方法和属性</span></h3><p><span class="yiyi-st" id="yiyi-79">纯路径提供以下方法和属性：</span></p><dl class="data"><dt id="pathlib.PurePath.drive"><span class="yiyi-st" id="yiyi-80"><code class="descclassname">PurePath.</code><code class="descname">drive</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-81">表示驱动器盘符或名称的字符串（如果有）：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'c:/Program Files/'</span><span class="p">)</span><span class="o">.</span><span class="n">drive</span>
<span class="go">'c:'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'/Program Files/'</span><span class="p">)</span><span class="o">.</span><span class="n">drive</span>
<span class="go">''</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'/etc'</span><span class="p">)</span><span class="o">.</span><span class="n">drive</span>
<span class="go">''</span>
</code></pre><p><span class="yiyi-st" id="yiyi-82">UNC股份也被视为驱动器：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'//host/share/foo.txt'</span><span class="p">)</span><span class="o">.</span><span class="n">drive</span>
<span class="go">'\\\\host\\share'</span>
</code></pre></dd></dl><dl class="data"><dt id="pathlib.PurePath.root"><span class="yiyi-st" id="yiyi-83"><code class="descclassname">PurePath.</code><code class="descname">root</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-84">表示（本地或全局）根（如果有）的字符串：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'c:/Program Files/'</span><span class="p">)</span><span class="o">.</span><span class="n">root</span>
<span class="go">'\\'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'c:Program Files/'</span><span class="p">)</span><span class="o">.</span><span class="n">root</span>
<span class="go">''</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'/etc'</span><span class="p">)</span><span class="o">.</span><span class="n">root</span>
<span class="go">'/'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-85">UNC共享总是有根：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'//host/share'</span><span class="p">)</span><span class="o">.</span><span class="n">root</span>
<span class="go">'\\'</span>
</code></pre></dd></dl><dl class="data"><dt id="pathlib.PurePath.anchor"><span class="yiyi-st" id="yiyi-86"><code class="descclassname">PurePath.</code><code class="descname">anchor</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-87">驱动器和根目录的连接：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'c:/Program Files/'</span><span class="p">)</span><span class="o">.</span><span class="n">anchor</span>
<span class="go">'c:\\'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'c:Program Files/'</span><span class="p">)</span><span class="o">.</span><span class="n">anchor</span>
<span class="go">'c:'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'/etc'</span><span class="p">)</span><span class="o">.</span><span class="n">anchor</span>
<span class="go">'/'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'//host/share'</span><span class="p">)</span><span class="o">.</span><span class="n">anchor</span>
<span class="go">'\\\\host\\share\\'</span>
</code></pre></dd></dl><dl class="data"><dt id="pathlib.PurePath.parents"><span class="yiyi-st" id="yiyi-88"><code class="descclassname">PurePath.</code><code class="descname">parents</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-89">提供对路径的逻辑祖先的访问的不可变序列：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'c:/foo/bar/setup.py'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">PureWindowsPath('c:/foo/bar')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">PureWindowsPath('c:/foo')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">PureWindowsPath('c:/')</span>
</code></pre></dd></dl><dl class="data"><dt id="pathlib.PurePath.parent"><span class="yiyi-st" id="yiyi-90"><code class="descclassname">PurePath.</code><code class="descname">parent</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-91">路径的逻辑父代：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'/a/b/c/d'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">parent</span>
<span class="go">PurePosixPath('/a/b/c')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-92">您不能通过锚点或空路径：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">parent</span>
<span class="go">PurePosixPath('/')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'.'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">parent</span>
<span class="go">PurePosixPath('.')</span>
</code></pre><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-93">注意</span></p><p><span class="yiyi-st" id="yiyi-94">这是一个纯粹的词汇操作，因此有以下行为：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'foo/..'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">parent</span>
<span class="go">PurePosixPath('foo')</span>
</code></pre><p class="last"><span class="yiyi-st" id="yiyi-95">如果你想向上走一个任意的文件系统路径，建议先调用<a class="reference internal" href="#pathlib.Path.resolve" title="pathlib.Path.resolve"><code class="xref py py-meth docutils literal"><span class="pre">Path.resolve()</span></code></a>，以便解决符号链接并消除<cite>“..”</cite>组件。</span></p></div></dd></dl><dl class="data"><dt id="pathlib.PurePath.name"><span class="yiyi-st" id="yiyi-96"><code class="descclassname">PurePath.</code><code class="descname">name</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-97">表示最终路径组件的字符串，不包括驱动器和根目录（如果有）：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'my/library/setup.py'</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
<span class="go">'setup.py'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-98"></span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'//some/share/setup.py'</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
<span class="go">'setup.py'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'//some/share'</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
<span class="go">''</span>
</code></pre></dd></dl><dl class="data"><dt id="pathlib.PurePath.suffix"><span class="yiyi-st" id="yiyi-99"><code class="descclassname">PurePath.</code><code class="descname">suffix</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-100">最终组件的文件扩展名（如果有）：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'my/library/setup.py'</span><span class="p">)</span><span class="o">.</span><span class="n">suffix</span>
<span class="go">'.py'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'my/library.tar.gz'</span><span class="p">)</span><span class="o">.</span><span class="n">suffix</span>
<span class="go">'.gz'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'my/library'</span><span class="p">)</span><span class="o">.</span><span class="n">suffix</span>
<span class="go">''</span>
</code></pre></dd></dl><dl class="data"><dt id="pathlib.PurePath.suffixes"><span class="yiyi-st" id="yiyi-101"><code class="descclassname">PurePath.</code><code class="descname">suffixes</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-102">路径的文件扩展名列表：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'my/library.tar.gar'</span><span class="p">)</span><span class="o">.</span><span class="n">suffixes</span>
<span class="go">['.tar', '.gar']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'my/library.tar.gz'</span><span class="p">)</span><span class="o">.</span><span class="n">suffixes</span>
<span class="go">['.tar', '.gz']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'my/library'</span><span class="p">)</span><span class="o">.</span><span class="n">suffixes</span>
<span class="go">[]</span>
</code></pre></dd></dl><dl class="data"><dt id="pathlib.PurePath.stem"><span class="yiyi-st" id="yiyi-103"><code class="descclassname">PurePath.</code><code class="descname">stem</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-104">最终路径组件，不带其后缀：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'my/library.tar.gz'</span><span class="p">)</span><span class="o">.</span><span class="n">stem</span>
<span class="go">'library.tar'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'my/library.tar'</span><span class="p">)</span><span class="o">.</span><span class="n">stem</span>
<span class="go">'library'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'my/library'</span><span class="p">)</span><span class="o">.</span><span class="n">stem</span>
<span class="go">'library'</span>
</code></pre></dd></dl><dl class="method"><dt id="pathlib.PurePath.as_posix"><span class="yiyi-st" id="yiyi-105"><code class="descclassname">PurePath.</code><code class="descname">as_posix</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-106">以正斜线（<code class="docutils literal"><span class="pre">/</span></code>）返回路径的字符串表示形式：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'c:</span><span class="se">\\</span><span class="s1">windows'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">'c:\\windows'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">as_posix</span><span class="p">()</span>
<span class="go">'c:/windows'</span>
</code></pre></dd></dl><dl class="method"><dt id="pathlib.PurePath.as_uri"><span class="yiyi-st" id="yiyi-107"><code class="descclassname">PurePath.</code><code class="descname">as_uri</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-108">将路径表示为<code class="docutils literal"><span class="pre">file</span></code> URI。</span><span class="yiyi-st" id="yiyi-109">如果路径不是绝对的，则会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'/etc/passwd'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">as_uri</span><span class="p">()</span>
<span class="go">'file:///etc/passwd'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'c:/Windows'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">as_uri</span><span class="p">()</span>
<span class="go">'file:///c:/Windows'</span>
</code></pre></dd></dl><dl class="method"><dt id="pathlib.PurePath.is_absolute"><span class="yiyi-st" id="yiyi-110"><code class="descclassname">PurePath.</code><code class="descname">is_absolute</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-111">返回路径是否为绝对路径。</span><span class="yiyi-st" id="yiyi-112">如果路径同时具有根和（如果flavor允许）驱动器，则路径被视为绝对路径：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'/a/b'</span><span class="p">)</span><span class="o">.</span><span class="n">is_absolute</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'a/b'</span><span class="p">)</span><span class="o">.</span><span class="n">is_absolute</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'c:/a/b'</span><span class="p">)</span><span class="o">.</span><span class="n">is_absolute</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'/a/b'</span><span class="p">)</span><span class="o">.</span><span class="n">is_absolute</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'c:'</span><span class="p">)</span><span class="o">.</span><span class="n">is_absolute</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'//some/share'</span><span class="p">)</span><span class="o">.</span><span class="n">is_absolute</span><span class="p">()</span>
<span class="go">True</span>
</code></pre></dd></dl><dl class="method"><dt id="pathlib.PurePath.is_reserved"><span class="yiyi-st" id="yiyi-113"><code class="descclassname">PurePath.</code><code class="descname">is_reserved</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-114">如果<a class="reference internal" href="#pathlib.PureWindowsPath" title="pathlib.PureWindowsPath"><code class="xref py py-class docutils literal"><span class="pre">PureWindowsPath</span></code></a>，则返回<code class="docutils literal"><span class="pre">True</span></code>如果路径在Windows下被视为保留，则<code class="docutils literal"><span class="pre">False</span></code></span><span class="yiyi-st" id="yiyi-115">使用<a class="reference internal" href="#pathlib.PurePosixPath" title="pathlib.PurePosixPath"><code class="xref py py-class docutils literal"><span class="pre">PurePosixPath</span></code></a>，始终返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'nul'</span><span class="p">)</span><span class="o">.</span><span class="n">is_reserved</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'nul'</span><span class="p">)</span><span class="o">.</span><span class="n">is_reserved</span><span class="p">()</span>
<span class="go">False</span>
</code></pre><p><span class="yiyi-st" id="yiyi-116">保留路径上的文件系统调用可能会神秘失败或产生意外的影响。</span></p></dd></dl><dl class="method"><dt id="pathlib.PurePath.joinpath"><span class="yiyi-st" id="yiyi-117"><code class="descclassname">PurePath.</code><code class="descname">joinpath</code><span class="sig-paren">(</span><em>*other</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-118">调用此方法等效于依次将路径与每个<em>其他</em>参数组合：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'/etc'</span><span class="p">)</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s1">'passwd'</span><span class="p">)</span>
<span class="go">PurePosixPath('/etc/passwd')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'/etc'</span><span class="p">)</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'passwd'</span><span class="p">))</span>
<span class="go">PurePosixPath('/etc/passwd')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'/etc'</span><span class="p">)</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s1">'init.d'</span><span class="p">,</span> <span class="s1">'apache2'</span><span class="p">)</span>
<span class="go">PurePosixPath('/etc/init.d/apache2')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'c:'</span><span class="p">)</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s1">'/Program Files'</span><span class="p">)</span>
<span class="go">PureWindowsPath('c:/Program Files')</span>
</code></pre></dd></dl><dl class="method"><dt id="pathlib.PurePath.match"><span class="yiyi-st" id="yiyi-119"><code class="descclassname">PurePath.</code><code class="descname">match</code><span class="sig-paren">(</span><em>pattern</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-120">将此路径与提供的glob样式模式匹配。</span><span class="yiyi-st" id="yiyi-121">如果匹配成功，返回<code class="docutils literal"><span class="pre">True</span></code>，否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-122">如果<em>模式</em>是相对的，则路径可以是相对的或绝对的，并且从右侧进行匹配：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PurePath</span><span class="p">(</span><span class="s1">'a/b.py'</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">'*.py'</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PurePath</span><span class="p">(</span><span class="s1">'/a/b/c.py'</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">'b/*.py'</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PurePath</span><span class="p">(</span><span class="s1">'/a/b/c.py'</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">'a/*.py'</span><span class="p">)</span>
<span class="go">False</span>
</code></pre><p><span class="yiyi-st" id="yiyi-123">如果<em>模式</em>是绝对路径，则路径必须是绝对路径，并且整个路径必须匹配：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PurePath</span><span class="p">(</span><span class="s1">'/a.py'</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">'/*.py'</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PurePath</span><span class="p">(</span><span class="s1">'a/b.py'</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">'/*.py'</span><span class="p">)</span>
<span class="go">False</span>
</code></pre><p><span class="yiyi-st" id="yiyi-124">与其他方法一样，观察到区分大小写：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'b.py'</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">'*.PY'</span><span class="p">)</span>
<span class="go">True</span>
</code></pre></dd></dl><dl class="method"><dt id="pathlib.PurePath.relative_to"><span class="yiyi-st" id="yiyi-125"><code class="descclassname">PurePath.</code><code class="descname">relative_to</code><span class="sig-paren">(</span><em>*other</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-126">计算此路径相对于由<em>其他</em>表示的路径的版本。</span><span class="yiyi-st" id="yiyi-127">如果不可能，ValueError会引发：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PurePosixPath</span><span class="p">(</span><span class="s1">'/etc/passwd'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">relative_to</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span>
<span class="go">PurePosixPath('etc/passwd')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">relative_to</span><span class="p">(</span><span class="s1">'/etc'</span><span class="p">)</span>
<span class="go">PurePosixPath('passwd')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">relative_to</span><span class="p">(</span><span class="s1">'/usr'</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">"pathlib.py"</span>, line <span class="m">694</span>, in <span class="n">relative_to</span>
    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">formatted</span><span class="p">)))</span>
<span class="gr">ValueError</span>: <span class="n">'/etc/passwd' does not start with '/usr'</span>
</code></pre></dd></dl><dl class="method"><dt id="pathlib.PurePath.with_name"><span class="yiyi-st" id="yiyi-128"><code class="descclassname">PurePath.</code><code class="descname">with_name</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-129">返回<a class="reference internal" href="#pathlib.PurePath.name" title="pathlib.PurePath.name"><code class="xref py py-attr docutils literal"><span class="pre">name</span></code></a>更改的新路径。</span><span class="yiyi-st" id="yiyi-130">如果原始路径没有名称，则会引发ValueError：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'c:/Downloads/pathlib.tar.gz'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">with_name</span><span class="p">(</span><span class="s1">'setup.py'</span><span class="p">)</span>
<span class="go">PureWindowsPath('c:/Downloads/setup.py')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'c:/'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">with_name</span><span class="p">(</span><span class="s1">'setup.py'</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">"/home/antoine/cpython/default/Lib/pathlib.py"</span>, line <span class="m">751</span>, in <span class="n">with_name</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"</span><span class="si">%r</span><span class="s2"> has an empty name"</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,))</span>
<span class="gr">ValueError</span>: <span class="n">PureWindowsPath('c:/') has an empty name</span>
</code></pre></dd></dl><dl class="method"><dt id="pathlib.PurePath.with_suffix"><span class="yiyi-st" id="yiyi-131"><code class="descclassname">PurePath.</code><code class="descname">with_suffix</code><span class="sig-paren">(</span><em>suffix</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-132">返回<a class="reference internal" href="#pathlib.PurePath.suffix" title="pathlib.PurePath.suffix"><code class="xref py py-attr docutils literal"><span class="pre">suffix</span></code></a>更改的新路径。</span><span class="yiyi-st" id="yiyi-133">如果原始路径没有后缀，则会附加新的<em>后缀</em>：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'c:/Downloads/pathlib.tar.gz'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s1">'.bz2'</span><span class="p">)</span>
<span class="go">PureWindowsPath('c:/Downloads/pathlib.tar.bz2')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PureWindowsPath</span><span class="p">(</span><span class="s1">'README'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s1">'.txt'</span><span class="p">)</span>
<span class="go">PureWindowsPath('README.txt')</span>
</code></pre></dd></dl></div></div><div class="section" id="concrete-paths"><h2><span class="yiyi-st" id="yiyi-134">11.1.3.</span><span class="yiyi-st" id="yiyi-135">具体路径</span></h2><p><span class="yiyi-st" id="yiyi-136">具体路径是纯路径类的子类。</span><span class="yiyi-st" id="yiyi-137">除了后者提供的操作之外，它们还提供了对路径对象进行系统调用的方法。</span><span class="yiyi-st" id="yiyi-138">有三种方法来实例化具体路径：</span></p><dl class="class"><dt id="pathlib.Path"><span class="yiyi-st" id="yiyi-139"><em class="property">class </em><code class="descclassname">pathlib.</code><code class="descname">Path</code><span class="sig-paren">(</span><em>*pathsegments</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-140"><a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code class="xref py py-class docutils literal"><span class="pre">PurePath</span></code></a>的子类，此类表示系统的路径flavor的具体路径（实例化它创建<a class="reference internal" href="#pathlib.PosixPath" title="pathlib.PosixPath"><code class="xref py py-class docutils literal"><span class="pre">PosixPath</span></code></a>或<a class="reference internal" href="#pathlib.WindowsPath" title="pathlib.WindowsPath"><code class="xref py py-class docutils literal"><span class="pre">WindowsPath</span></code></a>）：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Path</span><span class="p">(</span><span class="s1">'setup.py'</span><span class="p">)</span>
<span class="go">PosixPath('setup.py')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-141"><em>pathsegments</em>与<a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code class="xref py py-class docutils literal"><span class="pre">PurePath</span></code></a>类似地指定。</span></p></dd></dl><dl class="class"><dt id="pathlib.PosixPath"><span class="yiyi-st" id="yiyi-142"><em class="property">class </em><code class="descclassname">pathlib.</code><code class="descname">PosixPath</code><span class="sig-paren">(</span><em>*pathsegments</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-143"><a class="reference internal" href="#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal"><span class="pre">Path</span></code></a>和<a class="reference internal" href="#pathlib.PurePosixPath" title="pathlib.PurePosixPath"><code class="xref py py-class docutils literal"><span class="pre">PurePosixPath</span></code></a>的子类，此类表示具体的非Windows文件系统路径：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PosixPath</span><span class="p">(</span><span class="s1">'/etc'</span><span class="p">)</span>
<span class="go">PosixPath('/etc')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-144"><em>pathsegments</em>与<a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code class="xref py py-class docutils literal"><span class="pre">PurePath</span></code></a>类似地指定。</span></p></dd></dl><dl class="class"><dt id="pathlib.WindowsPath"><span class="yiyi-st" id="yiyi-145"><em class="property">class </em><code class="descclassname">pathlib.</code><code class="descname">WindowsPath</code><span class="sig-paren">(</span><em>*pathsegments</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-146"><a class="reference internal" href="#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal"><span class="pre">Path</span></code></a>和<a class="reference internal" href="#pathlib.PureWindowsPath" title="pathlib.PureWindowsPath"><code class="xref py py-class docutils literal"><span class="pre">PureWindowsPath</span></code></a>的子类，此类表示具体的Windows文件系统路径：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">WindowsPath</span><span class="p">(</span><span class="s1">'c:/Program Files/'</span><span class="p">)</span>
<span class="go">WindowsPath('c:/Program Files')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-147"><em>pathsegments</em>与<a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code class="xref py py-class docutils literal"><span class="pre">PurePath</span></code></a>类似地指定。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-148">您只能实例化对应于您的系统的类风格（允许对不兼容的路径风格的系统调用可能导致应用程序中的错误或失败）：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">name</span>
<span class="go">'posix'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Path</span><span class="p">(</span><span class="s1">'setup.py'</span><span class="p">)</span>
<span class="go">PosixPath('setup.py')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PosixPath</span><span class="p">(</span><span class="s1">'setup.py'</span><span class="p">)</span>
<span class="go">PosixPath('setup.py')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">WindowsPath</span><span class="p">(</span><span class="s1">'setup.py'</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">"pathlib.py"</span>, line <span class="m">798</span>, in <span class="n">__new__</span>
    <span class="o">%</span> <span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">__name__</span><span class="p">,))</span>
<span class="gr">NotImplementedError</span>: <span class="n">cannot instantiate 'WindowsPath' on your system</span>
</code></pre><div class="section" id="methods"><h3><span class="yiyi-st" id="yiyi-149">11.1.3.1.</span><span class="yiyi-st" id="yiyi-150">方法</span></h3><p><span class="yiyi-st" id="yiyi-151">除了纯路径方法之外，具体路径还提供以下方法。</span><span class="yiyi-st" id="yiyi-152">如果系统调用失败（例如因为路径不存在），这些方法中的许多可以引发<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>：</span></p><dl class="classmethod"><dt id="pathlib.Path.cwd"><span class="yiyi-st" id="yiyi-153"><em class="property">classmethod </em><code class="descclassname">Path.</code><code class="descname">cwd</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-154">返回表示当前目录的新路径对象（由<a class="reference internal" href="os.html#os.getcwd" title="os.getcwd"><code class="xref py py-func docutils literal"><span class="pre">os.getcwd()</span></code></a>返回）：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Path</span><span class="o">.</span><span class="n">cwd</span><span class="p">()</span>
<span class="go">PosixPath('/home/antoine/pathlib')</span>
</code></pre></dd></dl><dl class="classmethod"><dt id="pathlib.Path.home"><span class="yiyi-st" id="yiyi-155"><em class="property">classmethod </em><code class="descclassname">Path.</code><code class="descname">home</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-156">返回表示用户主目录（由<a class="reference internal" href="os.path.html#os.path.expanduser" title="os.path.expanduser"><code class="xref py py-func docutils literal"><span class="pre">os.path.expanduser()</span></code></a>返回的<code class="docutils literal"><span class="pre">~</span></code>构造）的新路径对象：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Path</span><span class="o">.</span><span class="n">home</span><span class="p">()</span>
<span class="go">PosixPath('/home/antoine')</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-157"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="pathlib.Path.stat"><span class="yiyi-st" id="yiyi-158"><code class="descclassname">Path.</code><code class="descname">stat</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-159">返回有关此路径的信息（类似于<a class="reference internal" href="os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a>）。</span><span class="yiyi-st" id="yiyi-160">在每次调用此方法时查找结果。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">'setup.py'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">stat</span><span class="p">()</span><span class="o">.</span><span class="n">st_size</span>
<span class="go">956</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">stat</span><span class="p">()</span><span class="o">.</span><span class="n">st_mtime</span>
<span class="go">1327883547.852554</span>
</code></pre></dd></dl><dl class="method"><dt id="pathlib.Path.chmod"><span class="yiyi-st" id="yiyi-161"><code class="descclassname">Path.</code><code class="descname">chmod</code><span class="sig-paren">(</span><em>mode</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-162">更改文件模式和权限，如<a class="reference internal" href="os.html#os.chmod" title="os.chmod"><code class="xref py py-func docutils literal"><span class="pre">os.chmod()</span></code></a>：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">'setup.py'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">stat</span><span class="p">()</span><span class="o">.</span><span class="n">st_mode</span>
<span class="go">33277</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="mo">0o444</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">stat</span><span class="p">()</span><span class="o">.</span><span class="n">st_mode</span>
<span class="go">33060</span>
</code></pre></dd></dl><dl class="method"><dt id="pathlib.Path.exists"><span class="yiyi-st" id="yiyi-163"><code class="descclassname">Path.</code><code class="descname">exists</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-164">路径是否指向现有文件或目录：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Path</span><span class="p">(</span><span class="s1">'.'</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Path</span><span class="p">(</span><span class="s1">'setup.py'</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Path</span><span class="p">(</span><span class="s1">'/etc'</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Path</span><span class="p">(</span><span class="s1">'nonexistentfile'</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
<span class="go">False</span>
</code></pre><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-165">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-166">如果路径指向符号链接，<a class="reference internal" href="#pathlib.Path.exists" title="pathlib.Path.exists"><code class="xref py py-meth docutils literal"><span class="pre">exists()</span></code></a>返回符号链接<em>是否指向</em>现有文件或目录。</span></p></div></dd></dl><dl class="method"><dt id="pathlib.Path.expanduser"><span class="yiyi-st" id="yiyi-167"><code class="descclassname">Path.</code><code class="descname">expanduser</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-168">返回由<a class="reference internal" href="os.path.html#os.path.expanduser" title="os.path.expanduser"><code class="xref py py-meth docutils literal"><span class="pre">os.path.expanduser()</span></code></a>返回的扩展<code class="docutils literal"><span class="pre">~</span></code>和<code class="docutils literal"><span class="pre">~user</span></code>构造的新路径：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PosixPath</span><span class="p">(</span><span class="s1">'~/films/Monty Python'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">expanduser</span><span class="p">()</span>
<span class="go">PosixPath('/home/eric/films/Monty Python')</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-169"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="pathlib.Path.glob"><span class="yiyi-st" id="yiyi-170"><code class="descclassname">Path.</code><code class="descname">glob</code><span class="sig-paren">(</span><em>pattern</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-171">将此路径表示的目录中给定的<em>模式</em>全局化，生成所有匹配的文件（任何类型）：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="s1">'.'</span><span class="p">)</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">'*.py'</span><span class="p">))</span>
<span class="go">[PosixPath('pathlib.py'), PosixPath('setup.py'), PosixPath('test_pathlib.py')]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="s1">'.'</span><span class="p">)</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">'*/*.py'</span><span class="p">))</span>
<span class="go">[PosixPath('docs/conf.py')]</span>
</code></pre><p><span class="yiyi-st" id="yiyi-172">“<code class="docutils literal"><span class="pre">**</span></code>”模式表示“此目录和所有子目录，递归”。</span><span class="yiyi-st" id="yiyi-173">换句话说，它启用递归globbing：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="s1">'.'</span><span class="p">)</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">'**/*.py'</span><span class="p">))</span>
<span class="go">[PosixPath('build/lib/pathlib.py'),</span>
<span class="go"> PosixPath('docs/conf.py'),</span>
<span class="go"> PosixPath('pathlib.py'),</span>
<span class="go"> PosixPath('setup.py'),</span>
<span class="go"> PosixPath('test_pathlib.py')]</span>
</code></pre><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-174">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-175">在大目录树中使用“<code class="docutils literal"><span class="pre">**</span></code>”模式可能会消耗过多的时间。</span></p></div></dd></dl><dl class="method"><dt id="pathlib.Path.group"><span class="yiyi-st" id="yiyi-176"><code class="descclassname">Path.</code><code class="descname">group</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-177">返回拥有该文件的组的名称。</span><span class="yiyi-st" id="yiyi-178">如果在系统数据库中找不到文件的gid，则会引发<a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="pathlib.Path.is_dir"><span class="yiyi-st" id="yiyi-179"><code class="descclassname">Path.</code><code class="descname">is_dir</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-180">如果路径指向目录（或指向目录的符号链接），则返回<code class="docutils literal"><span class="pre">True</span></code>，如果它指向另一种文件，则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-181"><code class="docutils literal"><span class="pre">False</span></code>也会在路径不存在或断开的符号链接时返回；其他错误（例如权限错误）被传播。</span></p></dd></dl><dl class="method"><dt id="pathlib.Path.is_file"><span class="yiyi-st" id="yiyi-182"><code class="descclassname">Path.</code><code class="descname">is_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-183">如果路径指向常规文件（或指向常规文件的符号链接），则返回<code class="docutils literal"><span class="pre">True</span></code>，如果它指向另一种文件，则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-184"><code class="docutils literal"><span class="pre">False</span></code>也会在路径不存在或断开的符号链接时返回；其他错误（例如权限错误）被传播。</span></p></dd></dl><dl class="method"><dt id="pathlib.Path.is_symlink"><span class="yiyi-st" id="yiyi-185"><code class="descclassname">Path.</code><code class="descname">is_symlink</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-186">如果路径指向符号链接，则返回<code class="docutils literal"><span class="pre">True</span></code>，否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-187"><code class="docutils literal"><span class="pre">False</span></code>也会在路径不存在时返回；其他错误（例如权限错误）被传播。</span></p></dd></dl><dl class="method"><dt id="pathlib.Path.is_socket"><span class="yiyi-st" id="yiyi-188"><code class="descclassname">Path.</code><code class="descname">is_socket</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-189">如果路径指向Unix套接字（或指向Unix套接字的符号链接），则返回<code class="docutils literal"><span class="pre">True</span></code>，如果它指向另一种文件，则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-190"><code class="docutils literal"><span class="pre">False</span></code>也会在路径不存在或断开的符号链接时返回；其他错误（例如权限错误）被传播。</span></p></dd></dl><dl class="method"><dt id="pathlib.Path.is_fifo"><span class="yiyi-st" id="yiyi-191"><code class="descclassname">Path.</code><code class="descname">is_fifo</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-192">如果路径指向一个FIFO（或指向一个FIFO的符号链接），则返回<code class="docutils literal"><span class="pre">True</span></code>，如果它指向另一种文件，则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-193"><code class="docutils literal"><span class="pre">False</span></code>也会在路径不存在或断开的符号链接时返回；其他错误（例如权限错误）被传播。</span></p></dd></dl><dl class="method"><dt id="pathlib.Path.is_block_device"><span class="yiyi-st" id="yiyi-194"><code class="descclassname">Path.</code><code class="descname">is_block_device</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-195">如果路径指向块设备（或指向块设备的符号链接），则返回<code class="docutils literal"><span class="pre">True</span></code>，如果它指向另一种文件，则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-196"><code class="docutils literal"><span class="pre">False</span></code>也会在路径不存在或断开的符号链接时返回；其他错误（例如权限错误）被传播。</span></p></dd></dl><dl class="method"><dt id="pathlib.Path.is_char_device"><span class="yiyi-st" id="yiyi-197"><code class="descclassname">Path.</code><code class="descname">is_char_device</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-198">如果路径指向字符设备（或指向字符设备的符号链接），则返回<code class="docutils literal"><span class="pre">True</span></code>，如果它指向另一种文件，则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-199"><code class="docutils literal"><span class="pre">False</span></code>也会在路径不存在或断开的符号链接时返回；其他错误（例如权限错误）被传播。</span></p></dd></dl><dl class="method"><dt id="pathlib.Path.iterdir"><span class="yiyi-st" id="yiyi-200"><code class="descclassname">Path.</code><code class="descname">iterdir</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-201">当路径指向一个目录时，yield目录内容的路径对象：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">'docs'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">iterdir</span><span class="p">():</span> <span class="n">child</span>
<span class="gp">...</span>
<span class="go">PosixPath('docs/conf.py')</span>
<span class="go">PosixPath('docs/_templates')</span>
<span class="go">PosixPath('docs/make.bat')</span>
<span class="go">PosixPath('docs/index.rst')</span>
<span class="go">PosixPath('docs/_build')</span>
<span class="go">PosixPath('docs/_static')</span>
<span class="go">PosixPath('docs/Makefile')</span>
</code></pre></dd></dl><dl class="method"><dt id="pathlib.Path.lchmod"><span class="yiyi-st" id="yiyi-202"><code class="descclassname">Path.</code><code class="descname">lchmod</code><span class="sig-paren">(</span><em>mode</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-203">像<a class="reference internal" href="#pathlib.Path.chmod" title="pathlib.Path.chmod"><code class="xref py py-meth docutils literal"><span class="pre">Path.chmod()</span></code></a>，但是，如果路径指向符号链接，符号链接的模式将更改，而不是其目标。</span></p></dd></dl><dl class="method"><dt id="pathlib.Path.lstat"><span class="yiyi-st" id="yiyi-204"><code class="descclassname">Path.</code><code class="descname">lstat</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-205">像<a class="reference internal" href="#pathlib.Path.stat" title="pathlib.Path.stat"><code class="xref py py-meth docutils literal"><span class="pre">Path.stat()</span></code></a>，但是，如果路径指向符号链接，则返回符号链接的信息，而不是其目标。</span></p></dd></dl><dl class="method"><dt id="pathlib.Path.mkdir"><span class="yiyi-st" id="yiyi-206"><code class="descclassname">Path.</code><code class="descname">mkdir</code><span class="sig-paren">(</span><em>mode=0o777</em>, <em>parents=False</em>, <em>exist_ok=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-207">在此给定路径创建一个新目录。</span><span class="yiyi-st" id="yiyi-208">如果给出<em>模式</em>，则将其与进程“<code class="docutils literal"><span class="pre">umask</span></code>值组合以确定文件模式和访问标志。</span><span class="yiyi-st" id="yiyi-209">如果路径已存在，则会引发<a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal"><span class="pre">FileExistsError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-210">如果<em>parents</em>为真，则根据需要创建此路径的任何缺少的父项；它们是使用默认权限创建的，而不考虑<em>模式</em>（模仿POSIX <code class="docutils literal"><span class="pre">mkdir</span> <span class="pre">-p</span></code>命令）。</span></p><p><span class="yiyi-st" id="yiyi-211">如果<em>parents</em>为false（默认值），则缺少父引用<a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal"><span class="pre">FileNotFoundError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-212">如果<em>exists_ok</em>为false（默认值），则如果目标目录已存在，则会引发<a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal"><span class="pre">FileExistsError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-213">如果<em>exists_ok</em>为真，则会忽略<a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal"><span class="pre">FileExistsError</span></code></a>异常（与POSIX <code class="docutils literal"><span class="pre">mkdir</span> <span class="pre">-p</span> </code>命令），但前提是最后一个路径组件不是现有的非目录文件。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-214"><span class="versionmodified">在版本3.5中已更改：</span>添加了<em>exists_ok</em>参数。</span></p></div></dd></dl><dl class="method"><dt id="pathlib.Path.open"><span class="yiyi-st" id="yiyi-215"><code class="descclassname">Path.</code><code class="descname">open</code><span class="sig-paren">(</span><em>mode='r'</em>, <em>buffering=-1</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-216">打开路径指向的文件，如内建<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>函数：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">'setup.py'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">p</span><span class="o">.</span><span class="n">open</span><span class="p">()</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">'#!/usr/bin/env python3\n'</span>
</code></pre></dd></dl><dl class="method"><dt id="pathlib.Path.owner"><span class="yiyi-st" id="yiyi-217"><code class="descclassname">Path.</code><code class="descname">owner</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-218">返回拥有该文件的用户的名称。</span><span class="yiyi-st" id="yiyi-219">如果在系统数据库中找不到文件的uid，则会引发<a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="pathlib.Path.read_bytes"><span class="yiyi-st" id="yiyi-220"><code class="descclassname">Path.</code><code class="descname">read_bytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-221">将指向的文件的二进制内容作为字节对象返回：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">'my_binary_file'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">write_bytes</span><span class="p">(</span><span class="n">b</span><span class="s1">'Binary file contents'</span><span class="p">)</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">()</span>
<span class="go">b'Binary file contents'</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-222"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="pathlib.Path.read_text"><span class="yiyi-st" id="yiyi-223"><code class="descclassname">Path.</code><code class="descname">read_text</code><span class="sig-paren">(</span><em>encoding=None</em>, <em>errors=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-224">以字符串形式返回指向的文件的解码内容：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">'my_text_file'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">write_text</span><span class="p">(</span><span class="s1">'Text file contents'</span><span class="p">)</span>
<span class="go">18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">read_text</span><span class="p">()</span>
<span class="go">'Text file contents'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-225">可选参数的含义与<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>中的相同。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-226"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="pathlib.Path.rename"><span class="yiyi-st" id="yiyi-227"><code class="descclassname">Path.</code><code class="descname">rename</code><span class="sig-paren">(</span><em>target</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-228">将此文件或目录重命名为给定的<em>目标</em>。</span><span class="yiyi-st" id="yiyi-229">在Unix上，如果<em>目标</em>存在并且是文件，如果用户具有权限，则将以静默方式替换。</span><span class="yiyi-st" id="yiyi-230"><em>target</em>可以是字符串或另一个路径对象：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">'w'</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'some text'</span><span class="p">)</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span><span class="o">.</span><span class="n">open</span><span class="p">()</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="go">'some text'</span>
</code></pre></dd></dl><dl class="method"><dt id="pathlib.Path.replace"><span class="yiyi-st" id="yiyi-231"><code class="descclassname">Path.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>target</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-232">将此文件或目录重命名为给定的<em>目标</em>。</span><span class="yiyi-st" id="yiyi-233">如果<em>target</em>指向现有文件或目录，它将被无条件替换。</span></p></dd></dl><dl class="method"><dt id="pathlib.Path.resolve"><span class="yiyi-st" id="yiyi-234"><code class="descclassname">Path.</code><code class="descname">resolve</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-235">使路径为绝对路径，解析任何符号链接。</span><span class="yiyi-st" id="yiyi-236">返回一个新的路径对象：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">PosixPath('.')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
<span class="go">PosixPath('/home/antoine/pathlib')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-237"><cite>“..”</cite>组件也被删除（这是唯一的方法）：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">'docs/../setup.py'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
<span class="go">PosixPath('/home/antoine/pathlib/setup.py')</span>
</code></pre><p><span class="yiyi-st" id="yiyi-238">如果路径不存在，则会引发<a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal"><span class="pre">FileNotFoundError</span></code></a>。</span><span class="yiyi-st" id="yiyi-239">如果沿解析路径遇到无限循环，则会引发<a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="pathlib.Path.rglob"><span class="yiyi-st" id="yiyi-240"><code class="descclassname">Path.</code><code class="descname">rglob</code><span class="sig-paren">(</span><em>pattern</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-241">这就像在给定的<em>模式</em>前添加“<code class="docutils literal"><span class="pre">**</span></code>”调用<a class="reference internal" href="glob.html#module-glob" title="glob: Unix shell style pathname pattern expansion."><code class="xref py py-meth docutils literal"><span class="pre">glob()</span></code></a></span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Path</span><span class="p">()</span><span class="o">.</span><span class="n">rglob</span><span class="p">(</span><span class="s2">"*.py"</span><span class="p">))</span>
<span class="go">[PosixPath('build/lib/pathlib.py'),</span>
<span class="go"> PosixPath('docs/conf.py'),</span>
<span class="go"> PosixPath('pathlib.py'),</span>
<span class="go"> PosixPath('setup.py'),</span>
<span class="go"> PosixPath('test_pathlib.py')]</span>
</code></pre></dd></dl><dl class="method"><dt id="pathlib.Path.rmdir"><span class="yiyi-st" id="yiyi-242"><code class="descclassname">Path.</code><code class="descname">rmdir</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-243">删除此目录。</span><span class="yiyi-st" id="yiyi-244">该目录必须为空。</span></p></dd></dl><dl class="method"><dt id="pathlib.Path.samefile"><span class="yiyi-st" id="yiyi-245"><code class="descclassname">Path.</code><code class="descname">samefile</code><span class="sig-paren">(</span><em>other_path</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-246">返回此路径是否指向与<em>other_path</em>相同的文件，它可以是Path对象或字符串。</span><span class="yiyi-st" id="yiyi-247">语义类似于<a class="reference internal" href="os.path.html#os.path.samefile" title="os.path.samefile"><code class="xref py py-func docutils literal"><span class="pre">os.path.samefile()</span></code></a>和<a class="reference internal" href="os.path.html#os.path.samestat" title="os.path.samestat"><code class="xref py py-func docutils literal"><span class="pre">os.path.samestat()</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-248">如果由于某种原因无法访问任何一个文件，则可能会出现<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">'spam'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">'eggs'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">samefile</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">samefile</span><span class="p">(</span><span class="s1">'spam'</span><span class="p">)</span>
<span class="go">True</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-249"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="pathlib.Path.symlink_to"><span class="yiyi-st" id="yiyi-250"><code class="descclassname">Path.</code><code class="descname">symlink_to</code><span class="sig-paren">(</span><em>target</em>, <em>target_is_directory=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-251">将此路径作为<em>目标</em>的符号链接。</span><span class="yiyi-st" id="yiyi-252">在Windows下，如果链接的目标是目录，则<em>target_is_directory</em>必须为true（默认值<code class="docutils literal"><span class="pre">False</span></code>）。</span><span class="yiyi-st" id="yiyi-253">在POSIX下，忽略<em>target_is_directory</em>的值。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">'mylink'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">symlink_to</span><span class="p">(</span><span class="s1">'setup.py'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
<span class="go">PosixPath('/home/antoine/pathlib/setup.py')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">stat</span><span class="p">()</span><span class="o">.</span><span class="n">st_size</span>
<span class="go">956</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">lstat</span><span class="p">()</span><span class="o">.</span><span class="n">st_size</span>
<span class="go">8</span>
</code></pre><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-254">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-255">参数（link，target）的顺序与<a class="reference internal" href="os.html#os.symlink" title="os.symlink"><code class="xref py py-func docutils literal"><span class="pre">os.symlink()</span></code></a>的顺序相反。</span></p></div></dd></dl><dl class="method"><dt id="pathlib.Path.touch"><span class="yiyi-st" id="yiyi-256"><code class="descclassname">Path.</code><code class="descname">touch</code><span class="sig-paren">(</span><em>mode=0o666</em>, <em>exist_ok=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-257">在此给定路径创建一个文件。</span><span class="yiyi-st" id="yiyi-258">如果给出<em>模式</em>，则将其与进程“<code class="docutils literal"><span class="pre">umask</span></code>值组合以确定文件模式和访问标志。</span><span class="yiyi-st" id="yiyi-259">如果文件已经存在，则如果<em>exists_ok</em>为真（并且其修改时间更新为当前时间），则函数将成功，否则会引发<a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal"><span class="pre">FileExistsError</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="pathlib.Path.unlink"><span class="yiyi-st" id="yiyi-260"><code class="descclassname">Path.</code><code class="descname">unlink</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-261">删除此文件或符号链接。</span><span class="yiyi-st" id="yiyi-262">如果路径指向目录，请改用<a class="reference internal" href="#pathlib.Path.rmdir" title="pathlib.Path.rmdir"><code class="xref py py-func docutils literal"><span class="pre">Path.rmdir()</span></code></a>。</span></p></dd></dl><dl class="method"><dt id="pathlib.Path.write_bytes"><span class="yiyi-st" id="yiyi-263"><code class="descclassname">Path.</code><code class="descname">write_bytes</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-264">以字节模式打开指向的文件，向其写入<em>数据</em>，然后关闭文件：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">'my_binary_file'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">write_bytes</span><span class="p">(</span><span class="n">b</span><span class="s1">'Binary file contents'</span><span class="p">)</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">()</span>
<span class="go">b'Binary file contents'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-265">将覆盖同名的现有文件。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-266"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="pathlib.Path.write_text"><span class="yiyi-st" id="yiyi-267"><code class="descclassname">Path.</code><code class="descname">write_text</code><span class="sig-paren">(</span><em>data</em>, <em>encoding=None</em>, <em>errors=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-268">在文本模式下打开指向的文件，向其写入<em>数据</em>，然后关闭文件：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">'my_text_file'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">write_text</span><span class="p">(</span><span class="s1">'Text file contents'</span><span class="p">)</span>
<span class="go">18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">read_text</span><span class="p">()</span>
<span class="go">'Text file contents'</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-269"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl></div></div></div></div>