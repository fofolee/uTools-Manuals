<div class="body" role="main"><div class="section" id="module-test"><h1><span class="yiyi-st" id="yiyi-10">26.8. <a class="reference internal" href="#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-mod docutils literal"><span class="pre">test</span></code></a>  -  Python的回归测试包</span></h1><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-11">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-12"><a class="reference internal" href="#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-mod docutils literal"><span class="pre">test</span></code></a>包仅供Python内部使用。</span><span class="yiyi-st" id="yiyi-13">它被记录为Python的核心开发人员的利益。</span><span class="yiyi-st" id="yiyi-14">任何使用这个包外面的Python的标准库是不鼓励的，因为这里提到的代码可以改变或删除没有通知Python版本之间。</span></p></div><p><span class="yiyi-st" id="yiyi-15"><a class="reference internal" href="#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-mod docutils literal"><span class="pre">test</span></code></a>包包含所有Python的回归测试以及模块<a class="reference internal" href="#module-test.support" title="test.support: Support for Python's regression test suite."><code class="xref py py-mod docutils literal"><span class="pre">test.support</span></code></a>和<code class="xref py py-mod docutils literal"><span class="pre">test.regrtest</span></code>。</span><span class="yiyi-st" id="yiyi-16"><a class="reference internal" href="#module-test.support" title="test.support: Support for Python's regression test suite."><code class="xref py py-mod docutils literal"><span class="pre">test.support</span></code></a>用于增强测试，而<code class="xref py py-mod docutils literal"><span class="pre">test.regrtest</span></code>驱动测试套件。</span></p><p><span class="yiyi-st" id="yiyi-17"><a class="reference internal" href="#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-mod docutils literal"><span class="pre">test</span></code></a>包中名称以<code class="docutils literal"><span class="pre">test_</span></code>开头的每个模块都是特定模块或功能的测试套件。</span><span class="yiyi-st" id="yiyi-18">所有新测试都应使用<a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a>或<a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal"><span class="pre">doctest</span></code></a>模块编写。</span><span class="yiyi-st" id="yiyi-19">一些较老的测试使用“传统”测试样式来编写，比较打印到<code class="docutils literal"><span class="pre">sys.stdout</span></code>的输出；这种风格的测试被视为已弃用。</span></p><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-20">也可以看看</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-21">模块<a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-22">编写PyUnit回归测试。</span></dd><dt><span class="yiyi-st" id="yiyi-23">模块<a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal"><span class="pre">doctest</span></code></a></span></dt><dd><span class="yiyi-st" id="yiyi-24">文档字符串中嵌入的测试。</span></dd></dl></div><div class="section" id="writing-unit-tests-for-the-test-package"><h2><span class="yiyi-st" id="yiyi-25">26.8.1. </span><span class="yiyi-st" id="yiyi-26">Writing Unit Tests for the <a class="reference internal" href="#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-mod docutils literal"><span class="pre">test</span></code></a> package</span></h2><p><span class="yiyi-st" id="yiyi-27">优选地，使用<a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a>模块的测试遵循一些准则。</span><span class="yiyi-st" id="yiyi-28">一种是通过使用<code class="docutils literal"><span class="pre">test_</span></code>启动测试模块来命名测试模块，并以被测试模块的名称结束测试模块。</span><span class="yiyi-st" id="yiyi-29">测试模块中的测试方法应以<code class="docutils literal"><span class="pre">test_</span></code>开始，并以该方法正在测试的内容结束。</span><span class="yiyi-st" id="yiyi-30">这是需要的，使得方法被测试驱动程序识别为测试方法。</span><span class="yiyi-st" id="yiyi-31">此外，不应包括方法的文档字符串。</span><span class="yiyi-st" id="yiyi-32">评论（如<code class="docutils literal"><span class="pre">＃</span> <span class="pre">测试</span> <span class="pre">功能</span> <span class="pre">仅返回</span> <span class="pre"></span> <span class="pre"> True</span> <span class="pre">或</span> <span class="pre">False</span></code>）来提供测试方法的文档。</span><span class="yiyi-st" id="yiyi-33">这样做是因为文档字符串打印出来，如果它们存在，并且因此正在运行的测试没有声明。</span></p><p><span class="yiyi-st" id="yiyi-34">经常使用一个基本的样板：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">from</span> <span class="nn">test</span> <span class="k">import</span> <span class="n">support</span>

<span class="k">class</span> <span class="nc">MyTestCase1</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="c1"># Only use setUp() and tearDown() if necessary</span>

    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span> <span class="n">code</span> <span class="n">to</span> <span class="n">execute</span> <span class="ow">in</span> <span class="n">preparation</span> <span class="k">for</span> <span class="n">tests</span> <span class="o">...</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span> <span class="n">code</span> <span class="n">to</span> <span class="n">execute</span> <span class="n">to</span> <span class="n">clean</span> <span class="n">up</span> <span class="n">after</span> <span class="n">tests</span> <span class="o">...</span>

    <span class="k">def</span> <span class="nf">test_feature_one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Test feature one.</span>
        <span class="o">...</span> <span class="n">testing</span> <span class="n">code</span> <span class="o">...</span>

    <span class="k">def</span> <span class="nf">test_feature_two</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Test feature two.</span>
        <span class="o">...</span> <span class="n">testing</span> <span class="n">code</span> <span class="o">...</span>

    <span class="o">...</span> <span class="n">more</span> <span class="n">test</span> <span class="n">methods</span> <span class="o">...</span>

<span class="k">class</span> <span class="nc">MyTestCase2</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="o">...</span> <span class="n">same</span> <span class="n">structure</span> <span class="k">as</span> <span class="n">MyTestCase1</span> <span class="o">...</span>

<span class="o">...</span> <span class="n">more</span> <span class="n">test</span> <span class="n">classes</span> <span class="o">...</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">'__main__'</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</code></pre><p><span class="yiyi-st" id="yiyi-35">此代码模式允许测试套件由<code class="xref py py-mod docutils literal"><span class="pre">test.regrtest</span></code>独立运行，作为支持<a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> CLI的脚本，或通过<code class="docutils literal"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">unittest</span></code> CLI。</span></p><p><span class="yiyi-st" id="yiyi-36">回归测试的目的是试图破解代码。</span><span class="yiyi-st" id="yiyi-37">这导致了一些指导方针：</span></p><ul><li><p class="first"><span class="yiyi-st" id="yiyi-38">测试套件应该运行所有类，函数和常量。</span><span class="yiyi-st" id="yiyi-39">这不仅包括要呈现给外部世界的外部API，还包括“私有”代码。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-40">白盒测试（在测试被编写时检查正在测试的代码）是优选的。</span><span class="yiyi-st" id="yiyi-41">黑盒测试（仅测试已发布的用户界面）不够完整，无法确保所有边界和边缘情况都已测试。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-42">确保测试所有可能的值，包括无效的值。</span><span class="yiyi-st" id="yiyi-43">这确保不仅所有有效值都是可接受的，而且不正确的值被正确处理。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-44">排尽尽可能多的代码路径。</span><span class="yiyi-st" id="yiyi-45">测试分支发生的地方，从而定制输入，以确保通过代码获取多个不同的路径。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-46">为发现的测试代码的任何错误添加显式测试。</span><span class="yiyi-st" id="yiyi-47">这将确保错误不会再次裁剪，如果代码在将来更改。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-48">确保在测试后清理（例如关闭和删除所有临时文件）。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-49">如果测试依赖于操作系统的特定条件，则在尝试测试之前验证条件已经存在。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-50">导入尽可能少的模块，并尽快做到。</span><span class="yiyi-st" id="yiyi-51">这最小化了测试的外部依赖性，并且最小化了导入模块的副作用的可能的异常行为。</span></p></li><li><p class="first"><span class="yiyi-st" id="yiyi-52">尝试最大化代码重用。</span><span class="yiyi-st" id="yiyi-53">有时，测试将随着使用什么类型的输入而变化。</span><span class="yiyi-st" id="yiyi-54">通过将基本测试类与指定输入的类子类化来最小化代码重复：</span></p><pre><code class="language-python"><span></span><span class="k">class</span> <span class="nc">TestFuncAcceptsSequencesMixin</span><span class="p">:</span>

    <span class="n">func</span> <span class="o">=</span> <span class="n">mySuperWhammyFunction</span>

    <span class="k">def</span> <span class="nf">test_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">AcceptLists</span><span class="p">(</span><span class="n">TestFuncAcceptsSequencesMixin</span><span class="p">,</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">AcceptStrings</span><span class="p">(</span><span class="n">TestFuncAcceptsSequencesMixin</span><span class="p">,</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="s1">'abc'</span>

<span class="k">class</span> <span class="nc">AcceptTuples</span><span class="p">(</span><span class="n">TestFuncAcceptsSequencesMixin</span><span class="p">,</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-55">当使用此模式时，请记住所有从<a class="reference internal" href="unittest.html#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">unittest.TestCase</span></code></a>继承的类作为测试运行。</span><span class="yiyi-st" id="yiyi-56">上述示例中的<code class="xref py py-class docutils literal"><span class="pre">Mixin</span></code>类没有任何数据，因此无法自行运行，因此不会继承<a class="reference internal" href="unittest.html#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">unittest.TestCase</span></code></a>。</span></p></li></ul><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-57">也可以看看</span></p><dl class="last docutils"><dt><span class="yiyi-st" id="yiyi-58">测试驱动开发</span></dt><dd><span class="yiyi-st" id="yiyi-59">一本由Kent Beck编写的测试代码之前的书。</span></dd></dl></div></div><div class="section" id="running-tests-using-the-command-line-interface"><h2><span class="yiyi-st" id="yiyi-60">26.8.2. </span><span class="yiyi-st" id="yiyi-61">Running tests using the command-line interface</span></h2><p><span class="yiyi-st" id="yiyi-62">由于<a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal"><span class="pre">-m</span></code></a>选项：<strong class="program">python -m test</strong>，<a class="reference internal" href="#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-mod docutils literal"><span class="pre">test</span></code></a>包可作为脚本运行以驱动Python的回归测试套件。</span><span class="yiyi-st" id="yiyi-63">在引擎盖下，它使用<code class="xref py py-mod docutils literal"><span class="pre">test.regrtest</span></code>；在以前的Python版本中使用的调用<strong class="program">python -m test.regrtest</strong>仍然有效。</span><span class="yiyi-st" id="yiyi-64">运行脚本本身会自动开始在<a class="reference internal" href="#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-mod docutils literal"><span class="pre">test</span></code></a>包中运行所有回归测试。</span><span class="yiyi-st" id="yiyi-65">它通过查找名称以<code class="docutils literal"><span class="pre">test_</span></code>开头的包中的所有模块，导入它们，并执行函数<code class="xref py py-func docutils literal"><span class="pre">test_main()</span></code>（如果存在）或通过unittest.TestLoader加载测试.loadTestsFromModule如果<code class="docutils literal"><span class="pre">test_main</span></code>不存在。</span><span class="yiyi-st" id="yiyi-66">要执行的测试的名称也可以传递给脚本。</span><span class="yiyi-st" id="yiyi-67">指定单个回归测试（<strong class="program">python -m test test_spam</strong>）将最小化输出，并仅打印测试是通过还是失败。</span></p><p><span class="yiyi-st" id="yiyi-68">运行<a class="reference internal" href="#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-mod docutils literal"><span class="pre">test</span></code></a>直接允许使用哪些资源来进行测试。</span><span class="yiyi-st" id="yiyi-69">您可以使用<code class="docutils literal"><span class="pre">-u</span></code>命令行选项。</span><span class="yiyi-st" id="yiyi-70">Specifying <code class="docutils literal"><span class="pre">all</span></code> as the value for the <code class="docutils literal"><span class="pre">-u</span></code> option enables all possible resources: <strong class="program">python -m test -uall</strong>. </span><span class="yiyi-st" id="yiyi-71">如果仅需要一个资源（更常见的情况），则可以在<code class="docutils literal"><span class="pre">all</span></code>之后列出不期望的逗号分隔的资源列表。</span><span class="yiyi-st" id="yiyi-72">The command <strong class="program">python -m test -uall,-audio,-largefile</strong> will run <a class="reference internal" href="#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-mod docutils literal"><span class="pre">test</span></code></a> with all resources except the <code class="docutils literal"><span class="pre">audio</span></code> and <code class="docutils literal"><span class="pre">largefile</span></code> resources. </span><span class="yiyi-st" id="yiyi-73">有关所有资源和更多命令行选项的列表，请运行<strong class="program">python -m test -h</strong>。</span></p><p><span class="yiyi-st" id="yiyi-74">执行回归测试的一些其他方法取决于在哪些平台上执行测试。</span><span class="yiyi-st" id="yiyi-75">在Unix上，您可以在Python构建的顶级目录中运行<strong class="program">make test</strong>。</span><span class="yiyi-st" id="yiyi-76">在Windows上，从<code class="file docutils literal"><span class="pre">PCBuild</span></code>目录中执行<strong class="program">rt.bat</strong>将运行所有回归测试。</span></p></div></div><div class="section" id="module-test.support"><h1><span class="yiyi-st" id="yiyi-77">26.9. <a class="reference internal" href="#module-test.support" title="test.support: Support for Python's regression test suite."><code class="xref py py-mod docutils literal"><span class="pre">test.support</span></code></a>  -  Python测试套件的实用程序</span></h1><p><span class="yiyi-st" id="yiyi-78"><a class="reference internal" href="#module-test.support" title="test.support: Support for Python's regression test suite."><code class="xref py py-mod docutils literal"><span class="pre">test.support</span></code></a>模块提供对Python回归测试套件的支持。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-79">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-80"><a class="reference internal" href="#module-test.support" title="test.support: Support for Python's regression test suite."><code class="xref py py-mod docutils literal"><span class="pre">test.support</span></code></a>不是公共模块。</span><span class="yiyi-st" id="yiyi-81">这里记录了帮助Python开发人员编写测试。</span><span class="yiyi-st" id="yiyi-82">此模块的API可能会发生更改，而不会在发行版之间出现向后兼容性问题。</span></p></div><p><span class="yiyi-st" id="yiyi-83">此模块定义了以下例外：</span></p><dl class="exception"><dt id="test.support.TestFailed"><span class="yiyi-st" id="yiyi-84"> <em class="property">exception </em><code class="descclassname">test.support.</code><code class="descname">TestFailed</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-85">测试失败时引发异常。</span><span class="yiyi-st" id="yiyi-86">这已被弃用，支持基于<a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a>的测试和<a class="reference internal" href="unittest.html#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">unittest.TestCase</span></code></a>的断言方法。</span></p></dd></dl><dl class="exception"><dt id="test.support.ResourceDenied"><span class="yiyi-st" id="yiyi-87"> <em class="property">exception </em><code class="descclassname">test.support.</code><code class="descname">ResourceDenied</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-88"><a class="reference internal" href="unittest.html#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal"><span class="pre">unittest.SkipTest</span></code></a>的子类。</span><span class="yiyi-st" id="yiyi-89">在资源（例如网络连接）不可用时触发。</span><span class="yiyi-st" id="yiyi-90">由<a class="reference internal" href="#test.support.requires" title="test.support.requires"><code class="xref py py-func docutils literal"><span class="pre">requires()</span></code></a>函数引发。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-91"><a class="reference internal" href="#module-test.support" title="test.support: Support for Python's regression test suite."><code class="xref py py-mod docutils literal"><span class="pre">test.support</span></code></a>模块定义以下常量：</span></p><dl class="data"><dt id="test.support.verbose"><span class="yiyi-st" id="yiyi-92"> <code class="descclassname">test.support.</code><code class="descname">verbose</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-93"><code class="docutils literal"><span class="pre">True</span></code>时启用详细输出。</span><span class="yiyi-st" id="yiyi-94">当需要有关运行测试的更详细信息时，应检查。</span><span class="yiyi-st" id="yiyi-95"><em>verbose</em>由<code class="xref py py-mod docutils literal"><span class="pre">test.regrtest</span></code>设置。</span></p></dd></dl><dl class="data"><dt id="test.support.is_jython"><span class="yiyi-st" id="yiyi-96"> <code class="descclassname">test.support.</code><code class="descname">is_jython</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-97"><code class="docutils literal"><span class="pre">True</span></code>如果正在运行的解释器是Jython。</span></p></dd></dl><dl class="data"><dt id="test.support.TESTFN"><span class="yiyi-st" id="yiyi-98"> <code class="descclassname">test.support.</code><code class="descname">TESTFN</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-99">设置为可安全用作临时文件名称的名称。</span><span class="yiyi-st" id="yiyi-100">创建的任何临时文件都应该关闭并取消链接（删除）。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-101"><a class="reference internal" href="#module-test.support" title="test.support: Support for Python's regression test suite."><code class="xref py py-mod docutils literal"><span class="pre">test.support</span></code></a>模块定义了以下功能：</span></p><dl class="function"><dt id="test.support.forget"><span class="yiyi-st" id="yiyi-102"> <code class="descclassname">test.support.</code><code class="descname">forget</code><span class="sig-paren">(</span><em>module_name</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-103">从<code class="docutils literal"><span class="pre">sys.modules</span></code>中删除名为<em>module_name</em>的模块，并删除模块的任何字节编译文件。</span></p></dd></dl><dl class="function"><dt id="test.support.is_resource_enabled"><span class="yiyi-st" id="yiyi-104"> <code class="descclassname">test.support.</code><code class="descname">is_resource_enabled</code><span class="sig-paren">(</span><em>resource</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-105">如果<em>资源</em>已启用并可用，则返回<code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-106">仅当<code class="xref py py-mod docutils literal"><span class="pre">test.regrtest</span></code>正在执行测试时，才设置可用资源的列表。</span></p></dd></dl><dl class="function"><dt id="test.support.requires"><span class="yiyi-st" id="yiyi-107"> <code class="descclassname">test.support.</code><code class="descname">requires</code><span class="sig-paren">(</span><em>resource</em>, <em>msg=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-108">引发<a class="reference internal" href="#test.support.ResourceDenied" title="test.support.ResourceDenied"><code class="xref py py-exc docutils literal"><span class="pre">ResourceDenied</span></code></a>如果<em>资源</em>不可用。</span><span class="yiyi-st" id="yiyi-109"><em>msg</em>是<a class="reference internal" href="#test.support.ResourceDenied" title="test.support.ResourceDenied"><code class="xref py py-exc docutils literal"><span class="pre">ResourceDenied</span></code></a>的参数，如果它被引发。</span><span class="yiyi-st" id="yiyi-110">如果由<code class="docutils literal"><span class="pre">__name__</span></code>为<code class="docutils literal"><span class="pre">'__main__'</span></code>的函数调用，则始终返回<code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-111">当测试由<code class="xref py py-mod docutils literal"><span class="pre">test.regrtest</span></code>执行时使用。</span></p></dd></dl><dl class="function"><dt id="test.support.findfile"><span class="yiyi-st" id="yiyi-112"> <code class="descclassname">test.support.</code><code class="descname">findfile</code><span class="sig-paren">(</span><em>filename</em>, <em>subdir=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-113">返回到名为<em>filename</em>的文件的路径。</span><span class="yiyi-st" id="yiyi-114">如果未找到匹配，则返回<em>filename</em>。</span><span class="yiyi-st" id="yiyi-115">这不等于故障，因为它可以是文件的路径。</span></p><span class="yiyi-st" id="yiyi-116"> <blockquote> <div>Setting <em>subdir</em> indicates a relative path to use to find the file rather than looking directly in the path directories.</div></blockquote></span></dd></dl><dl class="function"><dt id="test.support.run_unittest"><span class="yiyi-st" id="yiyi-117"> <code class="descclassname">test.support.</code><code class="descname">run_unittest</code><span class="sig-paren">(</span><em>*classes</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-118">执行传递给函数的<a class="reference internal" href="unittest.html#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal"><span class="pre">unittest.TestCase</span></code></a>子类。</span><span class="yiyi-st" id="yiyi-119">该函数扫描类前缀为<code class="docutils literal"><span class="pre">test_</span></code>的方法，并单独执行测试。</span></p><p><span class="yiyi-st" id="yiyi-120">将字符串作为参数传递也是合法的；这些应该是<code class="docutils literal"><span class="pre">sys.modules</span></code>中的键。</span><span class="yiyi-st" id="yiyi-121">每个相关模块将由<code class="docutils literal"><span class="pre">unittest.TestLoader.loadTestsFromModule()</span></code>扫描。</span><span class="yiyi-st" id="yiyi-122">这通常在以下<code class="xref py py-func docutils literal"><span class="pre">test_main()</span></code>函数中可见：</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">test_main</span><span class="p">():</span>
    <span class="n">support</span><span class="o">.</span><span class="n">run_unittest</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-123">这将运行在命名模块中定义的所有测试。</span></p></dd></dl><dl class="function"><dt id="test.support.run_doctest"><span class="yiyi-st" id="yiyi-124"> <code class="descclassname">test.support.</code><code class="descname">run_doctest</code><span class="sig-paren">(</span><em>module</em>, <em>verbosity=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-125">在给定的<em>模块</em>上运行<a class="reference internal" href="doctest.html#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal"><span class="pre">doctest.testmod()</span></code></a>。</span><span class="yiyi-st" id="yiyi-126">返回<code class="docutils literal"><span class="pre">（failure_count，</span> <span class="pre">test_count）</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-127">If <em>verbosity</em> is <code class="docutils literal"><span class="pre">None</span></code>, <a class="reference internal" href="doctest.html#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal"><span class="pre">doctest.testmod()</span></code></a> is run with verbosity set to <a class="reference internal" href="#test.support.verbose" title="test.support.verbose"><code class="xref py py-data docutils literal"><span class="pre">verbose</span></code></a>. </span><span class="yiyi-st" id="yiyi-128">否则，它的详细程度设置为<code class="docutils literal"><span class="pre">None</span></code>。</span></p></dd></dl><dl class="function"><dt id="test.support.check_warnings"><span class="yiyi-st" id="yiyi-129"> <code class="descclassname">test.support.</code><code class="descname">check_warnings</code><span class="sig-paren">(</span><em>*filters</em>, <em>quiet=True</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-130"><a class="reference internal" href="warnings.html#warnings.catch_warnings" title="warnings.catch_warnings"><code class="xref py py-func docutils literal"><span class="pre">warnings.catch_warnings()</span></code></a>的便利包装，可以更容易地测试警告是否正确引发。</span><span class="yiyi-st" id="yiyi-131">它大致相当于调用<code class="docutils literal"><span class="pre">warnings.catch_warnings(record=True)</span></code>与<a class="reference internal" href="warnings.html#warnings.simplefilter" title="warnings.simplefilter"><code class="xref py py-meth docutils literal"><span class="pre">warnings.simplefilter()</span></code></a>设置为<code class="docutils literal"><span class="pre">always</span></code>验证记录的结果。</span></p><p><span class="yiyi-st" id="yiyi-132"><code class="docutils literal"><span class="pre">check_warnings</span></code>接受以下形式的2元组：<code class="docutils literal"><span class="pre">（“message</span> <span class="pre">regexp”，</span> <span class="pre">WarningCategory）</span>  t2 &gt;作为位置参数。</code></span><span class="yiyi-st" id="yiyi-133">如果提供了一个或多个<em>过滤器</em>，或者如果可选的关键字参数<em>quiet</em>为<code class="docutils literal"><span class="pre">False</span></code>，它会检查以确保警告符合预期：每个指定的过滤器必须匹配附带代码引发的至少一个警告或测试失败，并且如果出现任何与任何指定过滤器不匹配的警告，测试将失败。</span><span class="yiyi-st" id="yiyi-134">要禁用这些检查中的第一个，请将<em>安静</em>设置为<code class="docutils literal"><span class="pre">True</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-135">如果未指定任何参数，则默认为：</span></p><pre><code class="language-python"><span></span><span class="n">check_warnings</span><span class="p">((</span><span class="s2">""</span><span class="p">,</span> <span class="ne">Warning</span><span class="p">),</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-136">在这种情况下，所有警告都被捕获，并且不会产生错误。</span></p><p><span class="yiyi-st" id="yiyi-137">在进入上下文管理器时，返回<code class="xref py py-class docutils literal"><span class="pre">WarningRecorder</span></code>实例。</span><span class="yiyi-st" id="yiyi-138">可通过记录器对象的<a class="reference internal" href="warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-attr docutils literal"><span class="pre">warnings</span></code></a>属性从<a class="reference internal" href="warnings.html#warnings.catch_warnings" title="warnings.catch_warnings"><code class="xref py py-func docutils literal"><span class="pre">catch_warnings()</span></code></a>获取基本警告列表。</span><span class="yiyi-st" id="yiyi-139">为方便起见，还可以通过记录器对象直接访问表示最近警告的对象的属性（参见下面的示例）。</span><span class="yiyi-st" id="yiyi-140">如果没有提出警告，那么在表示警告的对象上预期的任何属性将返回<code class="docutils literal"><span class="pre">None</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-141">记录器对象还有一个<code class="xref py py-meth docutils literal"><span class="pre">reset()</span></code>方法，它清除警告列表。</span></p><p><span class="yiyi-st" id="yiyi-142">上下文管理器被设计为这样使用：</span></p><pre><code class="language-python"><span></span><span class="k">with</span> <span class="n">check_warnings</span><span class="p">((</span><span class="s2">"assertion is always true"</span><span class="p">,</span> <span class="ne">SyntaxWarning</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">""</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)):</span>
    <span class="n">exec</span><span class="p">(</span><span class="s1">'assert(False, "Hey!")'</span><span class="p">)</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">(</span><span class="s2">"Hide me!"</span><span class="p">))</span>
</code></pre><p><span class="yiyi-st" id="yiyi-143">在这种情况下，如果没有提出警告或发出了其他警告，<a class="reference internal" href="#test.support.check_warnings" title="test.support.check_warnings"><code class="xref py py-func docutils literal"><span class="pre">check_warnings()</span></code></a>会引发错误。</span></p><p><span class="yiyi-st" id="yiyi-144">当测试需要更深入地观察警告时，而不仅仅是检查它们是否发生，可以使用这样的代码：</span></p><pre><code class="language-python"><span></span><span class="k">with</span> <span class="n">check_warnings</span><span class="p">(</span><span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">"foo"</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="s2">"foo"</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">"bar"</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="s2">"bar"</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">warnings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="s2">"foo"</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">warnings</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="s2">"bar"</span>
    <span class="n">w</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">warnings</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre><p><span class="yiyi-st" id="yiyi-145">这里所有的警告都将被捕获，测试代码直接测试捕获的警告。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-146"><span class="versionmodified">在版本3.2中更改：</span>新的可选参数<em>过滤器</em>和<em>安静</em>。</span></p></div></dd></dl><dl class="function"><dt id="test.support.captured_stdin"><span class="yiyi-st" id="yiyi-147"> <code class="descclassname">test.support.</code><code class="descname">captured_stdin</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dt id="test.support.captured_stdout"><span class="yiyi-st" id="yiyi-148"> <code class="descclassname">test.support.</code><code class="descname">captured_stdout</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dt id="test.support.captured_stderr"><span class="yiyi-st" id="yiyi-149"> <code class="descclassname">test.support.</code><code class="descname">captured_stderr</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-150">使用<a class="reference internal" href="io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">io.StringIO</span></code></a>对象临时替换命名流的上下文管理器。</span></p><p><span class="yiyi-st" id="yiyi-151">输出流使用示例：</span></p><pre><code class="language-python"><span></span><span class="k">with</span> <span class="n">captured_stdout</span><span class="p">()</span> <span class="k">as</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">captured_stderr</span><span class="p">()</span> <span class="k">as</span> <span class="n">stderr</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"hello"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"error"</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">stdout</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span> <span class="o">==</span> <span class="s2">"hello</span><span class="se">\n</span><span class="s2">"</span>
<span class="k">assert</span> <span class="n">stderr</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span> <span class="o">==</span> <span class="s2">"error</span><span class="se">\n</span><span class="s2">"</span>
</code></pre><p><span class="yiyi-st" id="yiyi-152">使用输入流的示例：</span></p><pre><code class="language-python"><span></span><span class="k">with</span> <span class="n">captured_stdin</span><span class="p">()</span> <span class="k">as</span> <span class="n">stdin</span><span class="p">:</span>
    <span class="n">stdin</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'hello</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
    <span class="n">stdin</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># call test code that consumes from sys.stdin</span>
    <span class="n">captured</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">captured</span><span class="p">,</span> <span class="s2">"hello"</span><span class="p">)</span>
</code></pre></dd></dl><dl class="function"><dt id="test.support.temp_dir"><span class="yiyi-st" id="yiyi-153"> <code class="descclassname">test.support.</code><code class="descname">temp_dir</code><span class="sig-paren">(</span><em>path=None</em>, <em>quiet=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-154">在<em>路径</em>创建临时目录并生成目录的上下文管理器。</span></p><p><span class="yiyi-st" id="yiyi-155">如果<em>路径</em>为无，则使用<a class="reference internal" href="tempfile.html#tempfile.mkdtemp" title="tempfile.mkdtemp"><code class="xref py py-func docutils literal"><span class="pre">tempfile.mkdtemp()</span></code></a>创建临时目录。</span><span class="yiyi-st" id="yiyi-156">如果<em>quiet</em>是<code class="docutils literal"><span class="pre">False</span></code>，则上下文管理器在错误时引发异常。</span><span class="yiyi-st" id="yiyi-157">否则，如果指定<em>路径</em>且无法创建，则只会发出警告。</span></p></dd></dl><dl class="function"><dt id="test.support.change_cwd"><span class="yiyi-st" id="yiyi-158"> <code class="descclassname">test.support.</code><code class="descname">change_cwd</code><span class="sig-paren">(</span><em>path</em>, <em>quiet=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-159">临时将当前工作目录更改为<em>路径</em>并生成目录的上下文管理器。</span></p><p><span class="yiyi-st" id="yiyi-160">如果<em>quiet</em>是<code class="docutils literal"><span class="pre">False</span></code>，则上下文管理器在错误时引发异常。</span><span class="yiyi-st" id="yiyi-161">否则，它只发出警告，并保持当前工作目录相同。</span></p></dd></dl><dl class="function"><dt id="test.support.temp_cwd"><span class="yiyi-st" id="yiyi-162"> <code class="descclassname">test.support.</code><code class="descname">temp_cwd</code><span class="sig-paren">(</span><em>name='tempcwd'</em>, <em>quiet=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-163">临时创建新目录并更改当前工作目录（CWD）的上下文管理器。</span></p><p><span class="yiyi-st" id="yiyi-164">上下文管理器在临时更改当前工作目录之前，在名为<em>name</em>的当前目录中创建一个临时目录。</span><span class="yiyi-st" id="yiyi-165">如果<em>name</em>为None，则使用<a class="reference internal" href="tempfile.html#tempfile.mkdtemp" title="tempfile.mkdtemp"><code class="xref py py-func docutils literal"><span class="pre">tempfile.mkdtemp()</span></code></a>创建临时目录。</span></p><p><span class="yiyi-st" id="yiyi-166">如果<em>quiet</em>是<code class="docutils literal"><span class="pre">False</span></code>，且无法创建或更改CWD，则会引发错误。</span><span class="yiyi-st" id="yiyi-167">否则，仅产生警告并使用原始CWD。</span></p></dd></dl><dl class="function"><dt id="test.support.temp_umask"><span class="yiyi-st" id="yiyi-168"> <code class="descclassname">test.support.</code><code class="descname">temp_umask</code><span class="sig-paren">(</span><em>umask</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-169">临时设置进程umask的上下文管理器。</span></p></dd></dl><dl class="function"><dt id="test.support.can_symlink"><span class="yiyi-st" id="yiyi-170"> <code class="descclassname">test.support.</code><code class="descname">can_symlink</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-171">如果操作系统支持符号链接，则返回<code class="docutils literal"><span class="pre">True</span></code>，否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span></p></dd></dl><dl class="function"><dt id="test.support.skip_unless_symlink"><span class="yiyi-st" id="yiyi-172"> <code class="descclassname">@</code><code class="descclassname">test.support.</code><code class="descname">skip_unless_symlink</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-173">一个装饰器，用于运行需要支持符号链接的测试。</span></p></dd></dl><dl class="function"><dt id="test.support.anticipate_failure"><span class="yiyi-st" id="yiyi-174"> <code class="descclassname">@</code><code class="descclassname">test.support.</code><code class="descname">anticipate_failure</code><span class="sig-paren">(</span><em>condition</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-175">有条件地使用<a class="reference internal" href="unittest.html#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal"><span class="pre">unittest.expectedFailure()</span></code></a>标记测试的装饰器。</span><span class="yiyi-st" id="yiyi-176">任何使用这个装饰器应该有一个相关的意见，标识相关的跟踪器问题。</span></p></dd></dl><dl class="function"><dt id="test.support.run_with_locale"><span class="yiyi-st" id="yiyi-177"> <code class="descclassname">@</code><code class="descclassname">test.support.</code><code class="descname">run_with_locale</code><span class="sig-paren">(</span><em>catstr</em>, <em>*locales</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-178">装饰器，用于在不同的场所运行功能，在完成后正确地重置它。</span><span class="yiyi-st" id="yiyi-179"><em>catstr</em>是作为字符串的区域设置类别（例如<code class="docutils literal"><span class="pre">"LC_ALL"</span></code>）。</span><span class="yiyi-st" id="yiyi-180">将按顺序尝试传递的<em>语言环境</em>，并使用第一个有效语言环境。</span></p></dd></dl><dl class="function"><dt id="test.support.make_bad_fd"><span class="yiyi-st" id="yiyi-181"> <code class="descclassname">test.support.</code><code class="descname">make_bad_fd</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-182">通过打开和关闭临时文件，并返回其描述器，创建一个无效的文件描述器。</span></p></dd></dl><dl class="function"><dt id="test.support.import_module"><span class="yiyi-st" id="yiyi-183"> <code class="descclassname">test.support.</code><code class="descname">import_module</code><span class="sig-paren">(</span><em>name</em>, <em>deprecated=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-184">此函数导入并返回指定的模块。</span><span class="yiyi-st" id="yiyi-185">与正常导入不同，此函数引发<a class="reference internal" href="unittest.html#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal"><span class="pre">unittest.SkipTest</span></code></a>如果模块无法导入。</span></p><p><span class="yiyi-st" id="yiyi-186">如果<em>已弃用</em>为<code class="docutils literal"><span class="pre">True</span></code>，则在导入期间将禁止模块和软件包弃用消息。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-187"><span class="versionmodified">版本3.1中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="test.support.import_fresh_module"><span class="yiyi-st" id="yiyi-188"> <code class="descclassname">test.support.</code><code class="descname">import_fresh_module</code><span class="sig-paren">(</span><em>name</em>, <em>fresh=()</em>, <em>blocked=()</em>, <em>deprecated=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-189">此函数通过在执行导入之前从<code class="docutils literal"><span class="pre">sys.modules</span></code>中删除指定的模块，导入并返回命名的Python模块的新副本。</span><span class="yiyi-st" id="yiyi-190">请注意，与<code class="xref py py-func docutils literal"><span class="pre">reload()</span></code>不同，原始模块不受此操作影响。</span></p><p><span class="yiyi-st" id="yiyi-191"><em>fresh</em>是在执行导入之前，还从<code class="docutils literal"><span class="pre">sys.modules</span></code>高速缓存中删除的其他模块名称的迭代。</span></p><p><span class="yiyi-st" id="yiyi-192"><em>已阻止</em>是在导入期间在模块高速缓存中替换为<code class="docutils literal"><span class="pre">None</span></code>的模块名称的可迭代，以确保尝试导入它们引发<a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-193">在开始导入之前保存命名的模块以及在<em>新鲜</em>和<em>阻塞</em>参数中命名的任何模块，然后重新插入<code class="docutils literal"><span class="pre">sys.modules</span></code>导入完成。</span></p><p><span class="yiyi-st" id="yiyi-194">如果<em>已弃用</em>为<code class="docutils literal"><span class="pre">True</span></code>，则在导入期间将禁止模块和软件包弃用消息。</span></p><p><span class="yiyi-st" id="yiyi-195">如果无法导入指定的模块，此函数将引发<a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-196">使用示例：</span></p><pre><code class="language-python"><span></span><span class="c1"># Get copies of the warnings module for testing without affecting the</span>
<span class="c1"># version being used by the rest of the test suite. One copy uses the</span>
<span class="c1"># C implementation, the other is forced to use the pure Python fallback</span>
<span class="c1"># implementation</span>
<span class="n">py_warnings</span> <span class="o">=</span> <span class="n">import_fresh_module</span><span class="p">(</span><span class="s1">'warnings'</span><span class="p">,</span> <span class="n">blocked</span><span class="o">=</span><span class="p">[</span><span class="s1">'_warnings'</span><span class="p">])</span>
<span class="n">c_warnings</span> <span class="o">=</span> <span class="n">import_fresh_module</span><span class="p">(</span><span class="s1">'warnings'</span><span class="p">,</span> <span class="n">fresh</span><span class="o">=</span><span class="p">[</span><span class="s1">'_warnings'</span><span class="p">])</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-197"><span class="versionmodified">版本3.1中的新功能。</span></span></p></div></dd></dl><dl class="function"><dt id="test.support.bind_port"><span class="yiyi-st" id="yiyi-198"> <code class="descclassname">test.support.</code><code class="descname">bind_port</code><span class="sig-paren">(</span><em>sock</em>, <em>host=HOST</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-199">将套接字绑定到一个空闲端口并返回端口号。</span><span class="yiyi-st" id="yiyi-200">依靠临时端口，以确保我们使用未绑定的端口。</span><span class="yiyi-st" id="yiyi-201">这很重要，因为许多测试可能同时运行，特别是在buildbot环境中。</span><span class="yiyi-st" id="yiyi-202">此方法在<code class="docutils literal"><span class="pre">sock.family</span></code>为<a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal"><span class="pre">AF_INET</span></code></a>且<code class="docutils literal"><span class="pre">sock.type</span></code>为<a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal"><span class="pre">SOCK_STREAM</span></code></a>时引发异常，且套接字已设置<code class="xref py py-const docutils literal"><span class="pre">SO_REUSEADDR</span></code>或<code class="xref py py-const docutils literal"><span class="pre">SO_REUSEPORT</span></code>。</span><span class="yiyi-st" id="yiyi-203">测试不应该为TCP / IP套接字设置这些套接字选项。</span><span class="yiyi-st" id="yiyi-204">设置这些选项的唯一情况是测试通过多个UDP套接字的多播。</span></p><p><span class="yiyi-st" id="yiyi-205">此外，如果<code class="xref py py-const docutils literal"><span class="pre">SO_EXCLUSIVEADDRUSE</span></code>套接字选项可用（即</span><span class="yiyi-st" id="yiyi-206">在Windows上），它将在套接字上设置。</span><span class="yiyi-st" id="yiyi-207">这将防止任何人在测试期间绑定到我们的主机/端口。</span></p></dd></dl><dl class="function"><dt id="test.support.find_unused_port"><span class="yiyi-st" id="yiyi-208"> <code class="descclassname">test.support.</code><code class="descname">find_unused_port</code><span class="sig-paren">(</span><em>family=socket.AF_INET</em>, <em>socktype=socket.SOCK_STREAM</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-209">返回应该适合绑定的未使用端口。</span><span class="yiyi-st" id="yiyi-210">这是通过创建与<code class="docutils literal"><span class="pre">sock</span></code>参数（默认值为<a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal"><span class="pre">AF_INET</span></code></a>，<a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal"><span class="pre">SOCK_STREAM</span></code></a>）相同的系列和类型的临时套接字并将其绑定到端口设置为0的指定主机地址（默认为<code class="docutils literal"><span class="pre">0.0.0.0</span></code>），从操作系统引出未使用的临时端口。</span><span class="yiyi-st" id="yiyi-211">然后关闭并删除临时套接字，并返回临时端口。</span></p><p><span class="yiyi-st" id="yiyi-212">对于在测试期间需要将服务器套接字绑定到特定端口的任何测试，都应使用此方法或<a class="reference internal" href="#test.support.bind_port" title="test.support.bind_port"><code class="xref py py-func docutils literal"><span class="pre">bind_port()</span></code></a>。</span><span class="yiyi-st" id="yiyi-213">使用哪一个取决于调用代码是否正在创建一个python套接字，或者如果一个未使用的端口需要在构造函数中提供或传递给外部程序。</span><span class="yiyi-st" id="yiyi-214">openssl的s_server模式的<code class="docutils literal"><span class="pre">-accept</span></code>参数）。</span><span class="yiyi-st" id="yiyi-215">始终优先于<a class="reference internal" href="#test.support.find_unused_port" title="test.support.find_unused_port"><code class="xref py py-func docutils literal"><span class="pre">find_unused_port()</span></code></a> <a class="reference internal" href="#test.support.bind_port" title="test.support.bind_port"><code class="xref py py-func docutils literal"><span class="pre">bind_port()</span></code></a>。</span><span class="yiyi-st" id="yiyi-216">不建议使用硬编码端口，因为它可以使多个测试实例无法同时运行，这是buildbots的一个问题。</span></p></dd></dl><dl class="function"><dt id="test.support.load_package_tests"><span class="yiyi-st" id="yiyi-217"> <code class="descclassname">test.support.</code><code class="descname">load_package_tests</code><span class="sig-paren">(</span><em>pkg_dir</em>, <em>loader</em>, <em>standard_tests</em>, <em>pattern</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-218">通用实现用于测试包的<a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal"><span class="pre">unittest</span></code></a> <code class="docutils literal"><span class="pre">load_tests</span></code>协议。</span><span class="yiyi-st" id="yiyi-219"><em>pkg_dir</em>是包的根目录； <em>装载器</em>，<em>standard_tests</em>和<em>模式</em>是<code class="docutils literal"><span class="pre">load_tests</span></code>期望的参数。</span><span class="yiyi-st" id="yiyi-220">在简单的情况下，测试包的<code class="docutils literal"><span class="pre">__init__.py</span></code>可以是：</span></p><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">test.support</span> <span class="k">import</span> <span class="n">load_package_tests</span>

<span class="k">def</span> <span class="nf">load_tests</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">load_package_tests</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">__file__</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</code></pre></dd></dl><dl class="function"><dt><span class="yiyi-st" id="yiyi-221"><code class="descname">detect_api_mismatch（ref_api，other_api，*，ignore =()）：</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-222">返回在<em>other_api</em>中找不到的<em>ref_api</em>的属性集，函数或方法，除了在<em>中指定的此检查中要忽略的项目的定义列表ignore 。</em></span></p><p><span class="yiyi-st" id="yiyi-223">默认情况下，这将跳过以“_”开头的私有属性，但包括所有魔法方法，即</span><span class="yiyi-st" id="yiyi-224">那些开始和结束于'__'。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-225"><span class="versionmodified">版本3.5中的新功能。</span></span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-226"><a class="reference internal" href="#module-test.support" title="test.support: Support for Python's regression test suite."><code class="xref py py-mod docutils literal"><span class="pre">test.support</span></code></a>模块定义以下类：</span></p><dl class="class"><dt id="test.support.TransientResource"><span class="yiyi-st" id="yiyi-227"> <em class="property">class </em><code class="descclassname">test.support.</code><code class="descname">TransientResource</code><span class="sig-paren">(</span><em>exc</em>, <em>**kwargs</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-228">实例是引发<a class="reference internal" href="#test.support.ResourceDenied" title="test.support.ResourceDenied"><code class="xref py py-exc docutils literal"><span class="pre">ResourceDenied</span></code></a>的上下文管理器，如果引发指定的异常类型。</span><span class="yiyi-st" id="yiyi-229">任何关键字参数都被视为属性/值对，以便与在<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>语句中引发的任何异常进行比较。</span><span class="yiyi-st" id="yiyi-230">只有当所有对匹配正确的属性，异常是<a class="reference internal" href="#test.support.ResourceDenied" title="test.support.ResourceDenied"><code class="xref py py-exc docutils literal"><span class="pre">ResourceDenied</span></code></a>引发。</span></p></dd></dl><dl class="class"><dt id="test.support.EnvironmentVarGuard"><span class="yiyi-st" id="yiyi-231"> <em class="property">class </em><code class="descclassname">test.support.</code><code class="descname">EnvironmentVarGuard</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-232">用于临时设置或取消设置环境变量的类。</span><span class="yiyi-st" id="yiyi-233">实例可以用作上下文管理器，并具有完整的字典接口，用于查询/修改底层的<code class="docutils literal"><span class="pre">os.environ</span></code>。</span><span class="yiyi-st" id="yiyi-234">从上下文管理器退出后，通过此实例完成的对环境变量的所有更改将被回滚。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-235"><span class="versionmodified">在版本3.1中已更改：</span>添加了字典界面。</span></p></div></dd></dl><dl class="method"><dt id="test.support.EnvironmentVarGuard.set"><span class="yiyi-st" id="yiyi-236"> <code class="descclassname">EnvironmentVarGuard.</code><code class="descname">set</code><span class="sig-paren">(</span><em>envvar</em>, <em>value</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-237">将环境变量<code class="docutils literal"><span class="pre">envvar</span></code>临时设置为<code class="docutils literal"><span class="pre">value</span></code>的值。</span></p></dd></dl><dl class="method"><dt id="test.support.EnvironmentVarGuard.unset"><span class="yiyi-st" id="yiyi-238"> <code class="descclassname">EnvironmentVarGuard.</code><code class="descname">unset</code><span class="sig-paren">(</span><em>envvar</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-239">暂时取消设置环境变量<code class="docutils literal"><span class="pre">envvar</span></code>。</span></p></dd></dl><dl class="class"><dt id="test.support.SuppressCrashReport"><span class="yiyi-st" id="yiyi-240"> <em class="property">class </em><code class="descclassname">test.support.</code><code class="descname">SuppressCrashReport</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-241">一个上下文管理器，用于在预期会导致子进程崩溃的测试中尝试阻止崩溃对话框弹出。</span></p><p><span class="yiyi-st" id="yiyi-242">在Windows上，它使用<a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680621.aspx">SetErrorMode</a>禁用Windows错误报告对话框。</span></p><p><span class="yiyi-st" id="yiyi-243">在UNIX上，<a class="reference internal" href="resource.html#resource.setrlimit" title="resource.setrlimit"><code class="xref py py-func docutils literal"><span class="pre">resource.setrlimit()</span></code></a>用于将<a class="reference internal" href="resource.html#resource.RLIMIT_CORE" title="resource.RLIMIT_CORE"><code class="xref py py-attr docutils literal"><span class="pre">resource.RLIMIT_CORE</span></code></a>的软限制设置为0，以防止创建coredump文件。</span></p><p><span class="yiyi-st" id="yiyi-244">在这两个平台上，旧值由<a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a>恢复。</span></p></dd></dl><dl class="class"><dt id="test.support.WarningsRecorder"><span class="yiyi-st" id="yiyi-245"> <em class="property">class </em><code class="descclassname">test.support.</code><code class="descname">WarningsRecorder</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-246">用于记录单元测试警告的类。</span><span class="yiyi-st" id="yiyi-247">有关详细信息，请参阅上面的<a class="reference internal" href="#test.support.check_warnings" title="test.support.check_warnings"><code class="xref py py-func docutils literal"><span class="pre">check_warnings()</span></code></a>文档。</span></p></dd></dl></div></div>