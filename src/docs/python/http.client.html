<div class="body" role="main"><div class="section" id="module-http.client"><h1><span class="yiyi-st" id="yiyi-10">21.12。 <a class="reference internal" href="#module-http.client" title="http.client: HTTP and HTTPS protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">http.client</span></code></a>  -  HTTP协议客户端</span></h1><p><span class="yiyi-st" id="yiyi-11"><strong>源码:</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/http/client.py">Lib/http/client.py</a></span></p><p><span class="yiyi-st" id="yiyi-12">本模块定义了HTTP和HTTPS协议的客户端实现。</span><span class="yiyi-st" id="yiyi-13">通常来说，该模块不能直接使用，需要模块<a class="reference internal" href="urllib.request.html#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal"><span class="pre">urllib.request</span></code></a>调用该模块来处理使用HTTP和HTTPS的URL。</span></p><div class="admonition seealso"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-14">参考</span></p><p class="last"><span class="yiyi-st" id="yiyi-15">推荐使用<a class="reference external" href="https://requests.readthedocs.org/">Requests package</a>包处理高级别HTTP客户端接口。</span></p></div><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-16">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-17">仅当Python通过SSL支持（通过<a class="reference internal" href="ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal"><span class="pre">ssl</span></code></a>模块）进行编译时，HTTPS支持才可用。</span></p></div><p><span class="yiyi-st" id="yiyi-18">本模块提供以下类：</span></p><dl class="class"><dt id="http.client.HTTPConnection"><span class="yiyi-st" id="yiyi-19"> <em class="property">class </em><code class="descclassname">http.client.</code><code class="descname">HTTPConnection</code><span class="sig-paren">(</span><em>host</em>, <em>port=None</em>, <span class="optional">[</span><em>timeout</em>, <span class="optional">]</span><em>source_address=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-20">一个 <a class="reference internal" href="#http.client.HTTPConnection" title="http.client.HTTPConnection"><code class="xref py py-class docutils literal"><span class="pre">HTTPConnection</span></code></a>实例表示与HTTP服务器端的一次事务。</span><span class="yiyi-st" id="yiyi-21">通过传参host地址和端口号进行实例化。</span><span class="yiyi-st" id="yiyi-22">没有端口号传参，也可以通过host传参，形式同<code class="docutils literal"><span class="pre">host:port</span></code>，都没有的话，默认端口号为80。</span><span class="yiyi-st" id="yiyi-23">如果可选参数 <em>timeout</em>给出传参，阻塞操作（如连接）将在给出的秒数后超时（如果未给出该参数，默认使用全局默认超时设置值）。</span><span class="yiyi-st" id="yiyi-24">可选参数<em>source_address</em>可以是一个元组，形式同 (host, port)，作为HTTP链接的源地址使用。</span></p><p><span class="yiyi-st" id="yiyi-25">示例，下面几个调用都创建了实例，都是指向同个地址同个端口的服务器端的链接。见下：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h1</span> <span class="o">=</span> <span class="n">http</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">HTTPConnection</span><span class="p">(</span><span class="s1">'www.python.org'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h2</span> <span class="o">=</span> <span class="n">http</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">HTTPConnection</span><span class="p">(</span><span class="s1">'www.python.org:80'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h3</span> <span class="o">=</span> <span class="n">http</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">HTTPConnection</span><span class="p">(</span><span class="s1">'www.python.org'</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h4</span> <span class="o">=</span> <span class="n">http</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">HTTPConnection</span><span class="p">(</span><span class="s1">'www.python.org'</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</code></pre><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-26"><span class="versionmodified">在版本3.2中更改：</span> <em>source_address</em>已添加。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-27"><span class="versionmodified">在版本3.4中已更改：</span>已删除<em>严格</em>参数。</span><span class="yiyi-st" id="yiyi-28">不再支持HTTP 0.9样式的“简单响应”。</span></p></div></dd></dl><dl class="class"><dt id="http.client.HTTPSConnection"><span class="yiyi-st" id="yiyi-29"> <em class="property">class </em><code class="descclassname">http.client.</code><code class="descname">HTTPSConnection</code><span class="sig-paren">(</span><em>host</em>, <em>port=None</em>, <em>key_file=None</em>, <em>cert_file=None</em>, <span class="optional">[</span><em>timeout</em>, <span class="optional">]</span><em>source_address=None</em>, <em>*</em>, <em>context=None</em>, <em>check_hostname=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-30">该类是 <a class="reference internal" href="#http.client.HTTPConnection" title="http.client.HTTPConnection"><code class="xref py py-class docutils literal"><span class="pre">HTTPConnection</span></code></a>的子类，使用SSL，用于与服务器端的安全通信。</span><span class="yiyi-st" id="yiyi-31">默认端口是 <code class="docutils literal"><span class="pre">443</span></code>。</span><span class="yiyi-st" id="yiyi-32">如果需要指定上下文<em>context</em>，必须使用 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">ssl.SSLContext</span></code></a>实例化，它用于描述不同的SSL选项。</span></p><p><span class="yiyi-st" id="yiyi-33"><em>key_file</em>和<em>cert_file</em>已被弃用，请改用<a class="reference internal" href="ssl.html#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal"><span class="pre">ssl.SSLContext.load_cert_chain()</span></code></a>或让<a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal"><span class="pre">ssl.create_default_context()</span></code></a>为您选择系统的受信任的CA证书。</span><span class="yiyi-st" id="yiyi-34"><em>check_hostname</em>参数也已弃用；应使用<em>上下文</em>的<a class="reference internal" href="ssl.html#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal"><span class="pre">ssl.SSLContext.check_hostname</span></code></a>属性。</span></p><p><span class="yiyi-st" id="yiyi-35">有关最佳做法的详情，请参阅<a class="reference internal" href="ssl.html#ssl-security"><span>Security considerations</span></a>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-36"><span class="versionmodified">在版本3.2中更改：</span> <em>源地址</em>，<em>上下文</em>和<em>check_hostname</em>已添加。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-37"><span class="versionmodified">在版本3.2中更改：</span>此类现在支持HTTPS虚拟主机（如果可能的话）（即，如果<a class="reference internal" href="ssl.html#ssl.HAS_SNI" title="ssl.HAS_SNI"><code class="xref py py-data docutils literal"><span class="pre">ssl.HAS_SNI</span></code></a>为true）。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-38"><span class="versionmodified">在版本3.4中已更改：</span>已删除<em>严格</em>参数。</span><span class="yiyi-st" id="yiyi-39">不再支持HTTP 0.9样式的“简单响应”。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-40"><span class="versionmodified">在版本3.4.3中更改：</span>此类现在默认执行所有必需的证书和主机名检查。</span><span class="yiyi-st" id="yiyi-41">要还原到上一个未验证的行为，<code class="xref py py-func docutils literal"><span class="pre">ssl._create_unverified_context()</span></code>可以传递到<em>上下文</em>参数。</span></p></div></dd></dl><dl class="class"><dt id="http.client.HTTPResponse"><span class="yiyi-st" id="yiyi-42"> <em class="property">class </em><code class="descclassname">http.client.</code><code class="descname">HTTPResponse</code><span class="sig-paren">(</span><em>sock</em>, <em>debuglevel=0</em>, <em>method=None</em>, <em>url=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-43">该类是在连接成功后返回的实例。</span><span class="yiyi-st" id="yiyi-44">不需要用户直接实例化。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-45"><span class="versionmodified">在版本3.4中已更改：</span>已删除<em>严格</em>参数。</span><span class="yiyi-st" id="yiyi-46">不再支持HTTP 0.9样式“简单响应”。</span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-47">可能会涉及到的异常类，见下：</span></p><dl class="exception"><dt id="http.client.HTTPException"><span class="yiyi-st" id="yiyi-48"> <em class="property">exception </em><code class="descclassname">http.client.</code><code class="descname">HTTPException</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-49">是本模块内其他异常的基类。</span><span class="yiyi-st" id="yiyi-50">本身是 <a class="reference internal" href="exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal"><span class="pre">Exception</span></code></a>类的子类。</span></p></dd></dl><dl class="exception"><dt id="http.client.NotConnected"><span class="yiyi-st" id="yiyi-51"> <em class="property">exception </em><code class="descclassname">http.client.</code><code class="descname">NotConnected</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-52">是 <a class="reference internal" href="#http.client.HTTPException" title="http.client.HTTPException"><code class="xref py py-exc docutils literal"><span class="pre">HTTPException</span></code></a>类的子类。</span></p></dd></dl><dl class="exception"><dt id="http.client.InvalidURL"><span class="yiyi-st" id="yiyi-53"> <em class="property">exception </em><code class="descclassname">http.client.</code><code class="descname">InvalidURL</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-54">是 <a class="reference internal" href="#http.client.HTTPException" title="http.client.HTTPException"><code class="xref py py-exc docutils literal"><span class="pre">HTTPException</span></code></a>类的子类，如果端口号传参为空或不是数字型的，都会引起该异常。</span></p></dd></dl><dl class="exception"><dt id="http.client.UnknownProtocol"><span class="yiyi-st" id="yiyi-55"> <em class="property">exception </em><code class="descclassname">http.client.</code><code class="descname">UnknownProtocol</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-56">是<a class="reference internal" href="#http.client.HTTPException" title="http.client.HTTPException"><code class="xref py py-exc docutils literal"><span class="pre">HTTPException</span></code></a>类的子类。</span></p></dd></dl><dl class="exception"><dt id="http.client.UnknownTransferEncoding"><span class="yiyi-st" id="yiyi-57"> <em class="property">exception </em><code class="descclassname">http.client.</code><code class="descname">UnknownTransferEncoding</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-58">是<a class="reference internal" href="#http.client.HTTPException" title="http.client.HTTPException"><code class="xref py py-exc docutils literal"><span class="pre">HTTPException</span></code></a>类的子类。</span></p></dd></dl><dl class="exception"><dt id="http.client.UnimplementedFileMode"><span class="yiyi-st" id="yiyi-59"> <em class="property">exception </em><code class="descclassname">http.client.</code><code class="descname">UnimplementedFileMode</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-60">是<a class="reference internal" href="#http.client.HTTPException" title="http.client.HTTPException"><code class="xref py py-exc docutils literal"><span class="pre">HTTPException</span></code></a>类的子类。</span></p></dd></dl><dl class="exception"><dt id="http.client.IncompleteRead"><span class="yiyi-st" id="yiyi-61"> <em class="property">exception </em><code class="descclassname">http.client.</code><code class="descname">IncompleteRead</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-62">是<a class="reference internal" href="#http.client.HTTPException" title="http.client.HTTPException"><code class="xref py py-exc docutils literal"><span class="pre">HTTPException</span></code></a>类的子类。</span></p></dd></dl><dl class="exception"><dt id="http.client.ImproperConnectionState"><span class="yiyi-st" id="yiyi-63"> <em class="property">exception </em><code class="descclassname">http.client.</code><code class="descname">ImproperConnectionState</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-64">是<a class="reference internal" href="#http.client.HTTPException" title="http.client.HTTPException"><code class="xref py py-exc docutils literal"><span class="pre">HTTPException</span></code></a>类的子类。</span></p></dd></dl><dl class="exception"><dt id="http.client.CannotSendRequest"><span class="yiyi-st" id="yiyi-65"> <em class="property">exception </em><code class="descclassname">http.client.</code><code class="descname">CannotSendRequest</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-66">是 <a class="reference internal" href="#http.client.ImproperConnectionState" title="http.client.ImproperConnectionState"><code class="xref py py-exc docutils literal"><span class="pre">ImproperConnectionState</span></code></a>类的子类。</span></p></dd></dl><dl class="exception"><dt id="http.client.CannotSendHeader"><span class="yiyi-st" id="yiyi-67"> <em class="property">exception </em><code class="descclassname">http.client.</code><code class="descname">CannotSendHeader</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-68">是 <a class="reference internal" href="#http.client.ImproperConnectionState" title="http.client.ImproperConnectionState"><code class="xref py py-exc docutils literal"><span class="pre">ImproperConnectionState</span></code></a>类的子类。</span></p></dd></dl><dl class="exception"><dt id="http.client.ResponseNotReady"><span class="yiyi-st" id="yiyi-69"> <em class="property">exception </em><code class="descclassname">http.client.</code><code class="descname">ResponseNotReady</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-70">是 <a class="reference internal" href="#http.client.ImproperConnectionState" title="http.client.ImproperConnectionState"><code class="xref py py-exc docutils literal"><span class="pre">ImproperConnectionState</span></code></a>类的子类。</span></p></dd></dl><dl class="exception"><dt id="http.client.BadStatusLine"><span class="yiyi-st" id="yiyi-71"> <em class="property">exception </em><code class="descclassname">http.client.</code><code class="descname">BadStatusLine</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-72">是 <a class="reference internal" href="#http.client.HTTPException" title="http.client.HTTPException"><code class="xref py py-exc docutils literal"><span class="pre">HTTPException</span></code></a>类的子类。</span><span class="yiyi-st" id="yiyi-73">如果服务器端响应的HTTP状态码是我们所不知道的就会引起该异常。</span></p></dd></dl><dl class="exception"><dt id="http.client.LineTooLong"><span class="yiyi-st" id="yiyi-74"> <em class="property">exception </em><code class="descclassname">http.client.</code><code class="descname">LineTooLong</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-75">是 <a class="reference internal" href="#http.client.HTTPException" title="http.client.HTTPException"><code class="xref py py-exc docutils literal"><span class="pre">HTTPException</span></code></a>类的子类。</span><span class="yiyi-st" id="yiyi-76">如果从服务器端收到超长行的HTTP协议内容就会引起该异常。</span></p></dd></dl><dl class="exception"><dt id="http.client.RemoteDisconnected"><span class="yiyi-st" id="yiyi-77"> <em class="property">exception </em><code class="descclassname">http.client.</code><code class="descname">RemoteDisconnected</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-78">是 <a class="reference internal" href="exceptions.html#ConnectionResetError" title="ConnectionResetError"><code class="xref py py-exc docutils literal"><span class="pre">ConnectionResetError</span></code></a>类和 <a class="reference internal" href="#http.client.BadStatusLine" title="http.client.BadStatusLine"><code class="xref py py-exc docutils literal"><span class="pre">BadStatusLine</span></code></a>类的子类。</span><span class="yiyi-st" id="yiyi-79">由方法 <a class="reference internal" href="#http.client.HTTPConnection.getresponse" title="http.client.HTTPConnection.getresponse"><code class="xref py py-meth docutils literal"><span class="pre">HTTPConnection.getresponse()</span></code></a>引起，当试图读取连接的响应结果时，读取不到数据，意味着远端已关闭了连接。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-80"><span class="versionmodified">版本3.5中的新功能：</span>以前，<a class="reference internal" href="#http.client.BadStatusLine" title="http.client.BadStatusLine"><code class="xref py py-exc docutils literal"><span class="pre">BadStatusLine</span></code></a> <code class="docutils literal"><span class="pre">('')</span></code></span></p></div></dd></dl><p><span class="yiyi-st" id="yiyi-81">本模块中定义的常量包括：</span></p><dl class="data"><dt id="http.client.HTTP_PORT"><span class="yiyi-st" id="yiyi-82"> <code class="descclassname">http.client.</code><code class="descname">HTTP_PORT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-83">HTTP协议的默认端口值（总为 <code class="docutils literal"><span class="pre">80</span></code>）。</span></p></dd></dl><dl class="data"><dt id="http.client.HTTPS_PORT"><span class="yiyi-st" id="yiyi-84"> <code class="descclassname">http.client.</code><code class="descname">HTTPS_PORT</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-85">HTTPS协议的默认端口值（总为 <code class="docutils literal"><span class="pre">443</span></code>）。</span></p></dd></dl><dl class="data"><dt id="http.client.responses"><span class="yiyi-st" id="yiyi-86"> <code class="descclassname">http.client.</code><code class="descname">responses</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-87">该字典类匹配HTTP1.1状态码在W3C中的命名。</span></p><p><span class="yiyi-st" id="yiyi-88">Example: <code class="docutils literal"><span class="pre">http.client.responses[http.client.NOT_FOUND]</span></code> 就是 <code class="docutils literal"><span class="pre">'Not</span> <span class="pre">Found'</span></code>.</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-89">本模块中HTTP状态码的常量值列表可参考<a class="reference internal" href="http.html#http-status-codes"><span>HTTP status codes</span></a>。</span></p><div class="section" id="httpconnection-objects"><h2><span class="yiyi-st" id="yiyi-90">21.12.1. </span><span class="yiyi-st" id="yiyi-91">HTTPConnection对象</span></h2><p><span class="yiyi-st" id="yiyi-92"><a class="reference internal" href="#http.client.HTTPConnection" title="http.client.HTTPConnection"><code class="xref py py-class docutils literal"><span class="pre">HTTPConnection</span></code></a> 实例拥有方法如下：</span></p><dl class="method"><dt id="http.client.HTTPConnection.request"><span class="yiyi-st" id="yiyi-93"> <code class="descclassname">HTTPConnection.</code><code class="descname">request</code><span class="sig-paren">(</span><em>method</em>, <em>url</em>, <em>body=None</em>, <em>headers={}</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-94">该方法会向服务器端发送一个请求，入参为HTTP请求方法<em>method</em>和选择器<em>url</em>。</span></p><p><span class="yiyi-st" id="yiyi-95">如果指定了入参body ，那么在 <em>headers</em>发送完成后就发送body的数据。</span><span class="yiyi-st" id="yiyi-96">它可能是一个字符串、 一个 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">类似字节对象</span></a>、 打开的 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">文件对象</span></a>，或可迭代的 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">类似字节对象</span></a> 。如果 <em>body</em> 是一个字符串，它按 ISO-8859-1进行编码，默认 HTTP 。</span><span class="yiyi-st" id="yiyi-97">如果body是一个类似字节对象，按字节发送。</span><span class="yiyi-st" id="yiyi-98">如果body是一个 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">文件对象</span></a>，发送的是文件的内容；这个文件对象至少可支持 <code class="docutils literal"><span class="pre">read()</span></code> 方法。</span><span class="yiyi-st" id="yiyi-99">If the file object has a <code class="docutils literal"><span class="pre">mode</span></code> attribute, the data returned by the <code class="docutils literal"><span class="pre">read()</span></code> method will be encoded as ISO-8859-1 unless the <code class="docutils literal"><span class="pre">mode</span></code> attribute contains the substring <code class="docutils literal"><span class="pre">b</span></code>, otherwise the data returned by <code class="docutils literal"><span class="pre">read()</span></code> is sent as is. </span><span class="yiyi-st" id="yiyi-100">如果<em>body</em>是可迭代的，则可迭代的元素按照原样发送，直到可迭代被耗尽。</span></p><p><span class="yiyi-st" id="yiyi-101">参数 <em>headers</em> 应该是附带的HTTP报文头的映射，与请求一起发送。</span></p><p><span class="yiyi-st" id="yiyi-102">如果参数 <em>headers</em> 不包括内容长度项，那么就自动添加一个。</span><span class="yiyi-st" id="yiyi-103">如果<em>body</em>为<code class="docutils literal"><span class="pre">None</span></code>，那么对于需要body的方法（<code class="docutils literal"><span class="pre">PUT</span></code>），Content-Length标头设置为<code class="docutils literal"><span class="pre">0</span></code> ，<code class="docutils literal"><span class="pre">POST</span></code>和<code class="docutils literal"><span class="pre">PATCH</span></code>）。</span><span class="yiyi-st" id="yiyi-104">如果<em>body</em>是字符串或字节对象，则将Content-Length头设置为其长度。</span><span class="yiyi-st" id="yiyi-105">如果<em>body</em>是一个<a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>，并且它的作用是对<code class="docutils literal"><span class="pre">fileno()</span></code>的结果调用<a class="reference internal" href="os.html#os.fstat" title="os.fstat"><code class="xref py py-func docutils literal"><span class="pre">fstat()</span></code></a>方法，那么Content-Length头部被设置为由<code class="docutils literal"><span class="pre">fstat</span></code>调用报告的<code class="docutils literal"><span class="pre">st_size</span></code>。</span><span class="yiyi-st" id="yiyi-106">否则不添加Content-Length头。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-107"><span class="versionmodified">版本3.2中的新功能：</span> <em>正文</em>现在可以是可迭代的。</span></p></div></dd></dl><dl class="method"><dt id="http.client.HTTPConnection.getresponse"><span class="yiyi-st" id="yiyi-108"> <code class="descclassname">HTTPConnection.</code><code class="descname">getresponse</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-109">应该在发送请求后调用以从服务器获取响应。</span><span class="yiyi-st" id="yiyi-110">返回<a class="reference internal" href="#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal"><span class="pre">HTTPResponse</span></code></a>实例。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-111">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-112">请注意，您必须先阅读完整的响应，然后才能向服务器发送新的请求。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-113"><span class="versionmodified">在版本3.5中已更改：</span>如果发生<a class="reference internal" href="exceptions.html#ConnectionError" title="ConnectionError"><code class="xref py py-exc docutils literal"><span class="pre">ConnectionError</span></code></a>或子类，则在发送新请求时，<a class="reference internal" href="#http.client.HTTPConnection" title="http.client.HTTPConnection"><code class="xref py py-class docutils literal"><span class="pre">HTTPConnection</span></code></a>对象将准备重新连接。</span></p></div></dd></dl><dl class="method"><dt id="http.client.HTTPConnection.set_debuglevel"><span class="yiyi-st" id="yiyi-114"> <code class="descclassname">HTTPConnection.</code><code class="descname">set_debuglevel</code><span class="sig-paren">(</span><em>level</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-115">设置调试级别。</span><span class="yiyi-st" id="yiyi-116">默认调试级别为<code class="docutils literal"><span class="pre">0</span></code>，表示不打印调试输出。</span><span class="yiyi-st" id="yiyi-117">任何大于<code class="docutils literal"><span class="pre">0</span></code>的值都将导致所有当前定义的调试输出被打印到stdout。</span><span class="yiyi-st" id="yiyi-118"><code class="docutils literal"><span class="pre">debuglevel</span></code>会传递到创建的任何新<a class="reference internal" href="#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal"><span class="pre">HTTPResponse</span></code></a>对象。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-119"><span class="versionmodified">版本3.1中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="http.client.HTTPConnection.set_tunnel"><span class="yiyi-st" id="yiyi-120"> <code class="descclassname">HTTPConnection.</code><code class="descname">set_tunnel</code><span class="sig-paren">(</span><em>host</em>, <em>port=None</em>, <em>headers=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-121">设置HTTP Connect隧道的主机和端口。</span><span class="yiyi-st" id="yiyi-122">这允许通过代理服务器运行连接。</span></p><p><span class="yiyi-st" id="yiyi-123">主机和端口参数指定隧道连接的端点（即，</span><span class="yiyi-st" id="yiyi-124">CONNECT请求中包含的地址，<em>不是</em>代理服务器的地址）。</span></p><p><span class="yiyi-st" id="yiyi-125">headers参数应该是使用CONNECT请求发送的额外HTTP头的映射。</span></p><p><span class="yiyi-st" id="yiyi-126">例如，要通过在端口8080上本地运行的HTTPS代理服务器进行隧道传输，我们会将代理的地址传递到<a class="reference internal" href="#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal"><span class="pre">HTTPSConnection</span></code></a>构造函数，以及我们最终想要访问的主机地址<a class="reference internal" href="#http.client.HTTPConnection.set_tunnel" title="http.client.HTTPConnection.set_tunnel"><code class="xref py py-meth docutils literal"><span class="pre">set_tunnel()</span></code></a>方法：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">http.client</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span> <span class="o">=</span> <span class="n">http</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">HTTPSConnection</span><span class="p">(</span><span class="s2">"localhost"</span><span class="p">,</span> <span class="mi">8080</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">set_tunnel</span><span class="p">(</span><span class="s2">"www.python.org"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">request</span><span class="p">(</span><span class="s2">"HEAD"</span><span class="p">,</span><span class="s2">"/index.html"</span><span class="p">)</span>
</code></pre><div class="versionadded"><p><span class="yiyi-st" id="yiyi-127"><span class="versionmodified">版本3.2中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="http.client.HTTPConnection.connect"><span class="yiyi-st" id="yiyi-128"> <code class="descclassname">HTTPConnection.</code><code class="descname">connect</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-129">连接到创建对象时指定的服务器。</span><span class="yiyi-st" id="yiyi-130">默认情况下，如果客户端没有连接，则在发出请求时会自动调用。</span></p></dd></dl><dl class="method"><dt id="http.client.HTTPConnection.close"><span class="yiyi-st" id="yiyi-131"> <code class="descclassname">HTTPConnection.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-132">关闭与服务器的连接。</span></p></dd></dl><p><span class="yiyi-st" id="yiyi-133">作为使用上述<code class="xref py py-meth docutils literal"><span class="pre">request()</span></code>方法的替代方法，您还可以使用以下四个函数逐步发送请求。</span></p><dl class="method"><dt id="http.client.HTTPConnection.putrequest"><span class="yiyi-st" id="yiyi-134"> <code class="descclassname">HTTPConnection.</code><code class="descname">putrequest</code><span class="sig-paren">(</span><em>request</em>, <em>selector</em>, <em>skip_host=False</em>, <em>skip_accept_encoding=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-135">这应该是在连接到服务器之后的第一个调用。</span><span class="yiyi-st" id="yiyi-136">它向由<em>请求</em>字符串，<em>选择器</em>字符串和HTTP版本（<code class="docutils literal"><span class="pre">HTTP/1.1</span></code>）组成的服务器发送一行。</span><span class="yiyi-st" id="yiyi-137">要禁止自动发送<code class="docutils literal"><span class="pre">Host:</span></code>或<code class="docutils literal"><span class="pre">Accept-Encoding:</span></code>标头（例如接受附加内容编码），请指定<em>skip_host</em>或<em>skip_accept_encoding</em>与非False值。</span></p></dd></dl><dl class="method"><dt id="http.client.HTTPConnection.putheader"><span class="yiyi-st" id="yiyi-138"> <code class="descclassname">HTTPConnection.</code><code class="descname">putheader</code><span class="sig-paren">(</span><em>header</em>, <em>argument</em><span class="optional">[</span>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-139">向服务器发送<span class="target" id="index-2"></span> <a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a>类型头文件。</span><span class="yiyi-st" id="yiyi-140">它发送一行到服务器，包括头，冒号和空格，以及第一个参数。</span><span class="yiyi-st" id="yiyi-141">如果给出更多的参数，则发送连续行，每行由一个制表符和一个参数组成。</span></p></dd></dl><dl class="method"><dt id="http.client.HTTPConnection.endheaders"><span class="yiyi-st" id="yiyi-142"> <code class="descclassname">HTTPConnection.</code><code class="descname">endheaders</code><span class="sig-paren">(</span><em>message_body=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-143">发送空白行到服务器，用信号通知头的结束。</span><span class="yiyi-st" id="yiyi-144">可选的<em>message_body</em>参数可用于传递与请求相关联的消息体。</span><span class="yiyi-st" id="yiyi-145">如果消息头是字符串，消息体将与消息头在相同的分组中发送，否则它将在单独的分组中发送。</span></p></dd></dl><dl class="method"><dt id="http.client.HTTPConnection.send"><span class="yiyi-st" id="yiyi-146"> <code class="descclassname">HTTPConnection.</code><code class="descname">send</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-147">将数据发送到服务器。</span><span class="yiyi-st" id="yiyi-148">只有在调用<a class="reference internal" href="#http.client.HTTPConnection.endheaders" title="http.client.HTTPConnection.endheaders"><code class="xref py py-meth docutils literal"><span class="pre">endheaders()</span></code></a>方法和调用<a class="reference internal" href="#http.client.HTTPConnection.getresponse" title="http.client.HTTPConnection.getresponse"><code class="xref py py-meth docutils literal"><span class="pre">getresponse()</span></code></a>之前，才应该直接使用此方法。</span></p></dd></dl></div><div class="section" id="httpresponse-objects"><h2><span class="yiyi-st" id="yiyi-149">21.12.2. </span><span class="yiyi-st" id="yiyi-150">HTTPResponse对象</span></h2><p><span class="yiyi-st" id="yiyi-151"><a class="reference internal" href="#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal"><span class="pre">HTTPResponse</span></code></a>实例包装来自服务器的HTTP响应。</span><span class="yiyi-st" id="yiyi-152">它提供对请求标头和实体主体的访问。</span><span class="yiyi-st" id="yiyi-153">响应是一个可迭代的对象，可以在with语句中使用。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-154"><span class="versionmodified">在3.5版中已更改：</span>现在实现了<a class="reference internal" href="io.html#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">io.BufferedIOBase</span></code></a>界面，并支持其所有阅读器操作。</span></p></div><dl class="method"><dt id="http.client.HTTPResponse.read"><span class="yiyi-st" id="yiyi-155"> <code class="descclassname">HTTPResponse.</code><code class="descname">read</code><span class="sig-paren">(</span><span class="optional">[</span><em>amt</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-156">读取并返回响应正文或直到下一个<em>amt</em>字节。</span></p></dd></dl><dl class="method"><dt id="http.client.HTTPResponse.readinto"><span class="yiyi-st" id="yiyi-157"> <code class="descclassname">HTTPResponse.</code><code class="descname">readinto</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-158">读取响应主体的下一个len（b）字节到缓冲区<em>b</em>中。</span><span class="yiyi-st" id="yiyi-159">返回读取的字节数。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-160"><span class="versionmodified">版本3.3中的新功能。</span></span></p></div></dd></dl><dl class="method"><dt id="http.client.HTTPResponse.getheader"><span class="yiyi-st" id="yiyi-161"> <code class="descclassname">HTTPResponse.</code><code class="descname">getheader</code><span class="sig-paren">(</span><em>name</em>, <em>default=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-162">如果没有与<em>名称</em>匹配的标头，请返回标头<em>name</em>或<em>默认</em>的值。</span><span class="yiyi-st" id="yiyi-163">如果有多个头名称<em>name</em>，则返回由'，'连接的所有值。</span><span class="yiyi-st" id="yiyi-164">如果'default'是除了单个字符串之外的任何可迭代，它的元素类似地返回用逗号连接。</span></p></dd></dl><dl class="method"><dt id="http.client.HTTPResponse.getheaders"><span class="yiyi-st" id="yiyi-165"> <code class="descclassname">HTTPResponse.</code><code class="descname">getheaders</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-166">返回（标题，值）元组的列表。</span></p></dd></dl><dl class="method"><dt id="http.client.HTTPResponse.fileno"><span class="yiyi-st" id="yiyi-167"> <code class="descclassname">HTTPResponse.</code><code class="descname">fileno</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-168">返回底层套接字的<code class="docutils literal"><span class="pre">fileno</span></code>。</span></p></dd></dl><dl class="attribute"><dt id="http.client.HTTPResponse.msg"><span class="yiyi-st" id="yiyi-169"> <code class="descclassname">HTTPResponse.</code><code class="descname">msg</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-170">包含响应标头的<code class="xref py py-class docutils literal"><span class="pre">http.client.HTTPMessage</span></code>实例。</span><span class="yiyi-st" id="yiyi-171"><code class="xref py py-class docutils literal"><span class="pre">http.client.HTTPMessage</span></code>是<a class="reference internal" href="email.message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal"><span class="pre">email.message.Message</span></code></a>的子类。</span></p></dd></dl><dl class="attribute"><dt id="http.client.HTTPResponse.version"><span class="yiyi-st" id="yiyi-172"> <code class="descclassname">HTTPResponse.</code><code class="descname">version</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-173">服务器使用的HTTP协议版本。</span><span class="yiyi-st" id="yiyi-174">10用于HTTP / 1.0，11用于HTTP / 1.1。</span></p></dd></dl><dl class="attribute"><dt id="http.client.HTTPResponse.status"><span class="yiyi-st" id="yiyi-175"> <code class="descclassname">HTTPResponse.</code><code class="descname">status</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-176">服务器返回的状态代码。</span></p></dd></dl><dl class="attribute"><dt id="http.client.HTTPResponse.reason"><span class="yiyi-st" id="yiyi-177"> <code class="descclassname">HTTPResponse.</code><code class="descname">reason</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-178">服务器返回的原因短语。</span></p></dd></dl><dl class="attribute"><dt id="http.client.HTTPResponse.debuglevel"><span class="yiyi-st" id="yiyi-179"> <code class="descclassname">HTTPResponse.</code><code class="descname">debuglevel</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-180">调试挂钩。</span><span class="yiyi-st" id="yiyi-181">如果<a class="reference internal" href="#http.client.HTTPResponse.debuglevel" title="http.client.HTTPResponse.debuglevel"><code class="xref py py-attr docutils literal"><span class="pre">debuglevel</span></code></a>大于零，则会在读取和解析响应时将消息打印到stdout。</span></p></dd></dl><dl class="attribute"><dt id="http.client.HTTPResponse.closed"><span class="yiyi-st" id="yiyi-182"> <code class="descclassname">HTTPResponse.</code><code class="descname">closed</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-183">如果流已关闭，则为<code class="docutils literal"><span class="pre">True</span></code>。</span></p></dd></dl></div><div class="section" id="examples"><h2><span class="yiyi-st" id="yiyi-184">21.12.3. </span><span class="yiyi-st" id="yiyi-185">示例</span></h2><p><span class="yiyi-st" id="yiyi-186">使用 <code class="docutils literal"><span class="pre">GET</span></code>方法的示例：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">http.client</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span> <span class="o">=</span> <span class="n">http</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">HTTPSConnection</span><span class="p">(</span><span class="s2">"www.python.org"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">request</span><span class="p">(</span><span class="s2">"GET"</span><span class="p">,</span> <span class="s2">"/"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">getresponse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">r1</span><span class="o">.</span><span class="n">status</span><span class="p">,</span> <span class="n">r1</span><span class="o">.</span><span class="n">reason</span><span class="p">)</span>
<span class="go">200 OK</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data1</span> <span class="o">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>  <span class="c1"># This will return entire content.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The following example demonstrates reading data in chunks.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">request</span><span class="p">(</span><span class="s2">"GET"</span><span class="p">,</span> <span class="s2">"/"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">getresponse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="ow">not</span> <span class="n">r1</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">r1</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">200</span><span class="p">))</span>  <span class="c1"># 200 bytes</span>
<span class="go">b'&lt;!doctype html&gt;\n&lt;!--[if"...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of an invalid request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">request</span><span class="p">(</span><span class="s2">"GET"</span><span class="p">,</span> <span class="s2">"/parrot.spam"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">getresponse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">r2</span><span class="o">.</span><span class="n">status</span><span class="p">,</span> <span class="n">r2</span><span class="o">.</span><span class="n">reason</span><span class="p">)</span>
<span class="go">404 Not Found</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data2</span> <span class="o">=</span> <span class="n">r2</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre><p><span class="yiyi-st" id="yiyi-187">使用 <code class="docutils literal"><span class="pre">HEAD</span></code> 方法的示例</span><span class="yiyi-st" id="yiyi-188">，注意<code class="docutils literal"><span class="pre">HEAD</span></code> 方法不返回任何数据。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">http.client</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span> <span class="o">=</span> <span class="n">http</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">HTTPSConnection</span><span class="p">(</span><span class="s2">"www.python.org"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">request</span><span class="p">(</span><span class="s2">"HEAD"</span><span class="p">,</span> <span class="s2">"/"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">getresponse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">status</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">reason</span><span class="p">)</span>
<span class="go">200 OK</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">==</span> <span class="n">b</span><span class="s1">''</span>
<span class="go">True</span>
</code></pre><p><span class="yiyi-st" id="yiyi-189">使用 <code class="docutils literal"><span class="pre">POST</span></code> 请求的示例：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">http.client</span><span class="o">,</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">params</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s1">'@number'</span><span class="p">:</span> <span class="mi">12524</span><span class="p">,</span> <span class="s1">'@type'</span><span class="p">:</span> <span class="s1">'issue'</span><span class="p">,</span> <span class="s1">'@action'</span><span class="p">:</span> <span class="s1">'show'</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">headers</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"Content-type"</span><span class="p">:</span> <span class="s2">"application/x-www-form-urlencoded"</span><span class="p">,</span>
<span class="gp">... </span>           <span class="s2">"Accept"</span><span class="p">:</span> <span class="s2">"text/plain"</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span> <span class="o">=</span> <span class="n">http</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">HTTPConnection</span><span class="p">(</span><span class="s2">"bugs.python.org"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">request</span><span class="p">(</span><span class="s2">"POST"</span><span class="p">,</span> <span class="s2">""</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">headers</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">getresponse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">status</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">reason</span><span class="p">)</span>
<span class="go">302 Found</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">b'Redirecting to &lt;a href="http://bugs.python.org/issue12524"&gt;http://bugs.python.org/issue12524&lt;/a&gt;'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre><p><span class="yiyi-st" id="yiyi-190">客户端<code class="docutils literal"><span class="pre">HTTP</span> <span class="pre">PUT</span></code>请求与<code class="docutils literal"><span class="pre">POST</span></code>请求非常相似。</span><span class="yiyi-st" id="yiyi-191">区别仅在于服务器端，HTTP服务器将允许通过<code class="docutils literal"><span class="pre">PUT</span></code>请求创建资源。</span><span class="yiyi-st" id="yiyi-192">应该注意的是，自定义HTTP方法+也通过发送适当的+方法属性在<a class="reference internal" href="urllib.request.html#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal"><span class="pre">urllib.request.Request</span></code></a>中处理。这是一个示例会话，显示如何做<code class="docutils literal"><span class="pre">PUT</span></code></span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># This creates an HTTP message</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># with the content of BODY as the enclosed representation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># for the resource http://localhost:8080/file</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">http.client</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BODY</span> <span class="o">=</span> <span class="s2">"***filecontents***"</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span> <span class="o">=</span> <span class="n">http</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">HTTPConnection</span><span class="p">(</span><span class="s2">"localhost"</span><span class="p">,</span> <span class="mi">8080</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">request</span><span class="p">(</span><span class="s2">"PUT"</span><span class="p">,</span> <span class="s2">"/file"</span><span class="p">,</span> <span class="n">BODY</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">getresponse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">status</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">reason</span><span class="p">)</span>
<span class="go">200, OK</span>
</code></pre></div><div class="section" id="httpmessage-objects"><h2><span class="yiyi-st" id="yiyi-193">21.12.4. </span><span class="yiyi-st" id="yiyi-194">HTTPMessage对象</span></h2><p><span class="yiyi-st" id="yiyi-195"><code class="xref py py-class docutils literal"><span class="pre">http.client.HTTPMessage</span></code>实例保存来自HTTP响应的标头。</span><span class="yiyi-st" id="yiyi-196">它使用<a class="reference internal" href="email.message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal"><span class="pre">email.message.Message</span></code></a>类实现。</span></p></div></div></div>