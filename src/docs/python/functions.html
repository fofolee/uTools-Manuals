<div class="body" role="main"><div class="section" id="built-in-functions"><h1><span class="yiyi-st" id="yiyi-9">2.</span><span class="yiyi-st" id="yiyi-10">内建函数 </span></h1><p><span class="yiyi-st" id="yiyi-11">Python解释器有许多内置的函数和类型，它们总是可用的。</span><span class="yiyi-st" id="yiyi-12">列表如下（按字母排序）</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"></th><th class="head"></th><th class="head"><span class="yiyi-st" id="yiyi-13">内置功能</span></th><th class="head"></th><th class="head"></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-14"><a class="reference internal" href="#abs" title="abs"><code class="xref py py-func docutils literal"><span class="pre">abs()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-15"><a class="reference internal" href="#func-dict"><code class="docutils literal"><span class="pre">dict()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-16"><a class="reference internal" href="#help" title="help"><code class="xref py py-func docutils literal"><span class="pre">help()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-17"><a class="reference internal" href="#min" title="min"><code class="xref py py-func docutils literal"><span class="pre">min()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-18"><a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal"><span class="pre">setattr()</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-19"><a class="reference internal" href="#all" title="all"><code class="xref py py-func docutils literal"><span class="pre">all()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-20"><a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-21"><a class="reference internal" href="#hex" title="hex"><code class="xref py py-func docutils literal"><span class="pre">hex()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-22"><a class="reference internal" href="#next" title="next"><code class="xref py py-func docutils literal"><span class="pre">next()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-23"><a class="reference internal" href="#slice" title="slice"><code class="xref py py-func docutils literal"><span class="pre">slice()</span></code></a></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-24"><a class="reference internal" href="#any" title="any"><code class="xref py py-func docutils literal"><span class="pre">any()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-25"><a class="reference internal" href="#divmod" title="divmod"><code class="xref py py-func docutils literal"><span class="pre">divmod()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-26"><a class="reference internal" href="#id" title="id"><code class="xref py py-func docutils literal"><span class="pre">id()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-27"><a class="reference internal" href="#object" title="object"><code class="xref py py-func docutils literal"><span class="pre">object()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-28"><a class="reference internal" href="#sorted" title="sorted"><code class="xref py py-func docutils literal"><span class="pre">sorted()</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-29"><a class="reference internal" href="#ascii" title="ascii"><code class="xref py py-func docutils literal"><span class="pre">ascii()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-30"><a class="reference internal" href="#enumerate" title="enumerate"><code class="xref py py-func docutils literal"><span class="pre">enumerate()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-31"><a class="reference internal" href="#input" title="input"><code class="xref py py-func docutils literal"><span class="pre">input()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-32"><a class="reference internal" href="#oct" title="oct"><code class="xref py py-func docutils literal"><span class="pre">oct()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-33"><a class="reference internal" href="#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal"><span class="pre">staticmethod()</span></code></a></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-34"><a class="reference internal" href="#bin" title="bin"><code class="xref py py-func docutils literal"><span class="pre">bin()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-35"><a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-36"><a class="reference internal" href="#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-37"><a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-38"><a class="reference internal" href="#func-str"><code class="docutils literal"><span class="pre">str()</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-39"><a class="reference internal" href="#bool" title="bool"><code class="xref py py-func docutils literal"><span class="pre">bool()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-40"><a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-41"><a class="reference internal" href="#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-42"><a class="reference internal" href="#ord" title="ord"><code class="xref py py-func docutils literal"><span class="pre">ord()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-43"><a class="reference internal" href="#sum" title="sum"><code class="xref py py-func docutils literal"><span class="pre">sum()</span></code></a></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-44"><a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-func docutils literal"><span class="pre">bytearray()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-45"><a class="reference internal" href="#filter" title="filter"><code class="xref py py-func docutils literal"><span class="pre">filter()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-46"><a class="reference internal" href="#issubclass" title="issubclass"><code class="xref py py-func docutils literal"><span class="pre">issubclass()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-47"><a class="reference internal" href="#pow" title="pow"><code class="xref py py-func docutils literal"><span class="pre">pow()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-48"><a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal"><span class="pre">super()</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-49"><a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-func docutils literal"><span class="pre">bytes()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-50"><a class="reference internal" href="#float" title="float"><code class="xref py py-func docutils literal"><span class="pre">float()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-51"><a class="reference internal" href="#iter" title="iter"><code class="xref py py-func docutils literal"><span class="pre">iter()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-52"><a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-53"><a class="reference internal" href="#func-tuple"><code class="docutils literal"><span class="pre">tuple()</span></code></a></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-54"><a class="reference internal" href="#callable" title="callable"><code class="xref py py-func docutils literal"><span class="pre">callable()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-55"><a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal"><span class="pre">format()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-56"><a class="reference internal" href="#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-57"><a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal"><span class="pre">property()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-58"><a class="reference internal" href="#type" title="type"><code class="xref py py-func docutils literal"><span class="pre">type()</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-59"><a class="reference internal" href="#chr" title="chr"><code class="xref py py-func docutils literal"><span class="pre">chr()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-60"><a class="reference internal" href="#func-frozenset"><code class="docutils literal"><span class="pre">frozenset()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-61"><a class="reference internal" href="#func-list"><code class="docutils literal"><span class="pre">list()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-62"><a class="reference internal" href="#func-range"><code class="docutils literal"><span class="pre">range()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-63"><a class="reference internal" href="#vars" title="vars"><code class="xref py py-func docutils literal"><span class="pre">vars()</span></code></a></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-64"><a class="reference internal" href="#classmethod" title="classmethod"><code class="xref py py-func docutils literal"><span class="pre">classmethod()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-65"><a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal"><span class="pre">getattr()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-66"><a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal"><span class="pre">locals()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-67"><a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-68"><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal"><span class="pre">zip()</span></code></a></span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-69"><a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-70"><a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal"><span class="pre">globals()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-71"><a class="reference internal" href="#map" title="map"><code class="xref py py-func docutils literal"><span class="pre">map()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-72"><a class="reference internal" href="#reversed" title="reversed"><code class="xref py py-func docutils literal"><span class="pre">reversed()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-73"><a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a></span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-74"><a class="reference internal" href="#complex" title="complex"><code class="xref py py-func docutils literal"><span class="pre">complex()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-75"><a class="reference internal" href="#hasattr" title="hasattr"><code class="xref py py-func docutils literal"><span class="pre">hasattr()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-76"><a class="reference internal" href="#max" title="max"><code class="xref py py-func docutils literal"><span class="pre">max()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-77"><a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal"><span class="pre">round()</span></code></a></span></td><td></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-78"><a class="reference internal" href="#delattr" title="delattr"><code class="xref py py-func docutils literal"><span class="pre">delattr()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-79"><a class="reference internal" href="#hash" title="hash"><code class="xref py py-func docutils literal"><span class="pre">hash()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-80"><a class="reference internal" href="#func-memoryview"><code class="docutils literal"><span class="pre">memoryview()</span></code></a></span></td><td><span class="yiyi-st" id="yiyi-81"><a class="reference internal" href="#func-set"><code class="docutils literal"><span class="pre">set()</span></code></a></span></td><td></td></tr></tbody></table><dl class="function"><dt id="abs"><span class="yiyi-st" id="yiyi-82"><code class="descname">abs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-83">返回一个数值的绝对值，</span><span class="yiyi-st" id="yiyi-84">参数可以是一个整数或浮点数。 </span><span class="yiyi-st" id="yiyi-85">如果参数是一个复数，则返回复数的模。</span></p></dd></dl><dl class="function"><dt id="all"><span class="yiyi-st" id="yiyi-86"> <code class="descname">all</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-87">如果<em>iterable</em>中所有的元素都为True，或iterable为空（empty），返回<code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-88">相当于如下:</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">element</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
</code></pre></dd></dl><dl class="function"><dt id="any"><span class="yiyi-st" id="yiyi-89"><code class="descname">any</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-90">如果<em>iterable</em>里任何一个元素为True，返回 <code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-91">如果iterable为空（empty）,返回 <code class="docutils literal"><span class="pre">False</span></code>。</span><span class="yiyi-st" id="yiyi-92">相当于如下:</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">element</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>
</code></pre></dd></dl><dl class="function"><dt id="ascii"><span class="yiyi-st" id="yiyi-93"><code class="descname">ascii</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-94">类似<a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a>，返回一个字符串，包含可打印的对象，但通过 <a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> 返回的字符串中非 ASCII 字符，使用 <code class="docutils literal"><span class="pre">\x</span></code>，<code class="docutils literal"><span class="pre">\u</span></code> 或者<code class="docutils literal"><span class="pre">\U</span></code> 进行转义。</span><span class="yiyi-st" id="yiyi-95">这将生成类似于 <a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> 在 Python 2 中返回的字符串。</span></p></dd></dl><dl class="function"><dt id="bin"><span class="yiyi-st" id="yiyi-96"><code class="descname">bin</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-97">将整数转换为二进制字符串。</span><span class="yiyi-st" id="yiyi-98">结果是一个有效的Python表达式。</span><span class="yiyi-st" id="yiyi-99">如果 <em>x</em> 不是 Python <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> 类型的对象，那么就定义一个 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">__index__()</span></code></a> 方法，返回是一个整数。</span></p></dd></dl><dl class="class"><dt id="bool"><span class="yiyi-st" id="yiyi-100"><em class="property"></em><code class="descname">bool</code><span class="sig-paren">(</span><span class="optional">[</span><em>x</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-101">返回一个布尔值，</span><span class="yiyi-st" id="yiyi-102"><code class="docutils literal"><span class="pre">True</span></code> 或 <code class="docutils literal"><span class="pre">False</span></code>。</span><span class="yiyi-st" id="yiyi-103">将会使用<a class="reference internal" href="stdtypes.html#truth"><span>真值测试</span></a> 标准对<em>x</em> 进行转换。</span><span class="yiyi-st" id="yiyi-104">如果 <em>x</em> 的值为 false 或被省略，这将返回 <code class="docutils literal"><span class="pre">False</span></code>;否则，将返回 <code class="docutils literal"><span class="pre">True</span></code>。</span><span class="yiyi-st" id="yiyi-105"><a class="reference internal" href="#bool" title="bool"><code class="xref py py-class docutils literal"><span class="pre">bool</span></code></a> 类是 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> 的子类 (见 <a class="reference internal" href="stdtypes.html#typesnumeric"><span>数值类型 — — int，float，complex</span></a>)。</span><span class="yiyi-st" id="yiyi-106">它不能进一步分类。</span><span class="yiyi-st" id="yiyi-107">其唯一的实例是 <code class="docutils literal"><span class="pre">False</span></code> 和 <code class="docutils literal"><span class="pre">True</span></code> （见 <a class="reference internal" href="stdtypes.html#bltin-boolean-values"><span>布尔值</span></a>）。</span></p></dd></dl><dl class="class"><dt id="bytearray"><span class="yiyi-st" id="yiyi-108"><em class="property">class </em><code class="descname">bytearray</code><span class="sig-paren">(</span><span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-109">返回一个新的字节数组。</span><span class="yiyi-st" id="yiyi-110"><a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 类是一个关于整数的 mutable（可变）序列，范围为0 &lt; = x &lt; 256。</span><span class="yiyi-st" id="yiyi-111">它包含了可变序列大部分的常用方法，参见 <a class="reference internal" href="stdtypes.html#typesseq-mutable"><span>Mutable Sequence Types</span></a>，同时也包含了<a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 类型的大部分方法，参见<a class="reference internal" href="stdtypes.html#bytes-methods"><span>Bytes 和 Bytearray 操作</span></a></span></p><p><span class="yiyi-st" id="yiyi-112">可选的<em>source</em>参数可以用几种不同的方式初始化数组：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-113">如果是个字符串 <em>string</em>，应该直接在参数中指定编码类型，例如：utf-8 <em></em> （以及可选参数 <em>errors</em>）；之后 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-func docutils literal"><span class="pre">bytearray()</span></code></a> 将使用 <a class="reference internal" href="stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal"><span class="pre">str.encode()</span></code></a>按照编码转化字符串为字节序列。</span></li><li><span class="yiyi-st" id="yiyi-114">如果它是一个<em>整数</em>，则该数组将具有该大小并将用空字节进行初始化。</span></li><li><span class="yiyi-st" id="yiyi-115">如果它是符合<em>缓冲区</em>接口的对象，则将使用该对象的只读缓冲区来初始化字节数组。</span></li><li><span class="yiyi-st" id="yiyi-116">如果它是可迭代类型<em>iterable</em>，其整数元素的取值范围是<code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code>，一般用作数组的初始内容。</span></li></ul><p><span class="yiyi-st" id="yiyi-117">没有参数，就会创建一个大小为0的数组。</span></p><p><span class="yiyi-st" id="yiyi-118">参见 <a class="reference internal" href="stdtypes.html#binaryseq"><span>Binary Sequence Types — bytes, bytearray, memoryview</span></a> 和<a class="reference internal" href="stdtypes.html#typebytearray"><span>Bytearray Objects</span></a>.</span></p></dd></dl><dl class="class"><dt id="bytes"><span class="yiyi-st" id="yiyi-119"><em class="property">class </em><code class="descname">bytes</code><span class="sig-paren">(</span><span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-120">返回一个新的字节对象，是一个在 <code class="docutils literal"><span class="pre">0</span><span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code>之间的不可变的整数序列。 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 是 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 的不可变版本 – 它具有同样的非改变性的方法和同样的索引和切片操作</span></p><p><span class="yiyi-st" id="yiyi-121">因此，构造函数参数的解释与<a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-func docutils literal"><span class="pre">bytearray()</span></code></a>相同。</span></p><p><span class="yiyi-st" id="yiyi-122">字节对象也可以用字面值创建，参见<a class="reference internal" href="../reference/lexical_analysis.html#strings"><span>字符串和字节字面值</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-123">另见<a class="reference internal" href="stdtypes.html#binaryseq"><span>Binary Sequence Types — bytes, bytearray, memoryview</span></a>，<a class="reference internal" href="stdtypes.html#typebytes"><span>Bytes</span></a>和<a class="reference internal" href="stdtypes.html#bytes-methods"><span>Bytes and Bytearray Operations</span></a>。</span></p></dd></dl><dl class="function"><dt id="callable"><span class="yiyi-st" id="yiyi-124"><code class="descname">callable</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-125">如果该 <em>object</em>是可调用的，返回 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> ,否则返回 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> 。</span><span class="yiyi-st" id="yiyi-126">如果返回True，对其调用仍有可能失败；但是如果返回False，对<em>object</em>的调用总是失败。</span><span class="yiyi-st" id="yiyi-127">请注意，类是可调用的（调用类将返回一个新的实例）。如果实例的类有<a class="reference internal" href="../reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a>方法，则它是可调用；否则它是不可调用的。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-128"><span class="versionmodified">在 3.2版本的更新:</span>这个函数第一次在 Python 3.0 中被移除，在Python 3.2.中被重新启用</span></p></div></dd></dl><dl class="function"><dt id="chr"><span class="yiyi-st" id="yiyi-129"><code class="descname">chr</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-130">返回代表Unicode码点为整数<em>i</em>的字符的字符串。</span><span class="yiyi-st" id="yiyi-131">例如，<code class="docutils literal"><span class="pre">chr(97)</span></code>返回字符串<code class="docutils literal"><span class="pre">'a'</span></code>，而<code class="docutils literal"><span class="pre">chr(8364)</span></code>返回字符串<code class="docutils literal"><span class="pre">'€'</span></code></span><span class="yiyi-st" id="yiyi-132">它是<a class="reference internal" href="#ord" title="ord"><code class="xref py py-func docutils literal"><span class="pre">ord()</span></code></a>的逆操作。</span></p><p><span class="yiyi-st" id="yiyi-133">参数的有效范围是从0到1,114,111（基于16的0x10FFFF）。</span><span class="yiyi-st" id="yiyi-134">如果<em>i</em>超出该范围，则会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="classmethod"><span class="yiyi-st" id="yiyi-135"><code class="descname">classmethod</code><span class="sig-paren">(</span><em>function</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-136">将 <em>function</em> 封装成类方法。</span></p><p><span class="yiyi-st" id="yiyi-137">类方法将类作为隐式第一个参数接收，就像实例方法接收实例一样。</span><span class="yiyi-st" id="yiyi-138">要声明一个类方法，请使用这个习惯用法：</span></p><pre><code class="language-python"><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span> <span class="o">...</span>
</code></pre><p><span class="yiyi-st" id="yiyi-139"><code class="docutils literal"><span class="pre">@classmethod</span></code>形式是一个函数<a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">装饰器</span></a> —— 请查看<a class="reference internal" href="../reference/compound_stmts.html#function"><span>函数定义</span></a>中关于函数定义的详细说明。</span></p><p><span class="yiyi-st" id="yiyi-140">它既可以在类上调用（如<code class="docutils literal"><span class="pre">C.f()</span></code>）也可以在实例上调用（如<code class="docutils literal"><span class="pre">C().f()</span></code>）。</span><span class="yiyi-st" id="yiyi-141">该实例被忽略，除了它的类。</span><span class="yiyi-st" id="yiyi-142">如果一个类方法在子类上调用，那么子类对象被传递为隐式的第一个参数。</span></p><p><span class="yiyi-st" id="yiyi-143">类方法与C ++或Java静态方法不同。</span><span class="yiyi-st" id="yiyi-144">如果你需要静态方法，参见本节中的<a class="reference internal" href="#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal"><span class="pre">staticmethod()</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-145">关于类方法更多的信息，参考<a class="reference internal" href="../reference/datamodel.html#types"><span>标注类型的层级</span></a>中的标准类型层级的文档。</span></p></dd></dl><dl class="function"><dt id="compile"><span class="yiyi-st" id="yiyi-146"> <code class="descname">compile</code><span class="sig-paren">(</span><em>source</em>, <em>filename</em>, <em>mode</em>, <em>flags=0</em>, <em>dont_inherit=False</em>, <em>optimize=-1</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-147">将<em>source</em>编译成代码或AST对象。</span><span class="yiyi-st" id="yiyi-148">代码对象可以由<a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a>或<a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a>执行。</span><span class="yiyi-st" id="yiyi-149"><em>source</em>可以是普通字符串，字节字符串或AST对象。</span><span class="yiyi-st" id="yiyi-150">有关如何使用AST对象的信息，请参阅<a class="reference internal" href="ast.html#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal"><span class="pre">ast</span></code></a>模块文档。</span></p><p><span class="yiyi-st" id="yiyi-151"><em>filename</em>参数是要从中读取代码的文件名；如果它不是从文件中读取的话，需要传入一些可识别的内容（通常使用<code class="docutils literal"><span class="pre">'string'</span></code>）</span></p><p><span class="yiyi-st" id="yiyi-152"><em>mode</em> 参数指定必须编译模式；如果<code class="docutils literal"><span class="pre">source</span></code>由语句序列组成，则它可以是<em>'exec'</em>；如果它是单个语句，则可以使用<code class="docutils literal"><span class="pre">'eval'</span></code>；如果它由单个交互式语句组成，则可以使用<code class="docutils literal"><span class="pre">'single'</span></code>。（在最后一种情况下，非<code class="docutils literal"><span class="pre">None</span></code>语句将会被打印出来）</span></p><p><span class="yiyi-st" id="yiyi-153">可选参数<em>flags</em>和<em>dont_inherit</em>控制哪些未来版本的语句（见<span class="target" id="index-1"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0236"><strong>PEP 236</strong></a>）会应用于<em>源</em>编译。</span><span class="yiyi-st" id="yiyi-154">如果两者都不存在（或两者均为零），则代码将与正在调用<a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a>的代码中的那些将来的语句一起编译。</span><span class="yiyi-st" id="yiyi-155">如果给出<em>flags</em>参数并且<em>dont_inherit</em>不是（或为零），那么除了使用<em>flags</em>参数指定的未来语句那些将被使用的东西。</span><span class="yiyi-st" id="yiyi-156">如果<em>dont_inherit</em>是一个非零整数，那么<em>flags</em>参数就是它 - 围绕编译调用生效的未来语句将被忽略。</span></p><p><span class="yiyi-st" id="yiyi-157">将来的语句由可以按位或运算来指定多个语句的位指定。</span><span class="yiyi-st" id="yiyi-158">指定给定特征所需的位域可以在<a class="reference internal" href="__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal"><span class="pre">__future__</span></code></a>模块中的<code class="xref py py-class docutils literal"><span class="pre">_Feature</span></code>实例上的<code class="xref py py-attr docutils literal"><span class="pre">compiler_flag</span></code>属性中找到。</span></p><p><span class="yiyi-st" id="yiyi-159">参数<em>optimize</em>指定编译器的优化级别； <code class="docutils literal"><span class="pre">-1</span></code>的默认值选择由<a class="reference internal" href="../using/cmdline.html#cmdoption-O"><code class="xref std std-option docutils literal"><span class="pre">-O</span></code></a>选项给出的解释器的优化级别。</span><span class="yiyi-st" id="yiyi-160">显式级别为<code class="docutils literal"><span class="pre">0</span></code>（无优化； <code class="docutils literal"><span class="pre">__debug__</span></code>为真），<code class="docutils literal"><span class="pre">1</span></code>（声明被删除，<code class="docutils literal"><span class="pre">__debug__</span></code>为假 ）或<code class="docutils literal"><span class="pre">2</span></code>（docstrings也被删除）。</span></p><p><span class="yiyi-st" id="yiyi-161">如果编译的源代码无效，则此函数引发<a class="reference internal" href="exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal"><span class="pre">SyntaxError</span></code></a>；如果源代码包含空字节，则此函数引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-162">如果要将Python代码解析为其AST表示形式，请参阅<a class="reference internal" href="ast.html#ast.parse" title="ast.parse"><code class="xref py py-func docutils literal"><span class="pre">ast.parse()</span></code></a>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-163">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-164">在<code class="docutils literal"><span class="pre">'single'</span></code>或<code class="docutils literal"><span class="pre">'eval'</span></code>模式下编译具有多行代码的字符串时，输入必须至少由一个换行符终止。</span><span class="yiyi-st" id="yiyi-165">这是为了便于在<a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-mod docutils literal"><span class="pre">code</span></code></a>模块中检测不完整和完整的语句。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-166"><span class="versionmodified">在版本3.2中更改：</span>允许使用Windows和Mac换行符。</span><span class="yiyi-st" id="yiyi-167">在<code class="docutils literal"><span class="pre">'exec'</span></code>模式下输入也不必以换行符结束。</span><span class="yiyi-st" id="yiyi-168">添加了<em>optimize</em>参数。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-169"><span class="versionmodified">在版本3.5中更改：</span>以前，在<em>source</em>中遇到空字节时引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span></p></div></dd></dl><dl class="class"><dt id="complex"><span class="yiyi-st" id="yiyi-170"><em class="property">class </em><code class="descname">complex</code><span class="sig-paren">(</span><span class="optional">[</span><em>real</em><span class="optional">[</span>, <em>imag</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-171">返回值形式为<em>real</em> + <em>imag</em> * 1j的复数，或将字符串或数字转换为复数。</span><span class="yiyi-st" id="yiyi-172">如果第一个参数是一个字符串，它将被解释为一个复数，并且该函数必须在没有第二个参数的情况下被调用。</span><span class="yiyi-st" id="yiyi-173">第二个参数不能是一个字符串。</span><span class="yiyi-st" id="yiyi-174">每个参数可以是任何数字类型（包括复数）。</span><span class="yiyi-st" id="yiyi-175">如果省略<em>imag</em>，则默认为零，构造函数会像<a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>和<a class="reference internal" href="#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>一样进行转换。</span><span class="yiyi-st" id="yiyi-176">如果省略这两个参数，则返回<code class="docutils literal"><span class="pre">0j</span></code>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-177">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-178">从字符串转换时，该字符串不得在中央<code class="docutils literal"><span class="pre">+</span></code>或<code class="docutils literal"><span class="pre">-</span></code>运算符周围包含空格。</span><span class="yiyi-st" id="yiyi-179">For example, <code class="docutils literal"><span class="pre">complex('1+2j')</span></code> is fine, but <code class="docutils literal"><span class="pre">complex('1</span> <span class="pre">+</span> <span class="pre">2j')</span></code> raises <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>.</span></p></div><p><span class="yiyi-st" id="yiyi-180">复数类型在<a class="reference internal" href="stdtypes.html#typesnumeric"><span>数字类型 -  int，float，complex</span></a>中描述。</span></p></dd></dl><dl class="function"><dt id="delattr"><span class="yiyi-st" id="yiyi-181"><code class="descname">delattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-182">这是<a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal"><span class="pre">setattr()</span></code></a>的相对值。</span><span class="yiyi-st" id="yiyi-183">参数是一个对象和一个字符串。</span><span class="yiyi-st" id="yiyi-184">该字符串必须是对象属性之一的名称。</span><span class="yiyi-st" id="yiyi-185">该函数删除指定的属性，只要该对象允许。</span><span class="yiyi-st" id="yiyi-186">For example, <code class="docutils literal"><span class="pre">delattr(x,</span> <span class="pre">'foobar')</span></code> is equivalent to <code class="docutils literal"><span class="pre">del</span> <span class="pre">x.foobar</span></code>.</span></p></dd></dl><dl class="class"><dt><span class="yiyi-st" id="yiyi-187"><em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>**kwarg</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-188"><em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>mapping</em>, <em>**kwarg</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-189"><em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>iterable</em>, <em>**kwarg</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-190">创建一个新的字典。</span><span class="yiyi-st" id="yiyi-191"><a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>对象是字典类。</span><span class="yiyi-st" id="yiyi-192">有关此类的文档，请参见<a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>和<a class="reference internal" href="stdtypes.html#typesmapping"><span>映射类型 -  dict</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-193">对于其他容器，请参阅内置的<a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">列表</span></code></a>，<a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">集合</span></code></a>和<a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">元组</span></code></a>类以及<a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">容器</span></code></a> 。</span></p></dd></dl><dl class="function"><dt id="dir"><span class="yiyi-st" id="yiyi-194"><code class="descname">dir</code><span class="sig-paren">(</span><span class="optional">[</span><em>object</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-195">不带参数时, 返回当前局部作用域中名称的列表。</span><span class="yiyi-st" id="yiyi-196">带参数时，尝试返回参数object的有效属性列表。</span></p><p><span class="yiyi-st" id="yiyi-197">如果 object 具有名为<a class="reference internal" href="../reference/datamodel.html#object.__dir__" title="object.__dir__"><code class="xref py py-meth docutils literal"><span class="pre">__dir__()</span></code></a>的方法，那么此方法将被调用并且必须返回属性列表。</span><span class="yiyi-st" id="yiyi-198">这允许实现自定义<a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-func docutils literal"><span class="pre">__getattr__()</span></code></a>或<a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-func docutils literal"><span class="pre">__getattribute__()</span></code></a>函数的对象自定义<a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a>报告其属性的方式。</span></p><p><span class="yiyi-st" id="yiyi-199">如果对象不提供<a class="reference internal" href="../reference/datamodel.html#object.__dir__" title="object.__dir__"><code class="xref py py-meth docutils literal"><span class="pre">__dir__()</span></code></a>，该函数会尽量从对象的<a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a>属性（如果已定义）和其类型对象中收集信息。</span><span class="yiyi-st" id="yiyi-200">结果列表不一定是完整的，并且当对象具有自定义<a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-func docutils literal"><span class="pre">__getattr__()</span></code></a>时，可能不准确。</span></p><p><span class="yiyi-st" id="yiyi-201">默认的<a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a>机制对于不同类型的对象具有不同的行为，因为它尝试生成最相关，而不是完整的信息：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-202">如果object是一个模块对象，列表包含模块中的属性的名称。</span></li><li><span class="yiyi-st" id="yiyi-203">如果object是一个类型或类对象，则该列表包含其属性的名称，并递归地显示其基类的属性。</span></li><li><span class="yiyi-st" id="yiyi-204">否则，该列表包含对象的属性名称、其类属性的名称以及其类的基类的属性的递归。</span></li></ul><p><span class="yiyi-st" id="yiyi-205">结果列表按字母顺序排序。</span><span class="yiyi-st" id="yiyi-206">例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">()</span>   <span class="c1"># show the names in the module namespace</span>
<span class="go">['__builtins__', '__name__', 'struct']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>   <span class="c1"># show the names in the struct module </span>
<span class="go">['Struct', '__all__', '__builtins__', '__cached__', '__doc__', '__file__',</span>
<span class="go"> '__initializing__', '__loader__', '__name__', '__package__',</span>
<span class="go"> '_clearcache', 'calcsize', 'error', 'pack', 'pack_into',</span>
<span class="go"> 'unpack', 'unpack_from']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Shape</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="p">[</span><span class="s1">'area'</span><span class="p">,</span> <span class="s1">'perimeter'</span><span class="p">,</span> <span class="s1">'location'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">['area', 'location', 'perimeter']</span>
</code></pre><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-207">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-208">因为<a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a>主要是方便在交互式环境中使用，它尝试提供一组有用的名称，而不是试图提供完整或一致性的名称集合，具体的行为在不同的版本之间会有变化。</span><span class="yiyi-st" id="yiyi-209">例如，当参数是一个类时，元类属性不在结果列表中。</span></p></div></dd></dl><dl class="function"><dt id="divmod"><span class="yiyi-st" id="yiyi-210"><code class="descname">divmod</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-211">以两个（非复数）数字作为参数，并在使用整数除法时返回由它们的商和余数组成的一对数字。</span><span class="yiyi-st" id="yiyi-212">使用混合操作数类型时，适用二元算术运算符的规则。</span><span class="yiyi-st" id="yiyi-213">对于整数，结果与<code class="docutils literal"><span class="pre">（a</span> <span class="pre">//</span> <span class="pre">b，</span> <span class="pre">a</span> <span class="pre">％</span> <span class="pre">b）</span></code>相同。</span><span class="yiyi-st" id="yiyi-214">对于浮点数，结果为<code class="docutils literal"><span class="pre">（q，</span> <span class="pre">a</span> <span class="pre">％</span> <span class="pre">b）</span></code>，其中<em>q</em>通常为<code class="docutils literal"><span class="pre">math.floor(a</span> <span class="pre">/</span> <span class="pre">b)</span></code>，也有可能比这个结果小1。</span><span class="yiyi-st" id="yiyi-215">In any case <code class="docutils literal"><span class="pre">q</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code> is very close to <em>a</em>, if <code class="docutils literal"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code> is non-zero it has the same sign as <em>b</em>, and <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">abs(a</span> <span class="pre">%</span> <span class="pre">b)</span> <span class="pre">&lt;</span> <span class="pre">abs(b)</span></code>.</span></p></dd></dl><dl class="function"><dt id="enumerate"><span class="yiyi-st" id="yiyi-216"><code class="descname">enumerate</code><span class="sig-paren">(</span><em>iterable</em>, <em>start=0</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-217">返回一个枚举对象。</span><span class="yiyi-st" id="yiyi-218"><em>iterable</em> 必须是一个序列、一个<a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">迭代器</span></a>，或者其它某种支持迭代的对象。</span><span class="yiyi-st" id="yiyi-219"><a class="reference internal" href="#enumerate" title="enumerate"><code class="xref py py-func docutils literal"><span class="pre">enumerate()</span></code></a>返回的迭代器的<a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a>方法返回一个元组，该元组包含一个计数（从<em>start</em>开始，默认为0）和迭代<em>iterable</em>得到的值。</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seasons</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'Spring'</span><span class="p">,</span> <span class="s1">'Summer'</span><span class="p">,</span> <span class="s1">'Fall'</span><span class="p">,</span> <span class="s1">'Winter'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">seasons</span><span class="p">))</span>
<span class="go">[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">seasons</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]</span>
</code></pre><p><span class="yiyi-st" id="yiyi-220">相当于如下:</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">start</span>
    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">n</span><span class="p">,</span> <span class="n">elem</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></dd></dl><dl class="function"><dt id="eval"><span class="yiyi-st" id="yiyi-221"><code class="descname">eval</code><span class="sig-paren">(</span><em>expression</em>, <em>globals=None</em>, <em>locals=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-222">参数是一个字符串和可选的全局变量和局部变量。</span><span class="yiyi-st" id="yiyi-223">If provided, <em>globals</em> must be a dictionary. </span><span class="yiyi-st" id="yiyi-224">If provided, <em>locals</em> can be any mapping object.</span></p><p><span class="yiyi-st" id="yiyi-225">使用<em>globals</em>和<em>locals</em>字典将<em>表达式</em>参数解析并计算为Python表达式（技术上讲是条件列表），并将其作为全局和本地命名空间。</span><span class="yiyi-st" id="yiyi-226">如果<em>globals</em>字典存在并且缺少'__builtins__'，则在解析<em>表达式</em>之前，将当前全局变量复制到<em>全局变量</em>中。</span><span class="yiyi-st" id="yiyi-227">这意味着<em>expression</em>通常具有对标准<a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal"><span class="pre">builtins</span></code></a>的完全访问权限，并且传播受限环境。</span><span class="yiyi-st" id="yiyi-228">如果省略<em>locals</em>词典，则默认为<em>globals</em>词典。</span><span class="yiyi-st" id="yiyi-229">如果两个字典都省略，则在调用<a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a>的环境中执行表达式。</span><span class="yiyi-st" id="yiyi-230">返回值是评估表达式的结果。</span><span class="yiyi-st" id="yiyi-231">语法错误被报告为例外。</span><span class="yiyi-st" id="yiyi-232">例：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">eval</span><span class="p">(</span><span class="s1">'x+1'</span><span class="p">)</span>
<span class="go">2</span>
</code></pre><p><span class="yiyi-st" id="yiyi-233">此函数也可用于执行任意代码对象（例如由<a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a>创建的代码对象）。</span><span class="yiyi-st" id="yiyi-234">在这种情况下，传递一个代码对象而不是一个字符串。</span><span class="yiyi-st" id="yiyi-235">如果代码对象已使用<code class="docutils literal"><span class="pre">'exec'</span></code>作为<em>mode</em>参数编译，则<a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a>的返回值将为<code class="docutils literal"><span class="pre">None </span></code>。</span></p><p><span class="yiyi-st" id="yiyi-236">提示：<a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a>函数支持语句的动态执行。</span><span class="yiyi-st" id="yiyi-237"><a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal"><span class="pre">globals()</span></code></a>和<a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal"><span class="pre">locals()</span></code></a>函数分别返回当前的全局和局部字典，可以用于传递给<a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval</span></code></a>或<a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-238">请参见<a class="reference internal" href="ast.html#ast.literal_eval" title="ast.literal_eval"><code class="xref py py-func docutils literal"><span class="pre">ast.literal_eval()</span></code></a>这个函数，它可以安全地计算只包含字面值表达式的字符串。</span></p></dd></dl><dl class="function"><dt id="exec"><span class="yiyi-st" id="yiyi-239"><code class="descname">exec</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>globals</em><span class="optional">[</span>, <em>locals</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-240">这个函数支持动态执行Python代码。</span><span class="yiyi-st" id="yiyi-241"><em>object</em>必须是一个字符串或代码对象。</span><span class="yiyi-st" id="yiyi-242">如果它是一个字符串，则将该字符串解析为一组Python语句，然后执行该语句（除非发生语法错误）。</span><span class="yiyi-st" id="yiyi-243"><a class="footnote-reference" href="#id2" id="id1">[1]</a>如果它是一个代码对象，只是简单地执行它。</span><span class="yiyi-st" id="yiyi-244">在所有情况下，执行的代码应该可以作为有效的文件输入（参见“参考手册”中的“文件输入”部分）。</span><span class="yiyi-st" id="yiyi-245">请注意，即使在传递给<a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a>函数的代码上下文中，函数定义外面的<a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal"><span class="pre">return</span></code></a>和<a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 语句可能不被执行。</span><span class="yiyi-st" id="yiyi-246">返回值为<code class="docutils literal"><span class="pre">None</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-247">在所有情况下，如果省略可选部件，则代码将在当前范围内执行。</span><span class="yiyi-st" id="yiyi-248">如果只提供<em>globals</em>，它必须是一个字典，它将用于全局变量和局部变量。</span><span class="yiyi-st" id="yiyi-249">如果提供<em>globals</em>和<em>locals</em>，它们分别用于全局变量和局部变量。</span><span class="yiyi-st" id="yiyi-250">If provided, <em>locals</em> can be any mapping object. </span><span class="yiyi-st" id="yiyi-251">请记住，在模块级别，全局变量和本地变量是相同的字典。</span><span class="yiyi-st" id="yiyi-252">如果exec的<em>globals</em>和<em>locals</em>是独立的两个对象，代码的执行就像它嵌入在类定义中一样。</span></p><p><span class="yiyi-st" id="yiyi-253">如果<em>globals</em>字典的<code class="docutils literal"><span class="pre">__builtins__</span></code>键没有值，则会给这个赋予一个内置模块<a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal"><span class="pre">builtins</span></code></a>字典的引用。</span><span class="yiyi-st" id="yiyi-254">这样，你可以在将<em>globals</em>传递给<a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a>之前插入自己的<code class="docutils literal"><span class="pre">__builtins__</span></code>字典，来控制执行的代码可访问的builtins。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-255">注</span></p><p class="last"><span class="yiyi-st" id="yiyi-256">内置函数<a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal"><span class="pre">globals()</span></code></a>和<a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal"><span class="pre">locals()</span></code></a>分别返回当前全局和局部字典，它们可以用做传递给<a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a>的第二和第三个参数。</span></p></div><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-257">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-258">默认<em>locals</em>的作用与下面的函数<a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal"><span class="pre">locals()</span></code></a>描述的一样：不应该尝试修改默认的<em>locals</em>词典。</span><span class="yiyi-st" id="yiyi-259">如果在函数<a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a>返回后，需要在<em>locals</em>上查看代码的效果，请传递一个明确的<em>locals</em>字典。</span></p></div></dd></dl><dl class="function"><dt id="filter"><span class="yiyi-st" id="yiyi-260"><code class="descname">filter</code><span class="sig-paren">(</span><em>function</em>, <em>iterable</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-261">用<em>iterable</em>中传入<em>function</em>后返回True的元素构造一个迭代器。</span><span class="yiyi-st" id="yiyi-262"><em>iterable</em>可以是序列，支持迭代的容器或迭代器。</span><span class="yiyi-st" id="yiyi-263">如果<em>function</em>是<code class="docutils literal"><span class="pre">None</span></code>，使用特性函数，即为False的<em>iterable</em>中的元素被移除。</span></p><p><span class="yiyi-st" id="yiyi-264">注意<code class="docutils literal"><span class="pre">filter(function,</span> <span class="pre">iterable)</span></code> 如果函数不是 <code class="docutils literal"><span class="pre">None</span></code>等效于生成器表达式 <code class="docutils literal"><span class="pre">(item</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">iterable</span> <span class="pre">if</span> <span class="pre">function(item))</span></code> 。如果函数是 <code class="docutils literal"><span class="pre">None</span></code> ，<code class="docutils literal"><span class="pre">(item</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">iterable</span> <span class="pre">if</span> <span class="pre">item)</span></code></span></p><p><span class="yiyi-st" id="yiyi-265">请参阅<a class="reference internal" href="itertools.html#itertools.filterfalse" title="itertools.filterfalse"><code class="xref py py-func docutils literal"><span class="pre">itertools.filterfalse()</span></code></a>，该函数返回<em>函数返回false的<em>iterable</em>元素。</em></span></p></dd></dl><dl class="class"><dt id="float"><span class="yiyi-st" id="yiyi-266"><em class="property">class </em><code class="descname">float</code><span class="sig-paren">(</span><span class="optional">[</span><em>x</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p id="index-3"><span class="yiyi-st" id="yiyi-267">返回一个由数字或字符串<em>x</em>构造的浮点数。</span></p><p><span class="yiyi-st" id="yiyi-268">如果参数是一个字符串，它应该包含一个十进制数字，可选地以一个符号开头，并且可以嵌入空格。</span><span class="yiyi-st" id="yiyi-269">可选的sign可以是<code class="docutils literal"><span class="pre">'+'</span></code>或<code class="docutils literal"><span class="pre">'–'</span></code>； <code class="docutils literal"><span class="pre">'+'</span></code>符号对生成的值没有影响。</span><span class="yiyi-st" id="yiyi-270">该参数也可以是表示NaN（非数字）或正或负无穷大的字符串。</span><span class="yiyi-st" id="yiyi-271">更确切地说，在删除前后空白字符后，输入必须符合以下语法：</span></p><pre>
<strong id="grammar-token-sign">sign          </strong> ::=  "+" | "-"
<strong id="grammar-token-infinity">infinity      </strong> ::=  "Infinity" | "inf"
<strong id="grammar-token-nan">nan           </strong> ::=  "nan"
<strong id="grammar-token-numeric_value">numeric_value </strong> ::=  <a class="reference internal" href="../reference/lexical_analysis.html#grammar-token-floatnumber"><code class="xref docutils literal"><span class="pre">floatnumber</span></code></a> | <a class="reference internal" href="#grammar-token-infinity"><code class="xref docutils literal"><span class="pre">infinity</span></code></a> | <a class="reference internal" href="#grammar-token-nan"><code class="xref docutils literal"><span class="pre">nan</span></code></a>
<strong id="grammar-token-numeric_string">numeric_string</strong> ::=  [<a class="reference internal" href="string.html#grammar-token-sign"><code class="xref docutils literal"><span class="pre">sign</span></code></a>] <a class="reference internal" href="#grammar-token-numeric_value"><code class="xref docutils literal"><span class="pre">numeric_value</span></code></a>
</pre><p><span class="yiyi-st" id="yiyi-272">这里<code class="docutils literal"><span class="pre">floatnumber</span></code>是在<a class="reference internal" href="../reference/lexical_analysis.html#floating"><span>浮点字面值</span></a>中描述的Python浮点字面值的形式。</span><span class="yiyi-st" id="yiyi-273">情况并不重要，因此，例如，“inf”，“Inf”，“INFINITY”和“iNfINity”对于正无穷大都是可接受的拼写。</span></p><p><span class="yiyi-st" id="yiyi-274">否则，如果参数是整数或浮点数，则返回具有相同值（在Python的浮点精度内）的浮点数。</span><span class="yiyi-st" id="yiyi-275">如果参数在Python浮点数的范围之外，则引发一个<a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-276">对于一般的Python对象<code class="docutils literal"><span class="pre">x</span></code>，<code class="docutils literal"><span class="pre">float(x)</span></code>委托给<code class="docutils literal"><span class="pre">x .__float__()</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-277">如果没有给出参数，则返回<code class="docutils literal"><span class="pre">0.0</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-278">例子：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">'+1.23'</span><span class="p">)</span>
<span class="go">1.23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">'   -12345</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
<span class="go">-12345.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">'1e-003'</span><span class="p">)</span>
<span class="go">0.001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">'+1E6'</span><span class="p">)</span>
<span class="go">1000000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">'-Infinity'</span><span class="p">)</span>
<span class="go">-inf</span>
</code></pre><p><span class="yiyi-st" id="yiyi-279">float类型在<a class="reference internal" href="stdtypes.html#typesnumeric"><span>数字类型 -  int，float，complex</span></a>中描述。</span></p></dd></dl><dl class="function"><dt id="format"><span class="yiyi-st" id="yiyi-280"><code class="descname">format</code><span class="sig-paren">(</span><em>value</em><span class="optional">[</span>, <em>format_spec</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-281">将<em>值</em>转换为“格式化”表示，由<em>format_spec</em>控制。</span><span class="yiyi-st" id="yiyi-282"><em>format_spec</em>的解释将取决于<em>值</em>参数的类型，但是存在大多数内置类型使用的标准格式化语法：<a class="reference internal" href="string.html#formatspec"><span>Format Specification Mini-Language</span></a></span></p><p><span class="yiyi-st" id="yiyi-283">默认的<em>format_spec</em>是一个空字符串，通常给出与调用<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str（value）</span></code></a>相同的效果。</span></p><p><span class="yiyi-st" id="yiyi-284">将<code class="docutils literal"><span class="pre">格式（值，</span> <span class="pre">format_spec）</span></code>的调用转换为<code class="docutils literal"><span class="pre">类型（值）.__格式__（值， t4&gt; <span class="pre">format_spec）</span></span></code>，它们在搜索值的<a class="reference internal" href="../reference/datamodel.html#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal"><span class="pre">__format__()</span></code></a>方法时绕过实例字典。</span><span class="yiyi-st" id="yiyi-285">如果方法搜索到达<a class="reference internal" href="#object" title="object"><code class="xref py py-mod docutils literal"><span class="pre">object</span></code></a>且<em>format_spec</em>不为空，或者<em>format_spec异常，则会引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> t7&gt;或返回值不是字符串。</em></span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-286"><span class="versionmodified">Changed in version 3.4: </span><code class="docutils literal"><span class="pre">object().__format__(format_spec)</span></code> raises <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> if <em>format_spec</em> is not an empty string.</span></p></div></dd></dl><dl class="class"><dt><span class="yiyi-st" id="yiyi-287"><em class="property">class </em><code class="descname">frozenset</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-288">返回一个新的<a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>对象，可选地使用<em>iterable</em>中的元素。</span><span class="yiyi-st" id="yiyi-289"><code class="docutils literal"><span class="pre">frozenset</span></code>是一个内置类。</span><span class="yiyi-st" id="yiyi-290">有关此类的文档，请参见<a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>和<a class="reference internal" href="stdtypes.html#types-set"><span>设置类型 - 集合，frozenset</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-291">对于其他容器，请参阅内置的<a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>，<a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>，<a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>和<a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>类以及<a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a>模块。</span></p></dd></dl><dl class="function"><dt id="getattr"><span class="yiyi-st" id="yiyi-292"><code class="descname">getattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-293">返回<em>对象</em>的命名属性的值。</span><span class="yiyi-st" id="yiyi-294"><em>名称</em>必须是字符串。</span><span class="yiyi-st" id="yiyi-295">如果字符串是对象属性之一的名称，则结果是该属性的值。</span><span class="yiyi-st" id="yiyi-296">例如，<code class="docutils literal"><span class="pre">getattr(x,</span> <span class="pre">'foobar')</span></code>等同于<code class="docutils literal"><span class="pre">x.foobar</span></code>。</span><span class="yiyi-st" id="yiyi-297">如果这个名字的属性不存在，如果提供<em>default</em>则返回它，否则引发<a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="globals"><span class="yiyi-st" id="yiyi-298"><code class="descname">globals</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-299">返回表示当前全局符号表的字典。</span><span class="yiyi-st" id="yiyi-300">这总是当前模块的字典（在函数或方法内部，这是定义它的模块，而不是调用它的模块）。</span></p></dd></dl><dl class="function"><dt id="hasattr"><span class="yiyi-st" id="yiyi-301"><code class="descname">hasattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-302">参数是一个对象和一个字符串。</span><span class="yiyi-st" id="yiyi-303">如果字符串是对象的一个属性，则返回<code class="docutils literal"><span class="pre">True</span></code>，否则返回<code class="docutils literal"><span class="pre">False</span></code>。</span><span class="yiyi-st" id="yiyi-304">（它的实现是通过调用<code class="docutils literal"><span class="pre">getattr(object,</span> <span class="pre">name)</span></code>并查看它是否引发一个<a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a>）。</span></p></dd></dl><dl class="function"><dt id="hash"><span class="yiyi-st" id="yiyi-305"><code class="descname">hash</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><span class="yiyi-st" id="yiyi-309"><blockquote><div>返回该对象的哈希值（如果有的话）. 哈希值应该是一个整数。哈希值用于在查找字典时快速地比较字典的键。相等数值的哈希值相同（即使它们的类型不同，比如1和1.0）.</div></blockquote></span><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-306">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-307">对于具有自定义<a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a>方法的对象，请注意，<a class="reference internal" href="#hash" title="hash"><code class="xref py py-func docutils literal"><span class="pre">hash()</span></code></a>根据主机的位宽截断返回值。</span><span class="yiyi-st" id="yiyi-308">有关详细信息，请参见<a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a>。</span></p></div></dd></dl><dl class="function"><dt id="help"><span class="yiyi-st" id="yiyi-310"><code class="descname">help</code><span class="sig-paren">(</span><span class="optional">[</span><em>object</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-311">调用内置的帮助系统。</span><span class="yiyi-st" id="yiyi-312">（此功能用于交互式使用。）</span><span class="yiyi-st" id="yiyi-313">如果没有提供参数，则交互式帮助系统将在解释器控制台上启动。</span><span class="yiyi-st" id="yiyi-314">如果参数是一个字符串，那么该字符串将被查找为模块，函数，类，方法，关键字或文档主题的名称，并在控制台上打印帮助页面。</span><span class="yiyi-st" id="yiyi-315">如果参数是任何其他类型的对象，则会生成对象上的帮助页面。</span></p><p><span class="yiyi-st" id="yiyi-316">该函数加入内置函数的名字空间，函数收录在<a class="reference internal" href="site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal"><span class="pre">site</span></code></a> 模块里.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-317"><span class="versionmodified">在版本3.4中更改：</span>对<a class="reference internal" href="pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal"><span class="pre">pydoc</span></code></a>和<a class="reference internal" href="inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal"><span class="pre">inspect</span></code></a>的更改意味着可报告的已报告签名现在更加全面和一致。</span></p></div></dd></dl><dl class="function"><dt id="hex"><span class="yiyi-st" id="yiyi-318"><code class="descname">hex</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-319">将整数转换为以“0x”为前缀的小写十六进制字符串，例如：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>
<span class="go">'0xff'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="o">-</span><span class="mi">42</span><span class="p">)</span>
<span class="go">'-0x2a'</span>
</code></pre><p><span class="yiyi-st" id="yiyi-320">如果x不是Python <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>对象，它必须定义一个__index__()方法，返回一个整数。</span></p><p><span class="yiyi-st" id="yiyi-321">另请参见<a class="reference internal" href="#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a>用于将十六进制字符串转换为使用16为基数的整数。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-322">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-323">要获取浮点型的十六进制字符串表示形式，请使用<a class="reference internal" href="stdtypes.html#float.hex" title="float.hex"><code class="xref py py-meth docutils literal"><span class="pre">float.hex()</span></code></a>方法。</span></p></div></dd></dl><dl class="function"><dt id="id"><span class="yiyi-st" id="yiyi-324"><code class="descname">id</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-325">返回一个对象的“身份”。</span><span class="yiyi-st" id="yiyi-326">这是一个整数，它保证在该对象的生命周期内是唯一的和恒定的。</span><span class="yiyi-st" id="yiyi-327">具有不重叠寿命的两个对象可以具有相同的<a class="reference internal" href="#id" title="id"><code class="xref py py-func docutils literal"><span class="pre">id()</span></code></a>值。</span></p><div class="impl-detail compound"><p><span class="yiyi-st" id="yiyi-328"><strong>CPython实现细节：</strong>这是内存中对象的地址。</span></p></div></dd></dl><dl class="function"><dt id="input"><span class="yiyi-st" id="yiyi-329"><code class="descname">input</code><span class="sig-paren">(</span><span class="optional">[</span><em>prompt</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-330">如果存在<em>提示符</em>参数，则将其写入标准输出而不带结尾换行符。</span><span class="yiyi-st" id="yiyi-331">然后该函数从输入中读取一行，将其转换为一个字符串（剥离尾随的换行符），然后返回该行。</span><span class="yiyi-st" id="yiyi-332">当读取到EOF时，会产生<a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal"><span class="pre">EOFError</span></code></a>。</span><span class="yiyi-st" id="yiyi-333">例：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">'--&gt; '</span><span class="p">)</span>  
<span class="go">--&gt; Monty Python's Flying Circus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">"Monty Python's Flying Circus"</span>
</code></pre><p><span class="yiyi-st" id="yiyi-334">如果<a class="reference internal" href="readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">readline</span></code></a>模块已加载，则<a class="reference internal" href="#input" title="input"><code class="xref py py-func docutils literal"><span class="pre">input()</span></code></a>将使用它提供精细的行编辑和历史记录功能。</span></p></dd></dl><dl class="class"><dt id="int"><span class="yiyi-st" id="yiyi-335"><em class="property">class </em><code class="descname">int</code><span class="sig-paren">(</span><em>x=0</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-336"><em class="property">class </em><code class="descname">int</code><span class="sig-paren">(</span><em>x</em>, <em>base=10</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-337">从数字或字符串（<em>x</em>）构造并返回一个整数对象，如果没有给出参数，则返回<code class="docutils literal"><span class="pre">0</span></code>。</span><span class="yiyi-st" id="yiyi-338">如果 <em>x</em> 是一个数字，返回 <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal"><span class="pre">x.__int__()</span></code></a>。</span><span class="yiyi-st" id="yiyi-339">对于浮点数，这将截断为零。</span></p><p><span class="yiyi-st" id="yiyi-340">If <em>x</em> is not a number or if <em>base</em> is given, then <em>x</em> must be a string, <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>, or <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> instance representing an <a class="reference internal" href="../reference/lexical_analysis.html#integers"><span>integer literal</span></a> in radix <em>base</em>. </span><span class="yiyi-st" id="yiyi-341">或者，文字可以在前面加上<code class="docutils literal"><span class="pre">+</span></code>或<code class="docutils literal"><span class="pre">-</span></code>（两者之间没有空格）并且用空格包围。</span><span class="yiyi-st" id="yiyi-342">基数n文字由数字0到n-1组成，其中<code class="docutils literal"><span class="pre">a</span></code>到<code class="docutils literal"><span class="pre">z</span></code>（或<code class="docutils literal"><span class="pre">A</span></code>到<code class="docutils literal"><span class="pre">Z</span></code></span><span class="yiyi-st" id="yiyi-343">默认的<em>base</em>是10。</span><span class="yiyi-st" id="yiyi-344">允许的值是0和2-36。</span><span class="yiyi-st" id="yiyi-345">Base-2, -8, and -16 literals can be optionally prefixed with <code class="docutils literal"><span class="pre">0b</span></code>/<code class="docutils literal"><span class="pre">0B</span></code>, <code class="docutils literal"><span class="pre">0o</span></code>/<code class="docutils literal"><span class="pre">0O</span></code>, or <code class="docutils literal"><span class="pre">0x</span></code>/<code class="docutils literal"><span class="pre">0X</span></code>, as with integer literals in code. </span><span class="yiyi-st" id="yiyi-346">base为0意味着完全解释为代码字面值，使得实际基数为2,8,10或16，并且使得<code class="docutils literal"><span class="pre">int（'010'，</span> <span class="pre">0 ）</span></code>是不合法的，而<code class="docutils literal"><span class="pre">int('010')</span></code>是以及<code class="docutils literal"><span class="pre">int（'010'，</span> <span class="pre">8）</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-347">整数类型在<a class="reference internal" href="stdtypes.html#typesnumeric"><span>数字类型 -  int，float，complex</span></a>中描述。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-348"><span class="versionmodified">Changed in version 3.4: </span>If <em>base</em> is not an instance of <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> and the <em>base</em> object has a <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">base.__index__</span></code></a> method, that method is called to obtain an integer for the base. </span><span class="yiyi-st" id="yiyi-349">以前的版本使用<a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal"><span class="pre">base.__int__</span></code></a>而不是<a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">base.__index__</span></code></a>。</span></p></div></dd></dl><dl class="function"><dt id="isinstance"><span class="yiyi-st" id="yiyi-350"><code class="descname">isinstance</code><span class="sig-paren">(</span><em>object</em>, <em>classinfo</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-351">如果<em>object</em>是<em>clsaainfo</em>的一个实例（或者是classinfo的直接、间接或<a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">虚拟</span></a>子类的实例），那么则返回true。</span><span class="yiyi-st" id="yiyi-352">如果<em>object</em>不是给定类型的对象，则该函数始终返回false。</span><span class="yiyi-st" id="yiyi-353">如果<em>classinfo</em>是类型对象的元组（或者其他这样的元组），如果<em>object</em>是任何类型的实例，则返回true。</span><span class="yiyi-st" id="yiyi-354">如果<em>classinfo</em>不是类型或类型组成的元祖和此类元组，则会引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>异常。</span></p></dd></dl><dl class="function"><dt id="issubclass"><span class="yiyi-st" id="yiyi-355"><code class="descname">issubclass</code><span class="sig-paren">(</span><em>class</em>, <em>classinfo</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-356">如果 <em>class</em> 是<em>classinfo</em>的子类(直接、 间接或 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">虚拟</span></a>) 则返回 true 。</span><span class="yiyi-st" id="yiyi-357">一个类被认为是它自己的一个子类。</span><span class="yiyi-st" id="yiyi-358"><em>classinfo</em> may be a tuple of class objects, in which case every entry in <em>classinfo</em> will be checked. </span><span class="yiyi-st" id="yiyi-359">在任何其他情况下，会引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>异常。</span></p></dd></dl><dl class="function"><dt id="iter"><span class="yiyi-st" id="yiyi-360"><code class="descname">iter</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>sentinel</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-361">返回一个<a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">迭代器</span></a>对象。</span><span class="yiyi-st" id="yiyi-362">根据第二个参数的存在，第一个参数被解释得非常不同。</span><span class="yiyi-st" id="yiyi-363">没有第二个参数，<em>object</em>必须是一个支持迭代协议（<a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a>方法）的容器对象，或者它必须支持序列协议（从 <code class="docutils literal"><span class="pre">0</span></code>开始的整数参数的<a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> 方法）。</span><span class="yiyi-st" id="yiyi-364">如果它不支持这些协议任何一个，将引发<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>。</span><span class="yiyi-st" id="yiyi-365">如果给出第二个参数<em>sentinel</em>，那么<em>object</em>必须是一个可调用的对象。</span><span class="yiyi-st" id="yiyi-366">这种情况下创建的迭代器将在每次调用时不带参数调用<em>object</em>的<a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a>方法；如果返回的值等于<em>sentinel</em>，将引发<a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a>，否则返回这个值。</span></p><p><span class="yiyi-st" id="yiyi-367">另见<a class="reference internal" href="stdtypes.html#typeiter"><span>迭代器类型</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-368"><a class="reference internal" href="#iter" title="iter"><code class="xref py py-func docutils literal"><span class="pre">iter()</span></code></a>第二个参数的有用的一个场景是读取文件的行直至到达某个特定的行。</span><span class="yiyi-st" id="yiyi-369">下面的示例读取一个文件，直至<a class="reference internal" href="io.html#io.TextIOBase.readline" title="io.TextIOBase.readline"><code class="xref py py-meth docutils literal"><span class="pre">readline()</span></code></a>方法返回一个空字符串：</span></p><pre><code class="language-python"><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'mydata.txt'</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">readline</span><span class="p">,</span> <span class="s1">''</span><span class="p">):</span>
        <span class="n">process_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</code></pre></dd></dl><dl class="function"><dt id="len"><span class="yiyi-st" id="yiyi-370"><code class="descname">len</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-371">返回对象的长度（项目数量）。</span><span class="yiyi-st" id="yiyi-372">参数可以是一个序列（如字符串，字节，元组，列表或范围）或集合（如字典，集合或冻结集合）。</span></p></dd></dl><dl class="class"><dt><span class="yiyi-st" id="yiyi-373"><em class="property">class </em><code class="descname">list</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-374"><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>不是一个函数，它实际上是一个可变的序列类型，其文档在<a class="reference internal" href="stdtypes.html#typesseq-list"><span>Lists</span></a>和<a class="reference internal" href="stdtypes.html#typesseq"><span>序列类型 — list, tuple, range</span></a>中。</span></p></dd></dl><dl class="function"><dt id="locals"><span class="yiyi-st" id="yiyi-375"><code class="descname">locals</code><span class="sig-paren">(</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-376">更新和返回表示当前局部符号表的字典。</span><span class="yiyi-st" id="yiyi-377">当<a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal"><span class="pre">locals()</span></code></a>在函数代码块中调用时会返回自由变量，但是在类代码块中不会。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-378">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-379">不应该修改这个字典的内容；因为这些变化可能不会影响解释器使用的局部变量和自由变量。</span></p></div></dd></dl><dl class="function"><dt id="map"><span class="yiyi-st" id="yiyi-380"><code class="descname">map</code><span class="sig-paren">(</span><em>function</em>, <em>iterable</em>, <em>...</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-381">返回一个迭代器，对<em>iterable</em>的每个项应用<em>function</em>，并yield结果。</span><span class="yiyi-st" id="yiyi-382">如果传递多个<em>iterable</em>参数，<em>function</em>必须接受这么多参数，并应用到从iterables并行提取的项中。</span><span class="yiyi-st" id="yiyi-383">如果有多个iterable，迭代器在最短的iterable耗尽时停止。</span><span class="yiyi-st" id="yiyi-384">对于函数的输入已经排列成参数元组的情况，参见<a class="reference internal" href="itertools.html#itertools.starmap" title="itertools.starmap"><code class="xref py py-func docutils literal"><span class="pre">itertools.starmap()</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="max"><span class="yiyi-st" id="yiyi-385"><code class="descname">max</code><span class="sig-paren">(</span><em>iterable</em>, <em>*</em><span class="optional">[</span>, <em>key</em>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-386"><code class="descname">max</code><span class="sig-paren">(</span><em>arg1</em>, <em>arg2</em>, <em>*args</em><span class="optional">[</span>, <em>key</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-387">返回iterable中的最大项或两个或更多个参数中最大的项。</span></p><p><span class="yiyi-st" id="yiyi-388">填入的位置参数应该是可迭代的（ <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a>）对象.</span><span class="yiyi-st" id="yiyi-389">迭代中最大的项目被返回。</span><span class="yiyi-st" id="yiyi-390">如果提供了两个或多个位置参数，则返回最大的位置参数。</span></p><p><span class="yiyi-st" id="yiyi-391">有两个可选的仅关键字参数。</span><span class="yiyi-st" id="yiyi-392"><em>key</em>参数指定类似于用于<a class="reference internal" href="stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></code></a>的单参数排序函数。</span><span class="yiyi-st" id="yiyi-393"><em>default</em>参数指定如果提供的iterable为空则要返回的对象。</span><span class="yiyi-st" id="yiyi-394">如果迭代器为空并且未提供<em>default</em>，则会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-395">如果多个项目最大，则该函数返回遇到的第一个项目。</span><span class="yiyi-st" id="yiyi-396">这与其他排序稳定性保持工具一致，如<code class="docutils literal"><span class="pre">已排序（可迭代，</span> <span class="pre">key = keyfunc，</span> <span class="pre">reverse = True）[0]  t3 &gt;</span></code>和<code class="docutils literal"><span class="pre">heapq.nlargest（1，</span> <span class="pre">iterable，</span> <span class="pre">key = keyfunc）</span></code>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-397"><span class="versionmodified">版本3.4中的新功能：</span> <em>default</em>关键字参数。</span></p></div></dd></dl><dl class="function"><dt><span class="yiyi-st" id="yiyi-398"><code class="descname">memoryview</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-399">返回从给定参数创建的“内存视图”对象。</span><span class="yiyi-st" id="yiyi-400">请参阅<a class="reference internal" href="stdtypes.html#typememoryview"><span>Memory Views</span></a>的详细信息。</span></p></dd></dl><dl class="function"><dt id="min"><span class="yiyi-st" id="yiyi-401"><code class="descname">min</code><span class="sig-paren">(</span><em>iterable</em>, <em>*</em><span class="optional">[</span>, <em>key</em>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-402"><code class="descname">min</code><span class="sig-paren">(</span><em>arg1</em>, <em>arg2</em>, <em>*args</em><span class="optional">[</span>, <em>key</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-403">返回可迭代中的最小项或两个或更多个参数中的最小项。</span></p><p><span class="yiyi-st" id="yiyi-404">如果提供了一个位置参数，它应该是一个<a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">可迭代对象</span></a>。</span><span class="yiyi-st" id="yiyi-405">迭代中的最小项返回。</span><span class="yiyi-st" id="yiyi-406">如果提供两个或多个位置参数，则返回最小的位置参数。</span></p><p><span class="yiyi-st" id="yiyi-407">有两个可选的仅关键字参数。</span><span class="yiyi-st" id="yiyi-408"><em>key</em>参数指定类似于用于<a class="reference internal" href="stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></code></a>的单参数排序函数。</span><span class="yiyi-st" id="yiyi-409"><em>default</em>参数指定如果提供的iterable为空则要返回的对象。</span><span class="yiyi-st" id="yiyi-410">如果迭代器为空并且未提供<em>default</em>，则会引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-411">如果多个项目最小，则该函数返回遇到的第一个项目。</span><span class="yiyi-st" id="yiyi-412">这与其他排序稳定性保持工具（如<code class="docutils literal"><span class="pre">）相一致，这些工具可以被排序（iterable，</span> <span class="pre">key = keyfunc）[0]</span></code>和<code class="docutils literal"><span class="pre"> heapq.nsmallest（1，</span> <span class="pre">iterable，</span> <span class="pre">key = keyfunc）</span></code>。</span></p><div class="versionadded"><p><span class="yiyi-st" id="yiyi-413"><span class="versionmodified">版本3.4中的新功能：</span> <em>default</em>关键字参数。</span></p></div></dd></dl><dl class="function"><dt id="next"><span class="yiyi-st" id="yiyi-414"><code class="descname">next</code><span class="sig-paren">(</span><em>iterator</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-415">通过调用<a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a>方法从<em>迭代器</em>中检索下一个项目。</span><span class="yiyi-st" id="yiyi-416">如果给出<em>default</em>，则在迭代器耗尽时返回，否则引发<a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a>。</span></p></dd></dl><dl class="class"><dt id="object"><span class="yiyi-st" id="yiyi-417"><em class="property">class </em><code class="descname">object</code></span></dt><dd><p><span class="yiyi-st" id="yiyi-418">返回一个新的无特征的对象。</span><span class="yiyi-st" id="yiyi-419"><a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a>是所有类的基础类.</span><span class="yiyi-st" id="yiyi-420">它包含所有Python类实例里都会有的通用方法.</span><span class="yiyi-st" id="yiyi-421">该函数不接受任何的参数。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-422">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-423"><a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a>没有<em>有<a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a>，所以你不能指定任何属性给<a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a>类的实例。</em></span></p></div></dd></dl><dl class="function"><dt id="oct"><span class="yiyi-st" id="yiyi-424"><code class="descname">oct</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-425">将整数转换为八进制字符串。</span><span class="yiyi-st" id="yiyi-426">结果是一个有效的Python表达式。</span><span class="yiyi-st" id="yiyi-427">如果<em>x</em>不是Python <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>对象，则必须定义一个返回整数的<a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">__index__()</span></code></a>方法。</span></p></dd></dl><dl class="function"><dt id="open"><span class="yiyi-st" id="yiyi-428"><code class="descname">open</code><span class="sig-paren">(</span><em>file</em>, <em>mode='r'</em>, <em>buffering=-1</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>, <em>closefd=True</em>, <em>opener=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-429">打开 <em>file</em> 并返回一个相应的 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">文件对象</span></a>.</span><span class="yiyi-st" id="yiyi-430">如果文件不能被打开, 抛出 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> 异常.</span></p><p><span class="yiyi-st" id="yiyi-431"><em>参数 file</em> 是一个字符串表示的文件名称，或者一个数组表示的文件名称。文件名称可以是相对当前目录的路径，也可以是绝对路径表示。</span><span class="yiyi-st" id="yiyi-432">（如果给出了一个文件描述器，则当关闭返回的I / O对象时除外，除非<em>closefd</em>设置为<code class="docutils literal"><span class="pre">False</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-433"><em>参数 mode</em> 是指明打开文件的模式。</span><span class="yiyi-st" id="yiyi-434">默认值是<code class="docutils literal"><span class="pre">'r'</span></code>，表示使用文本的方式打开文件来读取。</span><span class="yiyi-st" id="yiyi-435">其他常见值为<code class="docutils literal"><span class="pre">'w'</span></code>用于写入（如果文件已经存在则截断文件），<code class="docutils literal"><span class="pre">'x'</span></code>用于排他性创建，<code class="docutils literal"><span class="pre">'a'</span></code> （在<em>某些</em> Unix系统上，意味着<em>全部</em>写入追加到文件的末尾，而不管当前的查找位置）。</span><span class="yiyi-st" id="yiyi-436">在文本模式下，如果未指定<em>encoding</em>，则使用的编码取决于平台：<code class="docutils literal"><span class="pre">locale.getpreferredencoding（False）</span></code>以获取当前语言环境编码。</span><span class="yiyi-st" id="yiyi-437">（对于读取和写入原始字节，使用二进制模式，不指定<em>编码</em>。</span><span class="yiyi-st" id="yiyi-438">可用的模式有：</span></p><table border="1" class="docutils"><thead valign="bottom"><tr class="row-odd"><th class="head"><span class="yiyi-st" id="yiyi-439">字符</span></th><th class="head"><span class="yiyi-st" id="yiyi-440">含义</span></th></tr></thead><tbody valign="top"><tr class="row-even"><td><span class="yiyi-st" id="yiyi-441"><code class="docutils literal"><span class="pre">'r'</span></code></span></td><td><span class="yiyi-st" id="yiyi-442">打开阅读（默认）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-443"><code class="docutils literal"><span class="pre">'w'</span></code></span></td><td><span class="yiyi-st" id="yiyi-444">打开写入，首先截断文件</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-445"><code class="docutils literal"><span class="pre">'x'</span></code></span></td><td><span class="yiyi-st" id="yiyi-446">打开独占创建，如果文件已经存在则失败</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-447"><code class="docutils literal"><span class="pre">'a'</span></code></span></td><td><span class="yiyi-st" id="yiyi-448">打开写入，追加到文件末尾（如果存在）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-449"><code class="docutils literal"><span class="pre">'b'</span></code></span></td><td><span class="yiyi-st" id="yiyi-450">二进制模式</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-451"><code class="docutils literal"><span class="pre">'t'</span></code></span></td><td><span class="yiyi-st" id="yiyi-452">文本模式（默认）</span></td></tr><tr class="row-even"><td><span class="yiyi-st" id="yiyi-453"><code class="docutils literal"><span class="pre">'+'</span></code></span></td><td><span class="yiyi-st" id="yiyi-454">打开磁盘文件进行更新（读取和写入）</span></td></tr><tr class="row-odd"><td><span class="yiyi-st" id="yiyi-455"><code class="docutils literal"><span class="pre">'U'</span></code></span></td><td><span class="yiyi-st" id="yiyi-456"><a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">通用换行符</span></a>模式（已弃用）</span></td></tr></tbody></table><p><span class="yiyi-st" id="yiyi-457">默认模式为<code class="docutils literal"><span class="pre">'r'</span></code>（打开阅读文本，<code class="docutils literal"><span class="pre">'rt'</span></code>的同义词）。</span><span class="yiyi-st" id="yiyi-458">对于二进制读写访问，模式<code class="docutils literal"><span class="pre">'w b'</span></code>打开并将文件截断为0字节。</span><span class="yiyi-st" id="yiyi-459"><code class="docutils literal"><span class="pre">'r b'</span></code>打开文件而不截断。</span></p><p><span class="yiyi-st" id="yiyi-460">如<a class="reference internal" href="io.html#io-overview"><span>概述</span></a>中所述，Python区分二进制和文本I / O。</span><span class="yiyi-st" id="yiyi-461">以二进制模式打开的文件（包括<em>模式</em>参数中的<code class="docutils literal"><span class="pre">'b'</span></code>）将内容作为<a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">字节</span></code></a>对象，而不进行任何解码。</span><span class="yiyi-st" id="yiyi-462">在文本模式（默认情况下，或当<code class="docutils literal"><span class="pre">'t'</span></code>包括在<em>模式</em>参数中）时，文件的内容将作为<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> ，这些字节已经使用平台相关编码首先解码，或者如果给出则使用指定的<em>编码</em>。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-463">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-464">Python不依赖于底层操作系统的文本文件的概念；所有的处理都是由Python本身完成的，因此是平台无关的。</span></p></div><p><span class="yiyi-st" id="yiyi-465"><em>参数 buffering</em>是用于设置缓冲策略的可选整数。</span><span class="yiyi-st" id="yiyi-466">通过0以关闭缓冲（仅在二进制模式下允许），1选择行缓冲（仅在文本模式下可用）和整数</span><span class="yiyi-st" id="yiyi-467">当未给出<em>buffers</em>参数时，默认缓冲策略工作如下：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-468">二进制文件以固定大小的块缓冲；使用启发式尝试确定底层器件的“块大小”并回退到<a class="reference internal" href="io.html#io.DEFAULT_BUFFER_SIZE" title="io.DEFAULT_BUFFER_SIZE"><code class="xref py py-attr docutils literal"><span class="pre">io.DEFAULT_BUFFER_SIZE</span></code></a>来选择缓冲区的大小。</span><span class="yiyi-st" id="yiyi-469">在许多系统上，缓冲区通常为4096或8192字节长。</span></li><li><span class="yiyi-st" id="yiyi-470">“交互式”文本文件（<a class="reference internal" href="io.html#io.IOBase.isatty" title="io.IOBase.isatty"><code class="xref py py-meth docutils literal"><span class="pre">isatty()</span></code></a>返回<code class="docutils literal"><span class="pre">True</span></code>的文件）使用行缓冲。</span><span class="yiyi-st" id="yiyi-471">其他文本文件使用上述策略用于二进制文件。</span></li></ul><p><span class="yiyi-st" id="yiyi-472"><em>参数 encoding</em>是用于解码或编码文件的编码的名称。</span><span class="yiyi-st" id="yiyi-473">这应该只在文本模式下使用。</span><span class="yiyi-st" id="yiyi-474">默认编码是平台相关的（无论<a class="reference internal" href="locale.html#locale.getpreferredencoding" title="locale.getpreferredencoding"><code class="xref py py-func docutils literal"><span class="pre">locale.getpreferredencoding()</span></code></a>返回），但是可以使用Python支持的任何<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">文本编码</span></a>。</span><span class="yiyi-st" id="yiyi-475">有关支持的编码列表，请参阅<a class="reference internal" href="codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal"><span class="pre">编解码器</span></code></a>模块。</span></p><p><span class="yiyi-st" id="yiyi-476"><em>参数 errors</em>是一个可选字符串，指定如何处理编码和解码错误 - 这不能在二进制模式下使用。</span><span class="yiyi-st" id="yiyi-477">虽然使用<a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal"><span class="pre">codecs.register_error()</span></code></a>注册的任何错误处理名称也有效，但仍提供了多种标准错误处理程序（在<a class="reference internal" href="codecs.html#error-handlers"><span>错误处理程序</span></a>下列出）。</span><span class="yiyi-st" id="yiyi-478">标准名称包括：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-479"><code class="docutils literal"><span class="pre">'strict'</span></code>引发<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>例外，如果存在编码错误。</span><span class="yiyi-st" id="yiyi-480">默认值<code class="docutils literal"><span class="pre">None</span></code>具有相同的效果。</span></li><li><span class="yiyi-st" id="yiyi-481"><code class="docutils literal"><span class="pre">'ignore'</span></code>忽略错误。</span><span class="yiyi-st" id="yiyi-482">请注意，忽略编码错误可能会导致数据丢失。</span></li><li><span class="yiyi-st" id="yiyi-483"><code class="docutils literal"><span class="pre">'replace'</span></code>会导致替换标记（例如<code class="docutils literal"><span class="pre">'？'</span></code>）插入到存在格式错误的数据的位置。</span></li><li><span class="yiyi-st" id="yiyi-484"><code class="docutils literal"><span class="pre">'surrogateescape'</span></code>将表示任何不正确的字节，作为从U DC80到U DCFF范围内的Unicode私人使用区域中的代码点。</span><span class="yiyi-st" id="yiyi-485">当写入数据时使用<code class="docutils literal"><span class="pre">surrogateescape</span></code>错误处理程序时，这些专用代码点将被转回相同的字节。</span><span class="yiyi-st" id="yiyi-486">这对于处理未知编码中的文件很有用。</span></li><li><span class="yiyi-st" id="yiyi-487">仅当写入文件时，才支持<code class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></code>。</span><span class="yiyi-st" id="yiyi-488">编码不支持的字符将替换为相应的<code class="docutils literal"><span class="pre">XML字符引用</span></code></span></li><li><span class="yiyi-st" id="yiyi-489"><code class="docutils literal"><span class="pre">'backslashreplace'</span></code>通过Python的反斜杠转义序列替换格式错误的数据。</span></li><li><span class="yiyi-st" id="yiyi-490"><code class="docutils literal"><span class="pre">'namereplace'</span></code>（也仅在编写时支持）用<code class="docutils literal"><span class="pre">\ N {...}</span></code>转义序列替换不支持的字符。</span></li></ul><p id="index-6"><span class="yiyi-st" id="yiyi-491"><em>参数 newline</em>控制<a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">通用换行符</span></a>模式的工作原理（仅适用于文本模式）。</span><span class="yiyi-st" id="yiyi-492">它可以是<code class="docutils literal"><span class="pre">None</span></code>、<code class="docutils literal"><span class="pre">''</span></code>、<code class="docutils literal"><span class="pre">'\n'</span></code>、<code class="docutils literal"><span class="pre">'\r'</span></code>、<code class="docutils literal"><span class="pre">'\r\n'</span></code>。</span><span class="yiyi-st" id="yiyi-493">它的工作原理如下：</span></p><ul class="simple"><li><span class="yiyi-st" id="yiyi-494">从流读取输入时，如果<em>newline</em>为<code class="docutils literal"><span class="pre">None</span></code>，则启用通用换行符模式。</span><span class="yiyi-st" id="yiyi-495">输入中的行可以以<code class="docutils literal"><span class="pre">'\n'</span></code>，<code class="docutils literal"><span class="pre">'\r'</span></code>或<code class="docutils literal"><span class="pre">'\r\n'</span></code>结尾，它们在返回给调用者之前被转换成<code class="docutils literal"><span class="pre">'\n'</span></code>。</span><span class="yiyi-st" id="yiyi-496">如果它是<code class="docutils literal"><span class="pre">''</span></code>，则启用通用换行符模式，但行结尾将返回给调用者而不会转换。</span><span class="yiyi-st" id="yiyi-497">如果它具有任何其它合法值，则输入行仅由给定字符串终止，并且行结尾被返回给调用者而不会转换。</span></li><li><span class="yiyi-st" id="yiyi-498">将输出写入流时，如果<em>newline</em>为<code class="docutils literal"><span class="pre">None</span></code>，则写入的任何<code class="docutils literal"><span class="pre">'\n'</span></code>字符都将转换为系统默认行分隔符<a class="reference internal" href="os.html#os.linesep" title="os.linesep"><code class="xref py py-data docutils literal"><span class="pre">os.linesep</span></code></a>。</span><span class="yiyi-st" id="yiyi-499">如果<em>newline</em>是<code class="docutils literal"><span class="pre">''</span></code>或<code class="docutils literal"><span class="pre">'\n'</span></code>，则不会进行转换。</span><span class="yiyi-st" id="yiyi-500">如果<em>newline</em>是任何其他合法值，写入的任何<code class="docutils literal"><span class="pre">'\n'</span></code>字符都将转换为给定字符串。</span></li></ul><p><span class="yiyi-st" id="yiyi-501">如果<em>closefd</em>是<code class="docutils literal"><span class="pre">False</span></code>并且给出了文件描述器而不是文件名，则当文件关闭时，基本文件描述器将保持打开。</span><span class="yiyi-st" id="yiyi-502">如果给定文件名<em>，则closefd</em>必须为<code class="docutils literal"><span class="pre">True</span></code>（默认值），否则将产生错误。</span></p><p><span class="yiyi-st" id="yiyi-503">通过传递可调用对象<em>opener</em>可以使用自定义开启器。</span><span class="yiyi-st" id="yiyi-504">然后通过调用<em>opener</em>（<em>文件</em>，<em>标志</em>）获取文件对象的基础文件描述器。</span><span class="yiyi-st" id="yiyi-505"><em>opener</em>必须返回一个打开的文件描述器（传递<a class="reference internal" href="os.html#os.open" title="os.open"><code class="xref py py-mod docutils literal"><span class="pre">os.open</span></code></a>为<em>opener</em> 结果类似的功能 <code class="docutils literal"><span class="pre">None</span></code>）。</span></p><p><span class="yiyi-st" id="yiyi-506">新创建的文件为<a class="reference internal" href="os.html#fd-inheritance"><span>non-inheritable</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-507">以下示例使用<a class="reference internal" href="os.html#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">os.open()</span></code></a>函数的<a class="reference internal" href="os.html#dir-fd"><span>dir_fd</span></a>参数打开相对于给定目录的文件：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dir_fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">'somedir'</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_RDONLY</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">opener</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">dir_fd</span><span class="o">=</span><span class="n">dir_fd</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'spamspam.txt'</span><span class="p">,</span> <span class="s1">'w'</span><span class="p">,</span> <span class="n">opener</span><span class="o">=</span><span class="n">opener</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">'This will be written to somedir/spamspam.txt'</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">dir_fd</span><span class="p">)</span>  <span class="c1"># don't leak a file descriptor</span>
</code></pre><p><span class="yiyi-st" id="yiyi-508">由<a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>函数返回的<a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>的类型取决于模式。</span><span class="yiyi-st" id="yiyi-509">当<a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>用于以文本模式打开文件时（<code class="docutils literal"><span class="pre">'w'</span></code>，<code class="docutils literal"><span class="pre">'r'</span></code>，<code class="docutils literal"><span class="pre">'wt'</span></code>，<code class="docutils literal"><span class="pre">'rt'</span></code>等</span><span class="yiyi-st" id="yiyi-510">），它返回<a class="reference internal" href="io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal"><span class="pre">io.TextIOBase</span></code></a>的子类（特别是<a class="reference internal" href="io.html#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-class docutils literal"><span class="pre">io.TextIOWrapper</span></code></a>）。</span><span class="yiyi-st" id="yiyi-511">当用缓冲区以二进制模式打开文件时，返回的类是<a class="reference internal" href="io.html#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">io.BufferedIOBase</span></code></a>的子类。</span><span class="yiyi-st" id="yiyi-512">确切的类有所不同：在读取二进制模式下，它返回一个<a class="reference internal" href="io.html#io.BufferedReader" title="io.BufferedReader"><code class="xref py py-class docutils literal"><span class="pre">io.BufferedReader</span></code></a>；在写入二进制和附加二进制模式时，它返回一个<a class="reference internal" href="io.html#io.BufferedWriter" title="io.BufferedWriter"><code class="xref py py-class docutils literal"><span class="pre">io.BufferedWriter</span></code></a>，并且在读/写模式下，它返回一个<a class="reference internal" href="io.html#io.BufferedRandom" title="io.BufferedRandom"><code class="xref py py-class docutils literal"><span class="pre">io.BufferedRandom</span></code></a>。</span><span class="yiyi-st" id="yiyi-513">当禁用缓冲时，将返回原始流（<a class="reference internal" href="io.html#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">io.RawIOBase</span></code></a>，<a class="reference internal" href="io.html#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal"><span class="pre">io.FileIO</span></code></a>的子类）。</span></p><p id="index-7"><span class="yiyi-st" id="yiyi-514">See also the file handling modules, such as, <a class="reference internal" href="fileinput.html#module-fileinput" title="fileinput: Loop over standard input or a list of files."><code class="xref py py-mod docutils literal"><span class="pre">fileinput</span></code></a>, <a class="reference internal" href="io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal"><span class="pre">io</span></code></a> (where <a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> is declared), <a class="reference internal" href="os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a>, <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a>, <a class="reference internal" href="tempfile.html#module-tempfile" title="tempfile: Generate temporary files and directories."><code class="xref py py-mod docutils literal"><span class="pre">tempfile</span></code></a>, and <a class="reference internal" href="shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal"><span class="pre">shutil</span></code></a>.</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-515"><span class="versionmodified">在版本3.3中已更改：</span>添加了<em>开启程序</em>参数。</span><span class="yiyi-st" id="yiyi-516">添加了<code class="docutils literal"><span class="pre">'x'</span></code>模式。</span><span class="yiyi-st" id="yiyi-517"><a class="reference internal" href="exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal"><span class="pre">IOError</span></code></a>曾经被提出，它现在是<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>的别名。</span><span class="yiyi-st" id="yiyi-518"><a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal"><span class="pre">FileExistsError</span></code></a> is now raised if the file opened in exclusive creation mode (<code class="docutils literal"><span class="pre">'x'</span></code>) already exists.</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-519"><span class="versionmodified">在版本3.4中更改：</span>此文件现在是不可继承的。</span></p></div><div class="deprecated-removed"><p><span class="yiyi-st" id="yiyi-520"><span class="versionmodified">自版本3.4起弃用，将在版本4.0中删除：</span> <code class="docutils literal"><span class="pre">'U'</span></code>模式。</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-521"><span class="versionmodified">Changed in version 3.5: </span>If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> exception (see <span class="target" id="index-8"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a> for the rationale).</span></p></div><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-522"><span class="versionmodified">在版本3.5中更改：</span>添加了<code class="docutils literal"><span class="pre">'namereplace'</span></code>错误处理程序。</span></p></div></dd></dl><dl class="function"><dt id="ord"><span class="yiyi-st" id="yiyi-523"><code class="descname">ord</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-524">给定一个表示一个Unicode字符的字符串，返回一个表示该字符的Unicode代码点的整数。</span><span class="yiyi-st" id="yiyi-525">例如，<code class="docutils literal"><span class="pre">ord('a')</span></code> 返回整数 <code class="docutils literal"><span class="pre">97</span></code>， <code class="docutils literal"><span class="pre">ord('€')</span></code> （欧元符号）返回 <code class="docutils literal"><span class="pre">8364</span></code>。</span><span class="yiyi-st" id="yiyi-526">这是<a class="reference internal" href="#chr" title="chr"><code class="xref py py-func docutils literal"><span class="pre">chr()</span></code></a>的逆操作。</span></p></dd></dl><dl class="function"><dt id="pow"><span class="yiyi-st" id="yiyi-527"><code class="descname">pow</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="optional">[</span>, <em>z</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-528">返回<em>x</em>的<em>y</em>次方; 如果提供<em>z</em>参数， 返回<em>x</em> 的<em>y</em>次方再除以<em>z</em>的余数 (计算效率比<code class="docutils literal"><span class="pre">pow(x,</span> <span class="pre">y)</span> <span class="pre">%</span> <span class="pre">z</span></code>更高)。</span><span class="yiyi-st" id="yiyi-529">双参数形式<code class="docutils literal"><span class="pre">pow(x,</span> <span class="pre">y)</span></code>等效于使用幂操作符号：<code class="docutils literal"><span class="pre">x**y </span></code>。</span></p><p><span class="yiyi-st" id="yiyi-530">参数必须有数字类型。</span><span class="yiyi-st" id="yiyi-531">对于混合操作数类型，适用于二元算术运算符的强制规则。</span><span class="yiyi-st" id="yiyi-532">对于<a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>操作数，除非第二个参数为负数，否则结果与操作数（强制后）的类型相同。在这种情况下，所有参数都将转换为浮点数并传递浮点结果。</span><span class="yiyi-st" id="yiyi-533">例如，<code class="docutils literal"><span class="pre">10**2</span></code>返回 <code class="docutils literal"><span class="pre">100</span></code>，但是<code class="docutils literal"><span class="pre">10**-2</span></code>返回<code class="docutils literal"><span class="pre">0.01</span></code>。</span><span class="yiyi-st" id="yiyi-534">如果第二个参数是负数，则必须省略第三个参数。</span><span class="yiyi-st" id="yiyi-535">如果存在<em>z</em>，则<em>x</em>和<em>y</em>必须是整数类型，并且<em>y</em>必须是非负的。</span></p></dd></dl><dl class="function"><dt id="print"><span class="yiyi-st" id="yiyi-536"><code class="descname">print</code><span class="sig-paren">(</span><em>*objects</em>, <em>sep=' '</em>, <em>end='\n'</em>, <em>file=sys.stdout</em>, <em>flush=False</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-537">将<em>object</em>打印到文本流<em>file</em>，由<em>sep</em>分隔，尾部接<em>end</em>。</span><span class="yiyi-st" id="yiyi-538"><em>sep</em>, <em>end</em> 和 <em>file</em>，如果提供这三个参数的话，必须以关键参数的形式。</span></p><p><span class="yiyi-st" id="yiyi-539">All non-keyword arguments are converted to strings like <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> does and written to the stream, separated by <em>sep</em> and followed by <em>end</em>.</span><span class="yiyi-st" id="yiyi-540"><em>sep</em>和<em>end</em>都必须是字符串；他们也可以是<code class="docutils literal"><span class="pre">None</span></code>，这意味着使用默认值。</span><span class="yiyi-st" id="yiyi-541">如果没有给出<em>对象</em>，<a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a>将只写<em>end</em>。</span></p><p><span class="yiyi-st" id="yiyi-542"><em>file</em>参数必须是具有<code class="docutils literal"><span class="pre">write(string)</span></code>方法的对象；如果它不存在或<code class="docutils literal"><span class="pre">None</span></code>，将使用<a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></code></a>。</span><span class="yiyi-st" id="yiyi-543">由于打印的参数转换为文本字符串，因此<a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a>不能用于二进制模式文件对象。</span><span class="yiyi-st" id="yiyi-544">对于这些，请改用<code class="docutils literal"><span class="pre">file.write(...)</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-545">尽管通常是由<em>file 参数</em>来决定输出流是否缓存，但是如果 flush 参数为ture，那么输出流将会被强制<em>刷新</em>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-546"><span class="versionmodified">在版本3.3中已更改：</span>添加了<em>flush</em>关键字参数。</span></p></div></dd></dl><dl class="class"><dt id="property"><span class="yiyi-st" id="yiyi-547"><em class="property">class </em><code class="descname">property</code><span class="sig-paren">(</span><em>fget=None</em>, <em>fset=None</em>, <em>fdel=None</em>, <em>doc=None</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-548">返回一个property 属性。</span></p><p><span class="yiyi-st" id="yiyi-549"><em>fget</em>是获取属性值的函数。</span><span class="yiyi-st" id="yiyi-550"><em>fset</em>是用于设置属性值的函数。</span><span class="yiyi-st" id="yiyi-551"><em>fdel</em> 是用于删除属性值的函数。</span><span class="yiyi-st" id="yiyi-552">而<em>doc</em>为该属性创建一个文档字符串。</span></p><p><span class="yiyi-st" id="yiyi-553">典型的用法是定义一个托管属性<code class="docutils literal"><span class="pre">x</span></code>：</span></p><pre><code class="language-python"><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">getx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="k">def</span> <span class="nf">setx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">delx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="n">x</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">getx</span><span class="p">,</span> <span class="n">setx</span><span class="p">,</span> <span class="n">delx</span><span class="p">,</span> <span class="s2">"I'm the 'x' property."</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-554">如果<em>c</em>是<em>C</em>的实例，则<code class="docutils literal"><span class="pre">c.x</span></code>将调用getter，<code class="docutils literal"><span class="pre">c.x</span> <span class="pre">=</span> <span class="pre">value</span></code>将调用setter，<code class="docutils literal"><span class="pre">del</span> <span class="pre">c.x</span></code>将调用deleter。</span></p><p><span class="yiyi-st" id="yiyi-555">如果给定，<em>doc</em>将是property属性的docstring。</span><span class="yiyi-st" id="yiyi-556">否则，该属性将复制<em>fget</em>的文档字符串（如果存在）。</span><span class="yiyi-st" id="yiyi-557">这使得可以使用<a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal"><span class="pre">property()</span></code></a>作为<a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">装饰器</span></a>轻松创建只读属性：</span></p><pre><code class="language-python"><span></span><span class="k">class</span> <span class="nc">Parrot</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_voltage</span> <span class="o">=</span> <span class="mi">100000</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Get the current voltage."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_voltage</span>
</code></pre><p><span class="yiyi-st" id="yiyi-558"><code class="docutils literal"><span class="pre">@property</span></code>装饰器将<code class="xref py py-meth docutils literal"><span class="pre">voltage()</span></code>方法转换为具有相同名称的只读属性的“getter”，并设置为<em>voltage</em>的文档字符串为“Get the current voltage.”。</span></p><p><span class="yiyi-st" id="yiyi-559">Property对象具有可用作装饰器的<code class="xref py py-attr docutils literal"><span class="pre">getter</span></code>、<code class="xref py py-attr docutils literal"><span class="pre">setter</span></code>和<code class="xref py py-attr docutils literal"><span class="pre">deleter</span></code>方法，用于创建property的副本，并将相应的访问器函数设置为装饰的函数。</span><span class="yiyi-st" id="yiyi-560">这可以用一个例子来解释：</span></p><pre><code class="language-python"><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""I'm the 'x' property."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>
</code></pre><p><span class="yiyi-st" id="yiyi-561">此代码与第一个示例完全等效。</span><span class="yiyi-st" id="yiyi-562">请务必给予附加函数与原始属性相同的名称（在本例中为<code class="docutils literal"><span class="pre">x</span></code>）。</span></p><p><span class="yiyi-st" id="yiyi-563">返回的property对象还具有对应于构造函数参数的属性<code class="docutils literal"><span class="pre">fget</span></code>、<code class="docutils literal"><span class="pre">fset</span></code>和<code class="docutils literal"><span class="pre">fdel</span></code>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-564"><span class="versionmodified">在3.5版本中已更改：</span>属性对象的docstrings现在是可写的。</span></p></div></dd></dl><dl class="function"><dt><span class="yiyi-st" id="yiyi-565"><code class="descname">range</code><span class="sig-paren">(</span><em>stop</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-566"><code class="descname">range</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-567"><a class="reference internal" href="stdtypes.html#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a>实际上是一个不可变的序列类型，如<a class="reference internal" href="stdtypes.html#typesseq-range"><span>Ranges</span></a>和<a class="reference internal" href="stdtypes.html#typesseq"><span>Sequence Types — list, tuple, range</span></a>中所记录。</span></p></dd></dl><dl class="function"><dt id="repr"><span class="yiyi-st" id="yiyi-568"><code class="descname">repr</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-569">返回一个包含对象可打印表示的字符串。</span><span class="yiyi-st" id="yiyi-570">对于许多类型，此函数尝试返回一个字符串，该字符串在传递给<a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a>时会产生一个具有相同值的对象，否则该表示是一个用尖括号括起来的字符串，其中包含名称该对象的类型以及经常包括该对象的名称和地址的附加信息。</span><span class="yiyi-st" id="yiyi-571">一个类可以通过定义一个<a class="reference internal" href="../reference/datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal"><span class="pre">__repr__()</span></code></a>方法来控制该函数为其实例返回的内容。</span></p></dd></dl><dl class="function"><dt id="reversed"><span class="yiyi-st" id="yiyi-572"><code class="descname">reversed</code><span class="sig-paren">(</span><em>seq</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-573">返回一个反向<a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>。</span><span class="yiyi-st" id="yiyi-574"><em>seq</em>必须是具有<a class="reference internal" href="../reference/datamodel.html#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal"><span class="pre">__reversed__()</span></code></a>方法或支持序列协议（<a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal"><span class="pre">__len__()</span></code></a>方法和<a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a>方法，整数参数从<code class="docutils literal"><span class="pre">0</span></code>开始）。</span></p></dd></dl><dl class="function"><dt id="round"><span class="yiyi-st" id="yiyi-575"><code class="descname">round</code><span class="sig-paren">(</span><em>number</em><span class="optional">[</span>, <em>ndigits</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-576">返回<em>number</em>舍入到小数点后<em>ndigits</em>位的浮点值。</span><span class="yiyi-st" id="yiyi-577">如果省略<em>ndigits</em>，将返回最接近输入的整数。</span><span class="yiyi-st" id="yiyi-578">底层调用的是<code class="docutils literal"><span class="pre">number.__round__(ndigits)</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-579">对于支持<a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal"><span class="pre">round()</span></code></a>的内建类型，值舍入到10的最接近的负<em>ndigits</em>次幂的倍数；如果离两个倍数的距离相等，则舍入选择偶数（因此，<code class="docutils literal"><span class="pre">round(0.5)</span></code>和<code class="docutils literal"><span class="pre">round(-0.5)</span></code>都是<code class="docutils literal"><span class="pre">0</span></code>，而<code class="docutils literal"><span class="pre">round(1.5)</span></code>是<code class="docutils literal"><span class="pre">2</span></code>）。</span><span class="yiyi-st" id="yiyi-580">如果使用一个参数调用返回值是一个整数，否则其类型与<em>number</em>相同。</span></p><div class="admonition note"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-581">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-582">浮点数<a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal"><span class="pre">round()</span></code></a>的行为可能让人惊讶，例如<code class="docutils literal"><span class="pre">round(2.675,</span> <span class="pre">2)</span></code>给出的是<code class="docutils literal"><span class="pre">2.67</span></code>而不是期望的<code class="docutils literal"><span class="pre">2.68</span></code>。</span><span class="yiyi-st" id="yiyi-583">这不是一个错误：因为事实上大部分十进制小数不能用浮点数精确表示。</span><span class="yiyi-st" id="yiyi-584">更多信息，请参阅<a class="reference internal" href="../tutorial/floatingpoint.html#tut-fp-issues"><span>浮点数运算：问题和限制</span></a>。</span></p></div></dd></dl><dl class="class"><dt><span class="yiyi-st" id="yiyi-585"><em class="property">class </em><code class="descname">set</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-586">返回一个新的<a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>对象，可选地使用<em>iterable</em>中的元素。</span><span class="yiyi-st" id="yiyi-587"><code class="docutils literal"><span class="pre">set</span></code>是一个内置类。</span><span class="yiyi-st" id="yiyi-588">有关此类的文档，请参阅<a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>和<a class="reference internal" href="stdtypes.html#types-set"><span>Set Types — set, frozenset</span></a>。</span></p><p><span class="yiyi-st" id="yiyi-589">对于其他容器，请参阅内置的<a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>，<a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>，<a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>和<a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>类以及<a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a>模块。</span></p></dd></dl><dl class="function"><dt id="setattr"><span class="yiyi-st" id="yiyi-590"><code class="descname">setattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em>, <em>value</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-591">它与<a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal"><span class="pre">getattr()</span></code></a>相对应。</span><span class="yiyi-st" id="yiyi-592">参数是一个对象、一个字符串和一个任意值。</span><span class="yiyi-st" id="yiyi-593">该字符串可以命名现有的属性或新的属性。</span><span class="yiyi-st" id="yiyi-594">如果该对象允许，该函数将该值分配给该属性。</span><span class="yiyi-st" id="yiyi-595">例如，<code class="docutils literal"><span class="pre">setattr(x,</span> <span class="pre">'foobar',</span> <span class="pre">123)</span></code>等同于<code class="docutils literal"><span class="pre">x.foobar</span> <span class="pre">=</span> <span class="pre">123</span></code>。</span></p></dd></dl><dl class="class"><dt id="slice"><span class="yiyi-st" id="yiyi-596"><em class="property">class </em><code class="descname">slice</code><span class="sig-paren">(</span><em>stop</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-597"><em class="property">class </em><code class="descname">slice</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p id="index-9"><span class="yiyi-st" id="yiyi-598">返回一个 <a class="reference internal" href="../glossary.html#term-slice"><span class="xref std std-term">slice</span></a> 对象，表示 <code class="docutils literal"><span class="pre">range(start,</span> <span class="pre">stop,</span> <span class="pre">step)</span></code> 指定的索引集。</span><span class="yiyi-st" id="yiyi-599"><em>start</em> 和 <em>step</em> 参数默认为 <code class="docutils literal"><span class="pre">None</span></code>。</span><span class="yiyi-st" id="yiyi-600">Slice 对象有只读属性 <code class="xref py py-attr docutils literal"><span class="pre">start</span></code>、<code class="xref py py-attr docutils literal"><span class="pre">stop</span></code>和<code class="xref py py-attr docutils literal"><span class="pre">step</span></code>，它们只返回参数值（或其默认值）。</span><span class="yiyi-st" id="yiyi-601">它们没有其它明确的功能；然而它们被Numerical Python和其他第三方扩展使用。</span><span class="yiyi-st" id="yiyi-602">当使用扩展索引语法时还会生成 slice 对象。</span><span class="yiyi-st" id="yiyi-603">例如：<code class="docutils literal"><span class="pre">a[start:stop:step]</span></code>或者<code class="docutils literal"><span class="pre">a[start:stop,</span> <span class="pre">i]</span></code>。</span><span class="yiyi-st" id="yiyi-604">请参见<a class="reference internal" href="itertools.html#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal"><span class="pre">itertools.islice()</span></code></a>中另外一个返回迭代器的版本。</span></p></dd></dl><dl class="function"><dt id="sorted"><span class="yiyi-st" id="yiyi-605"><code class="descname">sorted</code><span class="sig-paren">(</span><em>iterable[, key][, reverse]</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-606">依据<em>iterable</em>中的元素返回一个新的排好序的列表。</span></p><p><span class="yiyi-st" id="yiyi-607">具有两个可选参数，它们必须指明为关键字参数。</span></p><p><span class="yiyi-st" id="yiyi-608"><em>key</em>指示一个带有一个参数的函数，它用于从列表的每个元素中提取比较的关键字：<code class="docutils literal"><span class="pre">key=str.lower</span></code>。</span><span class="yiyi-st" id="yiyi-609">默认值是<code class="docutils literal"><span class="pre">None</span></code>（直接比较元素）。</span></p><p><span class="yiyi-st" id="yiyi-610"><em>reverse</em>是一个布尔值。</span><span class="yiyi-st" id="yiyi-611">如果设置为<code class="docutils literal"><span class="pre">True</span></code>，那么列表中元素反过来比较来排序。</span></p><p><span class="yiyi-st" id="yiyi-612"><a class="reference internal" href="functools.html#functools.cmp_to_key" title="functools.cmp_to_key"><code class="xref py py-func docutils literal"><span class="pre">functools.cmp_to_key()</span></code></a>用于将老式的<em>cmp</em>函数转换为<em>key</em>函数。</span></p><p><span class="yiyi-st" id="yiyi-613">内建的<a class="reference internal" href="#sorted" title="sorted"><code class="xref py py-func docutils literal"><span class="pre">sorted()</span></code></a>函数保证是稳定的。</span><span class="yiyi-st" id="yiyi-614">如果确保不会更改比较相等的元素的相对顺序，则排序是稳定的 - 这对于多次排序（例如，按部门排序，然后按薪级）进行排序很有帮助。</span></p><p><span class="yiyi-st" id="yiyi-615">关于排序的例子以及一个简短的排序教程，参见<a class="reference internal" href="../howto/sorting.html#sortinghowto"><span>Sorting HOW TO</span></a>。</span></p></dd></dl><dl class="function"><dt id="staticmethod"><span class="yiyi-st" id="yiyi-616"><code class="descname">staticmethod</code><span class="sig-paren">(</span><em>function</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-617">为<em>函数</em>返回一个静态方法。</span></p><p><span class="yiyi-st" id="yiyi-618">静态方法不会收到隐式的第一个参数。</span><span class="yiyi-st" id="yiyi-619">要声明一个静态方法，使用这个习惯用法：</span></p><pre><code class="language-python"><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span> <span class="o">...</span>
</code></pre><p><span class="yiyi-st" id="yiyi-620"><code class="docutils literal"><span class="pre">@staticmethod</span></code>形式是一个函数<a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">装饰器</span></a>  - 有关详细信息，请参阅<a class="reference internal" href="../reference/compound_stmts.html#function"><span>函数定义</span></a>中的函数定义的描述。</span></p><p><span class="yiyi-st" id="yiyi-621">它可以在类上（如<code class="docutils literal"><span class="pre">C.f()</span></code>）或实例上（如<code class="docutils literal"><span class="pre">C().f()</span></code>）调用。</span><span class="yiyi-st" id="yiyi-622">该实例被忽略，除了它的类。</span></p><p><span class="yiyi-st" id="yiyi-623">Python中的静态方法类似于Java或C ++中的方法。</span><span class="yiyi-st" id="yiyi-624">另请参见<a class="reference internal" href="#classmethod" title="classmethod"><code class="xref py py-func docutils literal"><span class="pre">classmethod()</span></code></a>了解用于创建备用类构造函数的变体。</span></p><p><span class="yiyi-st" id="yiyi-625">有关静态方法的详细信息，请参阅<a class="reference internal" href="../reference/datamodel.html#types"><span>标准类型层次结构</span></a>中标准类型层次结构的文档。</span></p></dd></dl><dl class="class"><dt><span class="yiyi-st" id="yiyi-626"><em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=''</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-627"><em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=b''</em>, <em>encoding='utf-8'</em>, <em>errors='strict'</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-628">返回<em>object</em>的<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>版本。</span><span class="yiyi-st" id="yiyi-629">有关详细信息，请参见<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-630"><code class="docutils literal"><span class="pre">str</span></code>是内置字符串<a class="reference internal" href="../glossary.html#term-class"><span class="xref std std-term">类</span></a>。</span><span class="yiyi-st" id="yiyi-631">有关字符串的一般信息，请参阅<a class="reference internal" href="stdtypes.html#textseq"><span>文本序列类型 -  str</span></a>。</span></p></dd></dl><dl class="function"><dt id="sum"><span class="yiyi-st" id="yiyi-632"><code class="descname">sum</code><span class="sig-paren">(</span><em>iterable</em><span class="optional">[</span>, <em>start</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-633">从左到右总计<em>start</em>和<em>可迭代</em>的项目并返回总数。</span><span class="yiyi-st" id="yiyi-634"><em>开始</em>默认为<code class="docutils literal"><span class="pre">0</span></code>。</span><span class="yiyi-st" id="yiyi-635"><em>可迭代</em>的项目通常是数字，并且起始值不允许为字符串。</span></p><p><span class="yiyi-st" id="yiyi-636">对于某些使用情况，有很好的替代<a class="reference internal" href="#sum" title="sum"><code class="xref py py-func docutils literal"><span class="pre">sum()</span></code></a>的方法。</span><span class="yiyi-st" id="yiyi-637">连接字符串序列的首选方法是通过调用<code class="docutils literal"><span class="pre">''.join(sequence)</span></code>。</span><span class="yiyi-st" id="yiyi-638">要以扩展精度添加浮点值，请参见<a class="reference internal" href="math.html#math.fsum" title="math.fsum"><code class="xref py py-func docutils literal"><span class="pre">math.fsum()</span></code></a>。</span><span class="yiyi-st" id="yiyi-639">要连接一系列可迭代对象，请考虑使用<a class="reference internal" href="itertools.html#itertools.chain" title="itertools.chain"><code class="xref py py-func docutils literal"><span class="pre">itertools.chain()</span></code></a>。</span></p></dd></dl><dl class="function"><dt id="super"><span class="yiyi-st" id="yiyi-640"><code class="descname">super</code><span class="sig-paren">(</span><span class="optional">[</span><em>type</em><span class="optional">[</span>, <em>object-or-type</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-641">返回一个代理对象，它委托方法给父类或者<em>type</em>的同级类。</span><span class="yiyi-st" id="yiyi-642">这对于访问类中被覆盖的继承方法很有用。</span><span class="yiyi-st" id="yiyi-643">除了跳过<em>type</em>本身之外，搜索顺序与<a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal"><span class="pre">getattr()</span></code></a>所使用的顺序相同。</span></p><p><span class="yiyi-st" id="yiyi-644"><em>type</em>的<a class="reference internal" href="stdtypes.html#class.__mro__" title="class.__mro__"><code class="xref py py-attr docutils literal"><span class="pre">__mro__</span></code></a>属性列出<a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal"><span class="pre">getattr()</span></code></a>和<a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal"><span class="pre">super()</span></code></a>使用的方法解析顺序。</span><span class="yiyi-st" id="yiyi-645">该属性是动态的，并且可以在继承层次结构更新时更改。</span></p><p><span class="yiyi-st" id="yiyi-646">如果省略第二个参数，则返回的super对象是未绑定的。</span><span class="yiyi-st" id="yiyi-647">如果第二个参数是一个对象，则<code class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">type)</span></code>必须为真。</span><span class="yiyi-st" id="yiyi-648">如果第二个参数是类型，则<code class="docutils literal"><span class="pre">issubclass(type2,</span> <span class="pre">type)</span></code>必须为真（这对类方法很有用）。</span></p><p><span class="yiyi-st" id="yiyi-649"><em>super</em>有两种典型的使用情况。</span><span class="yiyi-st" id="yiyi-650">在具有单继承的类层次结构中，可以使用<em>super</em>来引用父类，而不必明确命名它们，从而使代码更易于维护。</span><span class="yiyi-st" id="yiyi-651">这种使用非常类似于在其他编程语言中<em>super</em>的使用。</span></p><p><span class="yiyi-st" id="yiyi-652">第二种使用情况是在动态执行环境中支持协同多继承。</span><span class="yiyi-st" id="yiyi-653">这种使用情况是Python独有的，在静态编译语言或仅支持单继承的语言中找不到。</span><span class="yiyi-st" id="yiyi-654">这使得可以实现“菱形图”，其中多个基类实现相同的方法。</span><span class="yiyi-st" id="yiyi-655">良好的设计指出此方法在每种情况下具有相同的调用顺序（因为调用的顺序在运行时确定，因为该顺序适应类层次结构中的更改，并且因为该顺序可以包括在运行时之前未知的兄弟类）。</span></p><p><span class="yiyi-st" id="yiyi-656">对于这两种使用情况，典型的超类调用看起来像这样：</span></p><pre><code class="language-python"><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>    <span class="c1"># This does the same thing as:</span>
                               <span class="c1"># super(C, self).method(arg)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-657">注意，<a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal"><span class="pre">super()</span></code></a>只实现显式点分属性查找的绑定过程，例如<code class="docutils literal"><span class="pre">super().__getitem__(name)</span></code>。</span><span class="yiyi-st" id="yiyi-658">它通过实现自己的<a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></code></a>方法来实现这一点，以便以支持协同多继承需要的以可预测的顺序搜索类。</span><span class="yiyi-st" id="yiyi-659">因此，<a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal"><span class="pre">super()</span></code></a>没有定义隐式的查找语句或操作，例如<code class="docutils literal"><span class="pre">super()[name]</span></code>。</span></p><p><span class="yiyi-st" id="yiyi-660">还要注意，如果不是零个参数的形式，没有限制<a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal"><span class="pre">super()</span></code></a>在方法内部使用。</span><span class="yiyi-st" id="yiyi-661">如果两个参数的形式指定准确的参数，就能进行正确的引用。</span><span class="yiyi-st" id="yiyi-662">零个参数的形式只在类定义中工作，因为编译器填充必要的细节以正确检索正在定义的类，原理类似访问当前实例的普通方法。</span></p><p><span class="yiyi-st" id="yiyi-663">有关如何使用<a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal"><span class="pre">super()</span></code></a>设计协同类的实用建议，请参阅<a class="reference external" href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/">使用super()的指南</a>。</span></p></dd></dl><dl class="function"><dt><span class="yiyi-st" id="yiyi-664"><code class="descname">tuple</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-665"><a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>实际上是一个不可变的序列类型，而不是一个函数。<a class="reference internal" href="stdtypes.html#typesseq-tuple"><span>Tuples</span></a>和<a class="reference internal" href="stdtypes.html#typesseq"><span>Sequence Types — list, tuple, range</span></a>中有记录。</span></p></dd></dl><dl class="class"><dt id="type"><span class="yiyi-st" id="yiyi-666"><em class="property">class </em><code class="descname">type</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span></span></dt><dt><span class="yiyi-st" id="yiyi-667"><em class="property">class </em><code class="descname">type</code><span class="sig-paren">(</span><em>name</em>, <em>bases</em>, <em>dict</em><span class="sig-paren">)</span></span></dt><dd><p id="index-11"><span class="yiyi-st" id="yiyi-668">使用一个参数，返回<em>对象的类型</em>。</span><span class="yiyi-st" id="yiyi-669">返回值是一个类型对象，并且通常与<a class="reference internal" href="stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal"><span class="pre">object.__class__</span></code></a>返回的对象相同。</span></p><p><span class="yiyi-st" id="yiyi-670">建议使用<a class="reference internal" href="#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a>内置函数来测试对象的类型，因为它考虑了子类。</span></p><p><span class="yiyi-st" id="yiyi-671">有三个参数，返回一个新的类型对象。</span><span class="yiyi-st" id="yiyi-672">这本质上是<a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal"><span class="pre">class</span></code></a>语句的动态形式。</span><span class="yiyi-st" id="yiyi-673">The <em>name</em> string is the class name and becomes the <a class="reference internal" href="stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a> attribute; the <em>bases</em> tuple itemizes the base classes and becomes the <a class="reference internal" href="stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal"><span class="pre">__bases__</span></code></a> attribute; and the <em>dict</em> dictionary is the namespace containing definitions for class body and is copied to a standard dictionary to become the <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> attribute. </span><span class="yiyi-st" id="yiyi-674">例如，以下两条语句创建相同的<a class="reference internal" href="#type" title="type"><code class="xref py py-class docutils literal"><span class="pre">type</span></code></a>对象：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s1">'X'</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</code></pre><p><span class="yiyi-st" id="yiyi-675">另见<a class="reference internal" href="stdtypes.html#bltin-type-objects"><span>Type Objects</span></a>。</span></p></dd></dl><dl class="function"><dt id="vars"><span class="yiyi-st" id="yiyi-676"><code class="descname">vars</code><span class="sig-paren">(</span><span class="optional">[</span><em>object</em><span class="optional">]</span><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-677">返回一个模块、字典、类、实例或者其它任何一个具有<a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a>属性的对象的<a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a>属性。</span></p><p><span class="yiyi-st" id="yiyi-678">模块和实例这样的对象的<a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a>属性可以更新；但是其它对象可能对它们的<a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a>属性的写操作具有限制（例如，类使用<a class="reference internal" href="types.html#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-class docutils literal"><span class="pre">types.MappingProxyType</span></code></a>来阻止对字典直接更新）。</span></p><p><span class="yiyi-st" id="yiyi-679">如果不带参数，<a class="reference internal" href="#vars" title="vars"><code class="xref py py-func docutils literal"><span class="pre">vars()</span></code></a>的行为就像<a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal"><span class="pre">locals()</span></code></a>。</span><span class="yiyi-st" id="yiyi-680">注意，locals字典只用于读取，因为对locals字典的更新会被忽略。</span></p></dd></dl><dl class="function"><dt id="zip"><span class="yiyi-st" id="yiyi-681"><code class="descname">zip</code><span class="sig-paren">(</span><em>*iterables</em><span class="sig-paren">)</span></span></dt><dd><p><span class="yiyi-st" id="yiyi-682">创建一个迭代器，聚合来自每个迭代器的元素。</span></p><p><span class="yiyi-st" id="yiyi-683">返回一个由元组构成的迭代器，其中第<em>i</em>个元组包含来自每一组参数序列或可迭代量的第<em>i</em>元素。</span><span class="yiyi-st" id="yiyi-684">当最短的输入迭代耗尽时，迭代器停止。</span><span class="yiyi-st" id="yiyi-685">使用单个迭代参数，它将返回1元组的迭代器。</span><span class="yiyi-st" id="yiyi-686">没有参数，它返回一个空的迭代器。</span><span class="yiyi-st" id="yiyi-687">相当于如下:</span></p><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">zip</span><span class="p">(</span><span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
    <span class="c1"># zip('ABCD', 'xy') --&gt; Ax By</span>
    <span class="n">sentinel</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
    <span class="n">iterators</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">iterators</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterators</span><span class="p">:</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">sentinel</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="ow">is</span> <span class="n">sentinel</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-688">可保证迭代的从左到右的评估顺序。</span><span class="yiyi-st" id="yiyi-689">这使得使用<code class="docutils literal"><span class="pre">zip(*[iter(s)]*n)</span></code>将数据序列聚类为n长度组成为可能。</span><span class="yiyi-st" id="yiyi-690">这将重复<em>相同的</em>迭代器<code class="docutils literal"><span class="pre">n</span></code>次，以便每个输出元组都有<code class="docutils literal"><span class="pre">n</span></code>调用结果到迭代器。</span><span class="yiyi-st" id="yiyi-691">这具有将输入划分为n长度块的效果。</span></p><p><span class="yiyi-st" id="yiyi-692"><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal"><span class="pre">zip()</span></code></a>当迭代器元素不一致时，循环停止在较短的迭代器元素，较长的迭代器元素会被舍弃。</span><span class="yiyi-st" id="yiyi-693">如果这些值很重要，请改用<a class="reference internal" href="itertools.html#itertools.zip_longest" title="itertools.zip_longest"><code class="xref py py-func docutils literal"><span class="pre">itertools.zip_longest()</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-694"><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal"><span class="pre">zip()</span></code></a>结合<code class="docutils literal"><span class="pre">*</span></code>运算符可用于unzip列表：</span></p><pre><code class="language-python"><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zipped</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zipped</span><span class="p">)</span>
<span class="go">[(1, 4), (2, 5), (3, 6)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
<span class="go">True</span>
</code></pre></dd></dl><dl class="function"><dt id="__import__"><span class="yiyi-st" id="yiyi-695"><code class="descname">__import__</code><span class="sig-paren">(</span><em>name</em>, <em>globals=None</em>, <em>locals=None</em>, <em>fromlist=()</em>, <em>level=0</em><span class="sig-paren">)</span></span></dt><dd><div class="admonition note" id="index-12"><p class="first admonition-title"><span class="yiyi-st" id="yiyi-696">注意</span></p><p class="last"><span class="yiyi-st" id="yiyi-697">与<a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal"><span class="pre">importlib.import_module()</span></code></a>不同，这是一种日常Python编程中不需要的高级函数。</span></p></div><p><span class="yiyi-st" id="yiyi-698">通过 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 语句调用此函数。</span><span class="yiyi-st" id="yiyi-699">他能够被替代(通过导入<a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal"><span class="pre">builtins</span></code></a> 模块，赋值给 <code class="docutils literal"><span class="pre">builtins.__import__</span></code>)去改变 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 语句的语义, 但是<strong>强烈</strong> 不鼓励，因为通常使用import钩子 (见 <span class="target" id="index-13"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>) 更容易达到相同的目标，而且不会对使用了默认import实现的代码造成任何问题。</span><span class="yiyi-st" id="yiyi-700">直接使用<a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a>也不鼓励使用<a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal"><span class="pre">importlib.import_module()</span></code></a>。</span></p><p><span class="yiyi-st" id="yiyi-701">该函数导入模块<em>名称</em>，可能使用给定的<em>globals</em>和<em>locals</em>来确定如何解释包上下文中的名称。</span><span class="yiyi-st" id="yiyi-702"><em>fromlist</em>给出了应从<em>name</em>给出的模块导入的对象或子模块的名称。</span><span class="yiyi-st" id="yiyi-703">标准实现不使用其 <em>locals</em> 参数，仅仅使用 <em>globals</em> 确定 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">导入</span></code></a> 语句的包的上下文。</span></p><p><span class="yiyi-st" id="yiyi-704"><em>级别</em>指定是使用绝对导入还是相对导入。</span><span class="yiyi-st" id="yiyi-705"><code class="docutils literal"><span class="pre">0</span></code>（默认）意味着只执行绝对导入。</span><span class="yiyi-st" id="yiyi-706"><em>level</em>的正值表示相对于调用<a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a>的模块的目录搜索的父目录的数量（参见<span class="target" id="index-14"></span> <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a>了解详情）。</span></p><p><span class="yiyi-st" id="yiyi-707">当<em>name</em>变量​​的形式为<code class="docutils literal"><span class="pre">package.module</span></code>时，通常会返回顶级包（名称直到第一个点），<em>not &lt; / t3&gt;由<em>名称</em>命名的模块。</em></span><span class="yiyi-st" id="yiyi-708">但是，如果给出非空的<em>fromlist</em>参数，则返回由<em>name</em>命名的模块。</span></p><p><span class="yiyi-st" id="yiyi-709">例如，语句<code class="docutils literal"><span class="pre">import</span> <span class="pre">spam</span></code>导致字节码类似于以下代码：</span></p><pre><code class="language-python"><span></span><span class="n">spam</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">'spam'</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-710">语句<code class="docutils literal"><span class="pre">import</span> <span class="pre">spam.ham</span></code>导致此调用：</span></p><pre><code class="language-python"><span></span><span class="n">spam</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">'spam.ham'</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)</span>
</code></pre><p><span class="yiyi-st" id="yiyi-711">请注意，<a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a>在此返回顶层模块，因为这是通过<a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a>语句绑定到名称的对象。</span></p><p><span class="yiyi-st" id="yiyi-712">On the other hand, the statement <code class="docutils literal"><span class="pre">from</span> <span class="pre">spam.ham</span> <span class="pre">import</span> <span class="pre">eggs,</span> <span class="pre">sausage</span> <span class="pre">as</span> <span class="pre">saus</span></code> results in</span></p><pre><code class="language-python"><span></span><span class="n">_temp</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">'spam.ham'</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[</span><span class="s1">'eggs'</span><span class="p">,</span> <span class="s1">'sausage'</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">eggs</span> <span class="o">=</span> <span class="n">_temp</span><span class="o">.</span><span class="n">eggs</span>
<span class="n">saus</span> <span class="o">=</span> <span class="n">_temp</span><span class="o">.</span><span class="n">sausage</span>
</code></pre><p><span class="yiyi-st" id="yiyi-713">这里，<code class="docutils literal"><span class="pre">spam.ham</span></code>模块从<a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a>返回。</span><span class="yiyi-st" id="yiyi-714">从这个对象中，要导入的名称被检索并分配给它们各自的名称。</span></p><p><span class="yiyi-st" id="yiyi-715">如果你只是想要按名称导入模块 ，使用 <a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal"><span class="pre">importlib.import_module()</span></code></a>。</span></p><div class="versionchanged"><p><span class="yiyi-st" id="yiyi-716"><span class="versionmodified">在版本3.3中更改：</span>不再支持<em>level</em>的负值（它也将默认值更改为0）。</span></p></div></dd></dl><p class="rubric"><span class="yiyi-st" id="yiyi-717">脚注</span></p><table class="docutils footnote" frame="void" id="id2" rules="none"><tbody valign="top"><tr><td class="label"><span class="yiyi-st" id="yiyi-718"><a class="fn-backref" href="#id1">[1]</a></span></td><td><span class="yiyi-st" id="yiyi-719">请注意，解析器只接受Unix风格的行结束约定。</span><span class="yiyi-st" id="yiyi-720">如果你从文件中读取代码，请确保要使用换行符转换模式转换 Windows 或者 Mac 风格的换行符。</span></td></tr></tbody></table></div></div>