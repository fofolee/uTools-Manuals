<div class="container">
    <h1 id="pkg-overview">package image</h1>
    <p><code>import "image"</code>
    </p><p align="left">image实现了基本的2D图片库。</p>
    <p align="left">基本接口叫作Image。图片的色彩定义在image/color包。</p>
    <p align="left">Image接口可以通过调用如NewRGBA和NewPaletted函数等获得；也可以通过调用Decode函数解码包含GIF、JPEG或PNG格式图像数据的输入流获得。解码任何具体图像类型之前都必须注册对应类型的解码函数。注册过程一般是作为包初始化的副作用，放在包的init函数里。因此，要解码PNG图像，只需在程序的main包里嵌入如下代码：</p>
    <pre>import _ "image/png"
</pre>
    <p align="left">_表示导入包但不使用包中的变量/函数/类型，只是为了包初始化函数的副作用。</p>
    <p align="left">参见<a href="http://golang.org/doc/articles/image_package.html">http://golang.org/doc/articles/image_package.html</a></p>
    <div class="panel-group">
        <div class="panel panel-default" id="example-package">
            <div class="panel-heading" onclick="document.getElementById('ex-package').style.display = document.getElementById('ex-package').style.display=='none'?'block':'none';">Example</div>
            <div class="panel-collapse collapse" id="ex-package">
                <div class="panel-body">
                    <pre><span class="com">// This example demonstrates decoding a JPEG image and examining its pixels.</span>
package image_test
import (
    "encoding/base64"
    "fmt"
    "image"
    "log"
    "strings"
    <span class="com">// Package image/jpeg is not used explicitly in the code below,</span>
    <span class="com">// but is imported for its initialization side-effect, which allows</span>
    <span class="com">// image.Decode to understand JPEG formatted images. Uncomment these</span>
    <span class="com">// two lines to also understand GIF and PNG images:</span>
    <span class="com">// _ "image/gif"</span>
    <span class="com">// _ "image/png"</span>
    _ "image/jpeg"
)
func Example() {
    <span class="com">// Decode the JPEG data. If reading from file, create a reader with</span>
    <span class="com">//</span>
    <span class="com">// reader, err := os.Open("testdata/video-001.q50.420.jpeg")</span>
    <span class="com">// if err != nil {</span>
    <span class="com">//     log.Fatal(err)</span>
    <span class="com">// }</span>
    <span class="com">// defer reader.Close()</span>
    reader := base64.NewDecoder(base64.StdEncoding, strings.NewReader(data))
    m, _, err := image.Decode(reader)
    if err != nil {
        log.Fatal(err)
    }
    bounds := m.Bounds()
    <span class="com">// Calculate a 16-bin histogram for m's red, green, blue and alpha components.</span>
    <span class="com">//</span>
    <span class="com">// An image's bounds do not necessarily start at (0, 0), so the two loops start</span>
    <span class="com">// at bounds.Min.Y and bounds.Min.X. Looping over Y first and X second is more</span>
    <span class="com">// likely to result in better memory access patterns than X first and Y second.</span>
    var histogram [16][4]int
    for y := bounds.Min.Y; y &lt; bounds.Max.Y; y++ {
        for x := bounds.Min.X; x &lt; bounds.Max.X; x++ {
            r, g, b, a := m.At(x, y).RGBA()
            <span class="com">// A color's RGBA method returns values in the range [0, 65535].</span>
            <span class="com">// Shifting by 12 reduces this to the range [0, 15].</span>
            histogram[r&gt;&gt;12][0]++
            histogram[g&gt;&gt;12][1]++
            histogram[b&gt;&gt;12][2]++
            histogram[a&gt;&gt;12][3]++
        }
    }
    <span class="com">// Print the results.</span>
    fmt.Printf("%-14s %6s %6s %6s %6s\n", "bin", "red", "green", "blue", "alpha")
    for i, x := range histogram {
        fmt.Printf("0x%04x-0x%04x: %6d %6d %6d %6d\n", i&lt;&lt;12, (i+1)&lt;&lt;12-1, x[0], x[1], x[2], x[3])
    }
    <span class="com">// Output:</span>
    <span class="com">// bin               red  green   blue  alpha</span>
    <span class="com">// 0x0000-0x0fff:    353    759   7228      0</span>
    <span class="com">// 0x1000-0x1fff:    629   2944   1036      0</span>
    <span class="com">// 0x2000-0x2fff:   1075   2319    984      0</span>
    <span class="com">// 0x3000-0x3fff:    838   2291    988      0</span>
    <span class="com">// 0x4000-0x4fff:    540   1302    542      0</span>
    <span class="com">// 0x5000-0x5fff:    319    971    263      0</span>
    <span class="com">// 0x6000-0x6fff:    316    377    178      0</span>
    <span class="com">// 0x7000-0x7fff:    581    280    216      0</span>
    <span class="com">// 0x8000-0x8fff:   3457    228    274      0</span>
    <span class="com">// 0x9000-0x9fff:   2294    237    334      0</span>
    <span class="com">// 0xa000-0xafff:    938    283    370      0</span>
    <span class="com">// 0xb000-0xbfff:    322    338    401      0</span>
    <span class="com">// 0xc000-0xcfff:    229    386    295      0</span>
    <span class="com">// 0xd000-0xdfff:    263    416    281      0</span>
    <span class="com">// 0xe000-0xefff:    538    433    312      0</span>
    <span class="com">// 0xf000-0xffff:   2758   1886   1748  15450</span>
}
const data = `
/9j/4AAQSkZJRgABAQIAHAAcAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdA
SFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2Nj
Y2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wAARCABnAJYDASIAAhEBAxEB/8QA
HwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIh
MUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVW
V1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG
x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQF
BgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAV
YnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOE
hYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq
8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDlwKMD0pwzSiuK57QzGDxS7D6in8Y5ximnAPUfSlcq4m3ilUYp
2OKXHvRcVxnTtS7c07HNFK4DQPakC4PNOA+tOx70XAjK/So5gBGP94fzqfvUVx/qxx/EP51UXqRP4WSE
cmgjilP3jSEZqS0IO/NGDnpUiocDg/McDjvV6HTPOdVWYgsM5KcfzzQ2JySM2jp6VYu7SWzmMUwG4cgj
kMPUVBjjtTGtRu0Zopw+lFFxhinrGzuqqMsxAA9yaXFSRv5cqSEcIwYj6GpuZ30O30fSLKzhUpbpNMv3
5XGTn29BV28jt7pPLuIVljPBBFVreYx+VbqAjycgt3x14zRcNOxGyVFHQkIc/wA61exyKLbuzjdZ046d
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
`
</pre>
                </div>
            </div>
        </div>
    </div>
    
    
		
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
    
    
		
        
    
    <h2 id="pkg-variables">Variables </h2>
    <pre>var (
    <span class="com">// Black是一个完全不透明的面积无限大的黑色图像</span>
    <span id="Black">Black</span> = <a href="#NewUniform">NewUniform</a>(<a href="image/color.htm">color</a>.<a href="image/color.htm#Black">Black</a>)
    <span class="com">// White是一个完全不透明的面积无限大的白色图像</span>
    <span id="White">White</span> = <a href="#NewUniform">NewUniform</a>(<a href="image/color.htm">color</a>.<a href="image/color.htm#White">White</a>)
    <span class="com">// Transparent是一个完全透明的面积无限大的图像</span>
    <span id="Transparent">Transparent</span> = <a href="#NewUniform">NewUniform</a>(<a href="image/color.htm">color</a>.<a href="image/color.htm#Transparent">Transparent</a>)
    <span class="com">// Opaque是一个完全不透明的面积无限大的图像</span>
    <span id="Opaque">Opaque</span> = <a href="#NewUniform">NewUniform</a>(<a href="image/color.htm">color</a>.<a href="image/color.htm#Opaque">Opaque</a>)
)</pre>
    <pre>var <span id="ErrFormat">ErrFormat</span> = <a href="errors.htm">errors</a>.<a href="errors.htm#New">New</a>("image: unknown format")</pre>
    <p>ErrFormat说明解码时遇到了未知的格式。</p>
    <h2 id="Image">type <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#36" title="View Source">Image</a> </h2>
    <pre>type Image interface {
    <span class="com">// ColorModel方法返回图像的色彩模型</span>
    <span id="Image.ColorModel">ColorModel</span>() <a href="image/color.htm">color</a>.<a href="image/color.htm#Model">Model</a>
    <span class="com">// Bounds方法返回图像的范围，范围不一定包括点(0, 0)</span>
    <span id="Image.Bounds">Bounds</span>() <a href="#Rectangle">Rectangle</a>
    <span class="com">// At方法返回(x, y)位置的色彩</span>
    <span class="com">// At(Bounds().Min.X, Bounds().Min.Y)返回网格左上角像素的色彩</span>
    <span class="com">// At(Bounds().Max.X-1, Bounds().Max.Y-1) 返回网格右下角像素的色彩</span>
    <span id="Image.At">At</span>(x, y <a href="builtin.htm#int">int</a>) <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a>
}</pre>
    <p>Image接口表示一个采用某色彩模型的颜色构成的有限矩形网格（即一幅图像）。</p>
    <h3 id="Decode">func <a href="https://github.com/golang/go/blob/master/src/image/format.go?name=release#78" title="View Source">Decode</a> </h3>
    <pre class="funcdecl">func Decode(r <a href="io.htm">io</a>.<a href="io.htm#Reader">Reader</a>) (<a href="#Image">Image</a>, <a href="builtin.htm#string">string</a>, <a href="builtin.htm#error">error</a>)</pre>
    <p>DecodeConfig函数解码并返回一个采用某种已注册格式编码的图像。字符串返回值是该格式注册时的名字。格式一般是在该编码格式的包的init函数中注册的。</p>
    <h2 id="PalettedImage">type <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#53" title="View Source">PalettedImage</a> </h2>
    <pre>type PalettedImage interface {
    <span class="com">// ColorIndexAt方法返回(x, y)位置的像素的（调色板）索引</span>
    <span id="PalettedImage.ColorIndexAt">ColorIndexAt</span>(x, y <a href="builtin.htm#int">int</a>) <a href="builtin.htm#uint8">uint8</a>
    <a href="#Image">Image</a>
}</pre>
    <p align="left">PalettedImage接口代表一幅图像，它的像素可能来自一个有限的调色板。</p>
    <p align="left">如果有对象m满足PalettedImage接口，且m.ColorModel()返回的color.Model接口底层为一个Palette类型值（记为p），则m.At(x, y)返回值应等于p[m.ColorIndexAt(x, y)]。如果m的色彩模型不是Palette，则ColorIndexAt的行为是不确定的。</p>
    <h2 id="Config">type <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#29" title="View Source">Config</a> </h2>
    <pre>type Config struct {
    <span id="Config.ColorModel">ColorModel</span>    <a href="image/color.htm">color</a>.<a href="image/color.htm#Model">Model</a>
    <span id="Config.Width">Width</span>, <span id="Config.Height">Height</span> <a href="builtin.htm#int">int</a>
}</pre>
    <p>Config保管图像的色彩模型和尺寸信息。</p>
    <h3 id="DecodeConfig">func <a href="https://github.com/golang/go/blob/master/src/image/format.go?name=release#92" title="View Source">DecodeConfig</a> </h3>
    <pre class="funcdecl">func DecodeConfig(r <a href="io.htm">io</a>.<a href="io.htm#Reader">Reader</a>) (<a href="#Config">Config</a>, <a href="builtin.htm#string">string</a>, <a href="builtin.htm#error">error</a>)</pre>
    <p>DecodeConfig函数解码并返回一个采用某种已注册格式编码的图像的色彩模型和尺寸。字符串返回值是该格式注册时的名字。格式一般是在该编码格式的包的init函数中注册的。</p>
    <h2 id="RegisterFormat">func <a href="https://github.com/golang/go/blob/master/src/image/format.go?name=release#32" title="View Source">RegisterFormat</a> </h2>
    <pre class="funcdecl">func RegisterFormat(name, magic <a href="builtin.htm#string">string</a>, decode func(<a href="io.htm">io</a>.<a href="io.htm#Reader">Reader</a>) (<a href="#Image">Image</a>, <a href="builtin.htm#error">error</a>), decodeConfig func(<a href="io.htm">io</a>.<a href="io.htm#Reader">Reader</a>) (<a href="#Config">Config</a>, <a href="builtin.htm#error">error</a>))</pre>
    <p>RegisterFormat注册一个供Decode函数使用的图片格式。name是格式的名字，如"jpeg"或"png"；magic是该格式编码的魔术前缀，该字符串可以包含"?"通配符，每个通配符匹配一个字节；decode函数用于解码图片；decodeConfig函数只解码图片的配置。</p>
    <h2 id="Point">type <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#12" title="View Source">Point</a> </h2>
    <pre>type Point struct {
    <span id="Point.X">X</span>, <span id="Point.Y">Y</span> <a href="builtin.htm#int">int</a>
}</pre>
    <p>Point是X, Y坐标对。坐标轴是向右（X）向下（Y）的。既可以表示点，也可以表示向量。</p>
    <pre>var <span id="ZP">ZP</span> <a href="#Point">Point</a></pre>
    <p>ZP是原点。</p>
    <h3 id="Pt">func <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#72" title="View Source">Pt</a> </h3>
    <pre class="funcdecl">func Pt(X, Y <a href="builtin.htm#int">int</a>) <a href="#Point">Point</a></pre>
    <p>返回Point{X , Y}</p>
    <h3 id="Point.Eq">func (Point) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#64" title="View Source">Eq</a> </h3>
    <pre class="funcdecl">func (p <a href="#Point">Point</a>) Eq(q <a href="#Point">Point</a>) <a href="builtin.htm#bool">bool</a></pre>
    <p>报告p和q是否相同。</p>
    <h3 id="Point.Add">func (Point) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#22" title="View Source">Add</a> </h3>
    <pre class="funcdecl">func (p <a href="#Point">Point</a>) Add(q <a href="#Point">Point</a>) <a href="#Point">Point</a></pre>
    <p>返回点Point{p.X+q.X, p.Y+q.Y}</p>
    <h3 id="Point.Sub">func (Point) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#27" title="View Source">Sub</a> </h3>
    <pre class="funcdecl">func (p <a href="#Point">Point</a>) Sub(q <a href="#Point">Point</a>) <a href="#Point">Point</a></pre>
    <p>返回点Point{p.X-q.X, p.Y-q.Y}</p>
    <h3 id="Point.Mul">func (Point) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#32" title="View Source">Mul</a> </h3>
    <pre class="funcdecl">func (p <a href="#Point">Point</a>) Mul(k <a href="builtin.htm#int">int</a>) <a href="#Point">Point</a></pre>
    <p>返回点Point{p.X*k, p.Y*k}</p>
    <h3 id="Point.Div">func (Point) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#37" title="View Source">Div</a> </h3>
    <pre class="funcdecl">func (p <a href="#Point">Point</a>) Div(k <a href="builtin.htm#int">int</a>) <a href="#Point">Point</a></pre>
    <p>返回点Point{p.X/k, p.Y/k }</p>
    <h3 id="Point.In">func (Point) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#42" title="View Source">In</a> </h3>
    <pre class="funcdecl">func (p <a href="#Point">Point</a>) In(r <a href="#Rectangle">Rectangle</a>) <a href="builtin.htm#bool">bool</a></pre>
    <p>报告p是否在r范围内。</p>
    <h3 id="Point.Mod">func (Point) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#49" title="View Source">Mod</a> </h3>
    <pre class="funcdecl">func (p <a href="#Point">Point</a>) Mod(r <a href="#Rectangle">Rectangle</a>) <a href="#Point">Point</a></pre>
    <p>返回r范围内的某点q，满足p.X-q.X是r宽度的倍数，p.Y-q.Y是r高度的倍数。</p>
    <h3 id="Point.String">func (Point) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#17" title="View Source">String</a> </h3>
    <pre class="funcdecl">func (p <a href="#Point">Point</a>) String() <a href="builtin.htm#string">string</a></pre>
    <p>返回p的字符串表示。格式为"(3,4)"</p>
    <h2 id="Rectangle">type <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#80" title="View Source">Rectangle</a> </h2>
    <pre>type Rectangle struct {
    <span id="Rectangle.Min">Min</span>, <span id="Rectangle.Max">Max</span> <a href="#Point">Point</a>
}</pre>
    <p>Rectangle代表一个矩形。该矩形包含所有满足Min.X &lt;= X &lt; Max.X且Min.Y &lt;= Y &lt; Max.Y的点。如果两个字段满足Min.X &lt;= Max.X且Min.Y &lt;= Max.Y，就称该实例为规范格式的。矩形的方法，当输入是规范格式时，总是返回规范格式的输出。</p>
    <pre>var <span id="ZR">ZR</span> <a href="#Rectangle">Rectangle</a></pre>
    <p>ZR是矩形的零值。</p>
    <h3 id="Rect">func <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#226" title="View Source">Rect</a> </h3>
    <pre class="funcdecl">func Rect(x0, y0, x1, y1 <a href="builtin.htm#int">int</a>) <a href="#Rectangle">Rectangle</a></pre>
    <p>返回一个矩形Rectangle{Pt(x0, y0), Pt(x1, y1)}。</p>
    <h3 id="Rectangle.Canon">func (Rectangle) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#212" title="View Source">Canon</a> </h3>
    <pre class="funcdecl">func (r <a href="#Rectangle">Rectangle</a>) Canon() <a href="#Rectangle">Rectangle</a></pre>
    <p>返回矩形的规范版本（左上&amp;右下），方法必要时会交换坐标的最大值和最小值。</p>
    <h3 id="Rectangle.Dx">func (Rectangle) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#90" title="View Source">Dx</a> </h3>
    <pre class="funcdecl">func (r <a href="#Rectangle">Rectangle</a>) Dx() <a href="builtin.htm#int">int</a></pre>
    <p>返回r的宽度。</p>
    <h3 id="Rectangle.Dy">func (Rectangle) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#95" title="View Source">Dy</a> </h3>
    <pre class="funcdecl">func (r <a href="#Rectangle">Rectangle</a>) Dy() <a href="builtin.htm#int">int</a></pre>
    <p>返回r的高度。</p>
    <h3 id="Rectangle.Size">func (Rectangle) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#100" title="View Source">Size</a> </h3>
    <pre class="funcdecl">func (r <a href="#Rectangle">Rectangle</a>) Size() <a href="#Point">Point</a></pre>
    <p>返回r的宽度w和高度h构成的点Point{w, h}。</p>
    <h3 id="Rectangle.Empty">func (Rectangle) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#183" title="View Source">Empty</a> </h3>
    <pre class="funcdecl">func (r <a href="#Rectangle">Rectangle</a>) Empty() <a href="builtin.htm#bool">bool</a></pre>
    <p>报告矩形是否为空矩形。（即内部不包含点的矩形）</p>
    <h3 id="Rectangle.Eq">func (Rectangle) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#188" title="View Source">Eq</a> </h3>
    <pre class="funcdecl">func (r <a href="#Rectangle">Rectangle</a>) Eq(s <a href="#Rectangle">Rectangle</a>) <a href="builtin.htm#bool">bool</a></pre>
    <p>报告两个矩形是否相同。</p>
    <h3 id="Rectangle.In">func (Rectangle) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#200" title="View Source">In</a> </h3>
    <pre class="funcdecl">func (r <a href="#Rectangle">Rectangle</a>) In(s <a href="#Rectangle">Rectangle</a>) <a href="builtin.htm#bool">bool</a></pre>
    <p>如果r包含的所有点都在s内，则返回真；否则返回假。</p>
    <h3 id="Rectangle.Overlaps">func (Rectangle) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#194" title="View Source">Overlaps</a> </h3>
    <pre class="funcdecl">func (r <a href="#Rectangle">Rectangle</a>) Overlaps(s <a href="#Rectangle">Rectangle</a>) <a href="builtin.htm#bool">bool</a></pre>
    <p>如果r和s有非空的交集，则返回真；否则返回假。</p>
    <h3 id="Rectangle.Add">func (Rectangle) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#108" title="View Source">Add</a> </h3>
    <pre class="funcdecl">func (r <a href="#Rectangle">Rectangle</a>) Add(p <a href="#Point">Point</a>) <a href="#Rectangle">Rectangle</a></pre>
    <p>返回矩形按p（作为向量）平移后的新矩形。</p>
    <h3 id="Rectangle.Sub">func (Rectangle) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#116" title="View Source">Sub</a> </h3>
    <pre class="funcdecl">func (r <a href="#Rectangle">Rectangle</a>) Sub(p <a href="#Point">Point</a>) <a href="#Rectangle">Rectangle</a></pre>
    <p>返回矩形按p（作为向量）反向平移后的新矩形。</p>
    <h3 id="Rectangle.Intersect">func (Rectangle) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#146" title="View Source">Intersect</a> </h3>
    <pre class="funcdecl">func (r <a href="#Rectangle">Rectangle</a>) Intersect(s <a href="#Rectangle">Rectangle</a>) <a href="#Rectangle">Rectangle</a></pre>
    <p>返回两个矩形的交集矩形（同时被r和s包含的最大矩形）；如果r和s没有重叠会返回Rectangle零值。</p>
    <h3 id="Rectangle.Union">func (Rectangle) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#166" title="View Source">Union</a> </h3>
    <pre class="funcdecl">func (r <a href="#Rectangle">Rectangle</a>) Union(s <a href="#Rectangle">Rectangle</a>) <a href="#Rectangle">Rectangle</a></pre>
    <p>返回同时包含r和s的最小矩形。</p>
    <h3 id="Rectangle.Inset">func (Rectangle) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#126" title="View Source">Inset</a> </h3>
    <pre class="funcdecl">func (r <a href="#Rectangle">Rectangle</a>) Inset(n <a href="builtin.htm#int">int</a>) <a href="#Rectangle">Rectangle</a></pre>
    <p>返回去掉矩形四周宽度n的框的矩形，n可为负数。如果n过大将返回靠近r中心位置的空矩形。</p>
    <h3 id="Rectangle.String">func (Rectangle) <a href="https://github.com/golang/go/blob/master/src/image/geom.go?name=release#85" title="View Source">String</a> </h3>
    <pre class="funcdecl">func (r <a href="#Rectangle">Rectangle</a>) String() <a href="builtin.htm#string">string</a></pre>
    <p>返回矩形的字符串表示，格式为"(3,4)-(6,5)"。</p>
    <h2 id="Uniform">type <a href="https://github.com/golang/go/blob/master/src/image/names.go?name=release#24" title="View Source">Uniform</a> </h2>
    <pre>type Uniform struct {
    <span id="Uniform.C">C</span> <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a>
}</pre>
    <p>Uniform类型代表一块面积无限大的具有同一色彩的图像。它实现了color.Color、color.Model和Image等接口。</p>
    <h3 id="NewUniform">func <a href="https://github.com/golang/go/blob/master/src/image/names.go?name=release#50" title="View Source">NewUniform</a> </h3>
    <pre class="funcdecl">func NewUniform(c <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a>) *<a href="#Uniform">Uniform</a></pre>
    <h3 id="Uniform.At">func (*Uniform) <a href="https://github.com/golang/go/blob/master/src/image/names.go?name=release#42" title="View Source">At</a> </h3>
    <pre class="funcdecl">func (c *<a href="#Uniform">Uniform</a>) At(x, y <a href="builtin.htm#int">int</a>) <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a></pre>
    <h3 id="Uniform.Bounds">func (*Uniform) <a href="https://github.com/golang/go/blob/master/src/image/names.go?name=release#40" title="View Source">Bounds</a> </h3>
    <pre class="funcdecl">func (c *<a href="#Uniform">Uniform</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
    <h3 id="Uniform.ColorModel">func (*Uniform) <a href="https://github.com/golang/go/blob/master/src/image/names.go?name=release#32" title="View Source">ColorModel</a> </h3>
    <pre class="funcdecl">func (c *<a href="#Uniform">Uniform</a>) ColorModel() <a href="image/color.htm">color</a>.<a href="image/color.htm#Model">Model</a></pre>
    <h3 id="Uniform.Convert">func (*Uniform) <a href="https://github.com/golang/go/blob/master/src/image/names.go?name=release#36" title="View Source">Convert</a> </h3>
    <pre class="funcdecl">func (c *<a href="#Uniform">Uniform</a>) Convert(<a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a>) <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a></pre>
    <h3 id="Uniform.Opaque">func (*Uniform) <a href="https://github.com/golang/go/blob/master/src/image/names.go?name=release#45" title="View Source">Opaque</a> </h3>
    <pre class="funcdecl">func (c *<a href="#Uniform">Uniform</a>) Opaque() <a href="builtin.htm#bool">bool</a></pre>
    <p>Opaque方法扫描整个图像并报告该图像是否是完全不透明的。</p>
    <h3 id="Uniform.RGBA">func (*Uniform) <a href="https://github.com/golang/go/blob/master/src/image/names.go?name=release#28" title="View Source">RGBA</a> </h3>
    <pre class="funcdecl">func (c *<a href="#Uniform">Uniform</a>) RGBA() (r, g, b, a <a href="builtin.htm#uint32">uint32</a>)</pre>
    <h2 id="Alpha">type <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#466" title="View Source">Alpha</a> </h2>
    <pre>type Alpha struct {
    <span class="com">// Pix保管图像的像素，内容为alpha通道值（即透明度）。</span>
    <span class="com">// 像素(x, y)起始位置是Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1]</span>
    <span id="Alpha.Pix">Pix</span> []<a href="builtin.htm#uint8">uint8</a>
    <span class="com">// Stride是Pix中每行像素占用的字节数</span>
    <span id="Alpha.Stride">Stride</span> <a href="builtin.htm#int">int</a>
    <span class="com">// Rect是图像的范围</span>
    <span id="Alpha.Rect">Rect</span> <a href="#Rectangle">Rectangle</a>
}</pre>
    <p>Alpha类型代表一幅内存中的图像，其At方法返回color.Alpha类型的值。</p>
    <h3 id="NewAlpha">func <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#547" title="View Source">NewAlpha</a> </h3>
    <pre class="funcdecl">func NewAlpha(r <a href="#Rectangle">Rectangle</a>) *<a href="#Alpha">Alpha</a></pre>
    <p>NewAlpha函数创建并返回一个具有指定宽度和高度的Alpha。</p>
    <h3 id="Alpha.At">func (*Alpha) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#480" title="View Source">At</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Alpha">Alpha</a>) At(x, y <a href="builtin.htm#int">int</a>) <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a></pre>
    <h3 id="Alpha.Bounds">func (*Alpha) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#478" title="View Source">Bounds</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Alpha">Alpha</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
    <h3 id="Alpha.ColorModel">func (*Alpha) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#476" title="View Source">ColorModel</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Alpha">Alpha</a>) ColorModel() <a href="image/color.htm">color</a>.<a href="image/color.htm#Model">Model</a></pre>
    <h3 id="Alpha.Opaque">func (*Alpha) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#529" title="View Source">Opaque</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Alpha">Alpha</a>) Opaque() <a href="builtin.htm#bool">bool</a></pre>
    <p>Opaque方法扫描整个图像并报告图像是否是完全不透明的。</p>
    <h3 id="Alpha.PixOffset">func (*Alpha) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#490" title="View Source">PixOffset</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Alpha">Alpha</a>) PixOffset(x, y <a href="builtin.htm#int">int</a>) <a href="builtin.htm#int">int</a></pre>
    <p>PixOffset方法返回像素(x, y)的数据起始位置在Pix字段的偏移量/索引。</p>
    <h3 id="Alpha.Set">func (*Alpha) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#494" title="View Source">Set</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Alpha">Alpha</a>) Set(x, y <a href="builtin.htm#int">int</a>, c <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a>)</pre>
    <h3 id="Alpha.SetAlpha">func (*Alpha) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#502" title="View Source">SetAlpha</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Alpha">Alpha</a>) SetAlpha(x, y <a href="builtin.htm#int">int</a>, c <a href="image/color.htm">color</a>.<a href="image/color.htm#Alpha">Alpha</a>)</pre>
    <h3 id="Alpha.SubImage">func (*Alpha) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#512" title="View Source">SubImage</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Alpha">Alpha</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
    <p>SubImage方法返回代表原图像一部分（r的范围）的新图像。返回值和原图像的像素数据是共用的。</p>
    <h2 id="Alpha16">type <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#554" title="View Source">Alpha16</a> </h2>
    <pre>type Alpha16 struct {
    <span class="com">// Pix保管图像的像素，内容为alpha通道值（即透明度，大端在前的格式）。</span>
    <span class="com">// 像素(x, y)起始位置是Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*2]</span>
    <span id="Alpha16.Pix">Pix</span> []<a href="builtin.htm#uint8">uint8</a>
    <span class="com">// Stride是Pix中每行像素占用的字节数</span>
    <span id="Alpha16.Stride">Stride</span> <a href="builtin.htm#int">int</a>
    <span class="com">// Rect是图像的范围</span>
    <span id="Alpha16.Rect">Rect</span> <a href="#Rectangle">Rectangle</a>
}</pre>
    <p>Alpha16类型代表一幅内存中的图像，其At方法返回color.Alpha16类型的值。</p>
    <h3 id="NewAlpha16">func <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#638" title="View Source">NewAlpha16</a> </h3>
    <pre class="funcdecl">func NewAlpha16(r <a href="#Rectangle">Rectangle</a>) *<a href="#Alpha16">Alpha16</a></pre>
    <p>NewAlpha16函数创建并返回一个具有指定范围的Alpha16。</p>
    <h3 id="Alpha16.At">func (*Alpha16) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#568" title="View Source">At</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Alpha16">Alpha16</a>) At(x, y <a href="builtin.htm#int">int</a>) <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a></pre>
    <h3 id="Alpha16.Bounds">func (*Alpha16) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#566" title="View Source">Bounds</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Alpha16">Alpha16</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
    <h3 id="Alpha16.ColorModel">func (*Alpha16) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#564" title="View Source">ColorModel</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Alpha16">Alpha16</a>) ColorModel() <a href="image/color.htm">color</a>.<a href="image/color.htm#Model">Model</a></pre>
    <h3 id="Alpha16.Opaque">func (*Alpha16) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#620" title="View Source">Opaque</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Alpha16">Alpha16</a>) Opaque() <a href="builtin.htm#bool">bool</a></pre>
    <p>Opaque方法扫描整个图像并报告图像是否是完全不透明的。</p>
    <h3 id="Alpha16.PixOffset">func (*Alpha16) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#578" title="View Source">PixOffset</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Alpha16">Alpha16</a>) PixOffset(x, y <a href="builtin.htm#int">int</a>) <a href="builtin.htm#int">int</a></pre>
    <p>PixOffset方法返回像素(x, y)的数据起始位置在Pix字段的偏移量/索引。</p>
    <h3 id="Alpha16.Set">func (*Alpha16) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#582" title="View Source">Set</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Alpha16">Alpha16</a>) Set(x, y <a href="builtin.htm#int">int</a>, c <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a>)</pre>
    <h3 id="Alpha16.SetAlpha16">func (*Alpha16) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#592" title="View Source">SetAlpha16</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Alpha16">Alpha16</a>) SetAlpha16(x, y <a href="builtin.htm#int">int</a>, c <a href="image/color.htm">color</a>.<a href="image/color.htm#Alpha16">Alpha16</a>)</pre>
    <h3 id="Alpha16.SubImage">func (*Alpha16) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#603" title="View Source">SubImage</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Alpha16">Alpha16</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
    <p>SubImage方法返回代表原图像一部分（r的范围）的新图像。返回值和原图像的像素数据是共用的。</p>
    <h2 id="Gray">type <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#645" title="View Source">Gray</a> </h2>
    <pre>type Gray struct {
    <span class="com">// Pix保管图像的像素，内容为灰度。</span>
    <span class="com">// 像素(x, y)起始位置是Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1]</span>
    <span id="Gray.Pix">Pix</span> []<a href="builtin.htm#uint8">uint8</a>
    <span class="com">// Stride是Pix中每行像素占用的字节数</span>
    <span id="Gray.Stride">Stride</span> <a href="builtin.htm#int">int</a>
    <span class="com">// Rect是图像的范围</span>
    <span id="Gray.Rect">Rect</span> <a href="#Rectangle">Rectangle</a>
}</pre>
    <p>Gray类型代表一幅内存中的图像，其At方法返回color.Gray类型的值。</p>
    <h3 id="NewGray">func <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#713" title="View Source">NewGray</a> </h3>
    <pre class="funcdecl">func NewGray(r <a href="#Rectangle">Rectangle</a>) *<a href="#Gray">Gray</a></pre>
    <p>NewGray函数创建并返回一个具有指定范围的Gray。</p>
    <h3 id="Gray.At">func (*Gray) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#659" title="View Source">At</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Gray">Gray</a>) At(x, y <a href="builtin.htm#int">int</a>) <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a></pre>
    <h3 id="Gray.Bounds">func (*Gray) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#657" title="View Source">Bounds</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Gray">Gray</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
    <h3 id="Gray.ColorModel">func (*Gray) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#655" title="View Source">ColorModel</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Gray">Gray</a>) ColorModel() <a href="image/color.htm">color</a>.<a href="image/color.htm#Model">Model</a></pre>
    <h3 id="Gray.Opaque">func (*Gray) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#708" title="View Source">Opaque</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Gray">Gray</a>) Opaque() <a href="builtin.htm#bool">bool</a></pre>
    <p>Opaque方法扫描整个图像并报告图像是否是完全不透明的。</p>
    <h3 id="Gray.PixOffset">func (*Gray) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#669" title="View Source">PixOffset</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Gray">Gray</a>) PixOffset(x, y <a href="builtin.htm#int">int</a>) <a href="builtin.htm#int">int</a></pre>
    <p>PixOffset方法返回像素(x, y)的数据起始位置在Pix字段的偏移量/索引。</p>
    <h3 id="Gray.Set">func (*Gray) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#673" title="View Source">Set</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Gray">Gray</a>) Set(x, y <a href="builtin.htm#int">int</a>, c <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a>)</pre>
    <h3 id="Gray.SetGray">func (*Gray) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#681" title="View Source">SetGray</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Gray">Gray</a>) SetGray(x, y <a href="builtin.htm#int">int</a>, c <a href="image/color.htm">color</a>.<a href="image/color.htm#Gray">Gray</a>)</pre>
    <h3 id="Gray.SubImage">func (*Gray) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#691" title="View Source">SubImage</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Gray">Gray</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
    <p>SubImage方法返回代表原图像一部分（r的范围）的新图像。返回值和原图像的像素数据是共用的。</p>
    <h2 id="Gray16">type <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#720" title="View Source">Gray16</a> </h2>
    <pre>type Gray16 struct {
    <span class="com">// Pix保管图像的像素，内容为灰度（大端在前的格式）。</span>
    <span class="com">// 像素(x, y)起始位置是Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*2]</span>
    <span id="Gray16.Pix">Pix</span> []<a href="builtin.htm#uint8">uint8</a>
    <span class="com">// Stride是Pix中每行像素占用的字节数</span>
    <span id="Gray16.Stride">Stride</span> <a href="builtin.htm#int">int</a>
    <span class="com">// Rect是图像的范围</span>
    <span id="Gray16.Rect">Rect</span> <a href="#Rectangle">Rectangle</a>
}</pre>
    <p>Gray16类型代表一幅内存中的图像，其At方法返回color.Gray16类型的值。</p>
    <h3 id="NewGray16">func <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#791" title="View Source">NewGray16</a> </h3>
    <pre class="funcdecl">func NewGray16(r <a href="#Rectangle">Rectangle</a>) *<a href="#Gray16">Gray16</a></pre>
    <p>NewGray16函数创建并返回一个具有指定范围的Gray16。</p>
    <h3 id="Gray16.At">func (*Gray16) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#734" title="View Source">At</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Gray16">Gray16</a>) At(x, y <a href="builtin.htm#int">int</a>) <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a></pre>
    <h3 id="Gray16.Bounds">func (*Gray16) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#732" title="View Source">Bounds</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Gray16">Gray16</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
    <h3 id="Gray16.ColorModel">func (*Gray16) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#730" title="View Source">ColorModel</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Gray16">Gray16</a>) ColorModel() <a href="image/color.htm">color</a>.<a href="image/color.htm#Model">Model</a></pre>
    <h3 id="Gray16.Opaque">func (*Gray16) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#786" title="View Source">Opaque</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Gray16">Gray16</a>) Opaque() <a href="builtin.htm#bool">bool</a></pre>
    <p>Opaque方法扫描整个图像并报告图像是否是完全不透明的。</p>
    <h3 id="Gray16.PixOffset">func (*Gray16) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#744" title="View Source">PixOffset</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Gray16">Gray16</a>) PixOffset(x, y <a href="builtin.htm#int">int</a>) <a href="builtin.htm#int">int</a></pre>
    <p>PixOffset方法返回像素(x, y)的数据起始位置在Pix字段的偏移量/索引。</p>
    <h3 id="Gray16.Set">func (*Gray16) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#748" title="View Source">Set</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Gray16">Gray16</a>) Set(x, y <a href="builtin.htm#int">int</a>, c <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a>)</pre>
    <h3 id="Gray16.SetGray16">func (*Gray16) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#758" title="View Source">SetGray16</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Gray16">Gray16</a>) SetGray16(x, y <a href="builtin.htm#int">int</a>, c <a href="image/color.htm">color</a>.<a href="image/color.htm#Gray16">Gray16</a>)</pre>
    <h3 id="Gray16.SubImage">func (*Gray16) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#769" title="View Source">SubImage</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Gray16">Gray16</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
    <p>SubImage方法返回代表原图像一部分（r的范围）的新图像。返回值和原图像的像素数据是共用的。</p>
    <h2 id="RGBA">type <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#60" title="View Source">RGBA</a> </h2>
    <pre>type RGBA struct {
    <span class="com">// Pix保管图像的像素色彩信息，顺序为R, G, B, A</span>
    <span class="com">// 像素(x, y)起始位置是Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4]</span>
    <span id="RGBA.Pix">Pix</span> []<a href="builtin.htm#uint8">uint8</a>
    <span class="com">// Stride是Pix中每行像素占用的字节数</span>
    <span id="RGBA.Stride">Stride</span> <a href="builtin.htm#int">int</a>
    <span class="com">// Rect是图像的范围</span>
    <span id="RGBA.Rect">Rect</span> <a href="#Rectangle">Rectangle</a>
}</pre>
    <p>RGBA类型代表一幅内存中的图像，其At方法返回color.RGBA类型的值。</p>
    <h3 id="NewRGBA">func <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#148" title="View Source">NewRGBA</a> </h3>
    <pre class="funcdecl">func NewRGBA(r <a href="#Rectangle">Rectangle</a>) *<a href="#RGBA">RGBA</a></pre>
    <p>NewRGBA函数创建并返回一个具有指定范围的RGBA。</p>
    <h3 id="RGBA.At">func (*RGBA) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#74" title="View Source">At</a> </h3>
    <pre class="funcdecl">func (p *<a href="#RGBA">RGBA</a>) At(x, y <a href="builtin.htm#int">int</a>) <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a></pre>
    <h3 id="RGBA.Bounds">func (*RGBA) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#72" title="View Source">Bounds</a> </h3>
    <pre class="funcdecl">func (p *<a href="#RGBA">RGBA</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
    <h3 id="RGBA.ColorModel">func (*RGBA) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#70" title="View Source">ColorModel</a> </h3>
    <pre class="funcdecl">func (p *<a href="#RGBA">RGBA</a>) ColorModel() <a href="image/color.htm">color</a>.<a href="image/color.htm#Model">Model</a></pre>
    <h3 id="RGBA.Opaque">func (*RGBA) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#130" title="View Source">Opaque</a> </h3>
    <pre class="funcdecl">func (p *<a href="#RGBA">RGBA</a>) Opaque() <a href="builtin.htm#bool">bool</a></pre>
    <p>Opaque方法扫描整个图像并报告图像是否是完全不透明的。</p>
    <h3 id="RGBA.PixOffset">func (*RGBA) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#84" title="View Source">PixOffset</a> </h3>
    <pre class="funcdecl">func (p *<a href="#RGBA">RGBA</a>) PixOffset(x, y <a href="builtin.htm#int">int</a>) <a href="builtin.htm#int">int</a></pre>
    <p>PixOffset方法返回像素(x, y)的数据起始位置在Pix字段的偏移量/索引。</p>
    <h3 id="RGBA.Set">func (*RGBA) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#88" title="View Source">Set</a> </h3>
    <pre class="funcdecl">func (p *<a href="#RGBA">RGBA</a>) Set(x, y <a href="builtin.htm#int">int</a>, c <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a>)</pre>
    <h3 id="RGBA.SetRGBA">func (*RGBA) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#100" title="View Source">SetRGBA</a> </h3>
    <pre class="funcdecl">func (p *<a href="#RGBA">RGBA</a>) SetRGBA(x, y <a href="builtin.htm#int">int</a>, c <a href="image/color.htm">color</a>.<a href="image/color.htm#RGBA">RGBA</a>)</pre>
    <h3 id="RGBA.SubImage">func (*RGBA) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#113" title="View Source">SubImage</a> </h3>
    <pre class="funcdecl">func (p *<a href="#RGBA">RGBA</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
    <p>SubImage方法返回代表原图像一部分（r的范围）的新图像。返回值和原图像的像素数据是共用的。</p>
    <h2 id="RGBA64">type <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#155" title="View Source">RGBA64</a> </h2>
    <pre>type RGBA64 struct {
    <span class="com">// Pix保管图像的像素色彩信息，顺序为R, G, B, A（每个值都是大端在前的格式）</span>
    <span class="com">// 像素(x, y)起始位置是Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*8]</span>
    <span id="RGBA64.Pix">Pix</span> []<a href="builtin.htm#uint8">uint8</a>
    <span class="com">// Stride是Pix中每行像素占用的字节数</span>
    <span id="RGBA64.Stride">Stride</span> <a href="builtin.htm#int">int</a>
    <span class="com">// Rect是图像的范围</span>
    <span id="RGBA64.Rect">Rect</span> <a href="#Rectangle">Rectangle</a>
}</pre>
    <p>RGBA64类型代表一幅内存中的图像，其At方法返回color.RGBA64类型的值</p>
    <h3 id="NewRGBA64">func <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#256" title="View Source">NewRGBA64</a> </h3>
    <pre class="funcdecl">func NewRGBA64(r <a href="#Rectangle">Rectangle</a>) *<a href="#RGBA64">RGBA64</a></pre>
    <p>NewRGBA64函数创建并返回一个具有指定范围的RGBA64</p>
    <h3 id="RGBA64.At">func (*RGBA64) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#169" title="View Source">At</a> </h3>
    <pre class="funcdecl">func (p *<a href="#RGBA64">RGBA64</a>) At(x, y <a href="builtin.htm#int">int</a>) <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a></pre>
    <h3 id="RGBA64.Bounds">func (*RGBA64) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#167" title="View Source">Bounds</a> </h3>
    <pre class="funcdecl">func (p *<a href="#RGBA64">RGBA64</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
    <h3 id="RGBA64.ColorModel">func (*RGBA64) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#165" title="View Source">ColorModel</a> </h3>
    <pre class="funcdecl">func (p *<a href="#RGBA64">RGBA64</a>) ColorModel() <a href="image/color.htm">color</a>.<a href="image/color.htm#Model">Model</a></pre>
    <h3 id="RGBA64.Opaque">func (*RGBA64) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#238" title="View Source">Opaque</a> </h3>
    <pre class="funcdecl">func (p *<a href="#RGBA64">RGBA64</a>) Opaque() <a href="builtin.htm#bool">bool</a></pre>
    <p>Opaque方法扫描整个图像并报告图像是否是完全不透明的。</p>
    <h3 id="RGBA64.PixOffset">func (*RGBA64) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#184" title="View Source">PixOffset</a> </h3>
    <pre class="funcdecl">func (p *<a href="#RGBA64">RGBA64</a>) PixOffset(x, y <a href="builtin.htm#int">int</a>) <a href="builtin.htm#int">int</a></pre>
    <p>PixOffset方法返回像素(x, y)的数据起始位置在Pix字段的偏移量/索引。</p>
    <h3 id="RGBA64.Set">func (*RGBA64) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#188" title="View Source">Set</a> </h3>
    <pre class="funcdecl">func (p *<a href="#RGBA64">RGBA64</a>) Set(x, y <a href="builtin.htm#int">int</a>, c <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a>)</pre>
    <h3 id="RGBA64.SetRGBA64">func (*RGBA64) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#204" title="View Source">SetRGBA64</a> </h3>
    <pre class="funcdecl">func (p *<a href="#RGBA64">RGBA64</a>) SetRGBA64(x, y <a href="builtin.htm#int">int</a>, c <a href="image/color.htm">color</a>.<a href="image/color.htm#RGBA64">RGBA64</a>)</pre>
    <h3 id="RGBA64.SubImage">func (*RGBA64) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#221" title="View Source">SubImage</a> </h3>
    <pre class="funcdecl">func (p *<a href="#RGBA64">RGBA64</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
    <p>SubImage方法返回代表原图像一部分（r的范围）的新图像。返回值和原图像的像素数据是共用的。</p>
    <h2 id="NRGBA">type <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#263" title="View Source">NRGBA</a> </h2>
    <pre>type NRGBA struct {
    <span class="com">// Pix保管图像的像素色彩信息，顺序为R, G, B, A</span>
    <span class="com">// 像素(x, y)起始位置是Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4]</span>
    <span id="NRGBA.Pix">Pix</span> []<a href="builtin.htm#uint8">uint8</a>
    <span class="com">// Stride是Pix中每行像素占用的字节数</span>
    <span id="NRGBA.Stride">Stride</span> <a href="builtin.htm#int">int</a>
    <span class="com">// Rect是图像的范围</span>
    <span id="NRGBA.Rect">Rect</span> <a href="#Rectangle">Rectangle</a>
}</pre>
    <p>NRGBA类型代表一幅内存中的图像，其At方法返回color.NRGBA类型的值。</p>
    <h3 id="NewNRGBA">func <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#351" title="View Source">NewNRGBA</a> </h3>
    <pre class="funcdecl">func NewNRGBA(r <a href="#Rectangle">Rectangle</a>) *<a href="#NRGBA">NRGBA</a></pre>
    <p>NewNRGBA函数创建并返回一个具有指定范围的NRGBA。</p>
    <h3 id="NRGBA.At">func (*NRGBA) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#277" title="View Source">At</a> </h3>
    <pre class="funcdecl">func (p *<a href="#NRGBA">NRGBA</a>) At(x, y <a href="builtin.htm#int">int</a>) <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a></pre>
    <h3 id="NRGBA.Bounds">func (*NRGBA) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#275" title="View Source">Bounds</a> </h3>
    <pre class="funcdecl">func (p *<a href="#NRGBA">NRGBA</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
    <h3 id="NRGBA.ColorModel">func (*NRGBA) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#273" title="View Source">ColorModel</a> </h3>
    <pre class="funcdecl">func (p *<a href="#NRGBA">NRGBA</a>) ColorModel() <a href="image/color.htm">color</a>.<a href="image/color.htm#Model">Model</a></pre>
    <h3 id="NRGBA.Opaque">func (*NRGBA) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#333" title="View Source">Opaque</a> </h3>
    <pre class="funcdecl">func (p *<a href="#NRGBA">NRGBA</a>) Opaque() <a href="builtin.htm#bool">bool</a></pre>
    <p>Opaque方法扫描整个图像并报告图像是否是完全不透明的。</p>
    <h3 id="NRGBA.PixOffset">func (*NRGBA) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#287" title="View Source">PixOffset</a> </h3>
    <pre class="funcdecl">func (p *<a href="#NRGBA">NRGBA</a>) PixOffset(x, y <a href="builtin.htm#int">int</a>) <a href="builtin.htm#int">int</a></pre>
    <p>PixOffset方法返回像素(x, y)的数据起始位置在Pix字段的偏移量/索引。</p>
    <h3 id="NRGBA.Set">func (*NRGBA) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#291" title="View Source">Set</a> </h3>
    <pre class="funcdecl">func (p *<a href="#NRGBA">NRGBA</a>) Set(x, y <a href="builtin.htm#int">int</a>, c <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a>)</pre>
    <h3 id="NRGBA.SetNRGBA">func (*NRGBA) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#303" title="View Source">SetNRGBA</a> </h3>
    <pre class="funcdecl">func (p *<a href="#NRGBA">NRGBA</a>) SetNRGBA(x, y <a href="builtin.htm#int">int</a>, c <a href="image/color.htm">color</a>.<a href="image/color.htm#NRGBA">NRGBA</a>)</pre>
    <h3 id="NRGBA.SubImage">func (*NRGBA) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#316" title="View Source">SubImage</a> </h3>
    <pre class="funcdecl">func (p *<a href="#NRGBA">NRGBA</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
    <p>SubImage方法返回代表原图像一部分（r的范围）的新图像。返回值和原图像的像素数据是共用的。</p>
    <h2 id="NRGBA64">type <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#358" title="View Source">NRGBA64</a> </h2>
    <pre>type NRGBA64 struct {
    <span class="com">// Pix保管图像的像素色彩信息，顺序为R, G, B, A（每个值都是大端在前的格式）</span>
    <span class="com">// 像素(x, y)起始位置是Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*8]</span>
    <span id="NRGBA64.Pix">Pix</span> []<a href="builtin.htm#uint8">uint8</a>
    <span class="com">// Stride是Pix中每行像素占用的字节数</span>
    <span id="NRGBA64.Stride">Stride</span> <a href="builtin.htm#int">int</a>
    <span class="com">// Rect是图像的范围</span>
    <span id="NRGBA64.Rect">Rect</span> <a href="#Rectangle">Rectangle</a>
}</pre>
    <p>NRGBA64类型代表一幅内存中的图像，其At方法返回color.NRGBA64类型的值。</p>
    <h3 id="NewNRGBA64">func <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#459" title="View Source">NewNRGBA64</a> </h3>
    <pre class="funcdecl">func NewNRGBA64(r <a href="#Rectangle">Rectangle</a>) *<a href="#NRGBA64">NRGBA64</a></pre>
    <p>NewNRGBA64函数创建并返回一个具有指定范围的NRGBA64。</p>
    <h3 id="NRGBA64.At">func (*NRGBA64) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#372" title="View Source">At</a> </h3>
    <pre class="funcdecl">func (p *<a href="#NRGBA64">NRGBA64</a>) At(x, y <a href="builtin.htm#int">int</a>) <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a></pre>
    <h3 id="NRGBA64.Bounds">func (*NRGBA64) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#370" title="View Source">Bounds</a> </h3>
    <pre class="funcdecl">func (p *<a href="#NRGBA64">NRGBA64</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
    <h3 id="NRGBA64.ColorModel">func (*NRGBA64) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#368" title="View Source">ColorModel</a> </h3>
    <pre class="funcdecl">func (p *<a href="#NRGBA64">NRGBA64</a>) ColorModel() <a href="image/color.htm">color</a>.<a href="image/color.htm#Model">Model</a></pre>
    <h3 id="NRGBA64.Opaque">func (*NRGBA64) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#441" title="View Source">Opaque</a> </h3>
    <pre class="funcdecl">func (p *<a href="#NRGBA64">NRGBA64</a>) Opaque() <a href="builtin.htm#bool">bool</a></pre>
    <p>Opaque方法扫描整个图像并报告图像是否是完全不透明的。</p>
    <h3 id="NRGBA64.PixOffset">func (*NRGBA64) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#387" title="View Source">PixOffset</a> </h3>
    <pre class="funcdecl">func (p *<a href="#NRGBA64">NRGBA64</a>) PixOffset(x, y <a href="builtin.htm#int">int</a>) <a href="builtin.htm#int">int</a></pre>
    <p>PixOffset方法返回像素(x, y)的数据起始位置在Pix字段的偏移量/索引。</p>
    <h3 id="NRGBA64.Set">func (*NRGBA64) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#391" title="View Source">Set</a> </h3>
    <pre class="funcdecl">func (p *<a href="#NRGBA64">NRGBA64</a>) Set(x, y <a href="builtin.htm#int">int</a>, c <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a>)</pre>
    <h3 id="NRGBA64.SetNRGBA64">func (*NRGBA64) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#407" title="View Source">SetNRGBA64</a> </h3>
    <pre class="funcdecl">func (p *<a href="#NRGBA64">NRGBA64</a>) SetNRGBA64(x, y <a href="builtin.htm#int">int</a>, c <a href="image/color.htm">color</a>.<a href="image/color.htm#NRGBA64">NRGBA64</a>)</pre>
    <h3 id="NRGBA64.SubImage">func (*NRGBA64) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#424" title="View Source">SubImage</a> </h3>
    <pre class="funcdecl">func (p *<a href="#NRGBA64">NRGBA64</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
    <p>SubImage方法返回代表原图像一部分（r的范围）的新图像。返回值和原图像的像素数据是共用的。</p>
    <h2 id="Paletted">type <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#798" title="View Source">Paletted</a> </h2>
    <pre>type Paletted struct {
    <span class="com">// Pix保存图像的象素，内容为调色板的索引。</span>
    <span class="com">// 像素(x, y)的位置是Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1]</span>
    <span id="Paletted.Pix">Pix</span> []<a href="builtin.htm#uint8">uint8</a>
    <span class="com">// Stride是Pix中每行像素占用的字节数</span>
    <span id="Paletted.Stride">Stride</span> <a href="builtin.htm#int">int</a>
    <span class="com">// Rect是图像的范围</span>
    <span id="Paletted.Rect">Rect</span> <a href="#Rectangle">Rectangle</a>
    <span class="com">// Palette是图像的调色板</span>
    <span id="Paletted.Palette">Palette</span> <a href="image/color.htm">color</a>.<a href="image/color.htm#Palette">Palette</a>
}</pre>
    <p>Paletted类型是一幅采用uint8类型索引调色板的内存中的图像。</p>
    <h3 id="NewPaletted">func <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#900" title="View Source">NewPaletted</a> </h3>
    <pre class="funcdecl">func NewPaletted(r <a href="#Rectangle">Rectangle</a>, p <a href="image/color.htm">color</a>.<a href="image/color.htm#Palette">Palette</a>) *<a href="#Paletted">Paletted</a></pre>
    <p>NewPaletted函数创建并返回一个具有指定范围、调色板的Paletted。</p>
    <h3 id="Paletted.At">func (*Paletted) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#814" title="View Source">At</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Paletted">Paletted</a>) At(x, y <a href="builtin.htm#int">int</a>) <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a></pre>
    <h3 id="Paletted.Bounds">func (*Paletted) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#812" title="View Source">Bounds</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Paletted">Paletted</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
    <h3 id="Paletted.ColorIndexAt">func (*Paletted) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#839" title="View Source">ColorIndexAt</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Paletted">Paletted</a>) ColorIndexAt(x, y <a href="builtin.htm#int">int</a>) <a href="builtin.htm#uint8">uint8</a></pre>
    <h3 id="Paletted.ColorModel">func (*Paletted) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#810" title="View Source">ColorModel</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Paletted">Paletted</a>) ColorModel() <a href="image/color.htm">color</a>.<a href="image/color.htm#Model">Model</a></pre>
    <h3 id="Paletted.Opaque">func (*Paletted) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#877" title="View Source">Opaque</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Paletted">Paletted</a>) Opaque() <a href="builtin.htm#bool">bool</a></pre>
    <p>Opaque方法扫描整个图像并报告图像是否是完全不透明的。</p>
    <h3 id="Paletted.PixOffset">func (*Paletted) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#827" title="View Source">PixOffset</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Paletted">Paletted</a>) PixOffset(x, y <a href="builtin.htm#int">int</a>) <a href="builtin.htm#int">int</a></pre>
    <p>PixOffset方法返回像素(x, y)的数据起始位置在Pix字段的偏移量/索引。</p>
    <h3 id="Paletted.Set">func (*Paletted) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#831" title="View Source">Set</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Paletted">Paletted</a>) Set(x, y <a href="builtin.htm#int">int</a>, c <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a>)</pre>
    <h3 id="Paletted.SetColorIndex">func (*Paletted) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#847" title="View Source">SetColorIndex</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Paletted">Paletted</a>) SetColorIndex(x, y <a href="builtin.htm#int">int</a>, index <a href="builtin.htm#uint8">uint8</a>)</pre>
    <h3 id="Paletted.SubImage">func (*Paletted) <a href="https://github.com/golang/go/blob/master/src/image/image.go?name=release#857" title="View Source">SubImage</a> </h3>
    <pre class="funcdecl">func (p *<a href="#Paletted">Paletted</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
    <p>SubImage方法返回代表原图像一部分（r的范围）的新图像。返回值和原图像的像素数据是共用的。</p>
    <h2 id="YCbCrSubsampleRatio">type <a href="https://github.com/golang/go/blob/master/src/image/ycbcr.go?name=release#12" title="View Source">YCbCrSubsampleRatio</a> </h2>
    <pre>type YCbCrSubsampleRatio <a href="builtin.htm#int">int</a></pre>
    <p>YcbCrSubsampleRatio是YCbCr图像的色度二次采样比率。</p>
    <pre>const (
    <span id="YCbCrSubsampleRatio444">YCbCrSubsampleRatio444</span> <a href="#YCbCrSubsampleRatio">YCbCrSubsampleRatio</a> = <a href="builtin.htm#iota">iota</a>
    <span id="YCbCrSubsampleRatio422">YCbCrSubsampleRatio422</span>
    <span id="YCbCrSubsampleRatio420">YCbCrSubsampleRatio420</span>
    <span id="YCbCrSubsampleRatio440">YCbCrSubsampleRatio440</span>
)</pre>
    <h3 id="YCbCrSubsampleRatio.String">func (YCbCrSubsampleRatio) <a href="https://github.com/golang/go/blob/master/src/image/ycbcr.go?name=release#21" title="View Source">String</a> </h3>
    <pre class="funcdecl">func (s <a href="#YCbCrSubsampleRatio">YCbCrSubsampleRatio</a>) String() <a href="builtin.htm#string">string</a></pre>
    <h2 id="YCbCr">type <a href="https://github.com/golang/go/blob/master/src/image/ycbcr.go?name=release#46" title="View Source">YCbCr</a> </h2>
    <pre>type YCbCr struct {
    <span id="YCbCr.Y">Y</span>, <span id="YCbCr.Cb">Cb</span>, <span id="YCbCr.Cr">Cr</span>      []<a href="builtin.htm#uint8">uint8</a>
    <span id="YCbCr.YStride">YStride</span>        <a href="builtin.htm#int">int</a>
    <span id="YCbCr.CStride">CStride</span>        <a href="builtin.htm#int">int</a>
    <span id="YCbCr.SubsampleRatio">SubsampleRatio</span> <a href="#YCbCrSubsampleRatio">YCbCrSubsampleRatio</a>
    <span id="YCbCr.Rect">Rect</span>           <a href="#Rectangle">Rectangle</a>
}</pre>
    <p>YcbCr代表采用Y'CbCr色彩模型的一幅内存中的图像。每个像素都对应一个Y采样，但每个Cb/Cr采样对应多个像素。Ystride是两个垂直相邻的像素之间的Y组分的索引增量。CStride是两个映射到单独的色度采样的垂直相邻的像素之间的Cb/Cr组分的索引增量。虽然不作绝对要求，但Ystride字段和len(Y)一般应为8的倍数，并且：</p>
    <pre>For 4:4:4, CStride == YStride/1 &amp;&amp; len(Cb) == len(Cr) == len(Y)/1.
For 4:2:2, CStride == YStride/2 &amp;&amp; len(Cb) == len(Cr) == len(Y)/2.
For 4:2:0, CStride == YStride/2 &amp;&amp; len(Cb) == len(Cr) == len(Y)/4.
For 4:4:0, CStride == YStride/1 &amp;&amp; len(Cb) == len(Cr) == len(Y)/2.
</pre>
    <h3 id="NewYCbCr">func <a href="https://github.com/golang/go/blob/master/src/image/ycbcr.go?name=release#126" title="View Source">NewYCbCr</a> </h3>
    <pre class="funcdecl">func NewYCbCr(r <a href="#Rectangle">Rectangle</a>, subsampleRatio <a href="#YCbCrSubsampleRatio">YCbCrSubsampleRatio</a>) *<a href="#YCbCr">YCbCr</a></pre>
    <p>NewYCbCr函数创建并返回一个具有指定宽度、高度和二次采样率的YcbCr。</p>
    <h3 id="YCbCr.At">func (*YCbCr) <a href="https://github.com/golang/go/blob/master/src/image/ycbcr.go?name=release#62" title="View Source">At</a> </h3>
    <pre class="funcdecl">func (p *<a href="#YCbCr">YCbCr</a>) At(x, y <a href="builtin.htm#int">int</a>) <a href="image/color.htm">color</a>.<a href="image/color.htm#Color">Color</a></pre>
    <h3 id="YCbCr.Bounds">func (*YCbCr) <a href="https://github.com/golang/go/blob/master/src/image/ycbcr.go?name=release#58" title="View Source">Bounds</a> </h3>
    <pre class="funcdecl">func (p *<a href="#YCbCr">YCbCr</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
    <h3 id="YCbCr.ColorModel">func (*YCbCr) <a href="https://github.com/golang/go/blob/master/src/image/ycbcr.go?name=release#54" title="View Source">ColorModel</a> </h3>
    <pre class="funcdecl">func (p *<a href="#YCbCr">YCbCr</a>) ColorModel() <a href="image/color.htm">color</a>.<a href="image/color.htm#Model">Model</a></pre>
    <h3 id="YCbCr.Opaque">func (*YCbCr) <a href="https://github.com/golang/go/blob/master/src/image/ycbcr.go?name=release#121" title="View Source">Opaque</a> </h3>
    <pre class="funcdecl">func (p *<a href="#YCbCr">YCbCr</a>) Opaque() <a href="builtin.htm#bool">bool</a></pre>
    <h3 id="YCbCr.COffset">func (*YCbCr) <a href="https://github.com/golang/go/blob/master/src/image/ycbcr.go?name=release#83" title="View Source">COffset</a> </h3>
    <pre class="funcdecl">func (p *<a href="#YCbCr">YCbCr</a>) COffset(x, y <a href="builtin.htm#int">int</a>) <a href="builtin.htm#int">int</a></pre>
    <p>像素(X, Y)的Cb或Cr（色度）组分的数据起始位置在Cb/Cr字段的偏移量/索引。</p>
    <h3 id="YCbCr.YOffset">func (*YCbCr) <a href="https://github.com/golang/go/blob/master/src/image/ycbcr.go?name=release#77" title="View Source">YOffset</a> </h3>
    <pre class="funcdecl">func (p *<a href="#YCbCr">YCbCr</a>) YOffset(x, y <a href="builtin.htm#int">int</a>) <a href="builtin.htm#int">int</a></pre>
    <p>像素(X, Y)的Y（亮度）组分的数据起始位置在Y字段的偏移量/索引。</p>
    <h3 id="YCbCr.SubImage">func (*YCbCr) <a href="https://github.com/golang/go/blob/master/src/image/ycbcr.go?name=release#98" title="View Source">SubImage</a> </h3>
    <pre class="funcdecl">func (p *<a href="#YCbCr">YCbCr</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
    <p>SubImage方法返回代表原图像一部分（r的范围）的新图像。返回值和原图像的像素数据是共用的。</p>
</div>